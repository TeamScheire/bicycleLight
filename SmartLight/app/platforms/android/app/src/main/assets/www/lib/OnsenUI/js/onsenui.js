/* onsenui v2.10.2 - 2018-07-03 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ons = factory());
}(this, (function () { 'use strict';

var onsElements = {};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Add vendor prefix.
 *
 * @param {String} name
 * @return {String}
 */
var prefix = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

  return function (name) {
    return '-' + prefix + '-' + util$1.hyphenate(name);
  };
}();

/**
 * Minimal utility library for manipulating element's style.
 * Set element's style.
 *
 * @param {Element} element
 * @param {Object} styles
 * @return {Element}
 */
var styler = function styler(element, style) {
  Object.keys(style).forEach(function (key) {
    if (key in element.style) {
      element.style[key] = style[key];
    } else if (prefix(key) in element.style) {
      element.style[prefix(key)] = style[key];
    } else {
      util$1.warn('No such style property: ' + key);
    }
  });
  return element;
};

/**
 * @param {Element} element
 * @param {String} styles Space-separated CSS properties to remove
 */
styler.clear = function (element) {
  var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var clearlist = styles.split(/\s+/).reduce(function (r, s) {
    return r.concat([util$1.hyphenate(s), prefix(s)]);
  }, []),
      keys = [];

  var _loop = function _loop(i) {
    var key = element.style[i];
    if (clearlist.length === 0 || clearlist.some(function (s) {
      return key.indexOf(s) === 0;
    })) {
      keys.push(key); // Store the key to fix Safari style indexes
    }
  };

  for (var i = element.style.length - 1; i >= 0; i--) {
    _loop(i);
  }

  keys.forEach(function (key) {
    return element.style[key] = '';
  });
  element.getAttribute('style') === '' && element.removeAttribute('style');
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// Save HTMLElement object before Custom Elements polyfill patch global HTMLElement.
var NativeHTMLElement = window.HTMLElement;

/**
 * @object ons.platform
 * @category util
 * @description
 *   [en]Utility methods to detect current platform.[/en]
 *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 */

var Platform = function () {

  /**
   * All elements will be rendered as if the app was running on this platform.
   * @type {String}
   */
  function Platform() {
    classCallCheck(this, Platform);

    this._selectedPlatform = null;
    this._ignorePlatformSelect = false;
  }

  /**
   * @method select
   * @signature select(platform)
   * @param  {string} platform Name of the platform.
   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
   * @description
   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
   */


  createClass(Platform, [{
    key: 'select',
    value: function select(platform) {
      if (typeof platform === 'string') {
        this._selectedPlatform = platform.trim().toLowerCase();
      }
    }
  }, {
    key: '_getSelectedPlatform',
    value: function _getSelectedPlatform() {
      return this._ignorePlatformSelect ? null : this._selectedPlatform;
    }
  }, {
    key: '_runOnActualPlatform',
    value: function _runOnActualPlatform(fn) {
      this._ignorePlatformSelect = true;
      var result = fn();
      this._ignorePlatformSelect = false;

      return result;
    }

    //----------------
    // General
    //----------------
    /**
     * @method isWebView
     * @signature isWebView()
     * @description
     *   [en]Returns whether app is running in Cordova.[/en]
     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWebView',
    value: function isWebView() {
      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
        throw new Error('isWebView() method is available after dom contents loaded.');
      }

      return !!(window.cordova || window.phonegap || window.PhoneGap);
    }

    //----------------
    // iOS devices
    //----------------
    /**
     * @method isIPhone
     * @signature isIPhone()
     * @description
     *   [en]Returns whether the device is iPhone.[/en]
     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhone',
    value: function isIPhone() {
      return (/iPhone/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isIPhoneX
     * @signature isIPhoneX()
     * @description
     *   [en]Returns whether the device is iPhone X.[/en]
     *   [ja]iPhone X上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhoneX',
    value: function isIPhoneX() {
      // iPhone 8 and iPhone X have a same user agent. We cannot avoid using window.screen.
      // This works well both in iOS Safari and (UI|WK)WebView of iPhone X.
      return this.isIPhone() && (window.screen.width === 375 && window.screen.height === 812 || window.screen.width === 812 && window.screen.height === 375);
    }

    /**
     * @method isIPad
     * @signature isIPad()
     * @description
     *   [en]Returns whether the device is iPad.[/en]
     *   [ja]iPad上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPad',
    value: function isIPad() {
      return (/iPad/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isIPod',
    value: function isIPod() {
      return (/iPod/i.test(navigator.userAgent)
      );
    }

    //----------------
    // iOS versions
    //----------------
    /**
     * @method isIOS
     * @signature isIOS()
     * @description
     *   [en]Returns whether the OS is iOS.[/en]
     *   [ja]iOS上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS',
    value: function isIOS() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'ios';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform)
        );
      } else {
        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isIOS7above
     * @signature isIOS7above()
     * @description
     *   [en]Returns whether the iOS version is 7 or above.[/en]
     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS7above',
    value: function isIOS7above() {
      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
        );
      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
        return parseInt(ver.split('.')[0]) >= 7;
      }
      return false;
    }

    //----------------
    // iOS browsers
    //----------------
    /**
     * @method isIOSSafari
     * @signature isIOSSafari()
     * @description
     *   [en]Returns whether app is running in iOS Safari.[/en]
     *   [ja]iOS Safariで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOSSafari',
    value: function isIOSSafari() {
      var navigator = window.navigator;
      var ua = navigator.userAgent;

      return !!(this.isIOS() && ua.indexOf('Safari') !== -1 && ua.indexOf('Version') !== -1 && !navigator.standalone);
    }

    /**
     * @method isWKWebView
     * @signature isWKWebView()
     * @description
     *   [en]Returns whether app is running in WKWebView.[/en]
     *   [ja]WKWebViewで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWKWebView',
    value: function isWKWebView() {
      var lte9 = /constructor/i.test(NativeHTMLElement);
      return !!(this.isIOS() && window.webkit && window.webkit.messageHandlers && window.indexedDB && !lte9);
    }

    /**
     * @method isUIWebView
     * @signature isUIWebView()
     * @description
     *   [en]Returns whether app is running in UIWebView.[/en]
     *   [ja]UIWebViewで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isUIWebView',
    value: function isUIWebView() {
      return !!(this.isIOS() && !this.isIOSSafari() && !this.isWKWebView());
    }

    //----------------
    // Android devices
    //----------------
    /**
     * @method isAndroidPhone
     * @signature isAndroidPhone()
     * @description
     *   [en]Returns whether the device is Android phone.[/en]
     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidPhone',
    value: function isAndroidPhone() {
      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isAndroidTablet
     * @signature isAndroidTablet()
     * @description
     *   [en]Returns whether the device is Android tablet.[/en]
     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidTablet',
    value: function isAndroidTablet() {
      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
      );
    }

    //----------------
    // Android versions
    //----------------
    /**
     * @method isAndroid
     * @signature isAndroid()
     * @description
     *   [en]Returns whether the OS is Android.[/en]
     *   [ja]Android上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroid',
    value: function isAndroid() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'android';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Android/i.test(device.platform)
        );
      } else {
        return (/Android/i.test(navigator.userAgent)
        );
      }
    }

    //----------------
    // Other devices
    //----------------
    /**
     * @return {Boolean}
     */

  }, {
    key: 'isWP',
    value: function isWP() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'wp';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Win32NT|WinCE/i.test(device.platform)
        );
      } else {
        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isBlackBerry
     * @signature isBlackBerry()
     * @description
     *   [en]Returns whether the device is BlackBerry.[/en]
     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isBlackBerry',
    value: function isBlackBerry() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'blackberry';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/BlackBerry/i.test(device.platform)
        );
      } else {
        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
        );
      }
    }

    //----------------
    // Other browsers
    //----------------
    /**
     * @method isOpera
     * @signature isOpera()
     * @description
     *   [en]Returns whether the browser is Opera.[/en]
     *   [ja]Opera上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isOpera',
    value: function isOpera() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'opera';
      }

      return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    }

    /**
     * @method isFirefox
     * @signature isFirefox()
     * @description
     *   [en]Returns whether the browser is Firefox.[/en]
     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isFirefox',
    value: function isFirefox() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'firefox';
      }

      return typeof InstallTrigger !== 'undefined';
    }

    /**
     * @method isSafari
     * @signature isSafari()
     * @description
     *   [en]Returns whether the browser is Safari.[/en]
     *   [ja]Safari上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isSafari',
    value: function isSafari() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'safari';
      }

      return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || function (p) {
        return p.toString() === '[object SafariRemoteNotification]';
      }(!window['safari'] || safari.pushNotification);
    }

    /**
     * @method isChrome
     * @signature isChrome()
     * @description
     *   [en]Returns whether the browser is Chrome.[/en]
     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isChrome',
    value: function isChrome() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'chrome';
      }

      return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
    }

    /**
     * @method isIE
     * @signature isIE()
     * @description
     *   [en]Returns whether the browser is Internet Explorer.[/en]
     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIE',
    value: function isIE() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'ie';
      }

      return false || !!document.documentMode;
    }

    /**
     * @method isEdge
     * @signature isEdge()
     * @description
     *   [en]Returns whether the browser is Edge.[/en]
     *   [ja]Edge上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isEdge',
    value: function isEdge() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'edge';
      }

      return navigator.userAgent.indexOf(' Edge/') >= 0;
    }

    //----------------
    // Utility functions
    //----------------
    /**
     * @return {String}
     */

  }, {
    key: 'getMobileOS',
    value: function getMobileOS() {
      if (this.isAndroid()) {
        return 'android';
      } else if (this.isIOS()) {
        return 'ios';
      } else if (this.isWP()) {
        return 'wp';
      } else {
        return 'other';
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getIOSDevice',
    value: function getIOSDevice() {
      if (this.isIPhone()) {
        return 'iphone';
      } else if (this.isIPad()) {
        return 'ipad';
      } else if (this.isIPod()) {
        return 'ipod';
      } else {
        return 'na';
      }
    }
  }]);
  return Platform;
}();

var platform = new Platform();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var error = function error(message) {
  return util$1.throw('In PageAttributeExpression: ' + message);
};

var pageAttributeExpression = {
  _variables: {},

  /**
   * Define a variable.
   *
   * @param {String} name Name of the variable
   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
   */
  defineVariable: function defineVariable(name, value) {
    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (typeof name !== 'string') {
      error('Variable name must be a string');
    } else if (typeof value !== 'string' && typeof value !== 'function') {
      error('Variable value must be a string or a function');
    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
      error('"' + name + '" is already defined');
    }
    this._variables[name] = value;
  },

  /**
   * Get a variable.
   *
   * @param {String} name Name of the variable.
   * @return {String|Function|null}
   */
  getVariable: function getVariable(name) {
    if (!this._variables.hasOwnProperty(name)) {
      return null;
    }

    return this._variables[name];
  },

  /**
   * Remove a variable.
   *
   * @param {String} name Name of the varaible.
   */
  removeVariable: function removeVariable(name) {
    delete this._variables[name];
  },

  /**
   * Get all variables.
   *
   * @return {Object}
   */
  getAllVariables: function getAllVariables() {
    return this._variables;
  },
  _parsePart: function _parsePart(part) {
    var c = void 0,
        inInterpolation = false,
        currentIndex = 0;

    var tokens = [];

    if (part.length === 0) {
      error('Unable to parse empty string');
    }

    for (var i = 0; i < part.length; i++) {
      c = part.charAt(i);

      if (c === '$' && part.charAt(i + 1) === '{') {
        if (inInterpolation) {
          error('Nested interpolation not supported');
        }

        var token = part.substring(currentIndex, i);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i));
        }

        currentIndex = i;
        inInterpolation = true;
      } else if (c === '}') {
        if (!inInterpolation) {
          error('} must be preceeded by ${');
        }

        var _token = part.substring(currentIndex, i + 1);
        if (_token.length > 0) {
          tokens.push(part.substring(currentIndex, i + 1));
        }

        currentIndex = i + 1;
        inInterpolation = false;
      }
    }

    if (inInterpolation) {
      error('Unterminated interpolation');
    }

    tokens.push(part.substring(currentIndex, part.length));

    return tokens;
  },
  _replaceToken: function _replaceToken(token) {
    var re = /^\${(.*?)}$/,
        match = token.match(re);

    if (match) {
      var name = match[1].trim();
      var variable = this.getVariable(name);

      if (variable === null) {
        error('Variable "' + name + '" does not exist');
      } else if (typeof variable === 'string') {
        return variable;
      } else {
        var rv = variable();

        if (typeof rv !== 'string') {
          error('Must return a string');
        }

        return rv;
      }
    } else {
      return token;
    }
  },
  _replaceTokens: function _replaceTokens(tokens) {
    return tokens.map(this._replaceToken.bind(this));
  },
  _parseExpression: function _parseExpression(expression) {
    return expression.split(',').map(function (part) {
      return part.trim();
    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
      return part.join('');
    });
  },

  /**
   * Evaluate an expression.
   *
   * @param {String} expression An page attribute expression.
   * @return {Array}
   */
  evaluate: function evaluate(expression) {
    if (!expression) {
      return [];
    }

    return this._parseExpression(expression);
  }
};

// Define default variables.
pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
pageAttributeExpression.defineVariable('runtime', function () {
  return platform.isWebView() ? 'cordova' : 'browser';
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var internal$1 = {};

internal$1.config = {
  autoStatusBarFill: true,
  animationsDisabled: false,
  warningsDisabled: false
};

internal$1.nullElement = window.document.createElement('div');

/**
 * @return {Boolean}
 */
internal$1.isEnabledAutoStatusBarFill = function () {
  return !!internal$1.config.autoStatusBarFill;
};

/**
 * @param {String} html
 * @return {String}
 */
internal$1.normalizePageHTML = function (html) {
  return ('' + html).trim();
};

internal$1.waitDOMContentLoaded = function (callback) {
  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
    var wrappedCallback = function wrappedCallback() {
      callback();
      window.document.removeEventListener('DOMContentLoaded', wrappedCallback);
    };
    window.document.addEventListener('DOMContentLoaded', wrappedCallback);
  } else {
    setImmediate(callback);
  }
};

internal$1.autoStatusBarFill = function (action) {
  var onReady = function onReady() {
    if (internal$1.shouldFillStatusBar()) {
      action();
    }
    document.removeEventListener('deviceready', onReady);
  };

  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {
    document.addEventListener('deviceready', onReady);
  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
    internal$1.waitDOMContentLoaded(onReady);
  } else {
    onReady();
  }
};

internal$1.shouldFillStatusBar = function () {
  return internal$1.isEnabledAutoStatusBarFill() && (platform.isWebView() && platform.isIOS7above() && !platform.isIPhoneX() || document.body.querySelector('.ons-status-bar-mock.ios'));
};

internal$1.templateStore = {
  _storage: {},

  /**
   * @param {String} key
   * @return {String/null} template
   */
  get: function get$$1(key) {
    return internal$1.templateStore._storage[key] || null;
  },


  /**
   * @param {String} key
   * @param {String} template
   */
  set: function set$$1(key, template) {
    internal$1.templateStore._storage[key] = template;
  }
};

window.document.addEventListener('_templateloaded', function (e) {
  if (e.target.nodeName.toLowerCase() === 'ons-template') {
    internal$1.templateStore.set(e.templateId, e.template);
  }
}, false);

internal$1.waitDOMContentLoaded(function () {
  register('script[type="text/ons-template"]');
  register('script[type="text/template"]');
  register('script[type="text/ng-template"]');
  register('template');

  function register(query) {
    var templates = window.document.querySelectorAll(query);
    for (var i = 0; i < templates.length; i++) {
      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent || templates[i].content);
    }
  }
});

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getTemplateHTMLAsync = function (page) {
  return new Promise(function (resolve, reject) {
    internal$1.waitDOMContentLoaded(function () {
      var cache = internal$1.templateStore.get(page);
      if (cache) {
        if (cache instanceof DocumentFragment) {
          return resolve(cache);
        }

        var html = typeof cache === 'string' ? cache : cache[1];
        return resolve(internal$1.normalizePageHTML(html));
      }

      var local = window.document.getElementById(page);
      if (local) {
        var _html = local.textContent || local.content;
        return resolve(_html);
      }

      var xhr = new XMLHttpRequest();
      xhr.open('GET', page, true);
      xhr.onload = function () {
        var html = xhr.responseText;
        if (xhr.status >= 400 && xhr.status < 600) {
          reject(html);
        } else {
          // Refresh script tags
          var fragment = util$1.createFragment(html);
          util$1.arrayFrom(fragment.querySelectorAll('script')).forEach(function (el) {
            var script = document.createElement('script');
            script.type = el.type || 'text/javascript';
            script.appendChild(document.createTextNode(el.text || el.textContent || el.innerHTML));
            el.parentNode.replaceChild(script, el);
          });

          internal$1.templateStore.set(page, fragment);
          resolve(fragment);
        }
      };
      xhr.onerror = function () {
        util$1.throw('Page template not found: ' + page);
      };
      xhr.send(null);
    });
  });
};

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getPageHTMLAsync = function (page) {
  var pages = pageAttributeExpression.evaluate(page);

  var getPage = function getPage(page) {
    if (typeof page !== 'string') {
      return Promise.reject('Must specify a page.');
    }

    return internal$1.getTemplateHTMLAsync(page).catch(function (error) {
      if (pages.length === 0) {
        return Promise.reject(error);
      }

      return getPage(pages.shift());
    });
  };

  return getPage(pages.shift());
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AnimatorFactory = function () {

  /**
   * @param {Object} opts
   * @param {Object} opts.animators The dictionary for animator classes
   * @param {Function} opts.baseClass The base class of animators
   * @param {String} [opts.baseClassName] The name of the base class of animators
   * @param {String} [opts.defaultAnimation] The default animation name
   * @param {Object} [opts.defaultAnimationOptions] The default animation options
   */
  function AnimatorFactory(opts) {
    classCallCheck(this, AnimatorFactory);

    this._animators = opts.animators;
    this._baseClass = opts.baseClass;
    this._baseClassName = opts.baseClassName || opts.baseClass.name;
    this._animation = opts.defaultAnimation || 'default';
    this._animationOptions = opts.defaultAnimationOptions || {};

    if (!this._animators[this._animation]) {
      util$1.throw('No such animation: ' + this._animation);
    }
  }

  /**
   * @param {String} jsonString
   * @return {Object/null}
   */


  createClass(AnimatorFactory, [{
    key: 'setAnimationOptions',


    /**
     * @param {Object} options
     */
    value: function setAnimationOptions(options) {
      this._animationOptions = options;
    }

    /**
     * @param {Object} options
     * @param {String} [options.animation] The animation name
     * @param {Object} [options.animationOptions] The animation options
     * @param {Object} defaultAnimator The default animator instance
     * @return {Object} An animator instance
     */

  }, {
    key: 'newAnimator',
    value: function newAnimator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultAnimator = arguments[1];


      var animator = null;

      if (options.animation instanceof this._baseClass) {
        return options.animation;
      }

      var Animator = null;

      if (typeof options.animation === 'string') {
        Animator = this._animators[options.animation];
      }

      if (!Animator && defaultAnimator) {
        animator = defaultAnimator;
      } else {
        Animator = Animator || this._animators[this._animation];

        var animationOpts = util$1.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

        animator = new Animator(animationOpts);

        if (typeof animator === 'function') {
          animator = new animator(animationOpts); // eslint-disable-line new-cap
        }
      }

      if (!(animator instanceof this._baseClass)) {
        util$1.throw('"animator" is not an instance of ' + this._baseClassName);
      }

      return animator;
    }
  }], [{
    key: 'parseAnimationOptionsString',
    value: function parseAnimationOptionsString(jsonString) {
      try {
        if (typeof jsonString === 'string') {
          var result = util$1.animationOptionsParse(jsonString);
          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
            return result;
          } else {
            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
          }
        }
        return {};
      } catch (e) {
        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
        return {};
      }
    }
  }]);
  return AnimatorFactory;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoStyleEnabled = true;

// Modifiers
var modifiersMap = {
  'quiet': 'material--flat',
  'light': 'material--flat',
  'outline': 'material--flat',
  'cta': '',
  'large--quiet': 'material--flat large',
  'large--cta': 'large',
  'noborder': '',
  'tappable': ''
};

var platforms = {};

platforms.android = function (element) {

  var elementName = element.tagName.toLowerCase();

  if (!util$1.hasModifier(element, 'material')) {
    var oldModifier = element.getAttribute('modifier') || '';

    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
    });
    newModifier.unshift('material');

    element.setAttribute('modifier', newModifier.join(' ').trim());
  }

  var elements = ['ons-alert-dialog-button', 'ons-toolbar-button', 'ons-back-button', 'ons-button', 'ons-list-item', 'ons-fab', 'ons-speed-dial', 'ons-speed-dial-item', 'ons-tab'];

  // Effects
  if (elements.indexOf(elementName) !== -1 && !element.hasAttribute('ripple') && !element.querySelector('ons-ripple')) {

    if (elementName === 'ons-list-item') {
      if (element.hasAttribute('tappable')) {
        element.setAttribute('ripple', '');
        element.removeAttribute('tappable');
      }
    } else {
      element.setAttribute('ripple', '');
    }
  }
};

platforms.ios = function (element) {

  // Modifiers
  if (util$1.removeModifier(element, 'material')) {
    if (util$1.removeModifier(element, 'material--flat')) {
      util$1.addModifier(element, util$1.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
    }

    if (!element.getAttribute('modifier')) {
      element.removeAttribute('modifier');
    }
  }

  // Effects
  if (element.hasAttribute('ripple')) {
    if (element.tagName.toLowerCase() === 'ons-list-item') {
      element.setAttribute('tappable', '');
    }

    element.removeAttribute('ripple');
  }
};

var unlocked = {
  android: true
};

var getPlatform = function getPlatform(element, force) {
  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
    var mobileOS = platform.getMobileOS();
    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
      return mobileOS;
    }
  }
  return null;
};

var prepare = function prepare(element, force) {
  var p = getPlatform(element, force);
  p && platforms[p](element);
};

var mapModifier = function mapModifier(modifier, element, force) {
  if (getPlatform(element, force)) {
    return modifier.split(/\s+/).map(function (m) {
      return modifiersMap.hasOwnProperty(m) ? modifiersMap[m] : m;
    }).join(' ');
  }
  return modifier;
};

var restoreModifier = function restoreModifier(element) {
  if (getPlatform(element) === 'android') {
    var modifier = element.getAttribute('modifier') || '';
    var newModifier = mapModifier(modifier, element);

    if (!/(^|\s+)material($|\s+)/i.test(modifier)) {
      newModifier = 'material ' + newModifier;
    }

    if (newModifier !== modifier) {
      element.setAttribute('modifier', newModifier.trim());
      return true;
    }
  }
  return false;
};

var autoStyle = {
  isEnabled: function isEnabled() {
    return autoStyleEnabled;
  },
  enable: function enable() {
    return autoStyleEnabled = true;
  },
  disable: function disable() {
    return autoStyleEnabled = false;
  },
  prepare: prepare,
  mapModifier: mapModifier,
  getPlatform: getPlatform,
  restoreModifier: restoreModifier
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModifierUtil = function () {
  function ModifierUtil() {
    classCallCheck(this, ModifierUtil);
  }

  createClass(ModifierUtil, null, [{
    key: 'diff',

    /**
     * @param {String} last
     * @param {String} current
     */
    value: function diff(last, current) {
      last = makeDict(('' + last).trim());
      current = makeDict(('' + current).trim());

      var removed = Object.keys(last).reduce(function (result, token) {
        if (!current[token]) {
          result.push(token);
        }
        return result;
      }, []);

      var added = Object.keys(current).reduce(function (result, token) {
        if (!last[token]) {
          result.push(token);
        }
        return result;
      }, []);

      return { added: added, removed: removed };

      function makeDict(modifier) {
        var dict = {};
        ModifierUtil.split(modifier).forEach(function (token) {
          return dict[token] = token;
        });
        return dict;
      }
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {Object} classList
     * @param {String} template
     */

  }, {
    key: 'applyDiffToClassList',
    value: function applyDiffToClassList(diff, classList, template) {
      diff.added.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return klass.split(/\s+/).forEach(function (k) {
          return classList.add(k);
        });
      });

      diff.removed.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return klass.split(/\s+/).forEach(function (k) {
          return classList.remove(k);
        });
      });
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'applyDiffToElement',
    value: function applyDiffToElement(diff, element, scheme) {
      Object.keys(scheme).forEach(function (selector) {
        var targetElements = !selector || util$1.match(element, selector) ? [element] : Array.prototype.filter.call(element.querySelectorAll(selector), function (targetElement) {
          return !util$1.findParent(targetElement, element.tagName, function (parent) {
            return parent === element;
          });
        });

        for (var i = 0; i < targetElements.length; i++) {
          ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
        }
      });
    }

    /**
     * @param {String} last
     * @param {String} current
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'onModifierChanged',
    value: function onModifierChanged(last, current, element, scheme) {
      ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
      autoStyle.restoreModifier(element);
    }
  }, {
    key: 'refresh',
    value: function refresh(element, scheme) {
      ModifierUtil.applyDiffToElement(ModifierUtil.diff('', element.getAttribute('modifier') || ''), element, scheme);
    }

    /**
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'initModifier',
    value: function initModifier(element, scheme) {
      var modifier = element.getAttribute('modifier');
      if (typeof modifier !== 'string') {
        return;
      }

      ModifierUtil.applyDiffToElement({
        removed: [],
        added: ModifierUtil.split(modifier)
      }, element, scheme);
    }
  }, {
    key: 'split',
    value: function split(modifier) {
      if (typeof modifier !== 'string') {
        return [];
      }

      return modifier.trim().split(/ +/).filter(function (token) {
        return token !== '';
      });
    }

    /**
     * Add modifier token to an element.
     */

  }, {
    key: 'addModifier',
    value: function addModifier(element, modifierToken) {
      if (!element.hasAttribute('modifier')) {
        element.setAttribute('modifier', modifierToken);
      } else {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        if (tokens.indexOf(modifierToken) == -1) {
          tokens.push(modifierToken);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }

    /**
     * Remove modifier token from an element.
     */

  }, {
    key: 'removeModifier',
    value: function removeModifier(element, modifierToken) {
      if (element.hasAttribute('modifier')) {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        var index = tokens.indexOf(modifierToken);
        if (index !== -1) {
          tokens.splice(index, 1);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }
  }]);
  return ModifierUtil;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$3 = {
  _ready: false,

  _domContentLoaded: false,

  _onDOMContentLoaded: function _onDOMContentLoaded() {
    util$3._domContentLoaded = true;

    if (platform.isWebView()) {
      window.document.addEventListener('deviceready', function () {
        util$3._ready = true;
      }, false);
    } else {
      util$3._ready = true;
    }
  },

  addBackButtonListener: function addBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.addEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.addEventListener('backbutton', fn, false);
      });
    }
  },

  removeBackButtonListener: function removeBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.removeEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.removeEventListener('backbutton', fn, false);
      });
    }
  }
};
window.addEventListener('DOMContentLoaded', function () {
  return util$3._onDOMContentLoaded();
}, false);

var HandlerRepository = {
  _store: {},

  _genId: function () {
    var i = 0;
    return function () {
      return i++;
    };
  }(),

  set: function set$$1(element, handler) {
    if (element.dataset.deviceBackButtonHandlerId) {
      this.remove(element);
    }
    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
    this._store[id] = handler;
  },

  remove: function remove(element) {
    if (element.dataset.deviceBackButtonHandlerId) {
      delete this._store[element.dataset.deviceBackButtonHandlerId];
      delete element.dataset.deviceBackButtonHandlerId;
    }
  },

  get: function get$$1(element) {
    if (!element.dataset.deviceBackButtonHandlerId) {
      return undefined;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    if (!this._store[id]) {
      throw new Error();
    }

    return this._store[id];
  },

  has: function has(element) {
    if (!element.dataset) {
      return false;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    return !!this._store[id];
  }
};

var DeviceBackButtonDispatcher = function () {
  function DeviceBackButtonDispatcher() {
    classCallCheck(this, DeviceBackButtonDispatcher);

    this._isEnabled = false;
    this._boundCallback = this._callback.bind(this);
  }

  /**
   * Enable to handle 'backbutton' events.
   */


  createClass(DeviceBackButtonDispatcher, [{
    key: 'enable',
    value: function enable() {
      if (!this._isEnabled) {
        util$3.addBackButtonListener(this._boundCallback);
        this._isEnabled = true;
      }
    }

    /**
     * Disable to handle 'backbutton' events.
     */

  }, {
    key: 'disable',
    value: function disable() {
      if (this._isEnabled) {
        util$3.removeBackButtonListener(this._boundCallback);
        this._isEnabled = false;
      }
    }

    /**
     * Fire a 'backbutton' event manually.
     */

  }, {
    key: 'fireDeviceBackButtonEvent',
    value: function fireDeviceBackButtonEvent() {
      var event = document.createEvent('Event');
      event.initEvent('backbutton', true, true);
      document.dispatchEvent(event);
    }
  }, {
    key: '_callback',
    value: function _callback() {
      this._dispatchDeviceBackButtonEvent();
    }

    /**
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }, {
    key: 'createHandler',
    value: function createHandler(element, callback) {
      if (!(element instanceof HTMLElement)) {
        throw new Error('element must be an instance of HTMLElement');
      }

      if (!(callback instanceof Function)) {
        throw new Error('callback must be an instance of Function');
      }

      var handler = {
        _callback: callback,
        _element: element,

        disable: function disable() {
          HandlerRepository.remove(element);
        },

        setListener: function setListener(callback) {
          this._callback = callback;
        },

        enable: function enable() {
          HandlerRepository.set(element, this);
        },

        isEnabled: function isEnabled() {
          return HandlerRepository.get(element) === this;
        },

        destroy: function destroy() {
          HandlerRepository.remove(element);
          this._callback = this._element = null;
        }
      };

      handler.enable();

      return handler;
    }
  }, {
    key: '_dispatchDeviceBackButtonEvent',
    value: function _dispatchDeviceBackButtonEvent() {
      var tree = this._captureTree();

      var element = this._findHandlerLeafElement(tree);

      var handler = HandlerRepository.get(element);
      handler._callback(createEvent(element));

      function createEvent(element) {
        return {
          _element: element,
          callParentHandler: function callParentHandler() {
            var parent = this._element.parentNode;

            while (parent) {
              handler = HandlerRepository.get(parent);
              if (handler) {
                return handler._callback(createEvent(parent));
              }
              parent = parent.parentNode;
            }
          }
        };
      }
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_captureTree',
    value: function _captureTree() {
      return createTree(document.body);

      function createTree(element) {
        var tree = {
          element: element,
          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

            if (childElement.style.display === 'none' || childElement._isShown === false) {
              return [];
            }

            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
              return [];
            }

            var result = createTree(childElement);

            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
              return [];
            }

            return [result];
          }))
        };

        if (!HandlerRepository.has(tree.element)) {
          for (var i = 0; i < tree.children.length; i++) {
            var subTree = tree.children[i];
            if (HandlerRepository.has(subTree.element)) {
              return subTree;
            }
          }
        }

        return tree;
      }

      function arrayOf(target) {
        var result = [];
        for (var i = 0; i < target.length; i++) {
          result.push(target[i]);
        }
        return result;
      }
    }

    /**
     * @param {Object} tree
     * @return {HTMLElement}
     */

  }, {
    key: '_findHandlerLeafElement',
    value: function _findHandlerLeafElement(tree) {
      return find(tree);

      function find(node) {
        if (node.children.length === 0) {
          return node.element;
        }

        if (node.children.length === 1) {
          return find(node.children[0]);
        }

        return node.children.map(function (childNode) {
          return childNode.element;
        }).reduce(function (left, right) {
          if (!left) {
            return right;
          }

          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

          if (!isNaN(leftZ) && !isNaN(rightZ)) {
            return leftZ > rightZ ? left : right;
          }

          throw new Error('Capturing backbutton-handler is failure.');
        }, null);
      }
    }
  }]);
  return DeviceBackButtonDispatcher;
}();

var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
internal$1.AnimatorFactory = AnimatorFactory;
internal$1.ModifierUtil = ModifierUtil;
internal$1.dbbDispatcher = deviceBackButtonDispatcher;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var startsWith = function startsWith(s, c) {
  return s.substr(0, c.length) === c;
};
var endsWith = function endsWith(s, c) {
  return s.substr(s.length - c.length, c.length) === c;
};
var unwrap = function unwrap(s) {
  return s.slice(1, -1);
};
var isObjectString = function isObjectString(s) {
  return startsWith(s, '{') && endsWith(s, '}');
};
var isArrayString = function isArrayString(s) {
  return startsWith(s, '[') && endsWith(s, ']');
};
var isQuotedString = function isQuotedString(s) {
  return startsWith(s, '\'') && endsWith(s, '\'') || startsWith(s, '"') && endsWith(s, '"');
};

var error$1 = function error(token, string, originalString) {
  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
};

var processToken = function processToken(token, string, originalString) {
  if (token === 'true' || token === 'false') {
    return token === 'true';
  } else if (isQuotedString(token)) {
    return unwrap(token);
  } else if (!isNaN(token)) {
    return +token;
  } else if (isObjectString(token)) {
    return parseObject(unwrap(token));
  } else if (isArrayString(token)) {
    return parseArray(unwrap(token));
  } else {
    error$1(token, string, originalString);
  }
};

var nextToken = function nextToken(string) {
  string = string.trim();
  var limit = string.length;

  if (string[0] === ':' || string[0] === ',') {

    limit = 1;
  } else if (string[0] === '{' || string[0] === '[') {

    var c = string.charCodeAt(0);
    var nestedObject = 1;
    for (var i = 1; i < string.length; i++) {
      if (string.charCodeAt(i) === c) {
        nestedObject++;
      } else if (string.charCodeAt(i) === c + 2) {
        nestedObject--;
        if (nestedObject === 0) {
          limit = i + 1;
          break;
        }
      }
    }
  } else if (string[0] === '\'' || string[0] === '"') {

    for (var _i = 1; _i < string.length; _i++) {
      if (string[_i] === string[0]) {
        limit = _i + 1;
        break;
      }
    }
  } else {

    for (var _i2 = 1; _i2 < string.length; _i2++) {
      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
        limit = _i2;
        break;
      }
    }
  }

  return string.slice(0, limit);
};

var parseObject = function parseObject(string) {
  var isValidKey = function isValidKey(key) {
    return (/^[A-Z_$][A-Z0-9_$]*$/i.test(key)
    );
  };

  string = string.trim();
  var originalString = string;
  var object = {};
  var readingKey = true,
      key = void 0,
      previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();

    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
      error$1(token, string, originalString);
    } else if (token === ':' && readingKey && previousToken) {
      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;
      if (isValidKey(previousToken)) {
        key = previousToken;
        readingKey = false;
      } else {
        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
      }
    } else if (token === ',' && !readingKey && previousToken) {
      object[key] = processToken(previousToken, string, originalString);
      readingKey = true;
    }
  }

  if (token) {
    object[key] = processToken(token, string, originalString);
  }

  return object;
};

var parseArray = function parseArray(string) {
  string = string.trim();
  var originalString = string;
  var array = [];
  var previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();

    if (token === ',' && (!previousToken || previousToken === ',')) {
      error$1(token, string, originalString);
    } else if (token === ',') {
      array.push(processToken(previousToken, string, originalString));
    }
  }

  if (token) {
    if (token !== ',') {
      array.push(processToken(token, string, originalString));
    } else {
      error$1(token, string, originalString);
    }
  }

  return array;
};

var parse = function parse(string) {
  string = string.trim();

  if (isObjectString(string)) {
    return parseObject(unwrap(string));
  } else if (isArrayString(string)) {
    return parseArray(unwrap(string));
  } else {
    throw new Error('Provided string must be object or array like: ' + string);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$1 = {};
var errorPrefix = '[Onsen UI]';

util$1.globals = {
  fabOffset: 0,
  errorPrefix: errorPrefix,
  supportsPassive: false
};

platform._runOnActualPlatform(function () {
  util$1.globals.actualMobileOS = platform.getMobileOS();
  util$1.globals.isUIWebView = platform.isUIWebView();
  util$1.globals.isWKWebView = platform.isWKWebView();
});

try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function get$$1() {
      util$1.globals.supportsPassive = true;
    }
  });
  window.addEventListener('testPassive', null, opts);
  window.removeEventListener('testPassive', null, opts);
} catch (e) {
  
}

/**
 * @param {Element} el Target
 * @param {String} name Event name
 * @param {Function} handler Event handler
 * @param {Object} [opt] Event options (passive, capture...)
 * @param {Boolean} [isGD] If comes from GestureDetector. Just for testing.
 */
util$1.addEventListener = function (el, name, handler, opt, isGD) {
  el.addEventListener(name, handler, util$1.globals.supportsPassive ? opt : (opt || {}).capture);
};
util$1.removeEventListener = function (el, name, handler, opt, isGD) {
  el.removeEventListener(name, handler, util$1.globals.supportsPassive ? opt : (opt || {}).capture);
};

/**
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {Function}
 */
util$1.prepareQuery = function (query) {
  return query instanceof Function ? query : function (element) {
    return util$1.match(element, query);
  };
};

/**
 * @param {Element} e
 * @param {String/Function} s CSS Selector.
 * @return {Boolean}
 */
util$1.match = function (e, s) {
  return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util$1.findChild = function (element, query) {
  var match = util$1.prepareQuery(query);

  // Caution: `element.children` is `undefined` in some environments if `element` is `svg`
  for (var i = 0; i < element.childNodes.length; i++) {
    var node = element.childNodes[i];
    if (node.nodeType !== Node.ELEMENT_NODE) {
      // process only element nodes
      continue;
    }
    if (match(node)) {
      return node;
    }
  }
  return null;
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util$1.findParent = function (element, query, until) {
  var match = util$1.prepareQuery(query);

  var parent = element.parentNode;
  for (;;) {
    if (!parent || parent === document || parent instanceof DocumentFragment || until && until(parent)) {
      return null;
    } else if (match(parent)) {
      return parent;
    }
    parent = parent.parentNode;
  }
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util$1.isAttached = function (element) {
  return document.body.contains(element);
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util$1.hasAnyComponentAsParent = function (element) {
  while (element && document.documentElement !== element) {
    element = element.parentNode;
    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal)/)) {
      return true;
    }
  }
  return false;
};

/**
 * @param {Object} element
 * @return {Array}
 */
util$1.getAllChildNodes = function (element) {
  var _ref;

  return (_ref = [element]).concat.apply(_ref, toConsumableArray(Array.from(element.children).map(function (childEl) {
    return util$1.getAllChildNodes(childEl);
  })));
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util$1.isPageControl = function (element) {
  return element.nodeName.match(/^ons-(navigator|splitter|tabbar|page)$/i);
};

/**
 * @param {Element} element
 * @param {String} action to propagate
 */
util$1.propagateAction = function (element, action) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (child[action] instanceof Function) {
      child[action]();
    } else {
      util$1.propagateAction(child, action);
    }
  }
};

/**
 * @param {String} string - string to be camelized
 * @return {String} Camelized string
 */
util$1.camelize = function (string) {
  return string.toLowerCase().replace(/-([a-z])/g, function (m, l) {
    return l.toUpperCase();
  });
};

/**
 * @param {String} string - string to be hyphenated
 * @return {String} Hyphenated string
 */
util$1.hyphenate = function (string) {
  return string.replace(/([a-zA-Z])([A-Z])/g, '$1-$2').toLowerCase();
};

/**
 * @param {String} selector - tag and class only
 * @param {Object} style
 * @param {Element}
 */
util$1.create = function () {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var classList = selector.split('.');
  var element = document.createElement(classList.shift() || 'div');

  if (classList.length) {
    element.className = classList.join(' ');
  }

  styler(element, style);

  return element;
};

/**
 * @param {String} html
 * @return {Element}
 */
util$1.createElement = function (html) {
  var wrapper = document.createElement('div');

  if (html instanceof DocumentFragment) {
    wrapper.appendChild(document.importNode(html, true));
  } else {
    wrapper.innerHTML = html.trim();
  }

  if (wrapper.children.length > 1) {
    util$1.throw('HTML template must contain a single root element');
  }

  var element = wrapper.children[0];
  wrapper.children[0].remove();
  return element;
};

/**
 * @param {String} html
 * @return {HTMLFragment}
 */
util$1.createFragment = function (html) {
  var template = document.createElement('template');
  template.innerHTML = html;
  return document.importNode(template.content, true);
};

/*
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
util$1.extend = function (dst) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < args.length; i++) {
    if (args[i]) {
      var keys = Object.keys(args[i]);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        dst[key] = args[i][key];
      }
    }
  }

  return dst;
};

/**
 * @param {Object} arrayLike
 * @return {Array}
 */
util$1.arrayFrom = function (arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

/**
 * @param {String} jsonString
 * @param {Object} [failSafe]
 * @return {Object}
 */
util$1.parseJSONObjectSafely = function (jsonString) {
  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    var result = JSON.parse('' + jsonString);
    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
      return result;
    }
  } catch (e) {
    return failSafe;
  }
  return failSafe;
};

/**
 * @param {String} path - path such as 'myApp.controllers.data.loadData'
 * @return {Any} - whatever is located at that path
 */
util$1.findFromPath = function (path) {
  path = path.split('.');
  var el = window,
      key;
  while (key = path.shift()) {
    // eslint-disable-line no-cond-assign
    el = el[key];
  }
  return el;
};

/**
 * @param {HTMLElement} container - Page or page-container that implements 'topPage'
 * @return {HTMLElement|null} - Visible page element or null if not found.
 */
util$1.getTopPage = function (container) {
  return container && (container.tagName.toLowerCase() === 'ons-page' ? container : container.topPage) || null;
};

/**
 * @param {HTMLElement} container - Element where the search begins
 * @return {HTMLElement|null} - Page element that contains the visible toolbar or null.
 */
util$1.findToolbarPage = function (container) {
  var page = util$1.getTopPage(container);

  if (page) {
    if (page._canAnimateToolbar()) {
      return page;
    }

    for (var i = 0; i < page._contentElement.children.length; i++) {
      var nextPage = util$1.getTopPage(page._contentElement.children[i]);
      if (nextPage && !/ons-tabbar/i.test(page._contentElement.children[i].tagName)) {
        return util$1.findToolbarPage(nextPage);
      }
    }
  }

  return null;
};

/**
 * @param {Element} element
 * @param {String} eventName
 * @param {Object} [detail]
 * @return {CustomEvent}
 */
util$1.triggerElementEvent = function (target, eventName) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  var event = new CustomEvent(eventName, {
    bubbles: true,
    cancelable: true,
    detail: detail
  });

  Object.keys(detail).forEach(function (key) {
    event[key] = detail[key];
  });

  target.dispatchEvent(event);

  return event;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean}
 */
util$1.hasModifier = function (target, modifierName) {
  if (!target.hasAttribute('modifier')) {
    return false;
  }

  return RegExp('(^|\\s+)' + modifierName + '($|\\s+)', 'i').test(target.getAttribute('modifier'));
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was added or not.
 */
util$1.addModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  if (util$1.hasModifier(target, modifierName)) {
    return false;
  }

  target.setAttribute('modifier', ((target.getAttribute('modifier') || '') + ' ' + modifierName).trim());
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was found or not.
 */
util$1.removeModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  if (!target.getAttribute('modifier') || !util$1.hasModifier(target, modifierName)) {
    return false;
  }

  var newModifiers = target.getAttribute('modifier').split(/\s+/).filter(function (m) {
    return m && m !== modifierName;
  });
  newModifiers.length ? target.setAttribute('modifier', newModifiers.join(' ')) : target.removeAttribute('modifier');
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Boolean} options.force Forces modifier to be added or removed.
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Boolean} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was found or not.
 */
util$1.toggleModifier = function () {
  var options = arguments.length > 2 ? arguments.length <= 2 ? undefined : arguments[2] : {};
  var force = typeof options === 'boolean' ? options : options.force;

  var toggle = typeof force === 'boolean' ? force : !util$1.hasModifier.apply(util$1, arguments);
  toggle ? util$1.addModifier.apply(util$1, arguments) : util$1.removeModifier.apply(util$1, arguments);
};

/**
 * @param {Element} el
 * @param {String} defaultClass
 * @param {Object} scheme
 */
util$1.restoreClass = function (el, defaultClass, scheme) {
  defaultClass.split(/\s+/).forEach(function (c) {
    return c !== '' && !el.classList.contains(c) && el.classList.add(c);
  });
  el.hasAttribute('modifier') && ModifierUtil.refresh(el, scheme);
};

// TODO: FIX
util$1.updateParentPosition = function (el) {
  if (!el._parentUpdated && el.parentElement) {
    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
      el.parentElement.style.position = 'relative';
    }
    el._parentUpdated = true;
  }
};

util$1.toggleAttribute = function (element, name, value) {
  if (value) {
    element.setAttribute(name, typeof value === 'boolean' ? '' : value);
  } else {
    element.removeAttribute(name);
  }
};

util$1.bindListeners = function (element, listenerNames) {
  listenerNames.forEach(function (name) {
    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
    element[boundName] = element[boundName] || element[name].bind(element);
  });
};

util$1.each = function (obj, f) {
  return Object.keys(obj).forEach(function (key) {
    return f(key, obj[key]);
  });
};

/**
 * @param {Element} target
 * @param {boolean} hasRipple
 * @param {Object} attrs
 */
util$1.updateRipple = function (target, hasRipple) {
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (hasRipple === undefined) {
    hasRipple = target.hasAttribute('ripple');
  }

  var rippleElement = util$1.findChild(target, 'ons-ripple');

  if (hasRipple) {
    if (!rippleElement) {
      var element = document.createElement('ons-ripple');
      Object.keys(attrs).forEach(function (key) {
        return element.setAttribute(key, attrs[key]);
      });
      target.insertBefore(element, target.firstChild);
    }
  } else if (rippleElement) {
    rippleElement.remove();
  }
};

/**
 * @param {String}
 * @return {Object}
 */
util$1.animationOptionsParse = parse;

/**
 * @param {*} value
 */
util$1.isInteger = function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

/**
 * @return {Object} Deferred promise.
 */
util$1.defer = function () {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

/**
 * Show warnings when they are enabled.
 *
 * @param {*} arguments to console.warn
 */
util$1.warn = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  if (!internal$1.config.warningsDisabled) {
    var _console;

    (_console = console).warn.apply(_console, [errorPrefix].concat(args));
  }
};

util$1.throw = function (message) {
  throw new Error(errorPrefix + ' ' + message);
};

util$1.throwAbstract = function () {
  return util$1.throw('Cannot instantiate abstract class');
};
util$1.throwMember = function () {
  return util$1.throw('Class member must be implemented');
};
util$1.throwPageLoader = function () {
  return util$1.throw('First parameter should be an instance of PageLoader');
};
util$1.throwAnimator = function (el) {
  return util$1.throw('"Animator" param must inherit ' + el + 'Animator');
};

var prevent = function prevent(e) {
  return e.cancelable && e.preventDefault();
};

/**
 * Prevent scrolling while draging horizontally on iOS.
 *
 * @param {gd} GestureDetector instance
 */
util$1.iosPreventScroll = function (gd) {
  if (util$1.globals.actualMobileOS === 'ios') {
    var clean = function clean(e) {
      gd.off('touchmove', prevent);
      gd.off('dragend', clean);
    };

    gd.on('touchmove', prevent);
    gd.on('dragend', clean);
  }
};

/**
 * Prevents scroll in underlying pages on iOS. See #2220 #2274 #1949
 *
 * @param {el} HTMLElement that prevents the events
 * @param {add} Boolean Add or remove event listeners
 */
util$1.iosPageScrollFix = function (add) {
  // Full fix - May cause issues with UIWebView's momentum scroll
  if (util$1.globals.actualMobileOS === 'ios') {
    document.body.classList.toggle('ons-ios-scroll', add); // Allows custom and localized fixes (#2274)
    if (!util$1.globals.isUIWebView || internal$1.config.forceUIWebViewScrollFix) {
      document.body.classList.toggle('ons-ios-scroll-fix', add);
    }
  }
};
util$1.iosMaskScrollFix = function (el, add) {
  // Half fix - only prevents scroll on masks
  if (util$1.globals.isUIWebView) {
    var action = (add ? 'add' : 'remove') + 'EventListener';
    el[action]('touchmove', prevent, false);
  }
};

/**
 * Distance and deltaTime filter some weird dragstart events that are not fired immediately.
 *
 * @param {event}
 */
util$1.isValidGesture = function (event) {
  return event.gesture !== undefined && (event.gesture.distance <= 15 || event.gesture.deltaTime <= 100);
};

util$1.checkMissingImport = function () {
  for (var _len3 = arguments.length, elementNames = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    elementNames[_key3] = arguments[_key3];
  }

  elementNames.forEach(function (name) {
    if (!onsElements[name]) {
      util$1.throw('Ons' + name + ' is required but was not imported (Custom Elements)');
    }
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
var TIMEOUT_RATIO = 1.4;

var util$4 = {};

// capitalize string
util$4.capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * @param {Object} params
 * @param {String} params.property
 * @param {Float} params.duration
 * @param {String} params.timing
 */
util$4.buildTransitionValue = function (params) {
  params.property = params.property || 'all';
  params.duration = params.duration || 0.4;
  params.timing = params.timing || 'linear';

  var props = params.property.split(/ +/);

  return props.map(function (prop) {
    return prop + ' ' + params.duration + 's ' + params.timing;
  }).join(', ');
};

/**
 * Add an event handler on "transitionend" event.
 */
util$4.onceOnTransitionEnd = function (element, callback) {
  if (!element) {
    return function () {};
  }

  var fn = function fn(event) {
    if (element == event.target) {
      event.stopPropagation();
      removeListeners();

      callback();
    }
  };

  var removeListeners = function removeListeners() {
    util$4._transitionEndEvents.forEach(function (eventName) {
      element.removeEventListener(eventName, fn, false);
    });
  };

  util$4._transitionEndEvents.forEach(function (eventName) {
    element.addEventListener(eventName, fn, false);
  });

  return removeListeners;
};

util$4._transitionEndEvents = function () {

  if ('ontransitionend' in window) {
    return ['transitionend'];
  }

  if ('onwebkittransitionend' in window) {
    return ['webkitTransitionEnd'];
  }

  if (util$4.vendorPrefix === 'webkit' || util$4.vendorPrefix === 'o' || util$4.vendorPrefix === 'moz' || util$4.vendorPrefix === 'ms') {
    return [util$4.vendorPrefix + 'TransitionEnd', 'transitionend'];
  }

  return [];
}();

util$4._cssPropertyDict = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var dict = {};
  var a = 'A'.charCodeAt(0);
  var z = 'z'.charCodeAt(0);

  var upper = function upper(s) {
    return s.substr(1).toUpperCase();
  };

  for (var i = 0; i < styles.length; i++) {

    var key = styles[i].replace(/^[-]+/, '').replace(/[-][a-z]/g, upper).replace(/^moz/, 'Moz');

    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
      if (key !== 'cssText' && key !== 'parentText') {
        dict[key] = true;
      }
    }
  }

  return dict;
}();

util$4.hasCssProperty = function (name) {
  return name in util$4._cssPropertyDict;
};

/**
 * Vendor prefix for css property.
 */
util$4.vendorPrefix = function () {
  var styles = window.getComputedStyle(document.documentElement, ''),
      pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];
  return pre;
}();

util$4.forceLayoutAtOnce = function (elements, callback) {
  this.batchImmediate(function () {
    elements.forEach(function (element) {
      // force layout
      element.offsetHeight;
    });
    callback();
  });
};

util$4.batchImmediate = function () {
  var callbacks = [];

  return function (callback) {
    if (callbacks.length === 0) {
      setImmediate(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$4.batchAnimationFrame = function () {
  var callbacks = [];

  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    setTimeout(callback, 1000 / 60);
  };

  return function (callback) {
    if (callbacks.length === 0) {
      raf(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$4.transitionPropertyName = function () {
  if (util$4.hasCssProperty('transitionDuration')) {
    return 'transition';
  }

  if (util$4.hasCssProperty(util$4.vendorPrefix + 'TransitionDuration')) {
    return util$4.vendorPrefix + 'Transition';
  }

  throw new Error('Invalid state');
}();

/**
 * @param {HTMLElement} element
 */
var Animit = function Animit(element, defaults) {
  if (!(this instanceof Animit)) {
    return new Animit(element, defaults);
  }

  if (element instanceof HTMLElement) {
    this.elements = [element];
  } else if (Object.prototype.toString.call(element) === '[object Array]') {
    this.elements = element;
  } else {
    throw new Error('First argument must be an array or an instance of HTMLElement.');
  }

  this.defaults = defaults;
  this.transitionQueue = [];
  this.lastStyleAttributeDict = [];
};

Animit.prototype = {

  /**
   * @property {Array}
   */
  transitionQueue: undefined,

  /**
   * @property {Array}
   */
  elements: undefined,

  /**
   * @property {Object}
   */
  defaults: undefined,

  /**
   * Start animation sequence with passed animations.
   *
   * @param {Function} callback
   */
  play: function play(callback) {
    if (typeof callback === 'function') {
      this.transitionQueue.push(function (done) {
        callback();
        done();
      });
    }

    this.startAnimation();

    return this;
  },

  /**
   * Most of the animations follow this default process.
   *
   * @param {from} css or options object containing css
   * @param {to} css or options object containing css
   * @param {delay} delay to wait
   */
  default: function _default(from, to, delay) {
    function step(params, duration, timing) {
      if (params.duration !== undefined) {
        duration = params.duration;
      }
      if (params.timing !== undefined) {
        timing = params.timing;
      }

      return {
        css: params.css || params,
        duration: duration,
        timing: timing
      };
    }

    return this.saveStyle().queue(step(from, 0, this.defaults.timing)).wait(delay === undefined ? this.defaults.delay : delay).queue(step(to, this.defaults.duration, this.defaults.timing)).restoreStyle();
  },

  /**
   * Queue transition animations or other function.
   *
   * e.g. animit(elt).queue({color: 'red'})
   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
   *
   * @param {Object|Animit.Transition|Function} transition
   * @param {Object} [options]
   */
  queue: function queue(transition, options) {
    var queue = this.transitionQueue;

    if (transition && options) {
      options.css = transition;
      transition = new Animit.Transition(options);
    }

    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
      if (transition.css) {
        transition = new Animit.Transition(transition);
      } else {
        transition = new Animit.Transition({
          css: transition
        });
      }
    }

    if (transition instanceof Function) {
      queue.push(transition);
    } else if (transition instanceof Animit.Transition) {
      queue.push(transition.build());
    } else {
      throw new Error('Invalid arguments');
    }

    return this;
  },

  /**
   * Queue transition animations.
   *
   * @param {Float} seconds
   */
  wait: function wait(seconds) {
    if (seconds > 0) {
      this.transitionQueue.push(function (done) {
        setTimeout(done, 1000 * seconds);
      });
    }

    return this;
  },

  saveStyle: function saveStyle() {

    this.transitionQueue.push(function (done) {
      this.elements.forEach(function (element, index) {
        var css = this.lastStyleAttributeDict[index] = {};

        for (var i = 0; i < element.style.length; i++) {
          css[element.style[i]] = element.style[element.style[i]];
        }
      }.bind(this));
      done();
    }.bind(this));

    return this;
  },

  /**
   * Restore element's style.
   *
   * @param {Object} [options]
   * @param {Float} [options.duration]
   * @param {String} [options.timing]
   * @param {String} [options.transition]
   */
  restoreStyle: function restoreStyle(options) {
    options = options || {};
    var self = this;

    if (options.transition && !options.duration) {
      throw new Error('"options.duration" is required when "options.transition" is enabled.');
    }

    var transitionName = util$4.transitionPropertyName;

    if (options.transition || options.duration && options.duration > 0) {
      var transitionValue = options.transition || 'all ' + options.duration + 's ' + (options.timing || 'linear');

      this.transitionQueue.push(function (done) {
        var elements = this.elements;
        var timeoutId;

        var clearTransition = function clearTransition() {
          elements.forEach(function (element) {
            element.style[transitionName] = '';
          });
        };

        // add "transitionend" event handler
        var removeListeners = util$4.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          clearTransition();
          done();
        });

        // for fail safe.
        timeoutId = setTimeout(function () {
          removeListeners();
          clearTransition();
          done();
        }, options.duration * 1000 * TIMEOUT_RATIO);

        // transition and style settings
        elements.forEach(function (element, index) {

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          var name;
          for (var i = 0, len = element.style.length; i < len; i++) {
            name = element.style[i];
            if (css[name] === undefined) {
              css[name] = '';
            }
          }

          element.style[transitionName] = transitionValue;

          Object.keys(css).forEach(function (key) {
            if (key !== transitionName) {
              element.style[key] = css[key];
            }
          });

          element.style[transitionName] = transitionValue;
        });
      });
    } else {
      this.transitionQueue.push(function (done) {
        reset();
        done();
      });
    }

    return this;

    function reset() {
      // Clear transition animation settings.
      self.elements.forEach(function (element, index) {
        element.style[transitionName] = 'none';

        var css = self.lastStyleAttributeDict[index];

        if (!css) {
          throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
        }

        self.lastStyleAttributeDict[index] = undefined;

        for (var i = 0, name = ''; i < element.style.length; i++) {
          name = element.style[i];
          if (typeof css[element.style[i]] === 'undefined') {
            css[element.style[i]] = '';
          }
        }

        Object.keys(css).forEach(function (key) {
          element.style[key] = css[key];
        });
      });
    }
  },

  /**
   * Start animation sequence.
   */
  startAnimation: function startAnimation() {
    this._dequeueTransition();

    return this;
  },

  _dequeueTransition: function _dequeueTransition() {
    var transition = this.transitionQueue.shift();
    if (this._currentTransition) {
      throw new Error('Current transition exists.');
    }
    this._currentTransition = transition;
    var self = this;
    var called = false;

    var done = function done() {
      if (!called) {
        called = true;
        self._currentTransition = undefined;
        self._dequeueTransition();
      } else {
        throw new Error('Invalid state: This callback is called twice.');
      }
    };

    if (transition) {
      transition.call(this, done);
    }
  }

};

/**
 * @param {Animit} arguments
 */
Animit.runAll = function () /* arguments... */{
  for (var i = 0; i < arguments.length; i++) {
    arguments[i].play();
  }
};

/**
 * @param {Object} options
 * @param {Float} [options.duration]
 * @param {String} [options.property]
 * @param {String} [options.timing]
 */
Animit.Transition = function (options) {
  this.options = options || {};
  this.options.duration = this.options.duration || 0;
  this.options.timing = this.options.timing || 'linear';
  this.options.css = this.options.css || {};
  this.options.property = this.options.property || 'all';
};

Animit.Transition.prototype = {

  /**
   * @param {HTMLElement} element
   * @return {Function}
   */
  build: function build() {

    if (Object.keys(this.options.css).length === 0) {
      throw new Error('options.css is required.');
    }

    var css = createActualCssProps(this.options.css);

    if (this.options.duration > 0) {
      var transitionValue = util$4.buildTransitionValue(this.options);
      var self = this;

      return function (callback) {
        var elements = this.elements;
        var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
        var timeoutId;

        var removeListeners = util$4.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          callback();
        });

        timeoutId = setTimeout(function () {
          removeListeners();
          callback();
        }, timeout);

        elements.forEach(function (element) {
          element.style[util$4.transitionPropertyName] = transitionValue;

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });
      };
    }

    if (this.options.duration <= 0) {
      return function (callback) {
        var elements = this.elements;

        elements.forEach(function (element) {
          element.style[util$4.transitionPropertyName] = '';

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });

        if (elements.length > 0) {
          util$4.forceLayoutAtOnce(elements, function () {
            util$4.batchAnimationFrame(callback);
          });
        } else {
          util$4.batchAnimationFrame(callback);
        }
      };
    }

    function createActualCssProps(css) {
      var result = {};

      Object.keys(css).forEach(function (name) {
        var value = css[name];

        if (util$4.hasCssProperty(name)) {
          result[name] = value;
          return;
        }

        var prefixed = util$4.vendorPrefix + util$4.capitalize(name);
        if (util$4.hasCssProperty(prefixed)) {
          result[prefixed] = value;
        } else {
          result[prefixed] = value;
          result[name] = value;
        }
      });

      return result;
    }
  }
};

/*
 * Gesture detector library that forked from github.com/EightMedia/hammer.js.
 */

var Event$1;
var Utils;
var Detection;
var PointerEvent;

/**
 * @object ons.GestureDetector
 * @category gesture
 * @description
 *   [en]Utility class for gesture detection.[/en]
 *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
 */

/**
 * @method constructor
 * @signature constructor(element[, options])
 * @description
 *  [en]Create a new GestureDetector instance.[/en]
 *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
 * @param {Element} element
 *   [en]Name of the event.[/en]
 *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
 * @param {Object} [options]
 *   [en]Options object.[/en]
 *   [ja]オプションを指定します。[/ja]
 * @return {ons.GestureDetector.Instance}
 */
var GestureDetector = function GestureDetector(element, options) {
  return new GestureDetector.Instance(element, options || {});
};

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  GestureDetector.defaults.drag = false;
 *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
 *  delete GestureDetector.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
GestureDetector.defaults = {
  behavior: {
    // userSelect: 'none', // Also disables selection in `input` children
    touchAction: 'pan-y',
    touchCallout: 'none',
    contentZooming: 'none',
    userDrag: 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }
};

/**
 * GestureDetector document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
GestureDetector.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

/**
 * interval in which GestureDetector recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
GestureDetector.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = GestureDetector.EVENT_START = 'start';
var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
var EVENT_END = GestureDetector.EVENT_END = 'end';
var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
GestureDetector.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
GestureDetector.plugins = GestureDetector.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
GestureDetector.gestures = GestureDetector.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup(opts) {
  if (GestureDetector.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Event$1.determineEventTypes();

  // Register all gestures inside GestureDetector.gestures
  Utils.each(GestureDetector.gestures, function (gesture) {
    Detection.register(gesture);
  });

  // Add touch events on the document
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);

  // GestureDetector is ready...!
  GestureDetector.READY = true;
}

/**
 * @module GestureDetector
 *
 * @class Utils
 * @static
 */
Utils = GestureDetector.utils = {
  /**
   * extend method, could also be used for cloning when `dest` is an empty object.
   * changes the dest object
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]  do a merge
   * @return {Object} dest
   */
  extend: function extend(dest, src, merge) {
    for (var key in src) {
      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
        dest[key] = src[key];
      }
    }
    return dest;
  },

  /**
   * simple addEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  on: function on(element, type, handler, opt) {
    util$1.addEventListener(element, type, handler, opt, true);
  },

  /**
   * simple removeEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  off: function off(element, type, handler, opt) {
    util$1.removeEventListener(element, type, handler, opt, true);
  },

  /**
   * forEach over arrays and objects
   * @param {Object|Array} obj
   * @param {Function} iterator
   * @param {any} iterator.item
   * @param {Number} iterator.index
   * @param {Object|Array} iterator.obj the source object
   * @param {Object} context value to use as `this` in the iterator
   */
  each: function each(obj, iterator, context) {
    var i, len;

    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
      // arrays
    } else if (obj.length !== undefined) {
      for (i = 0, len = obj.length; i < len; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
      // objects
    } else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a string contains the string using indexOf
   * @param {String} src
   * @param {String} find
   * @return {Boolean} found
   */
  inStr: function inStr(src, find) {
    return src.indexOf(find) > -1;
  },

  /**
   * find if a array contains the object using indexOf or a simple polyfill
   * @param {String} src
   * @param {String} find
   * @return {Boolean|Number} false when not found, or the index
   */
  inArray: function inArray(src, find, deep) {
    if (deep) {
      for (var i = 0, len = src.length; i < len; i++) {
        // Array.findIndex
        if (Object.keys(find).every(function (key) {
          return src[i][key] === find[key];
        })) {
          return i;
        }
      }
      return -1;
    }

    if (src.indexOf) {
      return src.indexOf(find);
    } else {
      for (var i = 0, len = src.length; i < len; i++) {
        if (src[i] === find) {
          return i;
        }
      }
      return -1;
    }
  },

  /**
   * convert an array-like object (`arguments`, `touchlist`) to an array
   * @param {Object} obj
   * @return {Array}
   */
  toArray: function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  },

  /**
   * find if a node is in the given parent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  hasParent: function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },

  /**
   * get the center of all the touches
   * @param {Array} touches
   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
   */
  getCenter: function getCenter(touches) {
    var pageX = [],
        pageY = [],
        clientX = [],
        clientY = [],
        min = Math.min,
        max = Math.max;

    // no need to loop when only one touch
    if (touches.length === 1) {
      return {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY,
        clientX: touches[0].clientX,
        clientY: touches[0].clientY
      };
    }

    Utils.each(touches, function (touch) {
      pageX.push(touch.pageX);
      pageY.push(touch.pageY);
      clientX.push(touch.clientX);
      clientY.push(touch.clientY);
    });

    return {
      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
    };
  },

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   * @return {Object} velocity `x` and `y`
   */
  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
    return {
      x: Math.abs(deltaX / deltaTime) || 0,
      y: Math.abs(deltaY / deltaTime) || 0
    };
  },

  /**
   * calculate the angle between two coordinates
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {Number} angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.atan2(y, x) * 180 / Math.PI;
  },

  /**
   * do a small comparison to get the direction between two touches.
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.clientX - touch2.clientX),
        y = Math.abs(touch1.clientY - touch2.clientY);

    if (x >= y) {
      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },

  /**
   * calculate the distance between two touches
   * @param {Touch}touch1
   * @param {Touch} touch2
   * @return {Number} distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.sqrt(x * x + y * y);
  },

  /**
   * calculate the scale factor between two touchLists
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if (start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },

  /**
   * calculate the rotation degrees between two touchLists
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if (start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },

  /**
   * find out if the direction is vertical   *
   * @param {String} direction matches `DIRECTION_UP|DOWN`
   * @return {Boolean} is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },

  /**
   * set css properties with their prefixes
   * @param {HTMLElement} element
   * @param {String} prop
   * @param {String} value
   * @param {Boolean} [toggle=true]
   * @return {Boolean}
   */
  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
    prop = Utils.toCamelCase(prop);

    for (var i = 0; i < prefixes.length; i++) {
      var p = prop;
      // prefixes
      if (prefixes[i]) {
        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
      }

      // test the style
      if (p in element.style) {
        element.style[p] = (toggle === null || toggle) && value || '';
        break;
      }
    }
  },

  /**
   * toggle browser default behavior by setting css properties.
   * `userSelect='none'` also sets `element.onselectstart` to false
   * `userDrag='none'` also sets `element.ondragstart` to false
   *
   * @param {HtmlElement} element
   * @param {Object} props
   * @param {Boolean} [toggle=true]
   */
  toggleBehavior: function toggleBehavior(element, props, toggle) {
    if (!props || !element || !element.style) {
      return;
    }

    // set the css properties
    Utils.each(props, function (value, prop) {
      Utils.setPrefixedCss(element, prop, value, toggle);
    });

    var falseFn = toggle && function () {
      return false;
    };

    // also the disable onselectstart
    if (props.userSelect == 'none') {
      element.onselectstart = falseFn;
    }
    // and disable ondragstart
    if (props.userDrag == 'none') {
      element.ondragstart = falseFn;
    }
  },

  /**
   * convert a string with underscores to camelCase
   * so prevent_default becomes preventDefault
   * @param {String} str
   * @return {String} camelCaseStr
   */
  toCamelCase: function toCamelCase(str) {
    return str.replace(/[_-]([a-z])/g, function (s) {
      return s[1].toUpperCase();
    });
  }
};

/**
 * @module GestureDetector
 */
/**
 * @class Event
 * @static
 */
Event$1 = GestureDetector.event = {
  /**
   * when touch events have been fired, this is true
   * this is used to stop mouse events
   * @property prevent_mouseevents
   * @private
   * @type {Boolean}
   */
  preventMouseEvents: false,

  /**
   * if EVENT_START has been fired
   * @property started
   * @private
   * @type {Boolean}
   */
  started: false,

  /**
   * when the mouse is hold down, this is true
   * @property should_detect
   * @private
   * @type {Boolean}
   */
  shouldDetect: false,

  /**
   * simple event binder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Object} [opt]
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  on: function on(element, type, handler, opt, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.on(element, type, handler, opt);
      hook && hook(type);
    });
  },

  /**
   * simple event unbinder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Object} [opt]
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  off: function off(element, type, handler, opt, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.off(element, type, handler, opt);
      hook && hook(type);
    });
  },

  /**
   * the core touch event handler.
   * this finds out if we should to detect gestures
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Function} handler
   * @return onTouchHandler {Function} the core event handler
   */
  onTouch: function onTouch(element, eventType, handler, opt) {
    var self = this;

    var onTouchHandler = function onTouchHandler(ev) {
      var srcType = ev.type.toLowerCase(),
          isPointer = GestureDetector.HAS_POINTEREVENTS,
          isMouse = Utils.inStr(srcType, 'mouse'),
          triggerType;

      // if we are in a mouseevent, but there has been a touchevent triggered in this session
      // we want to do nothing. simply break out of the event.
      if (isMouse && self.preventMouseEvents) {
        return;

        // mousebutton must be down
      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
        self.preventMouseEvents = false;
        self.shouldDetect = true;
      } else if (isPointer && eventType == EVENT_START) {
        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
        // just a valid start event, but no mouse
      } else if (!isMouse && eventType == EVENT_START) {
        self.preventMouseEvents = true;
        self.shouldDetect = true;
      }

      // update the pointer event before entering the detection
      if (isPointer && eventType != EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }

      // we are in a touch/down state, so allowed detection of gestures
      if (self.shouldDetect) {
        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
      }

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      if (triggerType == EVENT_END) {
        self.preventMouseEvents = false;
        self.shouldDetect = false;
        PointerEvent.reset();
        // update the pointerevent object after the detection
      }

      if (isPointer && eventType == EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
    };

    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);
    return onTouchHandler;
  },

  /**
   * the core detection method
   * this finds out what GestureDetector-touch-events to trigger
   * @param {Object} ev
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {HTMLElement} element
   * @param {Function} handler
   * @return {String} triggerType matches `EVENT_START|MOVE|END`
   */
  doDetect: function doDetect(ev, eventType, element, handler) {
    var touchList = this.getTouchList(ev, eventType);
    var touchListLength = touchList.length;
    var triggerType = eventType;
    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
    var changedLength = touchListLength;

    // at each touchstart-like event we want also want to trigger a TOUCH event...
    if (eventType == EVENT_START) {
      triggerChange = EVENT_TOUCH;
      // ...the same for a touchend-like event
    } else if (eventType == EVENT_END) {
      triggerChange = EVENT_RELEASE;

      // keep track of how many touches have been removed
      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
    }

    // after there are still touches on the screen,
    // we just want to trigger a MOVE event. so change the START or END to a MOVE
    // but only after detection has been started, the first time we actually want a START
    if (changedLength > 0 && this.started) {
      triggerType = EVENT_MOVE;
    }

    // detection has been started, we keep track of this, see above
    this.started = true;

    // generate some event data, some basic information
    var evData = this.collectEventData(element, triggerType, touchList, ev);

    // trigger the triggerType event before the change (TOUCH, RELEASE) events
    // but the END event should be at last
    if (eventType != EVENT_END) {
      handler.call(Detection, evData);
    }

    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
    if (triggerChange) {
      evData.changedLength = changedLength;
      evData.eventType = triggerChange;

      handler.call(Detection, evData);

      evData.eventType = triggerType;
      delete evData.changedLength;
    }

    // trigger the END event
    if (triggerType == EVENT_END) {
      handler.call(Detection, evData);

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      this.started = false;
    }

    return triggerType;
  },

  /**
   * we have different events for each device/browser
   * determine what we need and set them in the EVENT_TYPES constant
   * the `onTouch` method is bind to these properties.
   * @return {Object} events
   */
  determineEventTypes: function determineEventTypes() {
    var types;
    if (GestureDetector.HAS_POINTEREVENTS) {
      if (window.PointerEvent) {
        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
      } else {
        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
      }
    } else if (GestureDetector.NO_MOUSEEVENTS) {
      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
    } else {
      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
    }

    EVENT_TYPES[EVENT_START] = types[0];
    EVENT_TYPES[EVENT_MOVE] = types[1];
    EVENT_TYPES[EVENT_END] = types[2];
    return EVENT_TYPES;
  },

  /**
   * create touchList depending on the event
   * @param {Object} ev
   * @param {String} eventType
   * @return {Array} touches
   */
  getTouchList: function getTouchList(ev, eventType) {
    // get the fake pointerEvent touchlist
    if (GestureDetector.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }

    // get the touchlist
    if (ev.touches) {
      if (eventType == EVENT_MOVE) {
        return ev.touches;
      }

      var identifiers = [];
      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
      var touchList = [];

      Utils.each(concat, function (touch) {
        if (Utils.inArray(identifiers, touch.identifier) === -1) {
          touchList.push(touch);
        }
        identifiers.push(touch.identifier);
      });

      return touchList;
    }

    // make fake touchList from mouse position
    ev.identifier = 1;
    return [ev];
  },

  /**
   * collect basic event data
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Array} touches
   * @param {Object} ev
   * @return {Object} ev
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = POINTER_TOUCH;
    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
      pointerType = POINTER_PEN;
    }

    return {
      center: Utils.getCenter(touches),
      timeStamp: Date.now(),
      target: ev.target,
      touches: touches,
      eventType: eventType,
      pointerType: pointerType,
      srcEvent: ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function preventDefault() {
        var srcEvent = this.srcEvent;
        srcEvent.preventManipulation && srcEvent.preventManipulation();
        srcEvent.preventDefault && srcEvent.preventDefault();
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function stopPropagation() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function stopDetect() {
        return Detection.stopDetect();
      }
    };
  }
};

/**
 * @module GestureDetector
 *
 * @class PointerEvent
 * @static
 */
PointerEvent = GestureDetector.PointerEvent = {
  /**
   * holds all pointers, by `identifier`
   * @property pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get the pointers as an array
   * @return {Array} touchlist
   */
  getTouchList: function getTouchList() {
    var touchlist = [];
    // we can use forEach since pointerEvents only is in IE10
    Utils.each(this.pointers, function (pointer) {
      touchlist.push(pointer);
    });
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Object} pointerEvent
   */
  updatePointer: function updatePointer(eventType, pointerEvent) {
    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
      delete this.pointers[pointerEvent.pointerId];
    } else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }
  },

  /**
   * check if ev matches pointertype
   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
   * @param {PointerEvent} ev
   */
  matchType: function matchType(pointerType, ev) {
    if (!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
        types = {};

    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
    return types[pointerType];
  },

  /**
   * reset the stored pointers
   */
  reset: function resetList() {
    this.pointers = {};
  }
};

/**
 * @module GestureDetector
 *
 * @class Detection
 * @static
 */
Detection = GestureDetector.detection = {
  // contains all registered GestureDetector.gestures in the correct order
  gestures: [],

  // data of the current GestureDetector.gesture detection session
  current: null,

  // the previous GestureDetector.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped: false,

  /**
   * start GestureDetector.gesture detection
   * @param {GestureDetector.Instance} inst
   * @param {Object} eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a GestureDetector.gesture detection on an element
    if (this.current) {
      return;
    }

    this.stopped = false;

    // holds current session
    this.current = {
      inst: inst, // reference to GestureDetectorInstance we're working for
      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent: false, // last eventData
      lastCalcEvent: false, // last eventData for calculations.
      futureCalcEvent: false, // last eventData for calculations.
      lastCalcData: {}, // last lastCalcData
      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },

  /**
   * GestureDetector.gesture detection
   * @param {Object} eventData
   * @return {any}
   */
  detect: function detect(eventData) {
    if (!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // GestureDetector instance and instance options
    var inst = this.current.inst,
        instOptions = inst.options;

    // call GestureDetector.gesture handlers
    Utils.each(this.gestures, function triggerGesture(gesture) {
      // only when the instance options have enabled this gesture
      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
        gesture.handler.call(gesture, eventData, inst);
      }
    }, this);

    // store as previous event event
    if (this.current) {
      this.current.lastEvent = eventData;
    }

    if (eventData.eventType == EVENT_END) {
      this.stopDetect();
    }

    return eventData; // eslint-disable-line consistent-return
  },

  /**
   * clear the GestureDetector.gesture vars
   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
   * to stop other GestureDetector.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Utils.extend({}, this.current);

    // reset the current
    this.current = null;
    this.stopped = true;
  },

  /**
   * calculate velocity, angle and direction
   * @param {Object} ev
   * @param {Object} center
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   */
  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
    var cur = this.current,
        recalc = false,
        calcEv = cur.lastCalcEvent,
        calcData = cur.lastCalcData;

    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
      center = calcEv.center;
      deltaTime = ev.timeStamp - calcEv.timeStamp;
      deltaX = ev.center.clientX - calcEv.center.clientX;
      deltaY = ev.center.clientY - calcEv.center.clientY;
      recalc = true;
    }

    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      cur.futureCalcEvent = ev;
    }

    if (!cur.lastCalcEvent || recalc) {
      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
      calcData.angle = Utils.getAngle(center, ev.center);
      calcData.direction = Utils.getDirection(center, ev.center);

      cur.lastCalcEvent = cur.futureCalcEvent || ev;
      cur.futureCalcEvent = ev;
    }

    ev.velocityX = calcData.velocity.x;
    ev.velocityY = calcData.velocity.y;
    ev.interimAngle = calcData.angle;
    ev.interimDirection = calcData.direction;
  },

  /**
   * extend eventData for GestureDetector.gestures
   * @param {Object} ev
   * @return {Object} ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current,
        startEv = cur.startEvent,
        lastEv = cur.lastEvent || startEv;

    // update the start touchlist to calculate the scale/rotation
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      startEv.touches = [];
      Utils.each(ev.touches, function (touch) {
        startEv.touches.push({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
      });
    }

    var deltaTime = ev.timeStamp - startEv.timeStamp,
        deltaX = ev.center.clientX - startEv.center.clientX,
        deltaY = ev.center.clientY - startEv.center.clientY;

    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

    Utils.extend(ev, {
      startEvent: startEv,

      deltaTime: deltaTime,
      deltaX: deltaX,
      deltaY: deltaY,

      distance: Utils.getDistance(startEv.center, ev.center),
      angle: Utils.getAngle(startEv.center, ev.center),
      direction: Utils.getDirection(startEv.center, ev.center),
      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches)
    });

    return ev;
  },

  /**
   * register new gesture
   * @param {Object} gesture object, see `gestures/` for documentation
   * @return {Array} gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if (options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend GestureDetector default options with the GestureDetector.gesture options
    Utils.extend(GestureDetector.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add GestureDetector.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function (a, b) {
      if (a.index < b.index) {
        return -1;
      }
      if (a.index > b.index) {
        return 1;
      }
      return 0;
    });

    return this.gestures;
  }
};

/**
 * @module GestureDetector
 */

/**
 * create new GestureDetector instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
 * @return {GestureDetector.Instance}
 */
GestureDetector.Instance = function (element, options) {
  var self = this;
  var listenerOptions = options && options.passive ? { passive: true } : undefined;

  // setup GestureDetectorJS window events and register all gestures
  // this also sets up the default options
  setup(listenerOptions);

  /**
   * @property element
   * @type {HTMLElement}
   */
  this.element = element;

  /**
   * @property enabled
   * @type {Boolean}
   * @protected
   */
  this.enabled = true;

  /**
   * options, merged with the defaults
   * options with an _ are converted to camelCase
   * @property options
   * @type {Object}
   */
  Utils.each(options, function (value, name) {
    delete options[name];
    options[Utils.toCamelCase(name)] = value;
  });

  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});
  this.options.listenerOptions = listenerOptions;

  // add some css to the element to prevent the browser from doing its native behavior
  if (this.options.behavior) {
    Utils.toggleBehavior(this.element, this.options.behavior, true);
  }

  /**
   * event start handler on the element to start the detection
   * @property eventStartHandler
   * @type {Object}
   */
  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
    if (self.enabled && ev.eventType == EVENT_START) {
      Detection.startDetect(self, ev);
    } else if (ev.eventType == EVENT_TOUCH) {
      Detection.detect(ev);
    }
  }, listenerOptions);

  /**
   * keep a list of user event handlers which needs to be removed when calling 'dispose'
   * @property eventHandlers
   * @type {Array}
   */
  this.eventHandlers = [];
};

GestureDetector.Instance.prototype = {
  /**
   * @method on
   * @signature on(gestures, handler)
   * @description
   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  on: function onEvent(gestures, handler, opt) {
    var self = this;

    Event$1.on(self.element, gestures, handler, util$1.extend({}, self.options.listenerOptions, opt), function (type) {
      self.eventHandlers.push({ gesture: type, handler: handler });
    });
    return self;
  },

  /**
   * @method off
   * @signature off(gestures, handler)
   * @description
   *  [en]Remove an event listener.[/en]
   *  [ja]イベントリスナーを削除します。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  off: function offEvent(gestures, handler, opt) {
    var self = this;

    Event$1.off(self.element, gestures, handler, util$1.extend({}, self.options.listenerOptions, opt), function (type) {
      var index = Utils.inArray(self.eventHandlers, { gesture: type, handler: handler }, true);
      if (index >= 0) {
        self.eventHandlers.splice(index, 1);
      }
    });
    return self;
  },

  /**
   * trigger gesture event
   * @method trigger
   * @signature trigger(gesture, eventData)
   * @param {String} gesture
   * @param {Object} [eventData]
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if (!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = GestureDetector.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if (Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },

  /**
   * @method enable
   * @signature enable(state)
   * @description
   *  [en]Enable or disable gesture detection.[/en]
   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
   * @param {Boolean} state
   *   [en]Specify if it should be enabled or not.[/en]
   *   [ja]有効にするかどうかを指定します。[/ja]
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },

  /**
   * @method dispose
   * @signature dispose()
   * @description
   *  [en]Remove and destroy all event handlers for this instance.[/en]
   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
   */
  dispose: function dispose() {
    var i, eh;

    // undo all changes made by stop_browser_behavior
    Utils.toggleBehavior(this.element, this.options.behavior, false);

    // unbind all custom event handlers
    for (i = -1; eh = this.eventHandlers[++i];) {
      // eslint-disable-line no-cond-assign
      Utils.off(this.element, eh.gesture, eh.handler);
    }

    this.eventHandlers = [];

    // unbind the start event listener
    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

    return null;
  }
};

/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  GestureDetectortime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function dragGesture(ev, inst) {
    var cur = Detection.current;

    // max touches
    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
      return;
    }

    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
          return;
        }

        var startCenter = cur.startEvent.center;

        // we are dragging!
        if (cur.name != name) {
          cur.name = name;
          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
            startCenter.pageX += ev.deltaX * factor;
            startCenter.pageY += ev.deltaY * factor;
            startCenter.clientX += ev.deltaX * factor;
            startCenter.clientY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
          ev.dragLockToAxis = true;
        }

        // keep direction on the axis that the drag gesture started on
        var lastDirection = cur.lastEvent.direction;
        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
          if (Utils.isVertical(lastDirection)) {
            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          } else {
            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        // trigger events
        inst.trigger(name, ev);
        inst.trigger(name + ev.direction, ev);

        var isVertical = Utils.isVertical(ev.direction);

        // block the browser events
        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
          ev.preventDefault();
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;

      case EVENT_END:
        triggered = false;
        break;
    }
  }

  GestureDetector.gestures.Drag = {
    name: name,
    index: 50,
    handler: dragGesture,
    defaults: {
      /**
       * minimal movement that have to be made before the drag event gets triggered
       * @property dragMinDistance
       * @type {Number}
       * @default 10
       */
      dragMinDistance: 10,

      /**
       * Set dragDistanceCorrection to true to make the starting point of the drag
       * be calculated from where the drag was triggered, not from where the touch started.
       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
       * through dragging difficult, and be visually unappealing.
       * @property dragDistanceCorrection
       * @type {Boolean}
       * @default true
       */
      dragDistanceCorrection: true,

      /**
       * set 0 for unlimited, but this can conflict with transform
       * @property dragMaxTouches
       * @type {Number}
       * @default 1
       */
      dragMaxTouches: 1,

      /**
       * prevent default browser behavior when dragging occurs
       * be careful with it, it makes the element a blocking element
       * when you are using the drag gesture, it is a good practice to set this true
       * @property dragBlockHorizontal
       * @type {Boolean}
       * @default false
       */
      dragBlockHorizontal: false,

      /**
       * same as `dragBlockHorizontal`, but for vertical movement
       * @property dragBlockVertical
       * @type {Boolean}
       * @default false
       */
      dragBlockVertical: false,

      /**
       * dragLockToAxis keeps the drag gesture on the axis that it started on,
       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
       * @property dragLockToAxis
       * @type {Boolean}
       * @default false
       */
      dragLockToAxis: false,

      /**
       * drag lock only kicks in when distance > dragLockMinDistance
       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
       * @property dragLockMinDistance
       * @type {Number}
       * @default 25
       */
      dragLockMinDistance: 25
    }
  };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
GestureDetector.gestures.Gesture = {
  name: 'gesture',
  index: 1337,
  handler: function releaseGesture(ev, inst) {
    inst.trigger(this.name, ev);
  }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var timer;

  function holdGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current;

    switch (ev.eventType) {
      case EVENT_START:
        clearTimeout(timer);

        // set the gesture so we can check in the timeout if it still is
        current.name = name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        timer = setTimeout(function () {
          if (current && current.name == name) {
            inst.trigger(name, ev);
          }
        }, options.holdTimeout);
        break;

      case EVENT_MOVE:
        if (ev.distance > options.holdThreshold) {
          clearTimeout(timer);
        }
        break;

      case EVENT_RELEASE:
        clearTimeout(timer);
        break;
    }
  }

  GestureDetector.gestures.Hold = {
    name: name,
    index: 10,
    defaults: {
      /**
       * @property holdTimeout
       * @type {Number}
       * @default 500
       */
      holdTimeout: 500,

      /**
       * movement allowed while holding
       * @property holdThreshold
       * @type {Number}
       * @default 2
       */
      holdThreshold: 2
    },
    handler: holdGesture
  };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
GestureDetector.gestures.Release = {
  name: 'release',
  index: Infinity,
  handler: function releaseGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
GestureDetector.gestures.Swipe = {
  name: 'swipe',
  index: 40,
  defaults: {
    /**
     * @property swipeMinTouches
     * @type {Number}
     * @default 1
     */
    swipeMinTouches: 1,

    /**
     * @property swipeMaxTouches
     * @type {Number}
     * @default 1
     */
    swipeMaxTouches: 1,

    /**
     * horizontal swipe velocity
     * @property swipeVelocityX
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityX: 0.6,

    /**
     * vertical swipe velocity
     * @property swipeVelocityY
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityY: 0.6
  },

  handler: function swipeGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      var touches = ev.touches.length,
          options = inst.options;

      // max touches
      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var hasMoved = false;

  function tapGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current,
        prev = Detection.previous,
        sincePrev,
        didDoubleTap;

    switch (ev.eventType) {
      case EVENT_START:
        hasMoved = false;
        break;

      case EVENT_MOVE:
        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
        break;

      case EVENT_END:
        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
          // previous gesture, for the double tap since these are two different gesture detections
          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
          didDoubleTap = false;

          // check if double tap
          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
            inst.trigger('doubletap', ev);
            didDoubleTap = true;
          }

          // do a single tap
          if (!didDoubleTap || options.tapAlways) {
            current.name = name;
            inst.trigger(current.name, ev);
          }
        }
        break;
    }
  }

  GestureDetector.gestures.Tap = {
    name: name,
    index: 100,
    handler: tapGesture,
    defaults: {
      /**
       * max time of a tap, this is for the slow tappers
       * @property tapMaxTime
       * @type {Number}
       * @default 250
       */
      tapMaxTime: 250,

      /**
       * max distance of movement of a tap, this is for the slow tappers
       * @property tapMaxDistance
       * @type {Number}
       * @default 10
       */
      tapMaxDistance: 10,

      /**
       * always trigger the `tap` event, even while double-tapping
       * @property tapAlways
       * @type {Boolean}
       * @default true
       */
      tapAlways: true,

      /**
       * max distance between two taps
       * @property doubleTapDistance
       * @type {Number}
       * @default 20
       */
      doubleTapDistance: 20,

      /**
       * max time between two taps
       * @property doubleTapInterval
       * @type {Number}
       * @default 300
       */
      doubleTapInterval: 300
    }
  };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
GestureDetector.gestures.Touch = {
  name: 'touch',
  index: -Infinity,
  defaults: {
    /**
     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
     * but it improves gestures like transforming and dragging.
     * be careful with using this, it can be very annoying for users to be stuck on the page
     * @property preventDefault
     * @type {Boolean}
     * @default false
     */
    preventDefault: false,

    /**
     * disable mouse events, so only touch (or pen!) input triggers events
     * @property preventMouse
     * @type {Boolean}
     * @default false
     */
    preventMouse: false
  },
  handler: function touchGesture(ev, inst) {
    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if (inst.options.preventDefault) {
      ev.preventDefault();
    }

    if (ev.eventType == EVENT_TOUCH) {
      inst.trigger('touch', ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function transformGesture(ev, inst) {
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // at least multitouch
        if (ev.touches.length < 2) {
          return;
        }

        var scaleThreshold = Math.abs(1 - ev.scale);
        var rotationThreshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
          return;
        }

        // we are transforming!
        Detection.current.name = name;

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        inst.trigger(name, ev); // basic transform event

        // trigger rotate event
        if (rotationThreshold > inst.options.transformMinRotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if (scaleThreshold > inst.options.transformMinScale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength < 2) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;
    }
  }

  GestureDetector.gestures.Transform = {
    name: name,
    index: 45,
    defaults: {
      /**
       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
       * @property transformMinScale
       * @type {Number}
       * @default 0.01
       */
      transformMinScale: 0.01,

      /**
       * rotation in degrees
       * @property transformMinRotation
       * @type {Number}
       * @default 1
       */
      transformMinRotation: 1
    },

    handler: transformGesture
  };
})('transform');

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var readyMap = void 0;
var queueMap = void 0;

function isContentReady(element) {
  if (element.childNodes.length > 0) {
    setContentReady(element);
  }
  return readyMap.has(element);
}

function setContentReady(element) {
  readyMap.set(element, true);
}

function addCallback(element, fn) {
  if (!queueMap.has(element)) {
    queueMap.set(element, []);
  }
  queueMap.get(element).push(fn);
}

function consumeQueue(element) {
  var callbacks = queueMap.get(element, []) || [];
  queueMap.delete(element);
  callbacks.forEach(function (callback) {
    return callback();
  });
}

function contentReady(element) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  if (readyMap === undefined) {
    readyMap = new WeakMap();
    queueMap = new WeakMap();
  }

  addCallback(element, fn);

  if (isContentReady(element)) {
    consumeQueue(element);
    return;
  }

  var observer = new MutationObserver(function (changes) {
    setContentReady(element);
    consumeQueue(element);
  });
  observer.observe(element, { childList: true, characterData: true });

  // failback for elements has empty content.
  setImmediate(function () {
    setContentReady(element);
    consumeQueue(element);
  });
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ToastQueue = function () {
  function ToastQueue() {
    classCallCheck(this, ToastQueue);

    this.queue = [];
  }

  createClass(ToastQueue, [{
    key: "add",
    value: function add(fn, promise) {
      var _this = this;

      this.queue.push(fn);

      if (this.queue.length === 1) {
        setImmediate(this.queue[0]);
      }

      promise.then(function () {
        _this.queue.shift();

        if (_this.queue.length > 0) {
          setTimeout(_this.queue[0], 1000 / 30); // Apply some visual delay
        }
      });
    }
  }]);
  return ToastQueue;
}();

var ToastQueue$1 = new ToastQueue();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _setAttributes = function _setAttributes(element, options) {
  ['id', 'class', 'animation'].forEach(function (a) {
    return options.hasOwnProperty(a) && element.setAttribute(a, options[a]);
  });

  if (options.modifier) {
    util$1.addModifier(element, options.modifier);
  }
};

var _normalizeArguments = function _normalizeArguments(message) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaults$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  options = _extends({}, options);
  typeof message === 'string' ? options.message = message : options = message;
  if (!options || !options.message && !options.messageHTML) {
    util$1.throw('Notifications must contain a message');
  }

  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {
    options.buttonLabels = options.buttonLabels || options.buttonLabel;
    if (!Array.isArray(options.buttonLabels)) {
      options.buttonLabels = [options.buttonLabels || ''];
    }
  }

  return util$1.extend({
    compile: function compile(param) {
      return param;
    },
    callback: function callback(param) {
      return param;
    },
    animation: 'default',
    cancelable: false,
    primaryButtonIndex: (options.buttonLabels || defaults$$1.buttonLabels || []).length - 1
  }, defaults$$1, options);
};

/**
 * @object ons.notification
 * @category dialog
 * @tutorial vanilla/Reference/notification
 * @description
 *   [en]
 *     Utility methods to create different kinds of notifications. There are three methods available:
 *
 *     * `ons.notification.alert()`
 *     * `ons.notification.confirm()`
 *     * `ons.notification.prompt()`
 *     * `ons.notification.toast()`
 *
 *     It will automatically display a Material Design dialog on Android devices.
 *   [/en]
 *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 * @example
 * ons.notification.alert('Hello, world!');
 *
 * ons.notification.confirm('Are you ready?')
 *   .then(
 *     function(answer) {
 *       if (answer === 1) {
 *         ons.notification.alert('Let\'s go!');
 *       }
 *     }
 *   );
 *
 * ons.notification.prompt('How old are ?')
 *   .then(
 *     function(age) {
 *       ons.notification.alert('You are ' + age + ' years old.');
 *     }
 *   );
 */
var notification = {};

notification._createAlertDialog = function () {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return new Promise(function (resolve) {
    var options = _normalizeArguments.apply(undefined, params);
    util$1.checkMissingImport('AlertDialog', 'AlertDialogButton');

    // Prompt input string
    var inputString = '';
    if (options.isPrompt) {
      inputString = '\n      <input\n        class="text-input text-input--underbar"\n        type="' + (options.inputType || 'text') + '"\n        placeholder="' + (options.placeholder || '') + '"\n        value="' + (options.defaultValue || '') + '"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ';
    }

    // Buttons string
    var buttons = '';
    options.buttonLabels.forEach(function (label, index) {
      buttons += '\n      <ons-alert-dialog-button\n        class="\n          ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--rowfooter' : '') + '\n        "\n        style="position: relative;">\n        ' + label + '\n      </ons-alert-dialog-button>\n    ';
    });

    // Dialog Element
    var el = {};
    var _destroyDialog = function _destroyDialog() {
      if (el.dialog.onDialogCancel) {
        el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);
      }

      Object.keys(el).forEach(function (key) {
        return delete el[key];
      });
      el = null;

      if (options.destroy instanceof Function) {
        options.destroy();
      }
    };

    el.dialog = document.createElement('ons-alert-dialog');
    el.dialog.innerHTML = '\n    <div class="alert-dialog-mask"\n      style="\n        ' + (options.maskColor ? 'background-color: ' + options.maskColor : '') + '\n      "></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          ' + (options.title || '') + '\n        </div>\n        <div class="alert-dialog-content">\n          ' + (options.message || options.messageHTML) + '\n          ' + inputString + '\n        </div>\n        <div class="\n          alert-dialog-footer\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--rowfooter' : '') + '\n        ">\n          ' + buttons + '\n        </div>\n      </div>\n    </div>\n  ';
    contentReady(el.dialog);

    // Set attributes
    _setAttributes(el.dialog, options);

    // Prompt events
    if (options.isPrompt && options.submitOnEnter) {
      el.input = el.dialog.querySelector('.text-input');
      el.input.onkeypress = function (event) {
        if (event.keyCode === 13) {
          el.dialog.hide().then(function () {
            if (el) {
              var resolveValue = el.input.value;
              _destroyDialog();
              options.callback(resolveValue);
              resolve(resolveValue);
            }
          });
        }
      };
    }

    // Button events
    el.footer = el.dialog.querySelector('.alert-dialog-footer');
    util$1.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {
      buttonElement.onclick = function () {
        el.dialog.hide().then(function () {
          if (el) {
            var resolveValue = index;
            if (options.isPrompt) {
              resolveValue = index === options.primaryButtonIndex ? el.input.value : null;
            }
            el.dialog.remove();
            _destroyDialog();
            options.callback(resolveValue);
            resolve(resolveValue);
          }
        });
      };

      el.footer.appendChild(buttonElement);
    });

    // Cancel events
    if (options.cancelable) {
      el.dialog.cancelable = true;
      el.dialog.onDialogCancel = function () {
        setImmediate(function () {
          el.dialog.remove();
          _destroyDialog();
        });
        var resolveValue = options.isPrompt ? null : -1;
        options.callback(resolveValue);
        resolve(resolveValue);
      };
      el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);
    }

    // Show dialog
    document.body.appendChild(el.dialog);
    options.compile(el.dialog);
    setImmediate(function () {
      el.dialog.show().then(function () {
        if (el.input && options.isPrompt && options.autofocus) {
          var strLength = el.input.value.length;
          el.input.focus();
          el.input.setSelectionRange(strLength, strLength);
        }
      });
    });
  });
};

/**
 * @method alert
 * @signature alert(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Notification message.[/en]
 *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
 * @param {String} [options.messageHTML]
 *   [en]Notification message in HTML.[/en]
 *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
 *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]
 *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade"のいずれかを指定できます。[/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
 *   [ja]ons-alert-dialog要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-alert-dialog>` element's class.[/en]
 *   [ja]ons-alert-dialog要素のclass。[/ja]
 * @param {String} [options.title]
 *   [en]Dialog title. Default is `"Alert"`.[/en]
 *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the dialog.[/en]
 *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
 * @param {String} [options.maskColor]
 *   [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)" ("rgba(0, 0, 0, 0.3)" for Material).[/en]
 *   [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after dialog has been closed.[/en]
 *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display an alert dialog to show the user a message.
 *
 *     The content of the message can be either simple text or HTML.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.alert(message, options);
 *     ons.notification.alert(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
 *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.alert = function (message, options) {
  return notification._createAlertDialog(message, options, {
    buttonLabels: ['OK'],
    title: 'Alert'
  });
};

/**
 * @method confirm
 * @signature confirm(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 * @param {Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
 *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
 * @description
 *   [en]
 *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.
 *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.confirm(message, options);
 *     ons.notification.confirm(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザに確認を促すダイアログを表示します。
 *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.confirm = function (message, options) {
  return notification._createAlertDialog(message, options, {
    buttonLabels: ['Cancel', 'OK'],
    title: 'Confirm'
  });
};

/**
 * @method prompt
 * @signature prompt(message [, options] | options)
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve to the input value when the dialog is closed or `null` when canceled.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {String} [options.placeholder]
 *   [en]Placeholder for the text input.[/en]
 *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
 * @param {String} [options.defaultValue]
 *   [en]Default value for the text input.[/en]
 *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
 * @param {String} [options.inputType]
 *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.autofocus]
 *   [en]Autofocus the input element. Default is `true`. In Cordova, `KeyboardDisplayRequiresUserAction` in `config.xml` must be `false` to activate this feature.[/en]
 *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。Cordova環境では、この機能を有効にするためには `config.xml` で `KeyboardDisplayRequiresUserAction` を `false` に設定する必要があります。[/ja]
 * @param {Boolean} [options.submitOnEnter]
 *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
 *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
 * @description
 *   [en]
 *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.prompt(message, options);
 *     ons.notification.prompt(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーに入力を促すダイアログを表示します。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.prompt = function (message, options) {
  return notification._createAlertDialog(message, options, {
    buttonLabels: ['OK'],
    title: 'Alert',
    isPrompt: true,
    autofocus: true,
    submitOnEnter: true
  });
};

/**
 * @method toast
 * @signature toast(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve when the toast is hidden.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Toast message. This argument is optional but if it's not defined then `options.message` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Notification message.[/en]
 *   [ja]トーストに表示する文字列を指定します。[/ja]
 * @param {String} [options.buttonLabel]
 *   [en]Label for the button.[/en]
 *   [ja]確認ボタンのラベルを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none`, `fade`, `ascend`, `lift` and `fall`. Default is `ascend` for Android and `lift` for iOS.[/en]
 *   [ja]トーストを表示する際のアニメーション名を指定します。"none", "fade", "ascend", "lift", "fall"のいずれかを指定できます。[/ja]
 * @param {Number} [options.timeout]
 *   [en]Number of miliseconds where the toast is visible before hiding automatically.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.force]
 *   [en]If `true`, the toast skips the notification queue and is shown immediately. Defaults to `false`.[/en]
 *   [ja][/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-toast>` element's ID.[/en]
 *   [ja]ons-toast要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-toast>` element's class.[/en]
 *   [ja]ons-toast要素のclass。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the element.[/en]
 *   [ja]トーストのmodifier属性の値を指定します。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after toast has been hidden.[/en]
 *   [ja]トーストが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display a simple notification toast with an optional button that can be used for simple actions.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.toast(message, options);
 *     ons.notification.toast(options);
 *     ```
 *   [/en]
 *   [ja][/ja]
 */
notification.toast = function (message, options) {
  var promise = new Promise(function (resolve) {
    util$1.checkMissingImport('Toast'); // Throws error, must be inside promise

    options = _normalizeArguments(message, options, {
      timeout: 0,
      force: false
    });

    var toast = util$1.createElement('\n      <ons-toast>\n        ' + options.message + '\n        ' + (options.buttonLabels ? '<button>' + options.buttonLabels[0] + '</button>' : '') + '\n      </ons-toast>\n    ');

    _setAttributes(toast, options);

    var finish = function finish(value) {
      if (toast) {
        toast.hide().then(function () {
          if (toast) {
            toast.remove();
            toast = null;
            options.callback(value);
            resolve(value);
          }
        });
      }
    };

    if (options.buttonLabels) {
      util$1.findChild(toast._toast, 'button').onclick = function () {
        return finish(0);
      };
    }

    document.body.appendChild(toast);
    options.compile(toast);

    var show = function show() {
      toast.parentElement && toast.show(options).then(function () {
        if (options.timeout) {
          setTimeout(function () {
            return finish(-1);
          }, options.timeout);
        }
      });
    };

    setImmediate(function () {
      return options.force ? show() : ToastQueue$1.add(show, promise);
    });
  });

  return promise;
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// Validate parameters
var checkOptions = function checkOptions(options) {
  var err = function err(prop) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Function';
    return util$1.throw('"options.' + prop + '" must be an instance of ' + type);
  };
  var hasOwnProperty = function hasOwnProperty(prop) {
    return Object.hasOwnProperty.call(options, prop);
  };
  var instanceOf = function instanceOf(prop) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Function;
    return options[prop] instanceof type;
  };

  var b = 'buttons',
      cb = 'callback',
      c = 'compile',
      d = 'destroy';
  (!hasOwnProperty(b) || !instanceOf(b, Array)) && err(b, 'Array');
  hasOwnProperty(cb) && !instanceOf(cb) && err(cb);
  hasOwnProperty(c) && !instanceOf(c) && err(c);
  hasOwnProperty(d) && !instanceOf(d) && err(d);
};

// Action Sheet
var actionSheet = (function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new Promise(function (resolve) {
    util$1.checkMissingImport('ActionSheet');
    checkOptions(options);

    // Main component
    var actionSheet = util$1.createElement('\n    <ons-action-sheet\n      ' + (options.title ? 'title="' + options.title + '"' : '') + '\n      ' + (options.cancelable ? 'cancelable' : '') + '\n      ' + (options.modifier ? 'modifier="' + options.modifier + '"' : '') + '\n      ' + (options.maskColor ? 'mask-color="' + options.maskColor + '"' : '') + '\n      ' + (options.id ? 'id="' + options.id + '"' : '') + '\n      ' + (options.class ? 'class="' + options.class + '"' : '') + '\n    >\n      <div class="action-sheet"></div>\n    </ons-action-sheet>\n  ');

    // Resolve action and clean up
    var finish = function finish(event) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      if (actionSheet) {
        options.destroy && options.destroy(actionSheet);

        actionSheet.removeEventListener('dialog-cancel', finish, false);
        actionSheet.remove();
        actionSheet = null;

        options.callback && options.callback(index);
        resolve(index);
      }
    };

    // Link cancel handler
    actionSheet.addEventListener('dialog-cancel', finish, false);

    // Create buttons and link action handler
    var buttons = document.createDocumentFragment();
    options.buttons.forEach(function (item, index) {
      var buttonOptions = typeof item === 'string' ? { label: item } : _extends({}, item);
      if (options.destructive === index) {
        buttonOptions.modifier = (buttonOptions.modifier || '') + ' destructive';
      }

      var button = util$1.createElement('\n      <ons-action-sheet-button\n        ' + (buttonOptions.icon ? 'icon="' + buttonOptions.icon + '"' : '') + '\n        ' + (buttonOptions.modifier ? 'modifier="' + buttonOptions.modifier + '"' : '') + '\n      >\n        ' + buttonOptions.label + '\n      </ons-action-sheet-button>\n    ');

      button.onclick = function (event) {
        return actionSheet.hide().then(function () {
          return finish(event, index);
        });
      };
      buttons.appendChild(button);
    });

    // Finish component and attach
    util$1.findChild(actionSheet, '.action-sheet').appendChild(buttons);
    document.body.appendChild(actionSheet);
    options.compile && options.compile(el.dialog);

    // Show
    setImmediate(function () {
      return actionSheet.show({
        animation: options.animation,
        animationOptions: options.animationOptions
      });
    });
  });
});

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 *
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent = function MicroEvent() {};
MicroEvent.prototype = {
  on: function on(event, fct) {
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once: function once(event, fct) {
    var self = this;
    var wrapper = function wrapper() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off: function off(event, fct) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }

    this._events[event] = this._events[event].filter(function (_fct) {
      if (fct) {
        return fct !== _fct;
      } else {
        return false;
      }
    });
  },
  emit: function emit(event /* , args... */) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }
    for (var i = 0; i < this._events[event].length; i++) {
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin = function (destObject) {
  var props = ['on', 'once', 'off', 'emit'];
  for (var i = 0; i < props.length; i++) {
    if (typeof destObject === 'function') {
      destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
    } else {
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
};

window.MicroEvent = MicroEvent;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var create = function create() {

  /**
   * @object ons.orientation
   * @category util
   * @description
   *   [en]Utility methods for orientation detection.[/en]
   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
   */
  var obj = {
    /**
     * @event change
     * @description
     *   [en]Fired when the device orientation changes.[/en]
     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Boolean} event.isPortrait
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
     */

    /**
     * @method on
     * @signature on(eventName, listener)
     * @description
     *   [en]Add an event listener.[/en]
     *   [ja]イベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method once
     * @signature once(eventName, listener)
     * @description
     *  [en]Add an event listener that's only triggered once.[/en]
     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method off
     * @signature off(eventName, [listener])
     * @description
     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]削除するイベントリスナーを指定します。[/ja]
     */

    // actual implementation to detect if whether current screen is portrait or not
    _isPortrait: false,

    /**
     * @method isPortrait
     * @signature isPortrait()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
     */
    isPortrait: function isPortrait() {
      return this._isPortrait();
    },

    /**
     * @method isLandscape
     * @signature isLandscape()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is landscape mode.[/en]
     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
     */
    isLandscape: function isLandscape() {
      return !this.isPortrait();
    },

    _init: function _init() {
      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

      if ('orientation' in window) {
        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
      } else {
        window.addEventListener('resize', this._onResize.bind(this), false);
      }

      this._isPortrait = function () {
        return window.innerHeight > window.innerWidth;
      };

      return this;
    },

    _onDOMContentLoaded: function _onDOMContentLoaded() {
      this._installIsPortraitImplementation();
      this.emit('change', { isPortrait: this.isPortrait() });
    },

    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
      var isPortrait = window.innerWidth < window.innerHeight;

      if (!('orientation' in window)) {
        this._isPortrait = function () {
          return window.innerHeight > window.innerWidth;
        };
      } else if (window.orientation % 180 === 0) {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
        };
      } else {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
        };
      }
    },

    _onOrientationChange: function _onOrientationChange() {
      var _this = this;

      var isPortrait = this._isPortrait();

      // Wait for the dimensions to change because
      // of Android inconsistency.
      var nIter = 0;
      var interval = setInterval(function () {
        nIter++;

        var w = window.innerWidth;
        var h = window.innerHeight;

        if (isPortrait && w <= h || !isPortrait && w >= h) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        } else if (nIter === 50) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        }
      }, 20);
    },

    // Run on not mobile browser.
    _onResize: function _onResize() {
      this.emit('change', { isPortrait: this.isPortrait() });
    }
  };

  MicroEvent.mixin(obj);

  return obj;
};

var orientation = create()._init();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.modifier
 * @category visual
 * @description
 *   [en]
 *     Utility methods to change modifier attributes of Onsen UI elements..
 *   [/en]
 *   [ja][/ja]
 * @example
 * ons.modifier.add(myOnsInputElement, 'underbar');
 * ons.modifier.toggle(myOnsToastElement, 'custom-modifier');
 *
 */
var modifier = {
  /**
   * @method add
   * @signature add(element, modifier [, modifier])
   * @description
   *   [en]Add the specified modifiers to the element if they are not already included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  add: function add(element) {
    for (var _len = arguments.length, modifiers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      modifiers[_key - 1] = arguments[_key];
    }

    return modifiers.forEach(function (modifier) {
      return util$1.addModifier(element, modifier);
    });
  },
  /**
   * @method remove
   * @signature remove(element, modifier [, modifier])
   * @description
   *   [en]Remove the specified modifiers from the element if they are included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  remove: function remove(element) {
    for (var _len2 = arguments.length, modifiers = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      modifiers[_key2 - 1] = arguments[_key2];
    }

    return modifiers.forEach(function (modifier) {
      return util$1.removeModifier(element, modifier);
    });
  },
  /**
   * @method contains
   * @signature contains(element, modifier)
   * @description
   *   [en]Check whether the specified modifier is included in the element.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @return {Boolean}
   *   [en]`true` when the specified modifier is found in the element's `modifier` attribute. `false` otherwise.[/en]
   *   [ja][/ja]
   */
  contains: util$1.hasModifier,
  /**
   * @method toggle
   * @signature toggle(element, modifier [, force])
   * @description
   *   [en]Toggle the specified modifier.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @param {String} force
   *   [en]If it evaluates to true, add specified modifier value, and if it evaluates to false, remove it.[/en]
   *   [ja][/ja]
   */
  toggle: util$1.toggleModifier
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var softwareKeyboard = new MicroEvent();
softwareKeyboard._visible = false;

var onShow = function onShow() {
  softwareKeyboard._visible = true;
  softwareKeyboard.emit('show');
};

var onHide = function onHide() {
  softwareKeyboard._visible = false;
  softwareKeyboard.emit('hide');
};

var bindEvents = function bindEvents() {
  if (typeof Keyboard !== 'undefined') {
    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
    Keyboard.onshow = onShow;
    Keyboard.onhide = onHide;
    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

    return true;
  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
    window.addEventListener('native.keyboardshow', onShow);
    window.addEventListener('native.keyboardhide', onHide);
    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

    return true;
  }

  return false;
};

var noPluginError = function noPluginError() {
  util$1.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
};

document.addEventListener('deviceready', function () {
  if (!bindEvents()) {
    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
      noPluginError();
    }

    softwareKeyboard.on = noPluginError;
  }
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var generateId = function () {
  var i = 0;
  return function () {
    return i++;
  };
}();

/**
 * Door locking system.
 *
 * @param {Object} [options]
 * @param {Function} [options.log]
 */

var DoorLock = function () {
  function DoorLock() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DoorLock);

    this._lockList = [];
    this._waitList = [];
    this._log = options.log || function () {};
  }

  /**
   * Register a lock.
   *
   * @return {Function} Callback for unlocking.
   */


  createClass(DoorLock, [{
    key: 'lock',
    value: function lock() {
      var _this = this;

      var unlock = function unlock() {
        _this._unlock(unlock);
      };
      unlock.id = generateId();
      this._lockList.push(unlock);
      this._log('lock: ' + unlock.id);

      return unlock;
    }
  }, {
    key: '_unlock',
    value: function _unlock(fn) {
      var index = this._lockList.indexOf(fn);
      if (index === -1) {
        throw new Error('This function is not registered in the lock list.');
      }

      this._lockList.splice(index, 1);
      this._log('unlock: ' + fn.id);

      this._tryToFreeWaitList();
    }
  }, {
    key: '_tryToFreeWaitList',
    value: function _tryToFreeWaitList() {
      while (!this.isLocked() && this._waitList.length > 0) {
        this._waitList.shift()();
      }
    }

    /**
     * Register a callback for waiting unlocked door.
     *
     * @params {Function} callback Callback on unlocking the door completely.
     */

  }, {
    key: 'waitUnlock',
    value: function waitUnlock(callback) {
      if (!(callback instanceof Function)) {
        throw new Error('The callback param must be a function.');
      }

      if (this.isLocked()) {
        this._waitList.push(callback);
      } else {
        callback();
      }
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isLocked',
    value: function isLocked() {
      return this._lockList.length > 0;
    }
  }]);
  return DoorLock;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
// Default implementation for global PageLoader.
function loadPage(_ref, done) {
  var page = _ref.page,
      parent = _ref.parent,
      _ref$params = _ref.params;

  internal$1.getPageHTMLAsync(page).then(function (html) {
    var pageElement = util$1.createElement(html);
    parent.appendChild(pageElement);

    done(pageElement);
  });
}

function unloadPage(element) {
  if (element._destroy instanceof Function) {
    element._destroy();
  } else {
    element.remove();
  }
}

var PageLoader = function () {
  /**
   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
   */
  function PageLoader(loader, unloader) {
    classCallCheck(this, PageLoader);

    this._loader = loader instanceof Function ? loader : loadPage;
    this._unloader = unloader instanceof Function ? unloader : unloadPage;
  }

  /**
   * Set internal loader implementation.
   */


  createClass(PageLoader, [{
    key: 'load',


    /**
     * @param {any} options.page
     * @param {Element} options.parent A location to load page.
     * @param {Object} [options.params] Extra parameters for ons-page.
     * @param {Function} done Take an object that has "element" property and "unload" function.
     */
    value: function load(_ref2, done) {
      var page = _ref2.page,
          parent = _ref2.parent,
          _ref2$params = _ref2.params,
          params = _ref2$params === undefined ? {} : _ref2$params;

      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {
        if (!(pageElement instanceof Element)) {
          throw Error('pageElement must be an instance of Element.');
        }

        done(pageElement);
      });
    }
  }, {
    key: 'unload',
    value: function unload(pageElement) {
      if (!(pageElement instanceof Element)) {
        throw Error('pageElement must be an instance of Element.');
      }

      this._unloader(pageElement);
    }
  }, {
    key: 'internalLoader',
    set: function set$$1(fn) {
      if (!(fn instanceof Function)) {
        throw Error('First parameter must be an instance of Function');
      }
      this._loader = fn;
    },
    get: function get$$1() {
      return this._loader;
    }
  }]);
  return PageLoader;
}();

var defaultPageLoader = new PageLoader();

var instantPageLoader = new PageLoader(function (_ref3, done) {
  var page = _ref3.page,
      parent = _ref3.parent,
      _ref3$params = _ref3.params;

  var element = util$1.createElement(page.trim());
  parent.appendChild(element);

  done(element);
}, unloadPage);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons
 * @category util
 * @description
 *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
 *   [en]A global object that's used in Onsen UI. [/en]
 */
var ons$1 = {
  animit: Animit,
  defaultPageLoader: defaultPageLoader,
  elements: onsElements,
  GestureDetector: GestureDetector,
  modifier: modifier,
  notification: notification,
  orientation: orientation,
  pageAttributeExpression: pageAttributeExpression,
  PageLoader: PageLoader,
  platform: platform,
  softwareKeyboard: softwareKeyboard,
  _autoStyle: autoStyle,
  _internal: internal$1,
  _readyLock: new DoorLock(),
  _util: util$1
};

ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

waitDeviceReady();

var readyError = function readyError(after) {
  return util$1.throw('This method must be called ' + (after ? 'after' : 'before') + ' ons.isReady() is true');
};

/**
 * @method isReady
 * @signature isReady()
 * @return {Boolean}
 *   [en]Will be true if Onsen UI is initialized.[/en]
 *   [ja]初期化されているかどうかを返します。[/ja]
 * @description
 *   [en]Returns true if Onsen UI is initialized.[/en]
 *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isReady = function () {
  return !ons$1._readyLock.isLocked();
};

/**
 * @method isWebView
 * @signature isWebView()
 * @return {Boolean}
 *   [en]Will be true if the app is running in Cordova.[/en]
 *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
 * @description
 *   [en]Returns true if running inside Cordova.[/en]
 *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isWebView = ons$1.platform.isWebView;

/**
 * @method ready
 * @signature ready(callback)
 * @description
 *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
 *   [en]Method used to wait for app initialization. Waits for `DOMContentLoaded` and `deviceready`, when necessary, before executing the callback.[/en]
 * @param {Function} callback
 *   [en]Function that executes after Onsen UI has been initialized.[/en]
 *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
 */
ons$1.ready = function (callback) {
  if (ons$1.isReady()) {
    callback();
  } else {
    ons$1._readyLock.waitUnlock(callback);
  }
};

/**
 * @method setDefaultDeviceBackButtonListener
 * @signature setDefaultDeviceBackButtonListener(listener)
 * @param {Function} listener
 *   [en]Function that executes when device back button is pressed. Must be called on `ons.ready`.[/en]
 *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]Set default handler for device back button.[/en]
 *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
 */
ons$1.setDefaultDeviceBackButtonListener = function (listener) {
  if (!ons$1.isReady()) {
    readyError(true);
  }
  ons$1._defaultDeviceBackButtonHandler.setListener(listener);
};

/**
 * @method disableDeviceBackButtonHandler
 * @signature disableDeviceBackButtonHandler()
 * @description
 * [en]Disable device back button event handler. Must be called on `ons.ready`.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
 */
ons$1.disableDeviceBackButtonHandler = function () {
  if (!ons$1.isReady()) {
    readyError(true);
  }
  internal$1.dbbDispatcher.disable();
};

/**
 * @method enableDeviceBackButtonHandler
 * @signature enableDeviceBackButtonHandler()
 * @description
 * [en]Enable device back button event handler. Must be called on `ons.ready`.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
 */
ons$1.enableDeviceBackButtonHandler = function () {
  if (!ons$1.isReady()) {
    readyError(true);
  }
  internal$1.dbbDispatcher.enable();
};

ons$1.fireDeviceBackButtonEvent = function () {
  internal$1.dbbDispatcher.fireDeviceBackButtonEvent();
};

/**
 * @method enableAutoStatusBarFill
 * @signature enableAutoStatusBarFill()
 * @description
 *   [en]Enable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
 *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
 */
ons$1.enableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    readyError(false);
  }
  internal$1.config.autoStatusBarFill = true;
};

/**
 * @method disableAutoStatusBarFill
 * @signature disableAutoStatusBarFill()
 * @description
 *   [en]Disable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
 *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
 */
ons$1.disableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    readyError(false);
  }
  internal$1.config.autoStatusBarFill = false;
};

/**
 * @method mockStatusBar
 * @signature mockStatusBar()
 * @description
 *   [en]Creates a static element similar to iOS status bar. Only useful for browser testing. Must be called before `ons.ready`.[/en]
 *   [ja][/ja]
 */
ons$1.mockStatusBar = function () {
  if (ons$1.isReady()) {
    readyError(false);
  }

  var mock = function mock() {
    if (!document.body.children[0] || !document.body.children[0].classList.contains('ons-status-bar-mock')) {
      var android = platform.isAndroid(),
          i = function i(_i) {
        return '<i class="' + _i.split('-')[0] + ' ' + _i + '"></i>';
      };
      var left = android ? i('zmdi-twitter') + ' ' + i('zmdi-google-play') : 'No SIM ' + i('fa-wifi'),
          center = android ? '' : '12:28 PM',
          right = android ? i('zmdi-network') + ' ' + i('zmdi-wifi') + ' ' + i('zmdi-battery') + ' 12:28 PM' : '80% ' + i('fa-battery-three-quarters');

      document.body.insertBefore(util$1.createElement('<div class="ons-status-bar-mock ' + (android ? 'android' : 'ios') + '">' + ('<div>' + left + '</div><div>' + center + '</div><div>' + right + '</div>') + '</div>'), document.body.firstChild);
    }
  };

  document.body ? mock() : internal$1.waitDOMContentLoaded(mock);
};

/**
 * @method disableAnimations
 * @signature disableAnimations()
 * @description
 *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
 *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
 */
ons$1.disableAnimations = function () {
  internal$1.config.animationsDisabled = true;
};

/**
 * @method enableAnimations
 * @signature enableAnimations()
 * @description
 *   [en]Enable animations (default).[/en]
 *   [ja]アニメーションを有効にします。[/ja]
 */
ons$1.enableAnimations = function () {
  internal$1.config.animationsDisabled = false;
};

ons$1._disableWarnings = function () {
  internal$1.config.warningsDisabled = true;
};

ons$1._enableWarnings = function () {
  internal$1.config.warningsDisabled = false;
};

/**
 * @method disableAutoStyling
 * @signature disableAutoStyling()
 * @description
 *   [en]Disable automatic styling.[/en]
 *   [ja][/ja]
 */
ons$1.disableAutoStyling = autoStyle.disable;

/**
 * @method enableAutoStyling
 * @signature enableAutoStyling()
 * @description
 *   [en]Enable automatic styling based on OS (default).[/en]
 *   [ja][/ja]
 */
ons$1.enableAutoStyling = autoStyle.enable;

/**
 * @method disableIconAutoPrefix
 * @signature disableIconAutoPrefix()
 * @description
 *   [en]Disable adding `fa-` prefix automatically to `ons-icon` classes. Useful when including custom icon packs.[/en]
 *   [ja][/ja]
 */
ons$1.disableIconAutoPrefix = function () {
  util$1.checkMissingImport('Icon');
  onsElements.Icon.setAutoPrefix(false);
};

/**
 * @method forceUIWebViewScrollFix
 * @signature forceUIWebViewScrollFix()
 * @param {Boolean} force Enable or disable the fix.
 * @description
 *   [en]Applies a fix for iOS UIWebView which prevents scroll events jumping to pages under the top layer. This may visually affect normal scrolling of UIWebView if you open a dialog/menu before the scroll momentum finished. Disabled by default.[/en]
 *   [ja][/ja]
 */
ons$1.forceUIWebViewScrollFix = function () {
  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  internal$1.config.forceUIWebViewScrollFix = force;
};

/**
 * @method forcePlatformStyling
 * @signature forcePlatformStyling(platform)
 * @description
 *   [en]Refresh styling for the given platform. Only useful for demos. Use `ons.platform.select(...)` instead for development and production.[/en]
 *   [ja][/ja]
 * @param {string} platform New platform to style the elements.
 */
ons$1.forcePlatformStyling = function (newPlatform) {
  ons$1.enableAutoStyling();
  ons$1.platform.select(newPlatform || 'ios');

  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
    if (element.tagName.toLowerCase() === 'ons-if') {
      element._platformUpdate();
    } else if (element.tagName.match(/^ons-/i)) {
      autoStyle.prepare(element, true);
      if (element.tagName.toLowerCase() === 'ons-tabbar') {
        element._updatePosition();
      }
    }
  });
};

/**
 * @method preload
 * @signature preload(templatePaths)
 * @param {String|Array} templatePaths
 *   [en]Set of HTML file paths containing 'ons-page' elements.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Promise that resolves when all the templates are cached.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Separated files need to be requested on demand and this can slightly delay pushing new pages. This method requests and caches templates for later use.[/en]
 *   [ja][/ja]
 */
ons$1.preload = function () {
  var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return Promise.all((templates instanceof Array ? templates : [templates]).map(function (template) {
    if (typeof template !== 'string') {
      util$1.throw('Expected string arguments but got ' + (typeof template === 'undefined' ? 'undefined' : _typeof(template)));
    }
    return internal$1.getTemplateHTMLAsync(template);
  }));
};

/**
 * @method createElement
 * @signature createElement(template, options)
 * @param {String} template
 *   [en]Either an HTML file path, a `<template>` id or an HTML string such as `'<div id="foo">hoge</div>'`.[/en]
 *   [ja][/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Boolean|HTMLElement} [options.append]
 *   [en]Whether or not the element should be automatically appended to the DOM.  Defaults to `false`. If `true` value is given, `document.body` will be used as the target.[/en]
 *   [ja][/ja]
 * @param {HTMLElement} [options.insertBefore]
 *   [en]Reference node that becomes the next sibling of the new node (`options.append` element).[/en]
 *   [ja][/ja]
 * @return {HTMLElement|Promise}
 *   [en]If the provided template was an inline HTML string, it returns the new element. Otherwise, it returns a promise that resolves to the new element.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Create a new element from a template. Both inline HTML and external files are supported although the return value differs.[/en]
 *   [ja][/ja]
 */
ons$1.createElement = function (template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  template = template.trim();

  var create = function create(html) {
    var element = ons$1._util.createElement(html);
    element.remove();

    if (options.append) {
      var target = options.append instanceof HTMLElement ? options.append : document.body;
      target.insertBefore(element, options.insertBefore || null);
      options.link instanceof Function && options.link(element);
    }

    return element;
  };

  return template.charAt(0) === '<' ? create(template) : internal$1.getPageHTMLAsync(template).then(create);
};

/**
 * @method createPopover
 * @signature createPopover(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or a <template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Object} [options.parentScope]
 *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
 *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the popover component object.[/en]
 *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a popover instance from a template.[/en]
 *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
 */
/**
 * @method createDialog
 * @signature createDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an `<template>` containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a dialog instance from a template.[/en]
 *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
 */
/**
 * @method createAlertDialog
 * @signature createAlertDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an `<template>` containing a <ons-alert-dialog> component.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the alert dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a alert dialog instance from a template.[/en]
 *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
 */
ons$1.createPopover = ons$1.createDialog = ons$1.createAlertDialog = function (template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return ons$1.createElement(template, _extends({ append: true }, options));
};

/**
 * @method openActionSheet
 * @signature openActionSheet(options)
 * @description
 *   [en]Shows an instant Action Sheet and lets the user choose an action.[/en]
 *   [ja][/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Array} [options.buttons]
 *   [en]Represent each button of the action sheet following the specified order. Every item can be either a string label or an object containing `label`, `icon` and `modifier` properties.[/en]
 *   [ja][/ja]
 * @param {String} [options.title]
 *   [en]Optional title for the action sheet.[/en]
 *   [ja][/ja]
 * @param {Number} [options.destructive]
 *   [en]Optional index of the "destructive" button (only for iOS). It can be specified in the button array as well.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the action sheet can be canceled by tapping on the background mask or not.[/en]
 *   [ja][/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier attribute of the action sheet. E.g. `'destructive'`.[/en]
 *   [ja][/ja]
 * @param {String} [options.maskColor]
 *   [en]Optionally change the background mask color.[/en]
 *   [ja][/ja]
 * @param {String} [options.id]
 *   [en]The element's id attribute.[/en]
 *   [ja][/ja]
 * @param {String} [options.class]
 *   [en]The element's class attribute.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve when the action sheet is closed. The resolve value is either the index of the tapped button or -1 when canceled.[/en]
 *   [ja][/ja]
 */
ons$1.openActionSheet = actionSheet;

/**
 * @method resolveLoadingPlaceholder
 * @signature resolveLoadingPlaceholder(page)
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or a `<template>` id.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @description
 *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
 *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
 */
ons$1.resolveLoadingPlaceholder = function (page, link) {
  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));
  if (elements.length === 0) {
    util$1.throw('No ons-loading-placeholder exists');
  }

  elements.filter(function (element) {
    return !element.getAttribute('page');
  }).forEach(function (element) {
    element.setAttribute('ons-loading-placeholder', page);
    ons$1._resolveLoadingPlaceholder(element, page, link);
  });
};

ons$1._setupLoadingPlaceHolders = function () {
  ons$1.ready(function () {
    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

    elements.forEach(function (element) {
      var page = element.getAttribute('ons-loading-placeholder');
      if (typeof page === 'string') {
        ons$1._resolveLoadingPlaceholder(element, page);
      }
    });
  });
};

ons$1._resolveLoadingPlaceholder = function (parent, page) {
  var link = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el, done) {
    return done();
  };

  page && ons$1.createElement(page).then(function (element) {
    element.style.display = 'none';
    parent.appendChild(element);
    link(element, function () {
      while (parent.firstChild && parent.firstChild !== element) {
        parent.removeChild(parent.firstChild);
      }
      element.style.display = '';
    });
  }).catch(function (error) {
    return Promise.reject('Unabled to resolve placeholder: ' + error);
  });
};

function waitDeviceReady() {
  var unlockDeviceReady = ons$1._readyLock.lock();
  window.addEventListener('DOMContentLoaded', function () {
    if (ons$1.isWebView()) {
      window.document.addEventListener('deviceready', unlockDeviceReady, false);
    } else {
      unlockDeviceReady();
    }
  }, false);
}

/**
 * @method getScriptPage
 * @signature getScriptPage()
 * @description
 *   [en]Access the last created page from the current `script` scope. Only works inside `<script></script>` tags that are direct children of `ons-page` element. Use this to add lifecycle hooks to a page.[/en]
 *   [ja][/ja]
 * @return {HTMLElement}
 *   [en]Returns the corresponding page element.[/en]
 *   [ja][/ja]
 */
var getCS = 'currentScript' in document ? function () {
  return document.currentScript;
} : function () {
  return document.scripts[document.scripts.length - 1];
};
ons$1.getScriptPage = function () {
  return getCS() && /ons-page/i.test(getCS().parentElement.tagName) && getCS().parentElement || null;
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var fastclick = createCommonjsModule(function (module) {
	(function () {
		function FastClick(layer, options) {
			var oldOnClick;

			options = options || {};

			/**
    * Whether a click is currently being tracked.
    *
    * @type boolean
    */
			this.trackingClick = false;

			/**
    * Timestamp for when click tracking started.
    *
    * @type number
    */
			this.trackingClickStart = 0;

			/**
    * The element being tracked for a click.
    *
    * @type EventTarget
    */
			this.targetElement = null;

			/**
    * X-coordinate of touch start event.
    *
    * @type number
    */
			this.touchStartX = 0;

			/**
    * Y-coordinate of touch start event.
    *
    * @type number
    */
			this.touchStartY = 0;

			/**
    * ID of the last touch, retrieved from Touch.identifier.
    *
    * @type number
    */
			this.lastTouchIdentifier = 0;

			/**
    * Touchmove boundary, beyond which a click will be cancelled.
    *
    * @type number
    */
			this.touchBoundary = options.touchBoundary || 10;

			/**
    * The FastClick layer.
    *
    * @type Element
    */
			this.layer = layer;

			/**
    * The minimum time between tap(touchstart and touchend) events
    *
    * @type number
    */
			this.tapDelay = options.tapDelay || 200;

			/**
    * The maximum time for a tap
    *
    * @type number
    */
			this.tapTimeout = options.tapTimeout || 700;

			if (FastClick.notNeeded(layer)) {
				return;
			}

			// Some old versions of Android don't have Function.prototype.bind
			function bind(method, context) {
				return function () {
					return method.apply(context, arguments);
				};
			}

			var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
			var context = this;
			for (var i = 0, l = methods.length; i < l; i++) {
				context[methods[i]] = bind(context[methods[i]], context);
			}

			// Set up event handlers as required
			if (deviceIsAndroid) {
				layer.addEventListener('mouseover', this.onMouse, true);
				layer.addEventListener('mousedown', this.onMouse, true);
				layer.addEventListener('mouseup', this.onMouse, true);
			}

			layer.addEventListener('click', this.onClick, true);
			layer.addEventListener('touchstart', this.onTouchStart, false);
			layer.addEventListener('touchmove', this.onTouchMove, false);
			layer.addEventListener('touchend', this.onTouchEnd, false);
			layer.addEventListener('touchcancel', this.onTouchCancel, false);

			// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
			// layer when they are cancelled.
			if (!Event.prototype.stopImmediatePropagation) {
				layer.removeEventListener = function (type, callback, capture) {
					var rmv = Node.prototype.removeEventListener;
					if (type === 'click') {
						rmv.call(layer, type, callback.hijacked || callback, capture);
					} else {
						rmv.call(layer, type, callback, capture);
					}
				};

				layer.addEventListener = function (type, callback, capture) {
					var adv = Node.prototype.addEventListener;
					if (type === 'click') {
						adv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {
							if (!event.propagationStopped) {
								callback(event);
							}
						}), capture);
					} else {
						adv.call(layer, type, callback, capture);
					}
				};
			}

			// If a handler is already declared in the element's onclick attribute, it will be fired before
			// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
			// adding it as listener.
			if (typeof layer.onclick === 'function') {

				// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
				// - the old one won't work if passed to addEventListener directly.
				oldOnClick = layer.onclick;
				layer.addEventListener('click', function (event) {
					oldOnClick(event);
				}, false);
				layer.onclick = null;
			}
		}

		/**
  * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
  *
  * @type boolean
  */
		var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

		/**
   * Android requires exceptions.
   *
   * @type boolean
   */
		var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;

		/**
   * iOS requires exceptions.
   *
   * @type boolean
   */
		var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;

		/**
   * iOS 4 requires an exception for select elements.
   *
   * @type boolean
   */
		var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);

		/**
   * iOS 6.0-7.* requires the target element to be manually derived
   *
   * @type boolean
   */
		var deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);

		/**
   * BlackBerry requires exceptions.
   *
   * @type boolean
   */
		var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

		/**
   * Valid types for text inputs
   *
   * @type array
   */
		var textFields = ['email', 'number', 'password', 'search', 'tel', 'text', 'url'];

		/**
   * Determine whether a given element requires a native click.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element needs a native click
   */
		FastClick.prototype.needsClick = function (target) {
			switch (target.nodeName.toLowerCase()) {

				// Don't send a synthetic click to disabled inputs (issue #62)
				case 'button':
				case 'select':
				case 'textarea':
					if (target.disabled) {
						return true;
					}

					break;
				case 'input':

					// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
					if (deviceIsIOS && target.type === 'file' || target.disabled) {
						return true;
					}

					break;
				case 'label':
				case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
				case 'video':
					return true;
			}

			return (/\bneedsclick\b/.test(target.className)
			);
		};

		/**
   * Determine whether a given element requires a call to focus to simulate click into element.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
   */
		FastClick.prototype.needsFocus = function (target) {
			switch (target.nodeName.toLowerCase()) {
				case 'textarea':
					return true;
				case 'select':
					return !deviceIsAndroid;
				case 'input':
					switch (target.type) {
						case 'button':
						case 'checkbox':
						case 'file':
						case 'image':
						case 'radio':
						case 'submit':
							return false;
					}

					// No point in attempting to focus disabled inputs
					return !target.disabled && !target.readOnly;
				default:
					return (/\bneedsfocus\b/.test(target.className)
					);
			}
		};

		/**
   * Send a click event to the specified element.
   *
   * @param {EventTarget|Element} targetElement
   * @param {Event} event
   */
		FastClick.prototype.sendClick = function (targetElement, event) {
			var clickEvent, touch;

			// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
			if (document.activeElement && document.activeElement !== targetElement) {
				document.activeElement.blur();
			}

			touch = event.changedTouches[0];

			// Synthesise a click event, with an extra attribute so it can be tracked
			clickEvent = document.createEvent('MouseEvents');
			clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
			clickEvent.forwardedTouchEvent = true;
			targetElement.dispatchEvent(clickEvent);
		};

		FastClick.prototype.determineEventType = function (targetElement) {

			//Issue #159: Android Chrome Select Box does not open with a synthetic click event
			if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
				return 'mousedown';
			}

			return 'click';
		};

		/**
   * @param {EventTarget|Element} targetElement
   */
		FastClick.prototype.focus = function (targetElement) {
			var length;

			// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
			if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month' && targetElement.type !== 'email' && targetElement.type !== 'number') {
				length = targetElement.value.length;
				targetElement.setSelectionRange(length, length);
			} else {
				targetElement.focus();
			}
		};

		/**
   * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
   *
   * @param {EventTarget|Element} targetElement
   */
		FastClick.prototype.updateScrollParent = function (targetElement) {
			var scrollParent, parentElement;

			scrollParent = targetElement.fastClickScrollParent;

			// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
			// target element was moved to another parent.
			if (!scrollParent || !scrollParent.contains(targetElement)) {
				parentElement = targetElement;
				do {
					if (parentElement.scrollHeight > parentElement.offsetHeight) {
						scrollParent = parentElement;
						targetElement.fastClickScrollParent = parentElement;
						break;
					}

					parentElement = parentElement.parentElement;
				} while (parentElement);
			}

			// Always update the scroll top tracker if possible.
			if (scrollParent) {
				scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
			}
		};

		/**
   * @param {EventTarget} targetElement
   * @returns {Element|EventTarget}
   */
		FastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {

			// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
			if (eventTarget.nodeType === Node.TEXT_NODE) {
				return eventTarget.parentNode;
			}

			return eventTarget;
		};

		/**
   * @param {EventTarget} targetElement
   * @returns {boolean}
   */
		FastClick.prototype.isTextField = function (targetElement) {
			return targetElement.tagName.toLowerCase() === 'textarea' || textFields.indexOf(targetElement.type) !== -1;
		};

		/**
   * On touch start, record the position and scroll offset.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onTouchStart = function (event) {
			var targetElement, touch;

			// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
			if (event.targetTouches.length > 1) {
				return true;
			}

			targetElement = this.getTargetElementFromEventTarget(event.target);
			touch = event.targetTouches[0];

			// Ignore touches on contenteditable elements to prevent conflict with text selection.
			// (For details: https://github.com/ftlabs/fastclick/pull/211 )
			if (targetElement.isContentEditable) {
				return true;
			}

			if (deviceIsIOS) {
				// Ignore touchstart in focused text field
				// Allows normal text selection and commands (select/paste/cut) when a field has focus, while still allowing fast tap-to-focus.
				// Without this fix, user needs to tap-and-hold a text field for context menu, and double-tap to select text doesn't work at all.
				if (targetElement === document.activeElement && this.isTextField(targetElement)) {
					return true;
				}

				if (!deviceIsIOS4) {

					// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
					// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
					// with the same identifier as the touch event that previously triggered the click that triggered the alert.
					// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
					// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
					// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
					// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
					// random integers, it's safe to to continue if the identifier is 0 here.
					if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
						event.preventDefault();
						return false;
					}

					this.lastTouchIdentifier = touch.identifier;

					// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
					// 1) the user does a fling scroll on the scrollable layer
					// 2) the user stops the fling scroll with another tap
					// then the event.target of the last 'touchend' event will be the element that was under the user's finger
					// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
					// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
					this.updateScrollParent(targetElement);
				}
			}

			this.trackingClick = true;
			this.trackingClickStart = event.timeStamp;
			this.targetElement = targetElement;

			this.touchStartX = touch.pageX;
			this.touchStartY = touch.pageY;

			// Prevent phantom clicks on fast double-tap (issue #36)
			if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
				event.preventDefault();
			}

			return true;
		};

		/**
   * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.touchHasMoved = function (event) {
			var touch = event.changedTouches[0],
			    boundary = this.touchBoundary;

			if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
				return true;
			}

			return false;
		};

		/**
   * Update the last position.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onTouchMove = function (event) {
			if (!this.trackingClick) {
				return true;
			}

			// If the touch has moved, cancel the click tracking
			if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
				this.trackingClick = false;
				this.targetElement = null;
			}

			return true;
		};

		/**
   * Attempt to find the labelled control for the given label element.
   *
   * @param {EventTarget|HTMLLabelElement} labelElement
   * @returns {Element|null}
   */
		FastClick.prototype.findControl = function (labelElement) {

			// Fast path for newer browsers supporting the HTML5 control attribute
			if (labelElement.control !== undefined) {
				return labelElement.control;
			}

			// All browsers under test that support touch events also support the HTML5 htmlFor attribute
			if (labelElement.htmlFor) {
				return document.getElementById(labelElement.htmlFor);
			}

			// If no for attribute exists, attempt to retrieve the first labellable descendant element
			// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
			return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
		};

		/**
   * On touch end, determine whether to send a click event at once.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onTouchEnd = function (event) {
			var forElement,
			    trackingClickStart,
			    targetTagName,
			    scrollParent,
			    touch,
			    targetElement = this.targetElement;

			if (!this.trackingClick) {
				return true;
			}

			// Prevent phantom clicks on fast double-tap (issue #36)
			if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
				this.cancelNextClick = true;
				return true;
			}

			if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
				return true;
			}

			// Reset to prevent wrong click cancel on input (issue #156).
			this.cancelNextClick = false;

			this.lastClickTime = event.timeStamp;

			trackingClickStart = this.trackingClickStart;
			this.trackingClick = false;
			this.trackingClickStart = 0;

			// On some iOS devices, the targetElement supplied with the event is invalid if the layer
			// is performing a transition or scroll, and has to be re-detected manually. Note that
			// for this to function correctly, it must be called *after* the event target is checked!
			// See issue #57; also filed as rdar://13048589 .
			if (deviceIsIOSWithBadTarget) {
				touch = event.changedTouches[0];

				// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
				targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
				targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
			}

			targetTagName = targetElement.tagName.toLowerCase();
			if (targetTagName === 'label') {
				forElement = this.findControl(targetElement);
				if (forElement) {
					this.focus(targetElement);
					if (deviceIsAndroid) {
						return false;
					}

					targetElement = forElement;
				}
			} else if (this.needsFocus(targetElement)) {

				// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
				// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
				if (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === 'input') {
					this.targetElement = null;
					return false;
				}

				this.focus(targetElement);
				this.sendClick(targetElement, event);

				// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
				// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
				if (!deviceIsIOS4 || targetTagName !== 'select') {
					this.targetElement = null;
					event.preventDefault();
				}

				return false;
			}

			if (deviceIsIOS && !deviceIsIOS4) {

				// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
				// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
				scrollParent = targetElement.fastClickScrollParent;
				if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
					return true;
				}
			}

			// Prevent the actual click from going though - unless the target node is marked as requiring
			// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
			if (!this.needsClick(targetElement)) {
				event.preventDefault();
				this.sendClick(targetElement, event);
			}

			return false;
		};

		/**
   * On touch cancel, stop tracking the click.
   *
   * @returns {void}
   */
		FastClick.prototype.onTouchCancel = function () {
			this.trackingClick = false;
			this.targetElement = null;
		};

		/**
   * Determine mouse events which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onMouse = function (event) {

			// If a target element was never set (because a touch event was never fired) allow the event
			if (!this.targetElement) {
				return true;
			}

			if (event.forwardedTouchEvent) {
				return true;
			}

			// Programmatically generated events targeting a specific element should be permitted
			if (!event.cancelable) {
				return true;
			}

			// Derive and check the target element to see whether the mouse event needs to be permitted;
			// unless explicitly enabled, prevent non-touch click events from triggering actions,
			// to prevent ghost/doubleclicks.
			if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

				// Prevent any user-added listeners declared on FastClick element from being fired.
				if (event.stopImmediatePropagation) {
					event.stopImmediatePropagation();
				} else {

					// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
					event.propagationStopped = true;
				}

				// Cancel the event
				event.stopPropagation();
				event.preventDefault();

				return false;
			}

			// If the mouse event is permitted, return true for the action to go through.
			return true;
		};

		/**
   * On actual clicks, determine whether this is a touch-generated click, a click action occurring
   * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
   * an actual click which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onClick = function (event) {
			var permitted;

			// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
			if (this.trackingClick) {
				this.targetElement = null;
				this.trackingClick = false;
				return true;
			}

			// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
			if (event.target.type === 'submit' && event.detail === 0) {
				return true;
			}

			permitted = this.onMouse(event);

			// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
			if (!permitted) {
				this.targetElement = null;
			}

			// If clicks are permitted, return true for the action to go through.
			return permitted;
		};

		/**
   * Remove all FastClick's event listeners.
   *
   * @returns {void}
   */
		FastClick.prototype.destroy = function () {
			var layer = this.layer;

			if (deviceIsAndroid) {
				layer.removeEventListener('mouseover', this.onMouse, true);
				layer.removeEventListener('mousedown', this.onMouse, true);
				layer.removeEventListener('mouseup', this.onMouse, true);
			}

			layer.removeEventListener('click', this.onClick, true);
			layer.removeEventListener('touchstart', this.onTouchStart, false);
			layer.removeEventListener('touchmove', this.onTouchMove, false);
			layer.removeEventListener('touchend', this.onTouchEnd, false);
			layer.removeEventListener('touchcancel', this.onTouchCancel, false);
		};

		/**
   * Check whether FastClick is needed.
   *
   * @param {Element} layer The layer to listen on
   */
		FastClick.notNeeded = function (layer) {
			var metaViewport;
			var chromeVersion;
			var blackberryVersion;
			var firefoxVersion;

			// Devices that don't support touch don't need FastClick
			if (typeof window.ontouchstart === 'undefined') {
				return true;
			}

			// Chrome version - zero for other browsers
			chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

			if (chromeVersion) {

				if (deviceIsAndroid) {
					metaViewport = document.querySelector('meta[name=viewport]');

					if (metaViewport) {
						// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
							return true;
						}
						// Chrome 32 and above with width=device-width or less don't need FastClick
						if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
							return true;
						}
					}

					// Chrome desktop doesn't need FastClick (issue #15)
				} else {
					return true;
				}
			}

			if (deviceIsBlackBerry10) {
				blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

				// BlackBerry 10.3+ does not require Fastclick library.
				// https://github.com/ftlabs/fastclick/issues/251
				if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
					metaViewport = document.querySelector('meta[name=viewport]');

					if (metaViewport) {
						// user-scalable=no eliminates click delay.
						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
							return true;
						}
						// width=device-width (or less than device-width) eliminates click delay.
						if (document.documentElement.scrollWidth <= window.outerWidth) {
							return true;
						}
					}
				}
			}

			// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
			if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
				return true;
			}

			// Firefox version - zero for other browsers
			firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

			if (firefoxVersion >= 27) {
				// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

				metaViewport = document.querySelector('meta[name=viewport]');
				if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
					return true;
				}
			}

			// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
			// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
			if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
				return true;
			}

			return false;
		};

		/**
   * Factory method for creating a FastClick object
   *
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */
		FastClick.attach = function (layer, options) {
			return new FastClick(layer, options);
		};

		if (typeof undefined === 'function' && _typeof(undefined.amd) === 'object' && undefined.amd) {

			// AMD. Register as an anonymous module.
			undefined(function () {
				return FastClick;
			});
		} else if ('object' !== 'undefined' && module.exports) {
			module.exports = FastClick.attach;
			module.exports.FastClick = FastClick;
		} else {
			window.FastClick = FastClick;
		}
	})();
});

var fastclick_1 = fastclick.FastClick;

// For @onsenui/custom-elements
if (window.customElements) {
    // even if native CE1 impl exists, use polyfill
    window.customElements.forcePolyfill = true;
}

var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.5.1' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _core_1 = _core.version;

var _isObject = function _isObject(it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function _anObject(it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function _fails(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function _domCreate(it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function _toPrimitive(it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
  f: f
};

var _propertyDesc = function _propertyDesc(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function _has(it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function _uid(key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');
  var TO_STRING = 'toString';
  var $toString = Function[TO_STRING];
  var TPL = ('' + $toString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    }
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
});

var _aFunction = function _aFunction(it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function _ctx(fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

var f$2 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$2
};

var toString = {}.toString;

var _cof = function _cof(it) {
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function _defined(it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function _toIobject(it) {
  return _iobject(_defined(it));
};

var gOPD = Object.getOwnPropertyDescriptor;

var f$1 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};

var _objectGopd = {
  f: f$1
};

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */

var check = function check(O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

// 19.1.3.19 Object.setPrototypeOf(O, proto)

_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

var setPrototypeOf = _core.Object.setPrototypeOf;

var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});
var _shared = function _shared(key) {
  return store[key] || (store[key] = {});
};

var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var _Symbol = _global.Symbol;
  var USE_SYMBOL = typeof _Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
});

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

var _classof = function _classof(it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  // builtinTag case
  : ARG ? _cof(O)
  // ES3 arguments fallback
  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

// 19.1.3.6 Object.prototype.toString()

var test = {};
test[_wks('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  _redefine(Object.prototype, 'toString', function toString() {
    return '[object ' + _classof(this) + ']';
  }, true);
}

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function _toInteger(it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// true  -> String#at
// false -> String#codePointAt
var _stringAt = function _stringAt(TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _library = false;

var _iterators = {};

// 7.1.15 ToLength

var min = Math.min;
var _toLength = function _toLength(it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes


var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

var shared = _shared('keys');

var _sharedKey = function _sharedKey(key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO$1 = _sharedKey('IE_PROTO');

var _objectKeysInternal = function _objectKeysInternal(object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
    if (key != IE_PROTO$1) _has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)


var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
    _objectDp.f(O, P = keys[i++], Properties[P]);
  }return O;
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


var IE_PROTO = _sharedKey('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE$1 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
    delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
  }return _createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = _createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

var def = _objectDp.f;

var TAG$1 = _wks('toStringTag');

var _setToStringTag = function _setToStringTag(it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });
};

var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () {
  return this;
});

var _iterCreate = function _iterCreate(Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

// 7.1.13 ToObject(argument)

var _toObject = function _toObject(it) {
  return Object(_defined(it));
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};

var ITERATOR = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!_library && !_has(IteratorPrototype, ITERATOR)) _hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    _hide(proto, ITERATOR, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _wks('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
var _addToUnscopables = function _addToUnscopables(key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

var _iterStep = function _iterStep(done, value) {
  return { value: value, done: !!done };
};

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

_addToUnscopables('keys');
_addToUnscopables('values');
_addToUnscopables('entries');

var ITERATOR$1 = _wks('iterator');
var TO_STRING_TAG = _wks('toStringTag');
var ArrayValues = _iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = _global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);
    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = ArrayValues;
    if (explicit) for (key in es6_array_iterator) {
      if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
    }
  }
}

var _redefineAll = function _redefineAll(target, src, safe) {
  for (var key in src) {
    _redefine(target, key, src[key], safe);
  }return target;
};

var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }return it;
};

// call something on iterator step with safe closing on error

var _iterCall = function _iterCall(iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator

var ITERATOR$2 = _wks('iterator');
var ArrayProto$1 = Array.prototype;

var _isArrayIter = function _isArrayIter(it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
};

var ITERATOR$3 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || _iterators[_classof(it)];
};

var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () {
      return iterable;
    } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
});

var SPECIES = _wks('species');

var _setSpecies = function _setSpecies(KEY) {
  var C = _global[KEY];
  if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');

  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function setMeta(it) {
    setDesc(it, META, { value: {
        i: 'O' + ++id, // object ID
        w: {} // weak collections IDs
      } });
  };
  var fastKey = function fastKey(it, create) {
    // return primitive with prefix
    if (!_isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMeta(it);
      // return object ID
    }return it[META].i;
  };
  var getWeak = function getWeak(it, create) {
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMeta(it);
      // return hash weak collections IDs
    }return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function onFreeze(it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
});

var _meta_1 = _meta.KEY;
var _meta_2 = _meta.NEED;
var _meta_3 = _meta.fastKey;
var _meta_4 = _meta.getWeak;
var _meta_5 = _meta.onFreeze;

var _validateCollection = function _validateCollection(it, TYPE) {
  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

var dP$1 = _objectDp.f;

var fastKey = _meta.fastKey;

var SIZE = _descriptors ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

var _collectionStrong = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      _anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = _objectCreate(null); // index
      that._f = undefined; // first entry
      that._l = undefined; // last entry
      that[SIZE] = 0; // size
      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
    });
    _redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = _validateCollection(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        _validateCollection(this, NAME);
        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(_validateCollection(this, NAME), key);
      }
    });
    if (_descriptors) dP$1(C.prototype, 'size', {
      get: function get() {
        return _validateCollection(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
      // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key, // <- key
        v: value, // <- value
        p: prev = that._l, // <- previous entry
        n: undefined, // <- next entry
        r: false // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    }return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    _iterDefine(C, NAME, function (iterated, kind) {
      this._t = _validateCollection(iterated, NAME); // target
      this._k = kind; // kind
      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return _iterStep(1);
      }
      // return step by kind
      if (kind == 'keys') return _iterStep(0, entry.k);
      if (kind == 'values') return _iterStep(0, entry.v);
      return _iterStep(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    _setSpecies(NAME);
  }
};

var ITERATOR$4 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$4]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  
} catch (e) {/* empty */}

var _iterDetect = function _iterDetect(exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$4]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR$4] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

var setPrototypeOf$2 = _setProto.set;
var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf$2) {
    setPrototypeOf$2(that, P);
  }return that;
};

var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = _global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    _redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);return this;
    });
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    _redefineAll(C.prototype, methods);
    _meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = _fails(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = _iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) {
        $instance[ADDER](index, index);
      }return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME);
        var that = _inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  _setToStringTag(C, NAME);

  O[NAME] = C;
  _export(_export.G + _export.W + _export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

var SET = 'Set';

// 23.2 Set Objects
var es6_set = _collection(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
  }
}, _collectionStrong);

var _arrayFromIterable = function _arrayFromIterable(iter, ITERATOR) {
  var result = [];
  _forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


var _collectionToJson = function _collectionToJson(NAME) {
  return function toJSON() {
    if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return _arrayFromIterable(this);
  };
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


_export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });

// https://tc39.github.io/proposal-setmap-offrom/


var _setCollectionOf = function _setCollectionOf(COLLECTION) {
  _export(_export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = Array(length);
      while (length--) {
        A[length] = arguments[length];
      }return new this(A);
    } });
};

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
_setCollectionOf('Set');

// https://tc39.github.io/proposal-setmap-offrom/


var _setCollectionFrom = function _setCollectionFrom(COLLECTION) {
  _export(_export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      _aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) _aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = _ctx(mapFn, arguments[2], 2);
        _forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        _forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
};

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
_setCollectionFrom('Set');

var set$1 = _core.Set;

var MAP = 'Map';

// 23.1 Map Objects
var es6_map = _collection(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
  }
}, _collectionStrong, true);

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


_export(_export.P + _export.R, 'Map', { toJSON: _collectionToJson('Map') });

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
_setCollectionOf('Map');

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
_setCollectionFrom('Map');

var map = _core.Map;

// 7.2.2 IsArray(argument)

var _isArray = Array.isArray || function isArray(arg) {
  return _cof(arg) == 'Array';
};

var SPECIES$1 = _wks('species');

var _arraySpeciesConstructor = function _arraySpeciesConstructor(original) {
  var C;
  if (_isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
    if (_isObject(C)) {
      C = C[SPECIES$1];
      if (C === null) C = undefined;
    }
  }return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


var _arraySpeciesCreate = function _arraySpeciesCreate(original, length) {
  return new (_arraySpeciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex


var _arrayMethods = function _arrayMethods(TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || _arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = _toObject($this);
    var self = _iobject(O);
    var f = _ctx(callbackfn, that, 3);
    var length = _toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true; // some
              case 5:
                return val; // find
              case 6:
                return index; // findIndex
              case 2:
                result.push(val); // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

var f$3 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$3
};

// 19.1.2.1 Object.assign(target, source, ...)


var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = _toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = _objectGops.f;
  var isEnum = _objectPie.f;
  while (aLen > index) {
    var S = _iobject(arguments[index++]);
    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }return T;
} : $assign;

var getWeak = _meta.getWeak;

var arrayFind = _arrayMethods(5);
var arrayFindIndex = _arrayMethods(6);
var id$1 = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};
var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

var _collectionWeak = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      _anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = id$1++; // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
    });
    _redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        if (!_isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);
        return data && _has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!_isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);
        return data && _has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(_anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

var es6_weakMap = createCommonjsModule(function (module) {
  var each = _arrayMethods(0);

  var WEAK_MAP = 'WeakMap';
  var getWeak = _meta.getWeak;
  var isExtensible = Object.isExtensible;
  var uncaughtFrozenStore = _collectionWeak.ufstore;
  var tmp = {};
  var InternalMap;

  var wrapper = function wrapper(get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  };

  var methods = {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function get(key) {
      if (_isObject(key)) {
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);
        return data ? data[this._i] : undefined;
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function set(key, value) {
      return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
    }
  };

  // 23.3 WeakMap Objects
  var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true);

  // IE11 WeakMap frozen keys fix
  if (_fails(function () {
    return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
  })) {
    InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
    _objectAssign(InternalMap.prototype, methods);
    _meta.NEED = true;
    each(['delete', 'has', 'get', 'set'], function (key) {
      var proto = $WeakMap.prototype;
      var method = proto[key];
      _redefine(proto, key, function (a, b) {
        // store frozen objects on internal weakmap shim
        if (_isObject(a) && !isExtensible(a)) {
          if (!this._f) this._f = new InternalMap();
          var result = this._f[key](a, b);
          return key == 'set' ? this : result;
          // store all the rest on native weakmap
        }return method.call(this, a, b);
      });
    });
  }
});

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
_setCollectionOf('WeakMap');

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
_setCollectionFrom('WeakMap');

var weakMap = _core.WeakMap;

var _createProperty = function _createProperty(object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
};

_export(_export.S + _export.F * !_iterDetect(function (iter) {
  
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = _toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);
      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var from$1 = _core.Array.from;

var reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);

/**
 * @param {string} localName
 * @returns {boolean}
 */
function isValidCustomElementName(localName) {
  var reserved = reservedTagList.has(localName);
  var validForm = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(localName);
  return !reserved && validForm;
}

/**
 * @private
 * @param {!Node} node
 * @return {boolean}
 */
function isConnected(node) {
  // Use `Node#isConnected`, if defined.
  var nativeValue = node.isConnected;
  if (nativeValue !== undefined) {
    return nativeValue;
  }

  /** @type {?Node|undefined} */
  var current = node;
  while (current && !(current.__CE_isImportDocument || current instanceof Document)) {
    current = current.parentNode || (window.ShadowRoot && current instanceof ShadowRoot ? current.host : undefined);
  }
  return !!(current && (current.__CE_isImportDocument || current instanceof Document));
}

/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */
function nextSiblingOrAncestorSibling(root, start) {
  var node = start;
  while (node && node !== root && !node.nextSibling) {
    node = node.parentNode;
  }
  return !node || node === root ? null : node.nextSibling;
}

/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */
function nextNode(root, start) {
  return start.firstChild ? start.firstChild : nextSiblingOrAncestorSibling(root, start);
}

/**
 * @param {!Node} root
 * @param {!function(!Element)} callback
 * @param {!Set<Node>=} visitedImports
 */
function walkDeepDescendantElements(root, callback) {
  var visitedImports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();

  var node = root;
  while (node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      var element = /** @type {!Element} */node;

      callback(element);

      var localName = element.localName;
      if (localName === 'link' && element.getAttribute('rel') === 'import') {
        // If this import (polyfilled or not) has it's root node available,
        // walk it.
        var importNode = /** @type {!Node} */element.import;
        if (importNode instanceof Node && !visitedImports.has(importNode)) {
          // Prevent multiple walks of the same import root.
          visitedImports.add(importNode);

          for (var child = importNode.firstChild; child; child = child.nextSibling) {
            walkDeepDescendantElements(child, callback, visitedImports);
          }
        }

        // Ignore descendants of import links to prevent attempting to walk the
        // elements created by the HTML Imports polyfill that we just walked
        // above.
        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      } else if (localName === 'template') {
        // Ignore descendants of templates. There shouldn't be any descendants
        // because they will be moved into `.content` during construction in
        // browsers that support template but, in case they exist and are still
        // waiting to be moved by a polyfill, they will be ignored.
        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      }

      // Walk shadow roots.
      var shadowRoot = element.__CE_shadowRoot;
      if (shadowRoot) {
        for (var _child = shadowRoot.firstChild; _child; _child = _child.nextSibling) {
          walkDeepDescendantElements(_child, callback, visitedImports);
        }
      }
    }

    node = nextNode(root, node);
  }
}

/**
 * Used to suppress Closure's "Modifying the prototype is only allowed if the
 * constructor is in the same scope" warning without using
 * `@suppress {newCheckTypes, duplicate}` because `newCheckTypes` is too broad.
 *
 * @param {!Object} destination
 * @param {string} name
 * @param {*} value
 */
function setPropertyUnchecked(destination, name, value) {
  destination[name] = value;
}

/**
 * @enum {number}
 */
var CustomElementState = {
  custom: 1,
  failed: 2
};

var CustomElementInternals = function () {
  function CustomElementInternals() {
    classCallCheck(this, CustomElementInternals);

    /** @type {!Map<string, !CustomElementDefinition>} */
    this._localNameToDefinition = new Map();

    /** @type {!Map<!Function, !CustomElementDefinition>} */
    this._constructorToDefinition = new Map();

    /** @type {!Array<!function(!Node)>} */
    this._patches = [];

    /** @type {boolean} */
    this._hasPatches = false;
  }

  /**
   * @param {string} localName
   * @param {!CustomElementDefinition} definition
   */


  createClass(CustomElementInternals, [{
    key: 'setDefinition',
    value: function setDefinition(localName, definition) {
      this._localNameToDefinition.set(localName, definition);
      this._constructorToDefinition.set(definition.constructor, definition);
    }

    /**
     * @param {string} localName
     * @return {!CustomElementDefinition|undefined}
     */

  }, {
    key: 'localNameToDefinition',
    value: function localNameToDefinition(localName) {
      return this._localNameToDefinition.get(localName);
    }

    /**
     * @param {!Function} constructor
     * @return {!CustomElementDefinition|undefined}
     */

  }, {
    key: 'constructorToDefinition',
    value: function constructorToDefinition(constructor) {
      return this._constructorToDefinition.get(constructor);
    }

    /**
     * @param {!function(!Node)} listener
     */

  }, {
    key: 'addPatch',
    value: function addPatch(listener) {
      this._hasPatches = true;
      this._patches.push(listener);
    }

    /**
     * @param {!Node} node
     */

  }, {
    key: 'patchTree',
    value: function patchTree(node) {
      var _this = this;

      if (!this._hasPatches) return;

      walkDeepDescendantElements(node, function (element) {
        return _this.patch(element);
      });
    }

    /**
     * @param {!Node} node
     */

  }, {
    key: 'patch',
    value: function patch(node) {
      if (!this._hasPatches) return;

      if (node.__CE_patched) return;
      node.__CE_patched = true;

      for (var i = 0; i < this._patches.length; i++) {
        this._patches[i](node);
      }
    }

    /**
     * @param {!Node} root
     */

  }, {
    key: 'connectTree',
    value: function connectTree(root) {
      var elements = [];

      walkDeepDescendantElements(root, function (element) {
        return elements.push(element);
      });

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.__CE_state === CustomElementState.custom) {
          if (isConnected(element)) {
            this.connectedCallback(element);
          }
        } else {
          this.upgradeElement(element);
        }
      }
    }

    /**
     * @param {!Node} root
     */

  }, {
    key: 'disconnectTree',
    value: function disconnectTree(root) {
      var elements = [];

      walkDeepDescendantElements(root, function (element) {
        return elements.push(element);
      });

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.__CE_state === CustomElementState.custom) {
          this.disconnectedCallback(element);
        }
      }
    }

    /**
     * Upgrades all uncustomized custom elements at and below a root node for
     * which there is a definition. When custom element reaction callbacks are
     * assumed to be called synchronously (which, by the current DOM / HTML spec
     * definitions, they are *not*), callbacks for both elements customized
     * synchronously by the parser and elements being upgraded occur in the same
     * relative order.
     *
     * NOTE: This function, when used to simulate the construction of a tree that
     * is already created but not customized (i.e. by the parser), does *not*
     * prevent the element from reading the 'final' (true) state of the tree. For
     * example, the element, during truly synchronous parsing / construction would
     * see that it contains no children as they have not yet been inserted.
     * However, this function does not modify the tree, the element will
     * (incorrectly) have children. Additionally, self-modification restrictions
     * for custom element constructors imposed by the DOM spec are *not* enforced.
     *
     *
     * The following nested list shows the steps extending down from the HTML
     * spec's parsing section that cause elements to be synchronously created and
     * upgraded:
     *
     * The "in body" insertion mode:
     * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
     * - Switch on token:
     *   .. other cases ..
     *   -> Any other start tag
     *      - [Insert an HTML element](below) for the token.
     *
     * Insert an HTML element:
     * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element
     * - Insert a foreign element for the token in the HTML namespace:
     *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element
     *   - Create an element for a token:
     *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token
     *     - Will execute script flag is true?
     *       - (Element queue pushed to the custom element reactions stack.)
     *     - Create an element:
     *       https://dom.spec.whatwg.org/#concept-create-element
     *       - Sync CE flag is true?
     *         - Constructor called.
     *         - Self-modification restrictions enforced.
     *       - Sync CE flag is false?
     *         - (Upgrade reaction enqueued.)
     *     - Attributes appended to element.
     *       (`attributeChangedCallback` reactions enqueued.)
     *     - Will execute script flag is true?
     *       - (Element queue popped from the custom element reactions stack.
     *         Reactions in the popped stack are invoked.)
     *   - (Element queue pushed to the custom element reactions stack.)
     *   - Insert the element:
     *     https://dom.spec.whatwg.org/#concept-node-insert
     *     - Shadow-including descendants are connected. During parsing
     *       construction, there are no shadow-*excluding* descendants.
     *       However, the constructor may have validly attached a shadow
     *       tree to itself and added descendants to that shadow tree.
     *       (`connectedCallback` reactions enqueued.)
     *   - (Element queue popped from the custom element reactions stack.
     *     Reactions in the popped stack are invoked.)
     *
     * @param {!Node} root
     * @param {!Set<Node>=} visitedImports
     */

  }, {
    key: 'patchAndUpgradeTree',
    value: function patchAndUpgradeTree(root) {
      var _this2 = this;

      var visitedImports = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

      var elements = [];

      var gatherElements = function gatherElements(element) {
        if (element.localName === 'link' && element.getAttribute('rel') === 'import') {
          // The HTML Imports polyfill sets a descendant element of the link to
          // the `import` property, specifically this is *not* a Document.
          var importNode = /** @type {?Node} */element.import;

          if (importNode instanceof Node && importNode.readyState === 'complete') {
            importNode.__CE_isImportDocument = true;

            // Connected links are associated with the registry.
            importNode.__CE_hasRegistry = true;
          } else {
            // If this link's import root is not available, its contents can't be
            // walked. Wait for 'load' and walk it when it's ready.
            element.addEventListener('load', function () {
              var importNode = /** @type {!Node} */element.import;

              if (importNode.__CE_documentLoadHandled) return;
              importNode.__CE_documentLoadHandled = true;

              importNode.__CE_isImportDocument = true;

              // Connected links are associated with the registry.
              importNode.__CE_hasRegistry = true;

              // Clone the `visitedImports` set that was populated sync during
              // the `patchAndUpgradeTree` call that caused this 'load' handler to
              // be added. Then, remove *this* link's import node so that we can
              // walk that import again, even if it was partially walked later
              // during the same `patchAndUpgradeTree` call.
              visitedImports.delete(importNode);

              _this2.patchAndUpgradeTree(importNode, visitedImports);
            });
          }
        } else {
          elements.push(element);
        }
      };

      // `walkDeepDescendantElements` populates (and internally checks against)
      // `visitedImports` when traversing a loaded import.
      walkDeepDescendantElements(root, gatherElements, visitedImports);

      if (this._hasPatches) {
        for (var i = 0; i < elements.length; i++) {
          this.patch(elements[i]);
        }
      }

      for (var _i = 0; _i < elements.length; _i++) {
        this.upgradeElement(elements[_i]);
      }
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'upgradeElement',
    value: function upgradeElement(element) {
      var currentState = element.__CE_state;
      if (currentState !== undefined) return;

      var definition = this.localNameToDefinition(element.localName);
      if (!definition) return;

      definition.constructionStack.push(element);

      var constructor = definition.constructor;
      try {
        try {
          var result = new constructor();
          if (result !== element) {
            throw new Error('The custom element constructor did not produce the element being upgraded.');
          }
        } finally {
          definition.constructionStack.pop();
        }
      } catch (e) {
        element.__CE_state = CustomElementState.failed;
        throw e;
      }

      element.__CE_state = CustomElementState.custom;
      element.__CE_definition = definition;

      if (definition.attributeChangedCallback) {
        var observedAttributes = definition.observedAttributes;
        for (var i = 0; i < observedAttributes.length; i++) {
          var name = observedAttributes[i];
          var value = element.getAttribute(name);
          if (value !== null) {
            this.attributeChangedCallback(element, name, null, value, null);
          }
        }
      }

      if (isConnected(element)) {
        this.connectedCallback(element);
      }
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback(element) {
      var definition = element.__CE_definition;
      if (definition.connectedCallback) {
        definition.connectedCallback.call(element);
      }

      element.__CE_isConnectedCallbackCalled = true;
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback(element) {
      if (!element.__CE_isConnectedCallbackCalled) {
        this.connectedCallback(element);
      }

      var definition = element.__CE_definition;
      if (definition.disconnectedCallback) {
        definition.disconnectedCallback.call(element);
      }

      element.__CE_isConnectedCallbackCalled = undefined;
    }

    /**
     * @param {!Element} element
     * @param {string} name
     * @param {?string} oldValue
     * @param {?string} newValue
     * @param {?string} namespace
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(element, name, oldValue, newValue, namespace) {
      var definition = element.__CE_definition;
      if (definition.attributeChangedCallback && definition.observedAttributes.indexOf(name) > -1) {
        definition.attributeChangedCallback.call(element, name, oldValue, newValue, namespace);
      }
    }
  }]);
  return CustomElementInternals;
}();

var DocumentConstructionObserver = function () {
  function DocumentConstructionObserver(internals, doc) {
    classCallCheck(this, DocumentConstructionObserver);

    /**
     * @type {!CustomElementInternals}
     */
    this._internals = internals;

    /**
     * @type {!Document}
     */
    this._document = doc;

    /**
     * @type {MutationObserver|undefined}
     */
    this._observer = undefined;

    // Simulate tree construction for all currently accessible nodes in the
    // document.
    this._internals.patchAndUpgradeTree(this._document);

    if (this._document.readyState === 'loading') {
      this._observer = new MutationObserver(this._handleMutations.bind(this));

      // Nodes created by the parser are given to the observer *before* the next
      // task runs. Inline scripts are run in a new task. This means that the
      // observer will be able to handle the newly parsed nodes before the inline
      // script is run.
      this._observer.observe(this._document, {
        childList: true,
        subtree: true
      });
    }
  }

  createClass(DocumentConstructionObserver, [{
    key: 'disconnect',
    value: function disconnect() {
      if (this._observer) {
        this._observer.disconnect();
      }
    }

    /**
     * @param {!Array<!MutationRecord>} mutations
     */

  }, {
    key: '_handleMutations',
    value: function _handleMutations(mutations) {
      // Once the document's `readyState` is 'interactive' or 'complete', all new
      // nodes created within that document will be the result of script and
      // should be handled by patching.
      var readyState = this._document.readyState;
      if (readyState === 'interactive' || readyState === 'complete') {
        this.disconnect();
      }

      for (var i = 0; i < mutations.length; i++) {
        var addedNodes = mutations[i].addedNodes;
        for (var j = 0; j < addedNodes.length; j++) {
          var node = addedNodes[j];
          this._internals.patchAndUpgradeTree(node);
        }
      }
    }
  }]);
  return DocumentConstructionObserver;
}();

/**
 * @template T
 */
var Deferred = function () {
  function Deferred() {
    var _this = this;

    classCallCheck(this, Deferred);

    /**
     * @private
     * @type {T|undefined}
     */
    this._value = undefined;

    /**
     * @private
     * @type {Function|undefined}
     */
    this._resolve = undefined;

    /**
     * @private
     * @type {!Promise<T>}
     */
    this._promise = new Promise(function (resolve) {
      _this._resolve = resolve;

      if (_this._value) {
        resolve(_this._value);
      }
    });
  }

  /**
   * @param {T} value
   */


  createClass(Deferred, [{
    key: 'resolve',
    value: function resolve(value) {
      if (this._value) {
        throw new Error('Already resolved.');
      }

      this._value = value;

      if (this._resolve) {
        this._resolve(value);
      }
    }

    /**
     * @return {!Promise<T>}
     */

  }, {
    key: 'toPromise',
    value: function toPromise() {
      return this._promise;
    }
  }]);
  return Deferred;
}();

/**
 * @unrestricted
 */

var CustomElementRegistry = function () {

  /**
   * @param {!CustomElementInternals} internals
   */
  function CustomElementRegistry(internals) {
    classCallCheck(this, CustomElementRegistry);

    /**
     * @private
     * @type {boolean}
     */
    this._elementDefinitionIsRunning = false;

    /**
     * @private
     * @type {!CustomElementInternals}
     */
    this._internals = internals;

    /**
     * @private
     * @type {!Map<string, !Deferred<undefined>>}
     */
    this._whenDefinedDeferred = new Map();

    /**
     * The default flush callback triggers the document walk synchronously.
     * @private
     * @type {!Function}
     */
    this._flushCallback = function (fn) {
      return fn();
    };

    /**
     * @private
     * @type {boolean}
     */
    this._flushPending = false;

    /**
     * @private
     * @type {!Array<string>}
     */
    this._unflushedLocalNames = [];

    /**
     * @private
     * @type {!DocumentConstructionObserver}
     */
    this._documentConstructionObserver = new DocumentConstructionObserver(internals, document);
  }

  /**
   * @param {string} localName
   * @param {!Function} constructor
   */


  createClass(CustomElementRegistry, [{
    key: 'define',
    value: function define(localName, constructor) {
      var _this = this;

      if (!(constructor instanceof Function)) {
        throw new TypeError('Custom element constructors must be functions.');
      }

      if (!isValidCustomElementName(localName)) {
        throw new SyntaxError('The element name \'' + localName + '\' is not valid.');
      }

      if (this._internals.localNameToDefinition(localName)) {
        throw new Error('A custom element with name \'' + localName + '\' has already been defined.');
      }

      if (this._elementDefinitionIsRunning) {
        throw new Error('A custom element is already being defined.');
      }
      this._elementDefinitionIsRunning = true;

      var connectedCallback = void 0;
      var disconnectedCallback = void 0;
      var adoptedCallback = void 0;
      var attributeChangedCallback = void 0;
      var observedAttributes = void 0;
      try {
        var getCallback = function getCallback(name) {
          var callbackValue = prototype[name];
          if (callbackValue !== undefined && !(callbackValue instanceof Function)) {
            throw new Error('The \'' + name + '\' callback must be a function.');
          }
          return callbackValue;
        };

        /** @type {!Object} */
        var prototype = constructor.prototype;
        if (!(prototype instanceof Object)) {
          throw new TypeError('The custom element constructor\'s prototype is not an object.');
        }

        connectedCallback = getCallback('connectedCallback');
        disconnectedCallback = getCallback('disconnectedCallback');
        adoptedCallback = getCallback('adoptedCallback');
        attributeChangedCallback = getCallback('attributeChangedCallback');
        observedAttributes = constructor['observedAttributes'] || [];
      } catch (e) {
        return;
      } finally {
        this._elementDefinitionIsRunning = false;
      }

      var definition = {
        localName: localName,
        constructor: constructor,
        connectedCallback: connectedCallback,
        disconnectedCallback: disconnectedCallback,
        adoptedCallback: adoptedCallback,
        attributeChangedCallback: attributeChangedCallback,
        observedAttributes: observedAttributes,
        constructionStack: []
      };

      this._internals.setDefinition(localName, definition);

      this._unflushedLocalNames.push(localName);

      // If we've already called the flush callback and it hasn't called back yet,
      // don't call it again.
      if (!this._flushPending) {
        this._flushPending = true;
        this._flushCallback(function () {
          return _this._flush();
        });
      }
    }
  }, {
    key: '_flush',
    value: function _flush() {
      // If no new definitions were defined, don't attempt to flush. This could
      // happen if a flush callback keeps the function it is given and calls it
      // multiple times.
      if (this._flushPending === false) return;

      this._flushPending = false;
      this._internals.patchAndUpgradeTree(document);

      while (this._unflushedLocalNames.length > 0) {
        var localName = this._unflushedLocalNames.shift();
        var deferred = this._whenDefinedDeferred.get(localName);
        if (deferred) {
          deferred.resolve(undefined);
        }
      }
    }

    /**
     * @param {string} localName
     * @return {Function|undefined}
     */

  }, {
    key: 'get',
    value: function get$$1(localName) {
      var definition = this._internals.localNameToDefinition(localName);
      if (definition) {
        return definition.constructor;
      }

      return undefined;
    }

    /**
     * @param {string} localName
     * @return {!Promise<undefined>}
     */

  }, {
    key: 'whenDefined',
    value: function whenDefined(localName) {
      if (!isValidCustomElementName(localName)) {
        return Promise.reject(new SyntaxError('\'' + localName + '\' is not a valid custom element name.'));
      }

      var prior = this._whenDefinedDeferred.get(localName);
      if (prior) {
        return prior.toPromise();
      }

      var deferred = new Deferred();
      this._whenDefinedDeferred.set(localName, deferred);

      var definition = this._internals.localNameToDefinition(localName);
      // Resolve immediately only if the given local name has a definition *and*
      // the full document walk to upgrade elements with that local name has
      // already happened.
      if (definition && this._unflushedLocalNames.indexOf(localName) === -1) {
        deferred.resolve(undefined);
      }

      return deferred.toPromise();
    }
  }, {
    key: 'polyfillWrapFlushCallback',
    value: function polyfillWrapFlushCallback(outer) {
      this._documentConstructionObserver.disconnect();
      var inner = this._flushCallback;
      this._flushCallback = function (flush) {
        return outer(function () {
          return inner(flush);
        });
      };
    }
  }]);
  return CustomElementRegistry;
}();

window['CustomElementRegistry'] = CustomElementRegistry;
CustomElementRegistry.prototype['define'] = CustomElementRegistry.prototype.define;
CustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;
CustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry.prototype.whenDefined;
CustomElementRegistry.prototype['polyfillWrapFlushCallback'] = CustomElementRegistry.prototype.polyfillWrapFlushCallback;

var Native = {
  Document_createElement: window.Document.prototype.createElement,
  Document_createElementNS: window.Document.prototype.createElementNS,
  Document_importNode: window.Document.prototype.importNode,
  Document_prepend: window.Document.prototype['prepend'],
  Document_append: window.Document.prototype['append'],
  Node_cloneNode: window.Node.prototype.cloneNode,
  Node_appendChild: window.Node.prototype.appendChild,
  Node_insertBefore: window.Node.prototype.insertBefore,
  Node_removeChild: window.Node.prototype.removeChild,
  Node_replaceChild: window.Node.prototype.replaceChild,
  Node_textContent: Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent'),
  Element_attachShadow: window.Element.prototype['attachShadow'],
  Element_innerHTML: Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML'),
  Element_getAttribute: window.Element.prototype.getAttribute,
  Element_setAttribute: window.Element.prototype.setAttribute,
  Element_removeAttribute: window.Element.prototype.removeAttribute,
  Element_getAttributeNS: window.Element.prototype.getAttributeNS,
  Element_setAttributeNS: window.Element.prototype.setAttributeNS,
  Element_removeAttributeNS: window.Element.prototype.removeAttributeNS,
  Element_insertAdjacentElement: window.Element.prototype['insertAdjacentElement'],
  Element_prepend: window.Element.prototype['prepend'],
  Element_append: window.Element.prototype['append'],
  Element_before: window.Element.prototype['before'],
  Element_after: window.Element.prototype['after'],
  Element_replaceWith: window.Element.prototype['replaceWith'],
  Element_remove: window.Element.prototype['remove'],
  HTMLElement: window.HTMLElement,
  HTMLElement_innerHTML: Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML'),
  HTMLElement_insertAdjacentElement: window.HTMLElement.prototype['insertAdjacentElement']
};

/**
 * This class exists only to work around Closure's lack of a way to describe
 * singletons. It represents the 'already constructed marker' used in custom
 * element construction stacks.
 *
 * https://html.spec.whatwg.org/#concept-already-constructed-marker
 */
var AlreadyConstructedMarker = function AlreadyConstructedMarker() {
  classCallCheck(this, AlreadyConstructedMarker);
};

var AlreadyConstructedMarker$1 = new AlreadyConstructedMarker();

/**
 * @param {!CustomElementInternals} internals
 */
var PatchHTMLElement = function (internals) {
  window['HTMLElement'] = function () {
    /**
     * @type {function(new: HTMLElement): !HTMLElement}
     */
    function HTMLElement() {
      // This should really be `new.target` but `new.target` can't be emulated
      // in ES5. Assuming the user keeps the default value of the constructor's
      // prototype's `constructor` property, this is equivalent.
      /** @type {!Function} */
      var constructor = this.constructor;

      var definition = internals.constructorToDefinition(constructor);
      if (!definition) {
        throw new Error('The custom element being constructed was not registered with `customElements`.');
      }

      var constructionStack = definition.constructionStack;

      if (constructionStack.length === 0) {
        var _element = Native.Document_createElement.call(document, definition.localName);
        Object.setPrototypeOf(_element, constructor.prototype);
        _element.__CE_state = CustomElementState.custom;
        _element.__CE_definition = definition;
        internals.patch(_element);
        return _element;
      }

      var lastIndex = constructionStack.length - 1;
      var element = constructionStack[lastIndex];
      if (element === AlreadyConstructedMarker$1) {
        throw new Error('The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.');
      }
      constructionStack[lastIndex] = AlreadyConstructedMarker$1;

      Object.setPrototypeOf(element, constructor.prototype);
      internals.patch( /** @type {!HTMLElement} */element);

      return element;
    }

    HTMLElement.prototype = Native.HTMLElement.prototype;

    return HTMLElement;
  }();
};

/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ParentNodeNativeMethods} builtIn
 */
var PatchParentNode = function (internals, destination, builtIn) {
  /**
   * @param {...(!Node|string)} nodes
   */
  destination['prepend'] = function () {
    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.prepend.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i = 0; _i < nodes.length; _i++) {
        var node = nodes[_i];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['append'] = function () {
    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      nodes[_key2] = arguments[_key2];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.append.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var node = nodes[_i2];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchDocument = function (internals) {
  setPropertyUnchecked(Document.prototype, 'createElement',
  /**
   * @this {Document}
   * @param {string} localName
   * @return {!Element}
   */
  function (localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry) {
      var definition = internals.localNameToDefinition(localName);
      if (definition) {
        return new definition.constructor();
      }
    }

    var result = /** @type {!Element} */
    Native.Document_createElement.call(this, localName);
    internals.patch(result);
    return result;
  });

  setPropertyUnchecked(Document.prototype, 'importNode',
  /**
   * @this {Document}
   * @param {!Node} node
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (node, deep) {
    var clone = Native.Document_importNode.call(this, node, deep);
    // Only create custom elements if this document is associated with the registry.
    if (!this.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }
    return clone;
  });

  var NS_HTML = "http://www.w3.org/1999/xhtml";

  setPropertyUnchecked(Document.prototype, 'createElementNS',
  /**
   * @this {Document}
   * @param {?string} namespace
   * @param {string} localName
   * @return {!Element}
   */
  function (namespace, localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry && (namespace === null || namespace === NS_HTML)) {
      var definition = internals.localNameToDefinition(localName);
      if (definition) {
        return new definition.constructor();
      }
    }

    var result = /** @type {!Element} */
    Native.Document_createElementNS.call(this, namespace, localName);
    internals.patch(result);
    return result;
  });

  PatchParentNode(internals, Document.prototype, {
    prepend: Native.Document_prepend,
    append: Native.Document_append
  });
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchNode = function (internals) {
  // `Node#nodeValue` is implemented on `Attr`.
  // `Node#textContent` is implemented on `Attr`, `Element`.

  setPropertyUnchecked(Node.prototype, 'insertBefore',
  /**
   * @this {Node}
   * @param {!Node} node
   * @param {?Node} refNode
   * @return {!Node}
   */
  function (node, refNode) {
    if (node instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
      var _nativeResult = Native.Node_insertBefore.call(this, node, refNode);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult;
    }

    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_insertBefore.call(this, node, refNode);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'appendChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    if (node instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
      var _nativeResult2 = Native.Node_appendChild.call(this, node);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult2;
    }

    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_appendChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'cloneNode',
  /**
   * @this {Node}
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (deep) {
    var clone = Native.Node_cloneNode.call(this, deep);
    // Only create custom elements if this element's owner document is
    // associated with the registry.
    if (!this.ownerDocument.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }
    return clone;
  });

  setPropertyUnchecked(Node.prototype, 'removeChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_removeChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'replaceChild',
  /**
   * @this {Node}
   * @param {!Node} nodeToInsert
   * @param {!Node} nodeToRemove
   * @return {!Node}
   */
  function (nodeToInsert, nodeToRemove) {
    if (nodeToInsert instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(nodeToInsert.childNodes);
      var _nativeResult3 = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        internals.disconnectTree(nodeToRemove);
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult3;
    }

    var nodeToInsertWasConnected = isConnected(nodeToInsert);
    var nativeResult = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);
    var thisIsConnected = isConnected(this);

    if (thisIsConnected) {
      internals.disconnectTree(nodeToRemove);
    }

    if (nodeToInsertWasConnected) {
      internals.disconnectTree(nodeToInsert);
    }

    if (thisIsConnected) {
      internals.connectTree(nodeToInsert);
    }

    return nativeResult;
  });

  function patch_textContent(destination, baseDescriptor) {
    Object.defineProperty(destination, 'textContent', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set: /** @this {Node} */function set(assignedValue) {
        // If this is a text node then there are no nodes to disconnect.
        if (this.nodeType === Node.TEXT_NODE) {
          baseDescriptor.set.call(this, assignedValue);
          return;
        }

        var removedNodes = undefined;
        // Checking for `firstChild` is faster than reading `childNodes.length`
        // to compare with 0.
        if (this.firstChild) {
          // Using `childNodes` is faster than `children`, even though we only
          // care about elements.
          var childNodes = this.childNodes;
          var childNodesLength = childNodes.length;
          if (childNodesLength > 0 && isConnected(this)) {
            // Copying an array by iterating is faster than using slice.
            removedNodes = new Array(childNodesLength);
            for (var i = 0; i < childNodesLength; i++) {
              removedNodes[i] = childNodes[i];
            }
          }
        }

        baseDescriptor.set.call(this, assignedValue);

        if (removedNodes) {
          for (var _i = 0; _i < removedNodes.length; _i++) {
            internals.disconnectTree(removedNodes[_i]);
          }
        }
      }
    });
  }

  if (Native.Node_textContent && Native.Node_textContent.get) {
    patch_textContent(Node.prototype, Native.Node_textContent);
  } else {
    internals.addPatch(function (element) {
      patch_textContent(element, {
        enumerable: true,
        configurable: true,
        // NOTE: This implementation of the `textContent` getter assumes that
        // text nodes' `textContent` getter will not be patched.
        get: /** @this {Node} */function get() {
          /** @type {!Array<string>} */
          var parts = [];

          for (var i = 0; i < this.childNodes.length; i++) {
            parts.push(this.childNodes[i].textContent);
          }

          return parts.join('');
        },
        set: /** @this {Node} */function set(assignedValue) {
          while (this.firstChild) {
            Native.Node_removeChild.call(this, this.firstChild);
          }
          Native.Node_appendChild.call(this, document.createTextNode(assignedValue));
        }
      });
    });
  }
};

/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ChildNodeNativeMethods} builtIn
 */
var PatchChildNode = function (internals, destination, builtIn) {
  /**
   * @param {...(!Node|string)} nodes
   */
  destination['before'] = function () {
    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.before.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i = 0; _i < nodes.length; _i++) {
        var node = nodes[_i];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['after'] = function () {
    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      nodes[_key2] = arguments[_key2];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.after.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var node = nodes[_i2];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['replaceWith'] = function () {
    for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      nodes[_key3] = arguments[_key3];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    var wasConnected = isConnected(this);

    builtIn.replaceWith.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (wasConnected) {
      internals.disconnectTree(this);
      for (var _i3 = 0; _i3 < nodes.length; _i3++) {
        var node = nodes[_i3];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  destination['remove'] = function () {
    var wasConnected = isConnected(this);

    builtIn.remove.call(this);

    if (wasConnected) {
      internals.disconnectTree(this);
    }
  };
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchElement = function (internals) {
  if (Native.Element_attachShadow) {
    setPropertyUnchecked(Element.prototype, 'attachShadow',
    /**
     * @this {Element}
     * @param {!{mode: string}} init
     * @return {ShadowRoot}
     */
    function (init) {
      var shadowRoot = Native.Element_attachShadow.call(this, init);
      this.__CE_shadowRoot = shadowRoot;
      return shadowRoot;
    });
  } else {
    console.warn('Custom Elements: `Element#attachShadow` was not patched.');
  }

  function patch_innerHTML(destination, baseDescriptor) {
    Object.defineProperty(destination, 'innerHTML', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set: /** @this {Element} */function set(htmlString) {
        var _this = this;

        var isConnected$$1 = isConnected(this);

        // NOTE: In IE11, when using the native `innerHTML` setter, all nodes
        // that were previously descendants of the context element have all of
        // their children removed as part of the set - the entire subtree is
        // 'disassembled'. This work around walks the subtree *before* using the
        // native setter.
        /** @type {!Array<!Element>|undefined} */
        var removedElements = undefined;
        if (isConnected$$1) {
          removedElements = [];
          walkDeepDescendantElements(this, function (element) {
            if (element !== _this) {
              removedElements.push(element);
            }
          });
        }

        baseDescriptor.set.call(this, htmlString);

        if (removedElements) {
          for (var i = 0; i < removedElements.length; i++) {
            var element = removedElements[i];
            if (element.__CE_state === CustomElementState.custom) {
              internals.disconnectedCallback(element);
            }
          }
        }

        // Only create custom elements if this element's owner document is
        // associated with the registry.
        if (!this.ownerDocument.__CE_hasRegistry) {
          internals.patchTree(this);
        } else {
          internals.patchAndUpgradeTree(this);
        }
        return htmlString;
      }
    });
  }

  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {
    patch_innerHTML(Element.prototype, Native.Element_innerHTML);
  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {
    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);
  } else {

    /** @type {HTMLDivElement} */
    var rawDiv = Native.Document_createElement.call(document, 'div');

    internals.addPatch(function (element) {
      patch_innerHTML(element, {
        enumerable: true,
        configurable: true,
        // Implements getting `innerHTML` by performing an unpatched `cloneNode`
        // of the element and returning the resulting element's `innerHTML`.
        // TODO: Is this too expensive?
        get: /** @this {Element} */function get() {
          return Native.Node_cloneNode.call(this, true).innerHTML;
        },
        // Implements setting `innerHTML` by creating an unpatched element,
        // setting `innerHTML` of that element and replacing the target
        // element's children with those of the unpatched element.
        set: /** @this {Element} */function set(assignedValue) {
          // NOTE: re-route to `content` for `template` elements.
          // We need to do this because `template.appendChild` does not
          // route into `template.content`.
          /** @type {!Node} */
          var content = this.localName === 'template' ? /** @type {!HTMLTemplateElement} */this.content : this;
          rawDiv.innerHTML = assignedValue;

          while (content.childNodes.length > 0) {
            Native.Node_removeChild.call(content, content.childNodes[0]);
          }
          while (rawDiv.childNodes.length > 0) {
            Native.Node_appendChild.call(content, rawDiv.childNodes[0]);
          }
        }
      });
    });
  }

  setPropertyUnchecked(Element.prototype, 'setAttribute',
  /**
   * @this {Element}
   * @param {string} name
   * @param {string} newValue
   */
  function (name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_setAttribute.call(this, name, newValue);
    }

    var oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_setAttribute.call(this, name, newValue);
    newValue = Native.Element_getAttribute.call(this, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, null);
  });

  setPropertyUnchecked(Element.prototype, 'setAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   * @param {string} newValue
   */
  function (namespace, name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    }

    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    newValue = Native.Element_getAttributeNS.call(this, namespace, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
  });

  setPropertyUnchecked(Element.prototype, 'removeAttribute',
  /**
   * @this {Element}
   * @param {string} name
   */
  function (name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_removeAttribute.call(this, name);
    }

    var oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_removeAttribute.call(this, name);
    if (oldValue !== null) {
      internals.attributeChangedCallback(this, name, oldValue, null, null);
    }
  });

  setPropertyUnchecked(Element.prototype, 'removeAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   */
  function (namespace, name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_removeAttributeNS.call(this, namespace, name);
    }

    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_removeAttributeNS.call(this, namespace, name);
    // In older browsers, `Element#getAttributeNS` may return the empty string
    // instead of null if the attribute does not exist. For details, see;
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes
    var newValue = Native.Element_getAttributeNS.call(this, namespace, name);
    if (oldValue !== newValue) {
      internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
    }
  });

  function patch_insertAdjacentElement(destination, baseMethod) {
    setPropertyUnchecked(destination, 'insertAdjacentElement',
    /**
     * @this {Element}
     * @param {string} where
     * @param {!Element} element
     * @return {?Element}
     */
    function (where, element) {
      var wasConnected = isConnected(element);
      var insertedElement = /** @type {!Element} */
      baseMethod.call(this, where, element);

      if (wasConnected) {
        internals.disconnectTree(element);
      }

      if (isConnected(insertedElement)) {
        internals.connectTree(element);
      }
      return insertedElement;
    });
  }

  if (Native.HTMLElement_insertAdjacentElement) {
    patch_insertAdjacentElement(HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);
  } else if (Native.Element_insertAdjacentElement) {
    patch_insertAdjacentElement(Element.prototype, Native.Element_insertAdjacentElement);
  } else {
    console.warn('Custom Elements: `Element#insertAdjacentElement` was not patched.');
  }

  PatchParentNode(internals, Element.prototype, {
    prepend: Native.Element_prepend,
    append: Native.Element_append
  });

  PatchChildNode(internals, Element.prototype, {
    before: Native.Element_before,
    after: Native.Element_after,
    replaceWith: Native.Element_replaceWith,
    remove: Native.Element_remove
  });
};

/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

var priorCustomElements = window['customElements'];

if (!priorCustomElements || priorCustomElements['forcePolyfill'] || typeof priorCustomElements['define'] != 'function' || typeof priorCustomElements['get'] != 'function') {
  /** @type {!CustomElementInternals} */
  var internals = new CustomElementInternals();

  PatchHTMLElement(internals);
  PatchDocument(internals);
  PatchNode(internals);
  PatchElement(internals);

  // The main document is always associated with the registry.
  document.__CE_hasRegistry = true;

  /** @type {!CustomElementRegistry} */
  var customElements$1 = new CustomElementRegistry(internals);

  Object.defineProperty(window, 'customElements', {
    configurable: true,
    enumerable: true,
    value: customElements$1
  });
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22

(function (global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function (e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function (func) {
          func();
        });
      }
    });
    setImmediate = function setImmediate(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function (o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function (observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function (node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function (registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function observe(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function disconnect() {
      this.nodes_.forEach(function (node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function takeRecords() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function enqueue(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function addListeners() {
      this.addListeners_(this.target);
    },
    addListeners_: function addListeners_(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function removeListeners() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function removeListeners_(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function addTransientObserver(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function removeTransientObservers() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function (node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function handleEvent(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
        case "DOMAttrModified":
          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;
          var record = new getRecord("attributes", target);
          record.attributeName = name;
          record.attributeNamespace = namespace;
          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
            if (!options.attributes) return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;

        case "DOMCharacterDataModified":
          var target = e.target;
          var record = getRecord("characterData", target);
          var oldValue = e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
            if (!options.characterData) return;
            if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;

        case "DOMNodeRemoved":
          this.addTransientObserver(e.target);

        case "DOMNodeInserted":
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === "DOMNodeInserted") {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          var record = getRecord("childList", e.target.parentNode);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function (options) {
            if (!options.childList) return;
            return record;
          });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function () {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                new Function("" + handler)();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(self);

// Caution:
// Do not replace this import statement with codes.
//
// If you replace this import statement with codes,
// the codes will be executed after the following polyfills are imported
// because import statements are hoisted during compilation.
// Polyfill ECMAScript standard features with global namespace pollution
// Polyfill Custom Elements v1 with global namespace pollution
// Polyfill MutationObserver with global namespace pollution
// Polyfill setImmediate with global namespace pollution

(function () {
  var DEFAULT_VIEWPORT = 'width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no';

  var Viewport = {
    ensureViewportElement: function ensureViewportElement() {
      var viewportElement = document.querySelector('meta[name=viewport]');

      if (!viewportElement) {
        viewportElement = document.createElement('meta');
        viewportElement.name = 'viewport';
        document.head.appendChild(viewportElement);
      }

      return viewportElement;
    },

    setup: function setup() {
      var viewportElement = Viewport.ensureViewportElement();

      if (!viewportElement) {
        return;
      }

      if (!viewportElement.hasAttribute('content')) {
        viewportElement.setAttribute('content', DEFAULT_VIEWPORT);
      }
    }
  };

  window.Viewport = Viewport;
})();

function setup$1(ons) {
  if (window._onsLoaded) {
    ons._util.warn('Onsen UI is loaded more than once.');
  }
  window._onsLoaded = true;

  // fastclick
  window.addEventListener('load', function () {
    ons.fastClick = fastclick_1.attach(document.body);

    var supportTouchAction = 'touch-action' in document.body.style;

    ons.platform._runOnActualPlatform(function () {
      if (ons.platform.isAndroid()) {
        // In Android4.4+, correct viewport settings can remove click delay.
        // So disable FastClick on Android.
        ons.fastClick.destroy();
      } else if (ons.platform.isIOS()) {
        if (supportTouchAction && (ons.platform.isIOSSafari() || ons.platform.isWKWebView())) {
          // If 'touch-action' supported in iOS Safari or WKWebView, disable FastClick.
          ons.fastClick.destroy();
        } else {
          // Do nothing. 'touch-action: manipulation' has no effect on UIWebView.
        }
      }
    });
  }, false);

  ons.ready(function () {
    ons.enableDeviceBackButtonHandler();
    ons._defaultDeviceBackButtonHandler = ons._internal.dbbDispatcher.createHandler(window.document.body, function () {
      if (Object.hasOwnProperty.call(navigator, 'app')) {
        navigator.app.exitApp();
      } else {
        console.warn('Could not close the app. Is \'cordova.js\' included?\nError: \'window.navigator.app\' is undefined.');
      }
    });
    document.body._gestureDetector = new ons.GestureDetector(document.body, { passive: true });

    // Simulate Device Back Button on ESC press
    if (!ons.platform.isWebView()) {
      document.body.addEventListener('keydown', function (event) {
        if (event.keyCode === 27) {
          ons.fireDeviceBackButtonEvent();
        }
      });
    }

    // setup loading placeholder
    ons._setupLoadingPlaceHolders();
  });

  // viewport.js
  Viewport.setup();
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

function getElementClass() {
  if (typeof HTMLElement !== 'function') {
    // case of Safari
    var _BaseElement = function _BaseElement() {};
    _BaseElement.prototype = document.createElement('div');
    return _BaseElement;
  } else {
    return HTMLElement;
  }
}

var BaseElement = function (_getElementClass) {
  inherits(BaseElement, _getElementClass);

  function BaseElement() {
    classCallCheck(this, BaseElement);
    return possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this));
  }

  return BaseElement;
}(getElementClass());

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-template
 * @category util
 * @description
 *   [en]
 *     Define a separate HTML fragment and use as a template. These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs. Since Onsen UI 2.4.0, the native `<template>` element can be used instead of `<ons-template>` for better performance and features. `<ons-template>` is still supported for backward compatibility.
 *   [/en]
 *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
 * @seealso ons-navigator
 *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-tabbar
 *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-splitter
 *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
 *   [ja][/ja]
 * @example
 * <ons-template id="foobar.html">
 *   <ons-page>
 *     Page content
 *   </ons-page>
 * </ons-template>
 *
 * <ons-navigator page="foobar.html"></ons-navigator>
 */

var TemplateElement = function (_BaseElement) {
  inherits(TemplateElement, _BaseElement);

  /**
   * @property template
   * @type {String}
   * @description
   *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
   *  [ja][/ja]
   */

  function TemplateElement() {
    classCallCheck(this, TemplateElement);

    var _this = possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).call(this));

    _this.template = _this.innerHTML;

    while (_this.firstChild) {
      _this.removeChild(_this.firstChild);
    }
    return _this;
  }

  createClass(TemplateElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (this.parentNode) {
        // Note: this.parentNode is not set in some CE0/CE1 polyfills.
        // Show warning when the ons-template is not located just under document.body
        if (this.parentNode !== document.body) {
          // if the parent is not document.body
          util$1.warn('ons-template (id = ' + this.getAttribute('id') + ') must be located just under document.body' + (this.parentNode.outerHTML ? ':\n\n' + this.parentNode.outerHTML : '.'));
        }
      }

      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
      event.template = this.template;
      event.templateId = this.getAttribute('id');

      this.dispatchEvent(event);
    }
  }]);
  return TemplateElement;
}(BaseElement);

onsElements.Template = TemplateElement;
customElements.define('ons-template', TemplateElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-if
 * @category conditional
 * @tutorial vanilla/Reference/if
 * @description
 *   [en]
 *     Conditionally display content depending on the platform, device orientation or both.
 *
 *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
 *   [/en]
 *   [ja][/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-page>
 *   <ons-if orientation="landscape">
 *     Landscape view!
 *   </ons-if>
 *   <ons-if platform="android">
 *     This is Android.
 *   </ons-if>
 *   <ons-if platform="ios other">
 *     This is not Android.
 *   </ons-if>
 * </ons-page>
 */

var IfElement = function (_BaseElement) {
  inherits(IfElement, _BaseElement);

  /**
   * @attribute platform
   * @initonly
   * @type {string}
   * @description
   *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute orientation
   * @type {string}
   * @description
   *  [en]Either `"portrait"` or `"landscape"`.[/en]
   *  [ja]portraitもしくはlandscapeを指定します[/ja]
   */

  function IfElement() {
    classCallCheck(this, IfElement);

    var _this = possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).call(this));

    contentReady(_this, function () {
      if (platform._getSelectedPlatform() !== null) {
        _this._platformUpdate();
      } else if (!_this._isAllowedPlatform()) {
        while (_this.childNodes[0]) {
          _this.childNodes[0].remove();
        }
        _this._platformUpdate();
      }
    });

    _this._onOrientationChange();
    return _this;
  }

  createClass(IfElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      orientation.on('change', this._onOrientationChange.bind(this));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name) {
      if (name === 'orientation') {
        this._onOrientationChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      orientation.off('change', this._onOrientationChange);
    }
  }, {
    key: '_platformUpdate',
    value: function _platformUpdate() {
      this.style.display = this._isAllowedPlatform() ? '' : 'none';
    }
  }, {
    key: '_isAllowedPlatform',
    value: function _isAllowedPlatform() {
      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
    }
  }, {
    key: '_onOrientationChange',
    value: function _onOrientationChange() {
      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['orientation'];
    }
  }]);
  return IfElement;
}(BaseElement);

onsElements.If = IfElement;
customElements.define('ons-if', IfElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function BaseAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, BaseAnimator);

    this.timing = options.timing || 'linear';
    this.duration = options.duration || 0;
    this.delay = options.delay || 0;

    this.def = {
      timing: this.timing,
      duration: this.duration,
      delay: this.delay
    };
  }

  createClass(BaseAnimator, null, [{
    key: 'extend',
    value: function extend() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var extendedAnimator = this;
      var newAnimator = function newAnimator() {
        extendedAnimator.apply(this, arguments);
        util$1.extend(this, properties);
      };

      newAnimator.prototype = this.prototype;
      return newAnimator;
    }
  }]);
  return BaseAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// This object should not be exposed to users. Please keep this private.
var iPhoneXPatch = {};

iPhoneXPatch.isIPhoneXPortraitPatchActive = function () {
  return document.documentElement.getAttribute('onsflag-iphonex-portrait') != null && window.innerWidth < window.innerHeight;
};

iPhoneXPatch.isIPhoneXLandscapePatchActive = function () {
  // If width === height, treat it as landscape
  return document.documentElement.getAttribute('onsflag-iphonex-landscape') != null && window.innerWidth >= window.innerHeight;
};

/**
 * Returns the safe area lengths based on the current state of the safe areas.
 */
iPhoneXPatch.getSafeAreaLengths = function () {
  var safeAreaLengths = void 0;
  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
    safeAreaLengths = {
      top: 44,
      right: 0,
      bottom: 34,
      left: 0
    };
  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
    safeAreaLengths = {
      top: 0,
      right: 44,
      bottom: 21,
      left: 44
    };
  } else {
    safeAreaLengths = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  return safeAreaLengths;
};

/**
 * Returns the safe area rect based on the current state of the safe areas.
 */
iPhoneXPatch.getSafeAreaDOMRect = function () {
  var safeAreaRect = void 0;
  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
    safeAreaRect = {
      x: 0,
      y: 44, /* 0 + 44 (top safe area) */
      width: window.innerWidth,
      height: window.innerHeight - 78 /* height - 44 (top safe area) - 34 (bottom safe area) */
    };
  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
    safeAreaRect = {
      x: 44, /* 0 + 44 (left safe area) */
      y: 0,
      width: window.innerWidth - 88, /* width - 44 (left safe area) - 34 (right safe area) */
      height: window.innerHeight - 21 /* height - 21 (bottom safe area) */
    };
  } else {
    safeAreaRect = {
      x: 0,
      y: 0,
      width: window.innerWidth,
      height: window.innerHeight
    };
  }

  return _extends({}, safeAreaRect, {
    left: safeAreaRect.x,
    top: safeAreaRect.y,
    right: safeAreaRect.x + safeAreaRect.width,
    bottom: safeAreaRect.y + safeAreaRect.height
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ActionSheetAnimator = function (_BaseAnimator) {
  inherits(ActionSheetAnimator, _BaseAnimator);

  function ActionSheetAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ActionSheetAnimator);
    return possibleConstructorReturn(this, (ActionSheetAnimator.__proto__ || Object.getPrototypeOf(ActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(ActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return ActionSheetAnimator;
}(BaseAnimator);

/**
 * Android style animator for Action Sheet.
 */
var MDActionSheetAnimator = function (_ActionSheetAnimator) {
  inherits(MDActionSheetAnimator, _ActionSheetAnimator);

  function MDActionSheetAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.4 : _ref2$duration;

    classCallCheck(this, MDActionSheetAnimator);

    var _this2 = possibleConstructorReturn(this, (MDActionSheetAnimator.__proto__ || Object.getPrototypeOf(MDActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this2.maskTiming = 'linear';
    _this2.maskDuration = 0.2;
    return _this2;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(MDActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {

      Animit.runAll(Animit(dialog._mask).queue({ opacity: 0 }).wait(this.delay).queue({ opacity: 1.0 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 80%, 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({ opacity: 1 }).wait(this.delay).queue({ opacity: 0 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, 80%, 0)', opacity: 0 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }]);
  return MDActionSheetAnimator;
}(ActionSheetAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSActionSheetAnimator = function (_ActionSheetAnimator2) {
  inherits(IOSActionSheetAnimator, _ActionSheetAnimator2);

  function IOSActionSheetAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;

    classCallCheck(this, IOSActionSheetAnimator);

    var _this3 = possibleConstructorReturn(this, (IOSActionSheetAnimator.__proto__ || Object.getPrototypeOf(IOSActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this3.maskTiming = 'linear';
    _this3.maskDuration = 0.2;
    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this3.liftAmount = 'calc(100% + 48px)';
    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
      _this3.liftAmount = 'calc(100% + 33px)';
    } else {
      _this3.liftAmount = document.body.clientHeight / 2.0 - 1 + 'px'; // avoid Forced Synchronous Layout
    }
    return _this3;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({ opacity: 0 }).wait(this.delay).queue({ opacity: 1 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, ' + this.liftAmount + ', 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({ opacity: 1 }).wait(this.delay).queue({ opacity: 0 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, ' + this.liftAmount + ', 0)' }).queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }]);
  return IOSActionSheetAnimator;
}(ActionSheetAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseDialogElement = function (_BaseElement) {
  inherits(BaseDialogElement, _BaseElement);
  createClass(BaseDialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      util$1.throwMember();
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      this.style.display = shouldShow ? 'block' : 'none';
    }
  }, {
    key: '_scheme',
    get: function get$$1() {
      util$1.throwMember();
    }
  }]);

  function BaseDialogElement() {
    classCallCheck(this, BaseDialogElement);

    var _this = possibleConstructorReturn(this, (BaseDialogElement.__proto__ || Object.getPrototypeOf(BaseDialogElement)).call(this));

    if (_this.constructor === BaseDialogElement) {
      util$1.throwAbstract();
    }

    _this._visible = false;
    _this._doorLock = new DoorLock();
    _this._cancel = _this._cancel.bind(_this);
    _this._selfCamelName = util$1.camelize(_this.tagName.slice(4));
    _this._defaultDBB = function (e) {
      return _this.cancelable ? _this._cancel() : e.callParentHandler();
    };
    _this._animatorFactory = _this._updateAnimatorFactory();
    return _this;
  }

  createClass(BaseDialogElement, [{
    key: '_cancel',
    value: function _cancel() {
      var _this2 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this2._running = false;
          util$1.triggerElementEvent(_this2, 'dialog-cancel');
        }, function () {
          return _this2._running = false;
        });
      }
    }
  }, {
    key: 'show',
    value: function show() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this._setVisible.apply(this, [true].concat(args));
    }
  }, {
    key: 'hide',
    value: function hide() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this._setVisible.apply(this, [false].concat(args));
    }
  }, {
    key: 'toggle',
    value: function toggle() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this._setVisible.apply(this, [!this.visible].concat(args));
    }
  }, {
    key: '_setVisible',
    value: function _setVisible(shouldShow) {
      var _util$triggerElementE,
          _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var action = shouldShow ? 'show' : 'hide';

      options = _extends({}, options);
      options.animationOptions = util$1.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var canceled = false;
      util$1.triggerElementEvent(this, 'pre' + action, (_util$triggerElementE = {}, defineProperty(_util$triggerElementE, this._selfCamelName, this), defineProperty(_util$triggerElementE, 'cancel', function cancel() {
        return canceled = true;
      }), _util$triggerElementE));

      if (canceled) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      return new Promise(function (resolve) {
        _this3._doorLock.waitUnlock(function () {
          var unlock = _this3._doorLock.lock();
          var animator = _this3._animatorFactory.newAnimator(options);

          shouldShow && _this3._toggleStyle(true, options);
          _this3._visible = shouldShow;
          util$1.iosPageScrollFix(shouldShow);

          contentReady(_this3, function () {
            animator[action](_this3, function () {
              !shouldShow && _this3._toggleStyle(false, options);

              unlock();

              util$1.propagateAction(_this3, '_' + action);
              util$1.triggerElementEvent(_this3, 'post' + action, defineProperty({}, _this3._selfCamelName, _this3)); // postshow posthide

              if (options.callback instanceof Function) {
                options.callback(_this3);
              }

              resolve(_this3);
            });
          });
        });
      });
    }
  }, {
    key: '_updateMask',
    value: function _updateMask() {
      var _this4 = this;

      contentReady(this, function () {
        if (_this4._mask && _this4.getAttribute('mask-color')) {
          _this4._mask.style.backgroundColor = _this4.getAttribute('mask-color');
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this5 = this;

      this.onDeviceBackButton = this._defaultDBB.bind(this);

      contentReady(this, function () {
        if (_this5._mask) {
          _this5._mask.addEventListener('click', _this5._cancel, false);
          util$1.iosMaskScrollFix(_this5._mask, true);
        }
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      if (this._mask) {
        this._mask.removeEventListener('click', this._cancel, false);
        util$1.iosMaskScrollFix(this._mask, false);
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, this._scheme);
          break;
        case 'animation':
          this._animatorFactory = this._updateAnimatorFactory();
          break;
        case 'mask-color':
          this._updateMask();
          break;
      }
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      return this._visible;
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: 'cancelable',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'cancelable', value);
    },
    get: function get$$1() {
      return this.hasAttribute('cancelable');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'animation', 'mask-color'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];
    }
  }]);
  return BaseDialogElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme = {
  '.action-sheet': 'action-sheet--*',
  '.action-sheet-mask': 'action-sheet-mask--*',
  '.action-sheet-title': 'action-sheet-title--*'
};

var _animatorDict = {
  'default': function _default() {
    return platform.isAndroid() ? MDActionSheetAnimator : IOSActionSheetAnimator;
  },
  'none': ActionSheetAnimator
};

/**
 * @element ons-action-sheet
 * @category dialog
 * @description
 *   [en]
 *     Action/bottom sheet that is displayed on top of current screen.
 *
 *     This element can either be attached directly to the `<body>` or dynamically created from a template using the `ons.createElement(template, { append: true })` utility function and the `<template>` tag.
 *
 *     The action sheet is useful for displaying a list of options and asking the user to make a decision. A `ons-action-sheet-button` is provided for this purpose, although it can contain any type of content.
 *
 *     It will automatically be displayed as Material Design (bottom sheet) when running on an Android device.
 *   [/en]
 *   [ja]
 *     アクションシート、もしくはボトムシートを現在のスクリーン上に表示します。
 *
 *     この要素は、`<body>`要素に直接アタッチされるか、もしくは`ons.createElement(template, { append: true })`と`<template>`タグを使ってテンプレートから動的に生成されます。
 *
 *     アクションシートは、選択肢のリストを表示してユーザーに尋ねるのに便利です。`ons-action-sheet-button`は、この要素の中に置くために提供されていますが、それ以外にも他のどのような要素を含むことができます。
 *
 *     Androidデバイスで実行されるときには、自動的にマテリアルデザイン(ボトムシート)として表示されます。
 *   [/ja]
 * @modifier material
 *   [en]Display a Material Design bottom sheet.[/en]
 *   [ja]マテリアルデザインのボトムシートを表示します。[/ja]
 * @tutorial vanilla/reference/action-sheet
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-action-sheet id="sheet">
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 * </ons-action-sheet>
 *
 * <script>
 *   document.getElementById('sheet').show();
 * </script>
 */

var ActionSheetElement = function (_BaseDialogElement) {
  inherits(ActionSheetElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the action sheet is displayed.[/en]
   * [ja]ダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the action sheet from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the action sheet is displayed.[/en]
   * [ja]ダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the action sheet is hidden.[/en]
   * [ja]ダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the action sheet from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the action sheet is hidden.[/en]
   * [ja]ダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute title
   * @type {String}
   * @description
   *  [en]Optional title of the action sheet. A new element will be created containing this string.[/en]
   *  [ja]アクションシートのタイトルを指定します。ここで指定した文字列を含む新しい要素が作成されます。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the action sheet.[/en]
   *  [ja]ダイアログの表現を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja]この属性が設定されると、アクションシートの背景やAndroidデバイスのバックボタンを推すことでアクションシートが閉じるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the action sheet is disabled.[/en]
   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the action sheet. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function ActionSheetElement() {
    classCallCheck(this, ActionSheetElement);

    var _this = possibleConstructorReturn(this, (ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ActionSheetElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict,
        baseClass: ActionSheetAnimator,
        baseClassName: 'ActionSheetAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-action-sheet>
       *     <div class="action-sheet-mask"></div>
       *     <div class="action-sheet">
       *       <div class="action-sheet-title></div>
       *       ...
       *     </div>
       *   </ons-action-sheet>
       */

      if (!this._sheet) {
        var sheet = document.createElement('div');
        sheet.classList.add('action-sheet');

        while (this.firstChild) {
          sheet.appendChild(this.firstChild);
        }

        this.appendChild(sheet);
      }

      if (!this._title && this.hasAttribute('title')) {
        var title = document.createElement('div');
        title.innerHTML = this.getAttribute('title');
        title.classList.add('action-sheet-title');
        this._sheet.insertBefore(title, this._sheet.firstChild);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('action-sheet-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._sheet.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateTitle',
    value: function _updateTitle() {
      if (this._title) {
        this._title.innerHTML = this.getAttribute('title');
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the action sheet has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the action sheet.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the action sheet has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the action sheet.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja]隠れた要素を解決します。[/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is cancelable or not. A cancelable action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja]アクションシートがキャンセル可能かどうかを設定します。キャンセル可能なアクションシートは、背景をタップしたりAndroidデバイスのバックボタンを推すことで閉じるようになります。[/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'title') {
        this._updateTitle();
      } else {
        get(ActionSheetElement.prototype.__proto__ || Object.getPrototypeOf(ActionSheetElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @param {String} name
     * @param {ActionSheetAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.action-sheet-mask');
    }
  }, {
    key: '_sheet',
    get: function get$$1() {
      return util$1.findChild(this, '.action-sheet');
    }
  }, {
    key: '_title',
    get: function get$$1() {
      return this.querySelector('.action-sheet-title');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ActionSheetAnimator)) {
        util$1.throwAnimator('ActionSheet');
      }
      _animatorDict[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement), 'observedAttributes', this)), ['title']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict;
    }
  }, {
    key: 'ActionSheetAnimator',
    get: function get$$1() {
      return ActionSheetAnimator;
    }
  }]);
  return ActionSheetElement;
}(BaseDialogElement);

onsElements.ActionSheet = ActionSheetElement;
customElements.define('ons-action-sheet', ActionSheetElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseButtonElement = function (_BaseElement) {
  inherits(BaseButtonElement, _BaseElement);
  createClass(BaseButtonElement, [{
    key: '_scheme',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return [this];
    }
  }]);

  function BaseButtonElement() {
    classCallCheck(this, BaseButtonElement);

    var _this = possibleConstructorReturn(this, (BaseButtonElement.__proto__ || Object.getPrototypeOf(BaseButtonElement)).call(this));

    if (_this.constructor === BaseButtonElement) {
      util$1.throwAbstract();
    }

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(BaseButtonElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(this._defaultClassName);

      if (!this._icon && this.hasAttribute('icon')) {
        util$1.checkMissingImport('Icon');
        var icon = util$1.createElement('<ons-icon icon="' + this.getAttribute('icon') + '"></ons-icon>');
        icon.classList.add(this._defaultClassName.replace('button', 'icon'));
        this.insertBefore(icon, this.firstChild);
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateIcon',
    value: function _updateIcon() {
      if (this._icon) {
        this._icon.setAttribute('icon', this.getAttribute('icon'));
      }
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      this._rippleOpt && util$1.updateRipple.apply(util$1, toConsumableArray(this._rippleOpt));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, this._defaultClassName, this._scheme);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, this._scheme);
          break;
        case 'icon':
          this._updateIcon();
          break;
        case 'ripple':
          this.classList.contains(this._defaultClassName) && this._updateRipple();
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: '_icon',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-icon');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class', 'icon', 'ripple'];
    }
  }]);
  return BaseButtonElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-action-sheet-button
 * @category dialog
 * @modifier destructive
 *   [en]Shows a "destructive" button (only for iOS).[/en]
 *   [ja]"destructive"なボタンを表示します(iOSでのみ有効)。[/ja]
 * @description
 *   [en]Component that represent each button of the action sheet.[/en]
 *   [ja]アクションシートに表示される各ボタンを表現するコンポーネントです。[/ja]
 * @seealso ons-action-sheet
 *   [en]The `<ons-action-sheet>` component[/en]
 *   [ja]ons-action-sheetコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]The `<ons-icon>` component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @tutorial vanilla/Reference/action-sheet
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @modifier material
 *   [en]Display a Material Design action sheet button.[/en]
 *   [ja]マテリアルデザインのアクションシート用のボタンを表示します。[/ja]
 * @example
 * <ons-action-sheet id="sheet">
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 * </ons-action-sheet>
 *
 * <script>
 *   document.getElementById('sheet').show();
 * </script>
 */

var ActionSheetButtonElement = function (_BaseButtonElement) {
  inherits(ActionSheetButtonElement, _BaseButtonElement);

  function ActionSheetButtonElement() {
    classCallCheck(this, ActionSheetButtonElement);
    return possibleConstructorReturn(this, (ActionSheetButtonElement.__proto__ || Object.getPrototypeOf(ActionSheetButtonElement)).apply(this, arguments));
  }

  createClass(ActionSheetButtonElement, [{
    key: '_scheme',


    /**
     * @attribute icon
     * @type {String}
     * @description
     *  [en]Creates an `ons-icon` component with this string. Only visible on Android. Check [See also](#seealso) section for more information.[/en]
     *  [ja]`ons-icon`コンポーネントを悪性します。Androidでのみ表示されます。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the action sheet button.[/en]
     *   [ja]アクションシートボタンの見た目を設定します。[/ja]
     */

    get: function get$$1() {
      return {
        '': 'action-sheet-button--*',
        '.action-sheet-icon': 'action-sheet-icon--*'
      };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'action-sheet-button';
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return undefined;
    }
  }]);
  return ActionSheetButtonElement;
}(BaseButtonElement);

onsElements.ActionSheetButton = ActionSheetButtonElement;
customElements.define('ons-action-sheet-button', ActionSheetButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AlertDialogAnimator = function (_BaseAnimator) {
  inherits(AlertDialogAnimator, _BaseAnimator);

  function AlertDialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, AlertDialogAnimator);
    return possibleConstructorReturn(this, (AlertDialogAnimator.__proto__ || Object.getPrototypeOf(AlertDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(AlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return AlertDialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for alert dialog.
 */
var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

  function AndroidAlertDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, AndroidAlertDialogAnimator);
    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)', opacity: 0 }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidAlertDialogAnimator;
}(AlertDialogAnimator);

/**
 * iOS style animator for alert dialog.
 */
var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

  function IOSAlertDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay;

    classCallCheck(this, IOSAlertDialogAnimator);
    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /*
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSAlertDialogAnimator;
}(AlertDialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$1 = {
  '.alert-dialog': 'alert-dialog--*',
  '.alert-dialog-container': 'alert-dialog-container--*',
  '.alert-dialog-title': 'alert-dialog-title--*',
  '.alert-dialog-content': 'alert-dialog-content--*',
  '.alert-dialog-footer': 'alert-dialog-footer--*',
  '.alert-dialog-footer--rowfooter': 'alert-dialog-footer--rowfooter--*',
  '.alert-dialog-button--rowfooter': 'alert-dialog-button--rowfooter--*',
  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
  '.alert-dialog-button': 'alert-dialog-button--*',
  'ons-alert-dialog-button': 'alert-dialog-button--*',
  '.alert-dialog-mask': 'alert-dialog-mask--*',
  '.text-input': 'text-input--*'
};

var _animatorDict$1 = {
  'none': AlertDialogAnimator,
  'default': function _default() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  }
};

/**
 * @element ons-alert-dialog
 * @category dialog
 * @description
 *   [en]
 *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<template>` tag.
 *   [/en]
 *   [ja]
 *     現在のスクリーンの上に表示するアラートダイアログです。ユーザに対する問いかけ、警告、エラーメッセージを表示するのに利用できます。タイトルやコンテンツやボタンは簡単にカスタマイズでき、実行しているプラットフォームに併せてスタイルが自動的に切り替わります。
 *   [/ja]
 * @codepen Qwwxyp
 * @tutorial vanilla/Reference/alert-dialog
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja]マテリアルデザインのスタイル[/ja]
 * @modifier rowfooter
 *   [en]Horizontally aligns the footer buttons.[/en]
 *   [ja]フッターの複数のボタンを水平に配置[/ja]
 * @seealso ons-dialog
 *   [en]ons-dialog component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]ons-popover component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons.notification
 *   [en]Using ons.notification utility functions.[/en]
 *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
 * @example
 * <ons-alert-dialog id="alert-dialog">
 *   <div class="alert-dialog-title">Warning!</div>
 *   <div class="alert-dialog-content">
 *     An error has occurred!
 *   </div>
 *   <div class="alert-dialog-footer">
 *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
 *   </div>
 * </ons-alert-dialog>
 * <script>
 *   document.getElementById('alert-dialog').show();
 * </script>
 */

var AlertDialogElement = function (_BaseDialogElement) {
  inherits(AlertDialogElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   *   [en]Fired just before the alert dialog is displayed.[/en]
   *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute to stop the dialog from showing.[/en]
   *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
   */

  /**
   * @event postshow
   * @description
   *   [en]Fired just after the alert dialog is displayed.[/en]
   *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   *   [en]Fired just before the alert dialog is hidden.[/en]
   *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute to stop the dialog from hiding.[/en]
   *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the alert dialog is hidden.[/en]
   * [ja]アラートダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the dialog.[/en]
   *  [ja]ダイアログの見た目を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja]この属性を設定すると、ダイアログの背景をタップしたりAndroidデバイスのバックボタンを押すとダイアログが閉じるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the dialog is disabled.[/en]
   *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function AlertDialogElement() {
    classCallCheck(this, AlertDialogElement);

    var _this = possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(AlertDialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$1,
        baseClass: AlertDialogAnimator,
        baseClassName: 'AlertDialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /**
       * Expected result after compile:
       *
       * <ons-alert-dialog style="none">
       *   <div class="alert-dialog-mask"></div>
       *   <div class="alert-dialog">
       *     <div class="alert-dialog-container">...</div>
       *   </div>
       * </ons-alert-dialog>
       */

      var content = document.createDocumentFragment();

      if (!this._mask && !this._dialog) {
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('alert-dialog-mask');
        this.insertBefore(mask, this.children[0]);
      }

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('alert-dialog');
        this.insertBefore(dialog, null);
      }

      if (!util$1.findChild(this._dialog, '.alert-dialog-container')) {
        var container = document.createElement('div');
        container.classList.add('alert-dialog-container');
        this._dialog.appendChild(container);
      }

      this._dialog.children[0].appendChild(content);

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja]そのダイアログがキャンセル可能かどうかを表します。キャンセル可能なダイアログは、背景をタップするかAndroidデバイスのバックボタンを押すことで閉じることが出来るようになります。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクトです。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。指定できるのは、"fade", "none"のいずれかです。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Show the alert dialog.[/en]
     *   [ja]ダイアログを表示します。[/ja]
     * @return {Promise}
     *   [en]A `Promise` object that resolves to the displayed element.[/en]
     *   [ja]表示される要素を解決する`Promise`オブジェクトを返します。[/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。"fade", "none"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been hidden.[/en]
     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Hide the alert dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja]隠れた要素を解決する`Promise`オブジェクトを返します。[/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$1;
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.alert-dialog-mask');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_dialog',
    get: function get$$1() {
      return util$1.findChild(this, '.alert-dialog');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_titleElement',
    get: function get$$1() {
      return util$1.findChild(this._dialog.children[0], '.alert-dialog-title');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_contentElement',
    get: function get$$1() {
      return util$1.findChild(this._dialog.children[0], '.alert-dialog-content');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof AlertDialogAnimator)) {
        util$1.throwAnimator('AlertDialog');
      }
      _animatorDict$1[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$1;
    }
  }, {
    key: 'AlertDialogAnimator',
    get: function get$$1() {
      return AlertDialogAnimator;
    }
  }]);
  return AlertDialogElement;
}(BaseDialogElement);

onsElements.AlertDialog = AlertDialogElement;
customElements.define('ons-alert-dialog', AlertDialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-alert-dialog-button
 * @modifier material
 *   [en]Material Design alert-dialog button.[/en]
 *   [ja]マテリアルデザインのボタンを表示します。[/ja]
 * @description
 *   [en][/en]
 *   [ja][/ja]
 * @seealso ons-alert-dialog
 *   [en]The `<ons-alert-dialog>` component displays a alert dialog.[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @example
 *  <ons-alert-dialog>
 *    <div class="alert-dialog-title">Warning!</div>
 *    <div class="alert-dialog-content">
 *      An error has occurred!
 *    </div>
 *    <div class="alert-dialog-footer">
 *      <alert-dialog-button onclick="app.close()">Cancel</alert-dialog-button>
 *      <alert-dialog-button class="alert-dialog-button" onclick="app.close()">OK</alert-dialog-button>
 *    </div>
 *  </ons-alert-dialog>
 */

var AlertDialogButtonElement = function (_BaseButtonElement) {
  inherits(AlertDialogButtonElement, _BaseButtonElement);

  function AlertDialogButtonElement() {
    classCallCheck(this, AlertDialogButtonElement);
    return possibleConstructorReturn(this, (AlertDialogButtonElement.__proto__ || Object.getPrototypeOf(AlertDialogButtonElement)).apply(this, arguments));
  }

  createClass(AlertDialogButtonElement, [{
    key: '_scheme',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the button.[/en]
     *   [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    get: function get$$1() {
      return { '': 'alert-dialog-button--*' };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'alert-dialog-button';
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return [this, undefined, { 'modifier': 'light-gray' }];
    }
  }]);
  return AlertDialogButtonElement;
}(BaseButtonElement);

onsElements.AlertDialogButton = AlertDialogButtonElement;
customElements.define('ons-alert-dialog-button', AlertDialogButtonElement);

var iosBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"13px\" height=\"21px\" viewBox=\"0 0 13 21\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>ios-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"ios\" transform=\"translate(-34.000000, -30.000000)\">\n            <polygon id=\"ios-back-button-icon\" points=\"34 40.5 44.5 30 46.5 32 38 40.5 46.5 49 44.5 51\"></polygon>\n        </g>\n    </g>\n</svg>\n";

var mdBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>md-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"android\" transform=\"translate(-32.000000, -32.000000)\" fill-rule=\"nonzero\">\n            <polygon id=\"md-back-button-icon\" points=\"48 39 35.83 39 41.42 33.41 40 32 32 40 40 48 41.41 46.59 35.83 41 48 41\"></polygon>\n        </g>\n    </g>\n</svg>\n";

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName = 'back-button';

var scheme$2 = {
  '': 'back-button--*',
  '.back-button__icon': 'back-button--*__icon',
  '.back-button__label': 'back-button--*__label'
};

/**
 * @element ons-back-button
 * @category navigation
 * @description
 *   [en]
 *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
 *
 *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
 *   [/en]
 *   [ja][/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/back-button
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar
 *   [en]ons-toolbar component[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-navigator
 *   [en]ons-navigator component[/en]
 *   [ja]ons-navigatorコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-back-button>Back</ons-back-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   <div>
 * </ons-toolbar>
 */

var BackButtonElement = function (_BaseElement) {
  inherits(BackButtonElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the back button.[/en]
   *  [ja]バックボタンの見た目を指定します。[/ja]
   */

  function BackButtonElement() {
    classCallCheck(this, BackButtonElement);

    var _this = possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });

    _this._options = {};
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(BackButtonElement, [{
    key: '_updateIcon',
    value: function _updateIcon() {
      var icon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : util$1.findChild(this, '.back-button__icon');

      icon.innerHTML = autoStyle.getPlatform(this) === 'android' || util$1.hasModifier(this, 'material') ? mdBackButtonIcon : iosBackButtonIcon;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName);

      if (!util$1.findChild(this, '.back-button__label')) {
        var label = util$1.create('span.back-button__label');

        while (this.childNodes[0]) {
          label.appendChild(this.childNodes[0]);
        }
        this.appendChild(label);
      }

      if (!util$1.findChild(this, '.back-button__icon')) {
        var icon = util$1.create('span.back-button__icon');
        this._updateIcon(icon);

        this.insertBefore(icon, this.children[0]);
      }

      util$1.updateRipple(this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' });

      ModifierUtil.initModifier(this, scheme$2);
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Options object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

  }, {
    key: '_onClick',


    /**
     * @property onClick
     * @type {Function}
     * @description
     *   [en]Used to override the default back button behavior.[/en]
     *   [ja][/ja]
     */
    value: function _onClick() {
      if (this.onClick) {
        this.onClick.apply(this);
      } else {
        var navigator = util$1.findParent(this, 'ons-navigator');
        if (navigator) {
          navigator.popPage(this.options);
        }
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName, scheme$2);
          break;

        case 'modifier':
          {
            ModifierUtil.onModifierChanged(last, current, this, scheme$2) && this._updateIcon();
            break;
          }
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'show',
    value: function show() {
      this.style.display = 'inline-block';
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.style.display = 'none';
    }
  }, {
    key: 'options',
    get: function get$$1() {
      return this._options;
    },
    set: function set$$1(object) {
      this._options = object;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return BackButtonElement;
}(BaseElement);

onsElements.BackButton = BackButtonElement;
customElements.define('ons-back-button', BackButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$1 = 'bottom-bar';
var scheme$3 = { '': 'bottom-bar--*' };

/**
 * @element ons-bottom-toolbar
 * @category page
 * @description
 *   [en]Toolbar component that is positioned at the bottom of the page. Since bottom toolbars are very versatile elements, `ons-bottom-toolbar` does not provide any specific layout syntax for its children. Modifiers or custom CSS must be used.[/en]
 *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
 * @modifier transparent
 *   [en]Make the toolbar transparent.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @modifier aligned
 *   [en]Vertically aligns its children and applies flexbox for block elements. `justify-content` CSS rule can be used to change horizontal align.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
 * @example
 * <ons-bottom-toolbar>
 *   Content
 * </ons-bottom-toolbar>
 */

var BottomToolbarElement = function (_BaseElement) {
  inherits(BottomToolbarElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the toolbar.[/en]
   *   [ja]ツールバーの見た目の表現を指定します。[/ja]
   */

  function BottomToolbarElement() {
    classCallCheck(this, BottomToolbarElement);

    var _this = possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).call(this));

    _this.classList.add(defaultClassName$1);
    ModifierUtil.initModifier(_this, scheme$3);
    return _this;
  }

  createClass(BottomToolbarElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$1, scheme$3);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return BottomToolbarElement;
}(BaseElement);

onsElements.BottomToolbar = BottomToolbarElement;
customElements.define('ons-bottom-toolbar', BottomToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-button
 * @category form
 * @modifier outline
 *   [en]Button with outline and transparent background[/en]
 *   [ja]アウトラインを持ったボタンを表示します。[/ja]
 * @modifier light
 *   [en]Button that doesn't stand out.[/en]
 *   [ja]目立たないボタンを表示します。[/ja]
 * @modifier quiet
 *   [en]Button with no outline and or background..[/en]
 *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
 * @modifier cta
 *   [en]Button that really stands out.[/en]
 *   [ja]目立つボタンを表示します。[/ja]
 * @modifier large
 *   [en]Large button that covers the width of the screen.[/en]
 *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
 * @modifier large--quiet
 *   [en]Large quiet button.[/en]
 *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
 * @modifier large--cta
 *   [en]Large call to action button.[/en]
 *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
 * @modifier material
 *   [en]Material Design button[/en]
 *   [ja]マテリアルデザインのボタン[/ja]
 * @modifier material--flat
 *   [en]Material Design flat button[/en]
 *   [ja]マテリアルデザインのフラットボタン[/ja]
 * @description
 *   [en]
 *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
 *
 *     Will automatically display as a Material Design button with a ripple effect on Android.
 *   [/en]
 *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/button
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-button modifier="large--cta">
 *   Tap Me
 * </ons-button>
 */

var ButtonElement = function (_BaseButtonElement) {
  inherits(ButtonElement, _BaseButtonElement);

  function ButtonElement() {
    classCallCheck(this, ButtonElement);
    return possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).apply(this, arguments));
  }

  createClass(ButtonElement, [{
    key: '_scheme',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    get: function get$$1() {
      return { '': 'button--*' };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'button';
    }
  }]);
  return ButtonElement;
}(BaseButtonElement);

onsElements.Button = ButtonElement;
customElements.define('ons-button', ButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$2 = 'card';
var scheme$4 = {
  '': 'card--*',
  '.card__title': 'card--*__title',
  '.card__content': 'card--*__content'
};

/**
 * @element ons-card
 * @category visual
 * @modifier material
 *   [en]A card with material design.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]
 *    Component to create a card that displays some information.
 *
 *    The card may be composed by divs with specially prepared classes `title` and/or `content`. You can also add your own content as you please.[/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/card
 * @example
 * <ons-card>
 *   <p>Some content</p>
 * </ons-card>
 */

var CardElement = function (_BaseElement) {
  inherits(CardElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the card.[/en]
   *   [ja]リストの表現を指定します。[/ja]
   */

  function CardElement() {
    classCallCheck(this, CardElement);

    var _this = possibleConstructorReturn(this, (CardElement.__proto__ || Object.getPrototypeOf(CardElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(CardElement, [{
    key: '_compile',
    value: function _compile() {
      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('title')) {
          el.classList.add('card__title');
          
        } else if (el.classList.contains('content')) {
          el.classList.add('card__content');
          
        }
      }

      autoStyle.prepare(this);
      this.classList.add(defaultClassName$2);
      ModifierUtil.initModifier(this, scheme$4);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$2, scheme$4);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$4);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return CardElement;
}(BaseElement);

onsElements.Card = CardElement;
customElements.define('ons-card', CardElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$5 = { '': 'carousel-item--*' };

/**
 * @element ons-carousel-item
 * @category carousel
 * @description
 *   [en]
 *     Carousel item component. Used as a child of the `<ons-carousel>` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel
 *   [en]`<ons-carousel>` components[/en]
 *   [ja]<ons-carousel>コンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselItemElement = function (_BaseElement) {
  inherits(CarouselItemElement, _BaseElement);

  function CarouselItemElement() {
    classCallCheck(this, CarouselItemElement);

    var _this = possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).call(this));

    _this.style.width = '100%';
    ModifierUtil.initModifier(_this, scheme$5);
    return _this;
  }

  createClass(CarouselItemElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier'];
    }
  }]);
  return CarouselItemElement;
}(BaseElement);

onsElements.CarouselItem = CarouselItemElement;
customElements.define('ons-carousel-item', CarouselItemElement);

var directionMap = {
  vertical: {
    axis: 'Y',
    size: 'Height',
    dir: ['up', 'down'],
    t3d: ['0px, ', 'px, 0px']
  },
  horizontal: {
    axis: 'X',
    size: 'Width',
    dir: ['left', 'right'],
    t3d: ['', 'px, 0px, 0px']
  }
};

var Swiper = function () {
  function Swiper(params) {
    var _this = this;

    classCallCheck(this, Swiper);

    // Parameters
    var FALSE = function FALSE() {
      return false;
    };
    'getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook'.split(/\s+/).forEach(function (key) {
      return _this[key] = params[key] || FALSE;
    });

    this.getElement = params.getElement; // Required
    this.scrollHook = params.scrollHook; // Optional
    this.itemSize = params.itemSize || '100%';

    this.getAutoScrollRatio = function () {
      var ratio = params.getAutoScrollRatio && params.getAutoScrollRatio.apply(params, arguments);
      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;
      if (ratio < 0.0 || ratio > 1.0) {
        util$1.throw('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');
      }
      return ratio;
    };

    // Prevent clicks only on desktop
    this.shouldBlock = util$1.globals.actualMobileOS === 'other';

    // Bind handlers
    this.onDragStart = this.onDragStart.bind(this);
    this.onDrag = this.onDrag.bind(this);
    this.onDragEnd = this.onDragEnd.bind(this);
    this.onResize = this.onResize.bind(this);

    this._shouldFixScroll = util$1.globals.actualMobileOS === 'ios';
  }

  createClass(Swiper, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          swipeable = _ref.swipeable,
          autoRefresh = _ref.autoRefresh;

      this.initialized = true;
      this.target = this.getElement().children[0];
      this.blocker = this.getElement().children[1];
      if (!this.target || !this.blocker) {
        util$1.throw('Expected "target" and "blocker" elements to exist before initializing Swiper');
      }

      if (!this.shouldBlock) {
        this.blocker.style.display = 'none';
      }

      // Add classes
      this.getElement().classList.add('ons-swiper');
      this.target.classList.add('ons-swiper-target');
      this.blocker.classList.add('ons-swiper-blocker');

      // Setup listeners
      this._gestureDetector = new GestureDetector(this.getElement(), { dragMinDistance: 1, dragLockToAxis: true, passive: !this._shouldFixScroll });
      this._mutationObserver = new MutationObserver(function () {
        return _this2.refresh();
      });
      this.updateSwipeable(swipeable);
      this.updateAutoRefresh(autoRefresh);

      // Setup initial layout
      this._scroll = this._offset = this._lastActiveIndex = 0;
      this._updateLayout();
      this._setupInitialIndex();
      setImmediate(function () {
        return _this2.initialized && _this2._setupInitialIndex();
      });

      // Fix rendering glitch on Android 4.1
      // Fix for iframes where the width is inconsistent at the beginning
      if (window !== window.parent || this.offsetHeight === 0) {
        window.requestAnimationFrame(function () {
          return _this2.initialized && _this2.onResize();
        });
      }
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this.initialized = false;
      this.updateSwipeable(false);
      this.updateAutoRefresh(false);

      this._gestureDetector && this._gestureDetector.dispose();
      this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;

      this.setupResize(false);
    }
  }, {
    key: 'onResize',
    value: function onResize() {
      var i = this._scroll / this.targetSize;
      this._reset();
      this.setActiveIndex(i);
      this.refresh();
    }
  }, {
    key: '_calculateItemSize',
    value: function _calculateItemSize() {
      var matches = this.itemSize.match(/^(\d+)(px|%)/);

      if (!matches) {
        util$1.throw('Invalid state: swiper\'s size unit must be \'%\' or \'px\'');
      }

      var value = parseInt(matches[1], 10);
      return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;
    }
  }, {
    key: '_setupInitialIndex',
    value: function _setupInitialIndex() {
      this._reset();
      this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);
      this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;
      this._scrollTo(this._scroll);
    }
  }, {
    key: '_setSwiping',
    value: function _setSwiping(toggle) {
      this.target.classList.toggle('swiping', toggle); // Hides everything except shown pages
    }
  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._setSwiping(true);
      index = Math.max(0, Math.min(index, this.itemCount - 1));
      var scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));

      if (platform.isUIWebView()) {
        /* Dirty fix for #2231(https://github.com/OnsenUI/OnsenUI/issues/2231). begin */
        var concat = function concat(arrayOfArray) {
          return Array.prototype.concat.apply([], arrayOfArray);
        };
        var contents = concat(util$1.arrayFrom(this.target.children).map(function (page) {
          return util$1.arrayFrom(page.children).filter(function (child) {
            return child.classList.contains('page__content');
          });
        }));

        var map = new Map();
        return new Promise(function (resolve) {
          contents.forEach(function (content) {
            map.set(content, content.getAttribute('class'));
            content.classList.add('page__content--suppress-layer-creation');
          });
          requestAnimationFrame(resolve);
        }).then(function () {
          return _this3._changeTo(scroll, options);
        }).then(function () {
          return new Promise(function (resolve) {
            contents.forEach(function (content) {
              content.setAttribute('class', map.get(content));
            });
            requestAnimationFrame(resolve);
          });
        });
        /* end */
      } else {
        return this._changeTo(scroll, options);
      }
    }
  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      var scroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._scroll;

      scroll -= this._offset;
      var count = this.itemCount,
          size = this.itemNumSize;

      if (this.itemNumSize === 0 || !util$1.isInteger(scroll)) {
        return this._lastActiveIndex;
      }

      if (scroll <= 0) {
        return 0;
      }

      for (var i = 0; i < count; i++) {
        if (size * i <= scroll && size * (i + 1) > scroll) {
          return i;
        }
      }

      return count - 1;
    }
  }, {
    key: 'setupResize',
    value: function setupResize(add) {
      window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);
    }
  }, {
    key: 'show',
    value: function show() {
      var _this4 = this;

      this.setupResize(true);
      this.onResize();
      setTimeout(function () {
        return _this4.target && _this4.target.classList.add('active');
      }, 1000 / 60); // Hide elements after animations
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setupResize(false);
      this.target.classList.remove('active'); // Show elements before animations
    }
  }, {
    key: 'updateSwipeable',
    value: function updateSwipeable(shouldUpdate) {
      if (this._gestureDetector) {
        var action = shouldUpdate ? 'on' : 'off';
        this._gestureDetector[action]('drag', this.onDrag);
        this._gestureDetector[action]('dragstart', this.onDragStart);
        this._gestureDetector[action]('dragend', this.onDragEnd);
      }
    }
  }, {
    key: 'updateAutoRefresh',
    value: function updateAutoRefresh(shouldWatch) {
      if (this._mutationObserver) {
        shouldWatch ? this._mutationObserver.observe(this.target, { childList: true }) : this._mutationObserver.disconnect();
      }
    }
  }, {
    key: 'updateItemSize',
    value: function updateItemSize(newSize) {
      this.itemSize = newSize || '100%';
      this.refresh();
    }
  }, {
    key: 'toggleBlocker',
    value: function toggleBlocker(block) {
      this.blocker.style.pointerEvents = block ? 'auto' : 'none';
    }
  }, {
    key: '_canConsumeGesture',
    value: function _canConsumeGesture(gesture) {
      var d = gesture.direction;
      var isFirst = this._scroll === 0 && !this.isOverScrollable();
      var isLast = this._scroll === this.maxScroll && !this.isOverScrollable();

      return this.isVertical() ? d === 'down' && !isFirst || d === 'up' && !isLast : d === 'right' && !isFirst || d === 'left' && !isLast;
    }
  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      var _this5 = this;

      this._ignoreDrag = event.consumed || !util$1.isValidGesture(event);

      if (!this._ignoreDrag) {
        var consume = event.consume;
        event.consume = function () {
          consume && consume();_this5._ignoreDrag = true;
        };

        if (this._canConsumeGesture(event.gesture)) {
          var startX = event.gesture.center && event.gesture.center.clientX || 0,
              distFromEdge = this.getBubbleWidth() || 0,
              start = function start() {
            consume && consume();
            event.consumed = true;
            _this5._started = true; // Avoid starting drag from outside
            _this5.shouldBlock && _this5.toggleBlocker(true);
            _this5._setSwiping(true);
            util$1.iosPreventScroll(_this5._gestureDetector);
          };

          // Let parent elements consume the gesture or consume it right away
          startX < distFromEdge || startX > this.targetSize - distFromEdge ? setImmediate(function () {
            return !_this5._ignoreDrag && start();
          }) : start();
        }
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(event) {
      if (!event.gesture || this._ignoreDrag || !this._started) {
        return;
      }

      this._continued = true; // Fix for random 'dragend' without 'drag'
      event.stopPropagation();

      this._scrollTo(this._scroll - this._getDelta(event), { throttle: true });
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(event) {
      this._started = false;
      if (!event.gesture || this._ignoreDrag || !this._continued) {
        this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate
        return;
      }

      this._continued = false;
      event.stopPropagation();

      var scroll = this._scroll - this._getDelta(event);
      var normalizedScroll = this._normalizeScroll(scroll);
      scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);
      this.shouldBlock && this.toggleBlocker(false);
    }
  }, {
    key: '_startMomentumScroll',
    value: function _startMomentumScroll(scroll, event) {
      var velocity = this._getVelocity(event),
          matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];

      var nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);
      var duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;
      duration = Math.min(.25, Math.max(.1, duration));

      this._changeTo(nextScroll, { swipe: true, animationOptions: { duration: duration, timing: 'cubic-bezier(.4, .7, .5, 1)' } });
    }
  }, {
    key: '_killOverScroll',
    value: function _killOverScroll(scroll) {
      var _this6 = this;

      this._scroll = scroll;
      var direction = this.dM.dir[Number(scroll > 0)];
      var killOverScroll = function killOverScroll() {
        return _this6._changeTo(scroll, { animationOptions: { duration: .4, timing: 'cubic-bezier(.1, .4, .1, 1)' } });
      };
      this.overScrollHook({ direction: direction, killOverScroll: killOverScroll }) || killOverScroll();
    }
  }, {
    key: '_changeTo',
    value: function _changeTo(scroll) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var e = { activeIndex: this.getActiveIndex(scroll), lastActiveIndex: this._lastActiveIndex, swipe: options.swipe || false };
      var change = e.activeIndex !== e.lastActiveIndex;
      var canceled = change ? this.preChangeHook(e) : false;

      this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;
      this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;

      return this._scrollTo(this._scroll, options).then(function () {
        if (scroll === _this7._scroll && !canceled) {
          _this7._setSwiping(false);
          change && _this7.postChangeHook(e);
        } else if (options.reject) {
          _this7._setSwiping(false);
          return Promise.reject('Canceled');
        }
      });
    }
  }, {
    key: '_scrollTo',
    value: function _scrollTo(scroll) {
      var _this8 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.throttle) {
        var ratio = 0.35;
        if (scroll < 0) {
          scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;
        } else {
          var maxScroll = this.maxScroll;
          if (maxScroll < scroll) {
            scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
          }
        }
      }

      var opt = options.animation === 'none' ? {} : options.animationOptions;
      this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});

      return new Promise(function (resolve) {
        return Animit(_this8.target).queue({ transform: _this8._getTransform(scroll) }, opt).play(resolve);
      });
    }
  }, {
    key: '_getAutoScroll',
    value: function _getAutoScroll(scroll, velocity, matchesDirection) {
      var max = this.maxScroll,
          offset = this._offset,
          size = this.itemNumSize;

      if (!this.isAutoScrollable()) {
        return Math.max(0, Math.min(max, scroll));
      }

      var arr = [];
      for (var s = offset; s < max; s += size) {
        arr.push(s);
      }
      arr.push(max);

      arr = arr.sort(function (left, right) {
        return Math.abs(left - scroll) - Math.abs(right - scroll);
      }).filter(function (item, pos) {
        return !pos || item !== arr[pos - 1];
      });

      var result = arr[0];
      var lastScroll = this._lastActiveIndex * size + offset;
      var scrollRatio = Math.abs(scroll - lastScroll) / size;

      if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {
        result = lastScroll;
      } else {
        if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {
          result = arr[1];
        }
      }
      return Math.max(0, Math.min(max, result));
    }
  }, {
    key: '_reset',
    value: function _reset() {
      this._targetSize = this._itemNumSize = undefined;
    }
  }, {
    key: '_normalizeScroll',
    value: function _normalizeScroll(scroll) {
      return Math.max(Math.min(scroll, this.maxScroll), 0);
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      this._reset();
      this._updateLayout();

      if (util$1.isInteger(this._scroll)) {
        var scroll = this._normalizeScroll(this._scroll);
        scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);
      } else {
        this._setupInitialIndex();
      }

      this.refreshHook();
    }
  }, {
    key: '_getDelta',
    value: function _getDelta(event) {
      return event.gesture['delta' + this.dM.axis];
    }
  }, {
    key: '_getVelocity',
    value: function _getVelocity(event) {
      return event.gesture['velocity' + this.dM.axis];
    }
  }, {
    key: '_getTransform',
    value: function _getTransform(scroll) {
      return 'translate3d(' + this.dM.t3d[0] + -scroll + this.dM.t3d[1] + ')';
    }
  }, {
    key: '_updateLayout',
    value: function _updateLayout() {
      this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];
      this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());

      for (var c = this.target.children[0]; c; c = c.nextElementSibling) {
        c.style[this.dM.size.toLowerCase()] = this.itemSize;
      }

      if (this.isCentered()) {
        this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;
      }
    }
  }, {
    key: 'itemCount',
    get: function get$$1() {
      return this.target.children.length;
    }
  }, {
    key: 'itemNumSize',
    get: function get$$1() {
      if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {
        this._itemNumSize = this._calculateItemSize();
      }
      return this._itemNumSize;
    }
  }, {
    key: 'maxScroll',
    get: function get$$1() {
      var max = this.itemCount * this.itemNumSize - this.targetSize;
      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
    }
  }, {
    key: 'targetSize',
    get: function get$$1() {
      if (!this._targetSize) {
        this._targetSize = this.target['offset' + this.dM.size];
      }
      return this._targetSize;
    }
  }]);
  return Swiper;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-carousel
 * @category carousel
 * @description
 *   [en]
 *     Carousel component. A carousel can be used to display several items in the same space.
 *
 *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel-item
 *   [en]`<ons-carousel-item>` component[/en]
 *   [ja]ons-carousel-itemコンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselElement = function (_BaseElement) {
  inherits(CarouselElement, _BaseElement);

  /**
   * @event postchange
   * @description
   *   [en]Fired just after the current carousel item has changed.[/en]
   *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Carousel object.[/en]
   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
   * @param {Number} event.activeIndex
   *   [en]Current active index.[/en]
   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
   * @param {Number} event.lastActiveIndex
   *   [en]Previous active index.[/en]
   *   [ja]以前アクティブだった要素のインデックス。[/ja]
   */

  /**
   * @event refresh
   * @description
   *   [en]Fired when the carousel has been refreshed.[/en]
   *   [ja]カルーセルが更新された時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Carousel object.[/en]
   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
   */

  /**
   * @event overscroll
   * @description
   *   [en]Fired when the carousel has been overscrolled.[/en]
   *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Fired when the carousel has been refreshed.[/en]
   *   [ja]カルーセルが更新された時に発火します。[/ja]
   * @param {Number} event.activeIndex
   *   [en]Current active index.[/en]
   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
   * @param {String} event.direction
   *   [en]Can be one of either "up", "down", "left" or "right".[/en]
   *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
   * @param {Function} event.waitToReturn
   *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
   *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
   *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
   */

  /**
   * @attribute fullscreen
   * @description
   *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
   *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
   */

  /**
   * @attribute overscrollable
   * @description
   *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
   *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
   */

  /**
   * @attribute centered
   * @description
   *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
   *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
   */

  /**
   * @attribute item-width
   * @type {String}
   * @description
   *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
   *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
   */

  /**
   * @attribute item-height
   * @type {String}
   * @description
   *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
   *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
   */

  /**
   * @attribute auto-scroll
   * @description
   *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
   *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
   */

  /**
   * @attribute auto-scroll-ratio
   * @type {Number}
   * @description
   *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
   *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
   */

  /**
   * @attribute swipeable
   * @description
   *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
   *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set the carousel is disabled.[/en]
   *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
   */

  /**
   * @attribute initial-index
   * @initonly
   * @default 0
   * @type {Number}
   * @description
   *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
   *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
   */

  /**
   * @attribute auto-refresh
   * @description
   *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
   *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @description
   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  function CarouselElement() {
    classCallCheck(this, CarouselElement);

    var _this = possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(CarouselElement, [{
    key: '_compile',
    value: function _compile() {
      var target = this.children[0] && this.children[0].tagName !== 'ONS-CAROUSEL-ITEM' && this.children[0] || document.createElement('div');
      if (!target.parentNode) {
        while (this.firstChild) {
          target.appendChild(this.firstChild);
        }
        this.appendChild(target);
      }

      !this.children[1] && this.appendChild(document.createElement('div'));

      this.appendChild = this.appendChild.bind(target);
      this.insertBefore = this.insertBefore.bind(target);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!this._swiper) {
        this._swiper = new Swiper({
          getElement: function getElement() {
            return _this2;
          },
          getInitialIndex: function getInitialIndex() {
            return _this2.getAttribute('initial-index');
          },
          getAutoScrollRatio: function getAutoScrollRatio() {
            return _this2.autoScrollRatio;
          },
          isVertical: function isVertical() {
            return _this2.vertical;
          },
          isOverScrollable: function isOverScrollable() {
            return _this2.overscrollable;
          },
          isCentered: function isCentered() {
            return _this2.centered;
          },
          isAutoScrollable: function isAutoScrollable() {
            return _this2.autoScroll;
          },
          itemSize: this.itemSize,
          overScrollHook: this._onOverScroll.bind(this),
          preChangeHook: this._onChange.bind(this, 'prechange'),
          postChangeHook: this._onChange.bind(this, 'postchange'),
          refreshHook: this._onRefresh.bind(this),
          scrollHook: function scrollHook() {
            return _this2._onSwipe && _this2._onSwipe.apply(_this2, arguments);
          }
        });

        contentReady(this, function () {
          return _this2._swiper.init({
            swipeable: _this2.hasAttribute('swipeable'),
            autoRefresh: _this2.hasAttribute('auto-refresh')
          });
        });
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._swiper && this._swiper.initialized) {
        this._swiper.dispose();
        this._swiper = null;
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (!this._swiper) {
        return;
      }

      switch (name) {
        case 'swipeable':
          this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
          break;
        case 'auto-refresh':
          this._swiper.updateAutoRefresh(this.hasAttribute('auto-refresh'));
          break;
        case 'item-height':
          this.vertical && this._swiper.updateItemSize(this.itemSize);
          break;
        case 'item-width':
          this.vertical || this._swiper.updateItemSize(this.itemSize);
          break;
        case 'direction':
          this._swiper.refresh();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this._swiper.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._swiper.hide();
    }
  }, {
    key: '_onOverScroll',
    value: function _onOverScroll(_ref) {
      var direction = _ref.direction,
          killOverScroll = _ref.killOverScroll;

      var waitForAction = false;
      util$1.triggerElementEvent(this, 'overscroll', {
        carousel: this,
        activeIndex: this.getActiveIndex(),
        direction: direction,
        waitToReturn: function waitToReturn(promise) {
          waitForAction = true;
          promise.then(killOverScroll);
        }
      });

      return waitForAction;
    }
  }, {
    key: '_onChange',
    value: function _onChange(eventName, _ref2) {
      var activeIndex = _ref2.activeIndex,
          lastActiveIndex = _ref2.lastActiveIndex;

      util$1.triggerElementEvent(this, eventName, { carousel: this, activeIndex: activeIndex, lastActiveIndex: lastActiveIndex });
    }
  }, {
    key: '_onRefresh',
    value: function _onRefresh() {
      util$1.triggerElementEvent(this, 'refresh', { carousel: this });
    }

    /**
     * @method setActiveIndex
     * @signature setActiveIndex(index, [options])
     * @param {Number} index
     *   [en]The index that the carousel should be set to.[/en]
     *   [ja]carousel要素のインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be called after the animation is finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options = _extends({
        animation: this.getAttribute('animation'),
        animationOptions: this.hasAttribute('animation-options') ? util$1.animationOptionsParse(this.getAttribute('animation-options')) : { duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }
      }, options);

      return this._swiper.setActiveIndex(index, options).then(function () {
        options.callback instanceof Function && options.callback(_this3);
        return Promise.resolve(_this3);
      });
    }

    /**
     * @method getActiveIndex
     * @signature getActiveIndex()
     * @return {Number}
     *   [en]The current carousel item index.[/en]
     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
     * @description
     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
     */

  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      return this._swiper.getActiveIndex();
    }

    /**
     * @method next
     * @signature next([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show next `<ons-carousel-item>`.[/en]
     *   [ja]次のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'next',
    value: function next(options) {
      return this.setActiveIndex(this.getActiveIndex() + 1, options);
    }

    /**
     * @method prev
     * @signature prev([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show previous `<ons-carousel-item>`.[/en]
     *   [ja]前のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'prev',
    value: function prev(options) {
      return this.setActiveIndex(this.getActiveIndex() - 1, options);
    }

    /**
     * @method first
     * @signature first()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this is set to `"none"`, the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show first `<ons-carousel-item>`.[/en]
     *   [ja]最初のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'first',
    value: function first(options) {
      return this.setActiveIndex(0, options);
    }

    /**
     * @method last
     * @signature last()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja]Resolves to the carousel element[/ja]
     * @description
     *   [en]Show last ons-carousel item.[/en]
     *   [ja]最後のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'last',
    value: function last(options) {
      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
    }

    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
     */

  }, {
    key: 'refresh',
    value: function refresh() {
      this._swiper.refresh();
    }

    /**
     * @property itemCount
     * @readonly
     * @type {Number}
     * @description
     *   [en]The number of carousel items.[/en]
     *   [ja]カルーセル要素の数です。[/ja]
     */

  }, {
    key: 'itemCount',
    get: function get$$1() {
      return this._swiper.itemCount;
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]true if the carousel is swipeable.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get$$1() {
      return this.hasAttribute('swipeable');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the carousel. It gets a decimal index and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }

    /**
     * @property autoScroll
     * @type {Boolean}
     * @description
     *   [en]true if auto scroll is enabled.[/en]
     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
     */

  }, {
    key: 'autoScroll',
    get: function get$$1() {
      return this.hasAttribute('auto-scroll');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'auto-scroll', value);
    }
  }, {
    key: 'vertical',
    get: function get$$1() {
      return this.getAttribute('direction') === 'vertical';
    }
  }, {
    key: 'itemSize',
    get: function get$$1() {
      var itemSizeAttr = (this.getAttribute('item-' + (this.vertical ? 'height' : 'width')) || '').trim();
      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
    }

    /**
     * @property autoScrollRatio
     * @type {Number}
     * @description
     *   [en]The current auto scroll ratio. [/en]
     *   [ja]現在のオートスクロールのratio値。[/ja]
     */

  }, {
    key: 'autoScrollRatio',
    get: function get$$1() {
      return parseFloat(this.getAttribute('auto-scroll-ratio'));
    },
    set: function set$$1(ratio) {
      this.setAttribute('auto-scroll-ratio', ratio);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    get: function get$$1() {
      return this.hasAttribute('disabled');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    }

    /**
     * @property overscrollable
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is overscrollable or not.[/en]
     *   [ja]overscrollできればtrueを返します。[/ja]
     */

  }, {
    key: 'overscrollable',
    get: function get$$1() {
      return this.hasAttribute('overscrollable');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'overscrollable', value);
    }

    /**
     * @property centered
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is centered or not.[/en]
     *   [ja]centered状態になっていればtrueを返します。[/ja]
     */

  }, {
    key: 'centered',
    get: function get$$1() {
      return this.hasAttribute('centered');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'centered', value);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['swipeable', 'auto-refresh', 'direction', 'item-height', 'item-width'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['postchange', 'refresh', 'overscroll'];
    }
  }]);
  return CarouselElement;
}(BaseElement);

onsElements.Carousel = CarouselElement;
customElements.define('ons-carousel', CarouselElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-col
 * @category grid
 * @description
 *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
 *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
 * @codepen GgujC {wide}
 * @guide theming.html [en]Layouting guide[/en][ja]レイアウト機能[/ja]
 * @seealso ons-row
 *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
 *   [ja]ons-rowコンポーネント[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
 *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
 */

/**
 * @attribute width
 * @type {String}
 * @description
 *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
 *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
 */

var ColElement = function (_BaseElement) {
  inherits(ColElement, _BaseElement);

  function ColElement() {
    classCallCheck(this, ColElement);

    var _this = possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).call(this));

    if (_this.getAttribute('width')) {
      _this._updateWidth();
    }
    return _this;
  }

  createClass(ColElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'width') {
        this._updateWidth();
      }
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      var width = this.getAttribute('width');
      if (!width) {
        styler.clear(this, 'flex maxWidth');
      } else {
        width = width.trim().match(/^\d+$/) ? width + '%' : width;

        styler(this, {
          flex: '0 0 ' + width,
          maxWidth: width
        });
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['width'];
    }
  }]);
  return ColElement;
}(BaseElement);

onsElements.Col = ColElement;
customElements.define('ons-col', ColElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var DialogAnimator = function (_BaseAnimator) {
  inherits(DialogAnimator, _BaseAnimator);

  function DialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, DialogAnimator);
    return possibleConstructorReturn(this, (DialogAnimator.__proto__ || Object.getPrototypeOf(DialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(DialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return DialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for dialog.
 */
var AndroidDialogAnimator = function (_DialogAnimator) {
  inherits(AndroidDialogAnimator, _DialogAnimator);

  function AndroidDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;

    classCallCheck(this, AndroidDialogAnimator);
    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -60%, 0)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0)', opacity: 1 }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)', opacity: 1 }, { transform: 'translate3d(-50%, -60%, 0)', opacity: 0 }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidDialogAnimator;
}(DialogAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSDialogAnimator = function (_DialogAnimator2) {
  inherits(IOSDialogAnimator, _DialogAnimator2);

  function IOSDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;

    classCallCheck(this, IOSDialogAnimator);

    var _this3 = possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this3.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this3;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)' }, { transform: 'translate3d(-50%, -50%, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)' }, { transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSDialogAnimator;
}(DialogAnimator);

/**
 * Slide animator for dialog.
 */
var SlideDialogAnimator = function (_DialogAnimator3) {
  inherits(SlideDialogAnimator, _DialogAnimator3);

  function SlideDialogAnimator() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$timing = _ref4.timing,
        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === undefined ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;

    classCallCheck(this, SlideDialogAnimator);

    var _this4 = possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this4.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this4;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(SlideDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default(
      // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
      { transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)' }, { transform: 'translate3d(-50%, -50%, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)' },
      // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
      { transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return SlideDialogAnimator;
}(DialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$6 = {
  '.dialog': 'dialog--*',
  '.dialog-container': 'dialog-container--*',
  '.dialog-mask': 'dialog-mask--*'
};

var _animatorDict$2 = {
  'default': function _default() {
    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
  },
  'slide': SlideDialogAnimator,
  'none': DialogAnimator
};

/**
 * @element ons-dialog
 * @category dialog
 * @description
 *   [en]
 *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<template>` tag.
 *
 *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
 *
 *     It will automatically be displayed as Material Design when running on an Android device.
 *   [/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design dialog.[/en]
 *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
 * @codepen zxxaGa
 * @tutorial vanilla/Reference/dialog
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-alert-dialog
 *   [en]`<ons-alert-dialog>` component[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-dialog id="dialog">
 *   <p>This is a dialog!</p>
 * </ons-dialog>
 *
 * <script>
 *   document.getElementById('dialog').show();
 * </script>
 */

var DialogElement = function (_BaseDialogElement) {
  inherits(DialogElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the dialog is displayed.[/en]
   * [ja]ダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the dialog from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the dialog is displayed.[/en]
   * [ja]ダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the dialog is hidden.[/en]
   * [ja]ダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the dialog from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the dialog is hidden.[/en]
   * [ja]ダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the dialog.[/en]
   *  [ja]ダイアログの表現を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the dialog is disabled.[/en]
   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function DialogElement() {
    classCallCheck(this, DialogElement);

    var _this = possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(DialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$2,
        baseClass: DialogAnimator,
        baseClassName: 'DialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-dialog>
       *     <div class="dialog-mask"></div>
       *     <div class="dialog">
       *       <div class="dialog-container">...</div>
       *     </div>
       *   </ons-dialog>
       */

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('dialog');

        var container = document.createElement('div');
        container.classList.add('dialog-container');
        while (this.firstChild) {
          container.appendChild(this.firstChild);
        }
        dialog.appendChild(container);

        this.appendChild(dialog);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('dialog-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      this.setAttribute('status-bar-fill', '');

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the dialog.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the dialog has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$6;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.dialog-mask');
    }
  }, {
    key: '_dialog',
    get: function get$$1() {
      return util$1.findChild(this, '.dialog');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof DialogAnimator)) {
        util$1.throwAnimator('Dialog');
      }
      _animatorDict$2[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$2;
    }
  }, {
    key: 'DialogAnimator',
    get: function get$$1() {
      return DialogAnimator;
    }
  }]);
  return DialogElement;
}(BaseDialogElement);

onsElements.Dialog = DialogElement;
customElements.define('ons-dialog', DialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$3 = 'fab';

var scheme$7 = {
  '': 'fab--*',
  '.fab__icon': 'fab--*__icon'
};

/**
 * @element ons-fab
 * @category form
 * @description
 *   [en]
 *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
 *
 *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/fab
 * @modifier mini
 *   [en]Makes the `ons-fab` smaller.[/en]
 *   [ja][/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
 *   [ja][/ja]
 */

var FabElement = function (_BaseElement) {
  inherits(FabElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the button.[/en]
   *  [ja]ボタンの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute position
   * @type {String}
   * @description
   *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定します。[/ja]
   */

  function FabElement() {
    classCallCheck(this, FabElement);

    // The following statements can be executed before contentReady
    // since these do not access the children
    var _this = possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).call(this));

    _this.hide();
    _this.classList.add(defaultClassName$3);

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(FabElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (!util$1.findChild(this, '.fab__icon')) {
        var content = document.createElement('span');
        content.classList.add('fab__icon');

        util$1.arrayFrom(this.childNodes).forEach(function (element) {
          if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
            content.appendChild(element);
          }
        });
        this.appendChild(content);
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$7);

      this._updatePosition();
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      setImmediate(function () {
        return _this2.show();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$3, scheme$7);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$7);
          break;
        case 'ripple':
          this._updateRipple();
          break;
        case 'position':
          this._updatePosition();
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this3 = this;

      setImmediate(function () {
        return _this3.hide();
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util$1.updateRipple(this);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *  [en]Show the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this.toggle(true);
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *  [en]Hide the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      this.toggle(false);
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle the visibility of the button.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.visible;

      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
      var translate = isBottom ? 'translate3d(0px, -' + (util$1.globals.fabOffset || 0) + 'px, 0px)' : '';

      styler(this, { transform: translate + ' scale(' + Number(action) + ')' });
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return this.style.transform.indexOf('scale(0)') === -1 && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'position', 'class'];
    }
  }]);
  return FabElement;
}(BaseElement);

onsElements.Fab = FabElement;
customElements.define('ons-fab', FabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-gesture-detector
 * @category gesture
 * @description
 *   [en]
 *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
 *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
 *     - Hold gestures: `hold`, `release`
 *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
 *     - Tap gestures: `tap`, `doubletap`
 *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
 *     - Other gestures: `touch`, `transform`, `rotate`
 *   [/en]
 *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
 * @guide features.html#gesture-detection
 *   [en]Detecting finger gestures[/en]
 *   [ja]ジェスチャー操作の検知[/ja]
 * @example
 * <ons-gesture-detector>
 *   <div id="detect-area" style="width: 100px; height: 100px;">
 *     Swipe Here
 *   </div>
 * </ons-gesture-detector>
 *
 * <script>
 *   document.addEventListener('swipeleft', function(event) {
 *     if (event.target.matches('#detect-area')) {
 *       console.log('Swipe left is detected.');
 *     }
 *   });
 * </script>
 */

var GestureDetectorElement = function (_BaseElement) {
  inherits(GestureDetectorElement, _BaseElement);

  function GestureDetectorElement() {
    classCallCheck(this, GestureDetectorElement);

    var _this = possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).call(this));

    _this._gestureDetector = new GestureDetector(_this, { passive: true });
    return _this;
  }

  return GestureDetectorElement;
}(BaseElement);

onsElements.GestureDetector = GestureDetectorElement;
customElements.define('ons-gesture-detector', GestureDetectorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoPrefix = 'fa'; // FIXME: To be removed in v3

/**
 * @element ons-icon
 * @category visual
 * @description
 *   [en]
 *     Displays an icon. The following icon suites are available:
 *
 *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
 *     * [Ionicons](http://ionicons.com/)
 *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
 *   [/en]
 *   [ja][/ja]
 * @codepen xAhvg
 * @tutorial vanilla/Reference/icon
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja][/ja]
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @example
 * <ons-icon
 *   icon="md-car"
 *   size="20px"
 *   style="color: red">
 * </ons-icon>
 *
 * <ons-button>
 *   <ons-icon icon="md-car"></ons-icon>
 *   Car
 * </ons-button>
 */

var IconElement = function (_BaseElement) {
  inherits(IconElement, _BaseElement);

  /**
   * @attribute icon
   * @type {String}
   * @description
   *   [en]
   *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
   *
   *     See all available icons on the element description (at the top).
   *
   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
   *
   *     The code `<ons-icon icon="ion-edit, material:md-edit"></ons-icon>` will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
   *
   *     `fa-` prefix is added automatically if none is provided. Check [See also](#seealso) section for more information.
   *   [/en]
   *   [ja][/ja]
   */

  /**
   * @attribute size
   * @type {String}
   * @description
   *   [en]
   *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
   *
   *     The code:
   *
   *     ```
   *     <ons-icon
   *       icon="ion-edit"
   *       size="32px, material:24px">
   *     </ons-icon>
   *     ```
   *
   *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
   *   [/en]
   *   [ja][/ja]
   */

  /**
   * @attribute rotate
   * @type {Number}
   * @description
   *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
   *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
   */

  /**
   * @attribute fixed-width
   * @type {Boolean}
   * @default false
   * @description
   *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute spin
   * @description
   *   [en]Specify whether the icon should be spinning.[/en]
   *   [ja]アイコンを回転するかどうかを指定します。[/ja]
   */

  function IconElement() {
    classCallCheck(this, IconElement);

    var _this = possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(IconElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      this._cleanClassAttribute(name === 'icon' ? last : this.getAttribute('icon'), name === 'modifier' ? last : undefined);
      this._update();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._update();
    }
  }, {
    key: '_update',
    value: function _update() {
      var _this2 = this;

      var _buildClassAndStyle2 = this._buildClassAndStyle(this._parseAttr('icon'), this._parseAttr('size')),
          classList = _buildClassAndStyle2.classList,
          style = _buildClassAndStyle2.style;

      util$1.extend(this.style, style);

      classList.forEach(function (className) {
        return _this2.classList.add(className);
      });
    }
  }, {
    key: '_parseAttr',
    value: function _parseAttr(attrName) {
      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getAttribute('modifier') || '';

      var attr = this.getAttribute(attrName) || attrName || '';
      var parts = attr.split(/\s*,\s*/);
      var def = parts[0];
      var md = parts[1];
      md = (md || '').split(/\s*:\s*/);

      return (modifier && RegExp('(^|\\s+)' + md[0] + '($|\\s+)', 'i').test(modifier) ? md[1] : def) || '';
    }

    /**
     * Remove unneeded class value.
     */

  }, {
    key: '_cleanClassAttribute',
    value: function _cleanClassAttribute(lastIcon, lastModifier) {
      var _this3 = this;

      var _prefixIcon2 = this._prefixIcon(this._parseAttr(lastIcon, lastModifier)),
          className = _prefixIcon2.className,
          prefix = _prefixIcon2.prefix;

      var customPrefixRE = className !== prefix ? '|' + prefix + '$|' + prefix + '-' : '|' + className + '$' || '';
      var re = new RegExp('^(fa$|fa-|ion-|zmdi$|zmdi-|ons-icon--' + customPrefixRE + ')');

      util$1.arrayFrom(this.classList).filter(function (className) {
        return re.test(className);
      }).forEach(function (className) {
        return _this3.classList.remove(className);
      });
    }
  }, {
    key: '_prefixIcon',
    value: function _prefixIcon(iconName) {
      var className = autoPrefix + (autoPrefix ? '-' : '') + iconName;
      return { className: className, prefix: className.split('-')[0] };
    }
  }, {
    key: '_buildClassAndStyle',
    value: function _buildClassAndStyle(iconName, size) {
      var classList = ['ons-icon'];
      var style = {};

      // Icon
      if (iconName.indexOf('ion-') === 0) {
        classList.push(iconName);
        classList.push('ons-icon--ion');
      } else if (iconName.indexOf('fa-') === 0) {
        classList.push(iconName);
        classList.push('fa');
      } else if (iconName.indexOf('md-') === 0) {
        classList.push('zmdi');
        classList.push('zmdi-' + iconName.split(/-(.+)?/)[1]);
      } else {
        var _prefixIcon3 = this._prefixIcon(iconName),
            className = _prefixIcon3.className,
            prefix = _prefixIcon3.prefix;

        prefix && classList.push(prefix);
        className && classList.push(className);
      }

      // Size
      if (size.match(/^[1-5]x|lg$/)) {
        classList.push('ons-icon--' + size);
        this.style.removeProperty('font-size');
      } else {
        style.fontSize = size;
      }

      return {
        classList: classList,
        style: style
      };
    }
  }], [{
    key: 'setAutoPrefix',
    value: function setAutoPrefix(prefix) {
      autoPrefix = prefix ? typeof prefix === 'string' && prefix || 'fa' : '';
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return ['icon', 'size', 'modifier', 'class'];
    }
  }]);
  return IconElement;
}(BaseElement);

onsElements.Icon = IconElement;
customElements.define('ons-icon', IconElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var LazyRepeatDelegate = function () {
  function LazyRepeatDelegate(userDelegate) {
    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, LazyRepeatDelegate);

    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {
      util$1.throw('"delegate" parameter must be an object');
    }
    this._userDelegate = userDelegate;

    if (!(templateElement instanceof Element) && templateElement !== null) {
      util$1.throw('"templateElement" parameter must be an instance of Element or null');
    }
    this._templateElement = templateElement;
  }

  createClass(LazyRepeatDelegate, [{
    key: 'hasRenderFunction',


    /**
     * @return {Boolean}
     */
    value: function hasRenderFunction() {
      return this._userDelegate._render instanceof Function;
    }

    /**
     * @return {void}
     */

  }, {
    key: '_render',
    value: function _render() {
      this._userDelegate._render.apply(this._userDelegate, arguments);
    }

    /**
     * @param {Number} index
     * @param {Function} done A function that take item object as parameter.
     */

  }, {
    key: 'loadItemElement',
    value: function loadItemElement(index, done) {
      if (this._userDelegate.loadItemElement instanceof Function) {
        this._userDelegate.loadItemElement(index, done);
      } else {
        var element = this._userDelegate.createItemContent(index, this._templateElement);
        if (!(element instanceof Element)) {
          util$1.throw('"createItemContent" must return an instance of Element');
        }

        done({ element: element });
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'countItems',
    value: function countItems() {
      var count = this._userDelegate.countItems();
      if (typeof count !== 'number') {
        util$1.throw('"countItems" must return a number');
      }
      return count;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     * @param {Element} item.element
     */

  }, {
    key: 'updateItem',
    value: function updateItem(index, item) {
      if (this._userDelegate.updateItemContent instanceof Function) {
        this._userDelegate.updateItemContent(index, item);
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'calculateItemHeight',
    value: function calculateItemHeight(index) {
      if (this._userDelegate.calculateItemHeight instanceof Function) {
        var height = this._userDelegate.calculateItemHeight(index);

        if (typeof height !== 'number') {
          util$1.throw('"calculateItemHeight" must return a number');
        }

        return height;
      }

      return 0;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     */

  }, {
    key: 'destroyItem',
    value: function destroyItem(index, item) {
      if (this._userDelegate.destroyItem instanceof Function) {
        this._userDelegate.destroyItem(index, item);
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._userDelegate.destroy instanceof Function) {
        this._userDelegate.destroy();
      }

      this._userDelegate = this._templateElement = null;
    }
  }, {
    key: 'itemHeight',
    get: function get$$1() {
      return this._userDelegate.itemHeight;
    }
  }]);
  return LazyRepeatDelegate;
}();

/**
 * This class provide core functions for ons-lazy-repeat.
 */
var LazyRepeatProvider = function () {

  /**
   * @param {Element} wrapperElement
   * @param {LazyRepeatDelegate} delegate
   */
  function LazyRepeatProvider(wrapperElement, delegate) {
    classCallCheck(this, LazyRepeatProvider);

    if (!(delegate instanceof LazyRepeatDelegate)) {
      util$1.throw('"delegate" parameter must be an instance of LazyRepeatDelegate');
    }

    this._wrapperElement = wrapperElement;
    this._delegate = delegate;
    this._insertIndex = this._wrapperElement.children[0] && this._wrapperElement.children[0].tagName === 'ONS-LAZY-REPEAT' ? 1 : 0;

    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
      wrapperElement.classList.add('lazy-list');
    }

    this._pageContent = this._findPageContentElement(wrapperElement);

    if (!this._pageContent) {
      util$1.throw('LazyRepeat must be descendant of a Page element');
    }

    this.lastScrollTop = this._pageContent.scrollTop;
    this.padding = 0;
    this._topPositions = [0];
    this._renderedItems = {};

    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
      this._unknownItemHeight = true;
    }

    this._addEventListeners();
    this._onChange();
  }

  createClass(LazyRepeatProvider, [{
    key: '_findPageContentElement',
    value: function _findPageContentElement(wrapperElement) {
      var pageContent = util$1.findParent(wrapperElement, '.page__content');

      if (pageContent) {
        return pageContent;
      }

      var page = util$1.findParent(wrapperElement, 'ons-page');
      if (page) {
        var content = util$1.findChild(page, '.content');
        if (content) {
          return content;
        }
      }

      return null;
    }
  }, {
    key: '_checkItemHeight',
    value: function _checkItemHeight(callback) {
      var _this = this;

      this._delegate.loadItemElement(0, function (item) {
        if (!_this._unknownItemHeight) {
          util$1.throw('Invalid state');
        }

        _this._wrapperElement.appendChild(item.element);

        var done = function done() {
          _this._delegate.destroyItem(0, item);
          item.element && item.element.remove();
          delete _this._unknownItemHeight;
          callback();
        };

        _this._itemHeight = item.element.offsetHeight;

        if (_this._itemHeight > 0) {
          done();
          return;
        }

        // retry to measure offset height
        // dirty fix for angular2 directive
        _this._wrapperElement.style.visibility = 'hidden';
        item.element.style.visibility = 'hidden';

        setImmediate(function () {
          _this._itemHeight = item.element.offsetHeight;
          if (_this._itemHeight == 0) {
            util$1.throw('Invalid state: "itemHeight" must be greater than zero');
          }
          _this._wrapperElement.style.visibility = '';
          done();
        });
      });
    }
  }, {
    key: '_countItems',
    value: function _countItems() {
      return this._delegate.countItems();
    }
  }, {
    key: '_getItemHeight',
    value: function _getItemHeight(i) {
      // Item is rendered
      if (this._renderedItems.hasOwnProperty(i)) {
        if (!this._renderedItems[i].hasOwnProperty('height')) {
          this._renderedItems[i].height = this._renderedItems[i].element.offsetHeight;
        }
        return this._renderedItems[i].height;
      }

      // Item is not rendered, scroll up
      if (this._topPositions[i + 1] && this._topPositions[i]) {
        return this._topPositions[i + 1] - this._topPositions[i];
      }
      // Item is not rendered, scroll down
      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
    }
  }, {
    key: '_calculateRenderedHeight',
    value: function _calculateRenderedHeight() {
      var _this2 = this;

      return Object.keys(this._renderedItems).reduce(function (a, b) {
        return a + _this2._getItemHeight(+b);
      }, 0);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._render();
    }
  }, {
    key: '_lastItemRendered',
    value: function _lastItemRendered() {
      return Math.max.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: '_firstItemRendered',
    value: function _firstItemRendered() {
      return Math.min.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      var forceRender = { forceScrollDown: true };
      var firstItemIndex = this._firstItemRendered();

      if (util$1.isInteger(firstItemIndex)) {
        this._wrapperElement.style.height = this._topPositions[firstItemIndex] + this._calculateRenderedHeight() + 'px';
        this.padding = this._topPositions[firstItemIndex];
        forceRender.forceFirstIndex = firstItemIndex;
      }

      this._removeAllElements();
      this._render(forceRender);
      this._wrapperElement.style.height = 'inherit';
    }
  }, {
    key: '_render',
    value: function _render() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$forceScrollDown = _ref.forceScrollDown,
          forceScrollDown = _ref$forceScrollDown === undefined ? false : _ref$forceScrollDown,
          forceFirstIndex = _ref.forceFirstIndex,
          forceLastIndex = _ref.forceLastIndex;

      if (this._unknownItemHeight) {
        return this._checkItemHeight(this._render.bind(this, arguments[0]));
      }

      var isScrollUp = !forceScrollDown && this.lastScrollTop > this._pageContent.scrollTop;
      this.lastScrollTop = this._pageContent.scrollTop;
      var keep = {};

      var offset = this._wrapperElement.getBoundingClientRect().top;
      var limit = 4 * window.innerHeight - offset;
      var count = this._countItems();

      var start = forceFirstIndex || Math.max(0, this._calculateStartIndex(offset) - 30); // Recalculate for 0 or undefined
      var i = start;

      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
        if (i >= this._topPositions.length) {
          // perf optimization
          this._topPositions.length += 100;
        }

        this._topPositions[i] = top;
        top += this._getItemHeight(i);
      }

      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
        return this._delegate._render(start, i, function () {
          _this3.padding = _this3._topPositions[start];
        });
      }

      if (isScrollUp) {
        for (var j = i - 1; j >= start; j--) {
          keep[j] = true;
          this._renderElement(j, isScrollUp);
        }
      } else {
        var lastIndex = forceLastIndex || Math.max.apply(Math, [i - 1].concat(toConsumableArray(Object.keys(this._renderedItems)))); // Recalculate for 0 or undefined
        for (var _j = start; _j <= lastIndex; _j++) {
          keep[_j] = true;
          this._renderElement(_j, isScrollUp);
        }
      }

      Object.keys(this._renderedItems).forEach(function (key) {
        return keep[key] || _this3._removeElement(key, isScrollUp);
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_renderElement',
    value: function _renderElement(index, isScrollUp) {
      var _this4 = this;

      var item = this._renderedItems[index];
      if (item) {
        this._delegate.updateItem(index, item); // update if it exists
        return;
      }

      this._delegate.loadItemElement(index, function (item) {
        if (isScrollUp) {
          _this4._wrapperElement.insertBefore(item.element, _this4._wrapperElement.children[_this4._insertIndex]);
          _this4.padding = _this4._topPositions[index];
          item.height = _this4._topPositions[index + 1] - _this4._topPositions[index];
        } else {
          _this4._wrapperElement.appendChild(item.element);
        }

        _this4._renderedItems[index] = item;
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_removeElement',
    value: function _removeElement(index) {
      var isScrollUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      index = +index;
      var item = this._renderedItems[index];
      this._delegate.destroyItem(index, item);

      if (isScrollUp) {
        this._topPositions[index + 1] = undefined;
      } else {
        this.padding = this.padding + this._getItemHeight(index);
      }

      if (item.element.parentElement) {
        item.element.parentElement.removeChild(item.element);
      }

      delete this._renderedItems[index];
    }
  }, {
    key: '_removeAllElements',
    value: function _removeAllElements() {
      var _this5 = this;

      Object.keys(this._renderedItems).forEach(function (key) {
        return _this5._removeElement(key);
      });
    }
  }, {
    key: '_recalculateTopPositions',
    value: function _recalculateTopPositions(start, end) {
      for (var i = start; i <= end; i++) {
        this._topPositions[i + 1] = this._topPositions[i] + this._getItemHeight(i);
      }
    }
  }, {
    key: '_calculateStartIndex',
    value: function _calculateStartIndex(current) {
      var firstItemIndex = this._firstItemRendered();
      var lastItemIndex = this._lastItemRendered();

      // Fix for Safari scroll and Angular 2
      this._recalculateTopPositions(firstItemIndex, lastItemIndex);

      var start = 0;
      var end = this._countItems() - 1;

      // Binary search for index at top of screen so we can speed up rendering.
      for (;;) {
        var middle = Math.floor((start + end) / 2);
        var value = current + this._topPositions[middle];

        if (end < start) {
          return 0;
        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
          return middle;
        } else if (isNaN(value) || value >= 0) {
          end = middle - 1;
        } else {
          start = middle + 1;
        }
      }
    }
  }, {
    key: '_debounce',
    value: function _debounce(func, wait, immediate) {
      var timeout = void 0;
      return function () {
        var _this6 = this,
            _arguments = arguments;

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        if (callNow) {
          func.apply(this, arguments);
        } else {
          timeout = setTimeout(function () {
            timeout = null;
            func.apply(_this6, _arguments);
          }, wait);
        }
      };
    }
  }, {
    key: '_doubleFireOnTouchend',
    value: function _doubleFireOnTouchend() {
      this._render();
      this._debounce(this._render.bind(this), 100);
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      util$1.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

      if (platform.isIOS()) {
        this._boundOnChange = this._debounce(this._boundOnChange, 30);
      }

      this._pageContent.addEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        util$1.addEventListener(this._pageContent, 'touchmove', this._boundOnChange, { capture: true, passive: true });
        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.addEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        util$1.removeEventListener(this._pageContent, 'touchmove', this._boundOnChange, { capture: true, passive: true });
        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.removeEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._removeAllElements();
      this._delegate.destroy();
      this._parentElement = this._delegate = this._renderedItems = null;
      this._removeEventListeners();
    }
  }, {
    key: 'padding',
    get: function get$$1() {
      return parseInt(this._wrapperElement.style.paddingTop, 10);
    },
    set: function set$$1(newValue) {
      this._wrapperElement.style.paddingTop = newValue + 'px';
    }
  }, {
    key: 'staticItemHeight',
    get: function get$$1() {
      return this._delegate.itemHeight || this._itemHeight;
    }
  }]);
  return LazyRepeatProvider;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @element ons-lazy-repeat
 * @category list
 * @description
 *   [en]
 *     Using this component a list with millions of items can be rendered without a drop in performance.
 *     It does that by "lazily" loading elements into the DOM when they come into view and
 *     removing items from the DOM when they are not visible.
 *   [/en]
 *   [ja]
 *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
 *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
 *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
 *   [/ja]
 * @codepen QwrGBm
 * @tutorial vanilla/Reference/lazy-repeat
 * @seealso ons-list
 *   [en]The `<ons-list>` element is used to render a list.[/en]
 *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]
 * @example
 * <script>
 *   window.addEventListener('load', function() {
 *     var lazyRepeat = document.querySelector('#list');
 *     lazyRepeat.delegate = {
 *      createItemContent: function(i, template) {
 *        var dom = template.cloneNode(true);
 *        dom.innerText = i;
 *
 *        return dom;
 *      },
 *      countItems: function() {
 *        return 10000000;
 *      },
 *      destroyItem: function(index, item) {
 *        console.log('Destroyed item with index: ' + index);
 *      }
 *     };
 *   });
 * </script>
 *
 * <ons-list id="list">
 *   <ons-lazy-repeat>
 *     <ons-list-item></ons-list-item>
 *   </ons-lazy-repeat>
 * </ons-list>
 */

var LazyRepeatElement = function (_BaseElement) {
  inherits(LazyRepeatElement, _BaseElement);

  function LazyRepeatElement() {
    classCallCheck(this, LazyRepeatElement);
    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));
  }

  createClass(LazyRepeatElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      // not very good idea and also not documented
      if (this.hasAttribute('delegate')) {
        this.delegate = window[this.getAttribute('delegate')];
      }
    }

    /**
     * @property delegate
     * @type {Object}
     * @description
     *  [en]Specify a delegate object to load and unload item elements.[/en]
     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
     */

    /**
     * @property delegate.createItemContent
     * @type {Function}
     * @description
     *   [en]
     *     This function should return a `HTMLElement`.
     *
     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
     *   [/en]
     *   [ja]
     *     この関数は`HTMLElement`を返してください。
     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。
     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。
     *   [/ja]
     */

    /**
     * @property delegate.countItems
     * @type {Function}
     * @description
     *   [en]Should return the number of items in the list.[/en]
     *   [ja]リスト内のアイテム数を返してください。[/ja]
     */

    /**
     * @property delegate.calculateItemHeight
     * @type {Function}
     * @description
     *   [en]
     *     Should return the height of an item. The index is provided as an argument.
     *
     *     This is important when rendering lists where the items have different height.
     *
     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
     *   [/en]
     *   [ja]
     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。
     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。
     *     この関数はオプショナルです。もしこの関数が無い場合には、
     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。
     *   [/ja]
     */

    /**
     * @property delegate.destroyItem
     * @type {Function}
     * @description
     *   [en]
     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
     *
     *     The function is optional but may be important in order to avoid memory leaks.
     *   [/en]
     *   [ja]
     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。
     *     アイテムのインデックス値とDOM要素が引数として渡されます。
     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。
     *   [/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Refresh the list. Use this method when the data has changed.[/en]
     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]
     */
    value: function refresh() {
      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._lazyRepeatProvider) {
        this._lazyRepeatProvider.destroy();
        this._lazyRepeatProvider = null;
      }
    }
  }, {
    key: 'delegate',
    set: function set$$1(userDelegate) {
      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

      if (!this._templateElement && this.children[0]) {
        this._templateElement = this.removeChild(this.children[0]);
      }

      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
    },
    get: function get$$1() {
      util$1.throw('No delegate getter');
    }
  }]);
  return LazyRepeatElement;
}(BaseElement);

internal$1.LazyRepeatDelegate = LazyRepeatDelegate;
internal$1.LazyRepeatProvider = LazyRepeatProvider;

onsElements.LazyRepeat = LazyRepeatElement;
customElements.define('ons-lazy-repeat', LazyRepeatElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$4 = 'list-header';
var scheme$8 = { '': 'list-header--*' };

/**
 * @element ons-list-header
 * @category list
 * @description
 *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
 *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
 * @seealso ons-list
 *   [en]The `<ons-list>` component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @modifier material
 *   [en]Display a Material Design list header.[/en]
 *   [ja][/ja]
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListHeaderElement = function (_BaseElement) {
  inherits(ListHeaderElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list header.[/en]
   *   [ja]ヘッダーの表現を指定します。[/ja]
   */

  function ListHeaderElement() {
    classCallCheck(this, ListHeaderElement);

    var _this = possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListHeaderElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$4);
      ModifierUtil.initModifier(this, scheme$8);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$4, scheme$8);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$8);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListHeaderElement;
}(BaseElement);

onsElements.ListHeader = ListHeaderElement;
customElements.define('ons-list-header', ListHeaderElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$5 = 'list-title';
var scheme$9 = { '': 'list-title--*' };

/**
 * @element ons-list-title
 * @category list
 * @description
 *   [en]Represents a list title.[/en]
 *   [ja]リストのタイトルを表現します。[/ja]
 * @example
 * <ons-list-title>List Title</ons-list-title>
 * <ons-list>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 * @modifier material
 *   [en]Display a Material Design list title.[/en]
 *   [ja][/ja]
 */

var ListTitleElement = function (_BaseElement) {
  inherits(ListTitleElement, _BaseElement);

  function ListTitleElement() {
    classCallCheck(this, ListTitleElement);

    var _this = possibleConstructorReturn(this, (ListTitleElement.__proto__ || Object.getPrototypeOf(ListTitleElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListTitleElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$5);
      ModifierUtil.initModifier(this, scheme$9);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$5, scheme$9);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$9);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListTitleElement;
}(BaseElement);

onsElements.ListTitle = ListTitleElement;
customElements.define('ons-list-title', ListTitleElement);

/*
Copyright 2013-2018 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var ListItemAnimator = function (_BaseAnimator) {
  inherits(ListItemAnimator, _BaseAnimator);

  function ListItemAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ListItemAnimator);
    return possibleConstructorReturn(this, (ListItemAnimator.__proto__ || Object.getPrototypeOf(ListItemAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  createClass(ListItemAnimator, [{
    key: 'showExpansion',
    value: function showExpansion(listItem, callback) {
      callback();
    }
  }, {
    key: 'hideExpansion',
    value: function hideExpansion(listItem, callback) {
      callback();
    }
  }]);
  return ListItemAnimator;
}(BaseAnimator);

var SlideListItemAnimator = function (_ListItemAnimator) {
  inherits(SlideListItemAnimator, _ListItemAnimator);

  function SlideListItemAnimator() {
    classCallCheck(this, SlideListItemAnimator);
    return possibleConstructorReturn(this, (SlideListItemAnimator.__proto__ || Object.getPrototypeOf(SlideListItemAnimator)).apply(this, arguments));
  }

  createClass(SlideListItemAnimator, [{
    key: 'showExpansion',
    value: function showExpansion(listItem, callback) {
      this._animateExpansion(listItem, true, callback);
    }
  }, {
    key: 'hideExpansion',
    value: function hideExpansion(listItem, callback) {
      this._animateExpansion(listItem, false, callback);
    }
  }, {
    key: '_animateExpansion',
    value: function _animateExpansion(listItem, shouldOpen, callback) {
      var _animit;

      // To animate the opening of the expansion panel correctly, we need to know its
      // height. To calculate this, we set its height to auto, and then get the computed
      // height and padding. Once this is done, we set the height back to its original value.
      var oldHeight = listItem.expandableContent.style.height;
      var oldDisplay = listItem.expandableContent.style.display;
      listItem.expandableContent.style.height = 'auto';
      listItem.expandableContent.style.display = 'block';
      var computedStyle = window.getComputedStyle(listItem.expandableContent);

      var expansionOpenTransition = [{ height: 0, paddingTop: 0, paddingBottom: 0 }, {
        height: computedStyle.height,
        paddingTop: computedStyle.paddingTop,
        paddingBottom: computedStyle.paddingBottom
      }];
      var iconOpenTransition = [{ transform: 'rotate(45deg)' }, { transform: 'rotate(225deg)' }];

      // Now that we have the values we need, reset the height back to its original state
      listItem.expandableContent.style.height = oldHeight;

      (_animit = Animit(listItem.expandableContent, { duration: this.duration, property: 'height padding-top padding-bottom' })).default.apply(_animit, toConsumableArray(shouldOpen ? expansionOpenTransition : expansionOpenTransition.reverse())).play(function () {
        listItem.expandableContent.style.display = oldDisplay;
        callback && callback();
      });

      if (listItem.expandChevron) {
        var _animit2;

        (_animit2 = Animit(listItem.expandChevron, { duration: this.duration, property: 'transform' })).default.apply(_animit2, toConsumableArray(shouldOpen ? iconOpenTransition : iconOpenTransition.reverse())).play();
      }
    }
  }]);
  return SlideListItemAnimator;
}(ListItemAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$6 = 'list-item';
var scheme$10 = {
  '.list-item': 'list-item--*',
  '.list-item__left': 'list-item--*__left',
  '.list-item__center': 'list-item--*__center',
  '.list-item__right': 'list-item--*__right',
  '.list-item__label': 'list-item--*__label',
  '.list-item__title': 'list-item--*__title',
  '.list-item__subtitle': 'list-item--*__subtitle',
  '.list-item__thumbnail': 'list-item--*__thumbnail',
  '.list-item__icon': 'list-item--*__icon'
};

var _animatorDict$3 = {
  'default': SlideListItemAnimator,
  'none': ListItemAnimator
};

/**
 * @element ons-list-item
 * @category list
 * @modifier tappable
 *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
 *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
 * @modifier chevron
 *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped.[/en]
 *   [ja][/ja]
 * @modifier longdivider
 *   [en]Displays a long horizontal divider between items.[/en]
 *   [ja][/ja]
 * @modifier nodivider
 *   [en]Removes the divider between list items.[/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design list item.[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Component that represents each item in a list. The list item is composed of four parts that are represented with the `left`, `center`, `right` and `expandable-content` classes. These classes can be used to ensure that the content of the list items is properly aligned.
 *
 *     ```
 *     <ons-list-item>
 *       <div class="left">Left</div>
 *       <div class="center">Center</div>
 *       <div class="right">Right</div>
 *       <div class="expandable-content">Expandable content</div>
 *     </ons-list-item>
 *     ```
 *
 *     There are also a number of classes (prefixed with `list-item__*`) that help when putting things like icons and thumbnails into the list items.
 *   [/en]
 *   [ja][/ja]
 * @seealso ons-list
 *   [en]ons-list component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list-item>
 *   <div class="left">
 *     <ons-icon icon="md-face" class="list-item__icon"></ons-icon>
 *   </div>
 *   <div class="center">
 *     <div class="list-item__title">Title</div>
 *     <div class="list-item__subtitle">Subtitle</div>
 *   </div>
 *   <div class="right">
 *     <ons-switch></ons-switch>
 *   </div>
 * </ons-list-item>
 */

var ListItemElement = function (_BaseElement) {
  inherits(ListItemElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list item.[/en]
   *   [ja]各要素の表現を指定します。[/ja]
   */

  /**
   * @attribute lock-on-drag
   * @type {String}
   * @description
   *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
   *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
   */

  /**
   * @attribute tappable
   * @type {Boolean}
   * @description
   *   [en]Makes the element react to taps. `prevent-tap` attribute can be added to child elements like buttons or inputs to prevent this effect. `ons-*` elements are ignored by default.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute tap-background-color
   * @type {Color}
   * @description
   *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute expandable
   * @type {Boolean}
   * @description
   *   [en]Makes the element able to be expanded to reveal extra content. For this to work, the expandable content must be defined in `div.expandable-content`.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the expandable content. Can be either `"default"` or `"none"`.[/en]
   *  [ja][/ja]
   */

  function ListItemElement() {
    classCallCheck(this, ListItemElement);

    var _this = possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).call(this));

    _this._animatorFactory = _this._updateAnimatorFactory();
    _this.toggleExpansion = _this.toggleExpansion.bind(_this);

    // Elements ignored when tapping
    var re = /^ons-(?!col$|row$|if$)/i;
    _this._shouldIgnoreTap = function (e) {
      return e.hasAttribute('prevent-tap') || re.test(e.tagName);
    };

    // show and hide functions for Vue hidable mixin
    _this.show = _this.showExpansion;
    _this.hide = _this.hideExpansion;

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(ListItemElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$6);

      if (this.hasAttribute('expandable')) {
        this.classList.add('list-item--expandable');
      }

      var left = void 0,
          center = void 0,
          right = void 0,
          top = void 0,
          expandableContent = void 0;

      var childEls = util$1.getAllChildNodes(this);

      for (var i = 0; i < childEls.length; i++) {
        var el = childEls[i];

        if (el.classList.contains('left')) {
          el.classList.add('list-item__left');
          left = el;
        } else if (el.classList.contains('center')) {
          center = el;
        } else if (el.classList.contains('right')) {
          el.classList.add('list-item__right');
          right = el;
        } else if (el.classList.contains('top')) {
          el.classList.add('list-item__top');
          top = el;
        } else if (el.classList.contains('expandable-content')) {
          el.classList.add('list-item__expandable-content');
          expandableContent = el;
        }
      }

      if (!right && this.hasAttribute('expandable')) {
        right = document.createElement('div');
        right.classList.add('list-item__right', 'right');

        // We cannot use a pseudo-element for this chevron, as we cannot animate it using
        // JS. So, we make a chevron span instead.
        var chevron = document.createElement('span');
        chevron.classList.add('list-item__expand-chevron');
        right.appendChild(chevron);
      }

      if (!center) {
        center = document.createElement('div');

        if (!left && !right && !expandableContent) {
          while (this.childNodes[0]) {
            center.appendChild(this.childNodes[0]);
          }
        } else {
          for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
            var _el = this.childNodes[_i];
            if (_el !== left && _el !== right && _el !== expandableContent && _el.tagName !== 'ONS-RIPPLE') {
              center.insertBefore(_el, center.firstChild);
            }
          }
        }

        if (!expandableContent) {
          this.insertBefore(center, right || null);
        }
      }

      center.classList.add('center', 'list-item__center');

      if (expandableContent) {
        // create 'top' div
        // this holds everything except the expandable content
        this._top = top || document.createElement('div');
        this._top.classList.add('top', 'list-item__top');
        this.appendChild(this._top);

        this._top.appendChild(center);
        if (left) {
          this._top.appendChild(left);
        }
        if (right) {
          this._top.appendChild(right);
        }
      }

      util$1.updateRipple(this);

      ModifierUtil.initModifier(this, scheme$10);
    }

    /**
     * @method showExpansion
     * @signature showExpansion()
     * @description
     *   [en]Show the expandable content if the element is expandable.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'showExpansion',
    value: function showExpansion() {
      var _this2 = this;

      if (this.hasAttribute('expandable') && !this._expanding) {
        this.expanded = true;
        this._expanding = true;

        var animator = this._animatorFactory.newAnimator();
        animator.showExpansion(this, function () {
          _this2.classList.add('expanded');
          _this2._expanding = false;
        });
      }
    }

    /**
     * @method hideExpansion
     * @signature hideExpansion()
     * @description
     *   [en]Hide the expandable content if the element expandable.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hideExpansion',
    value: function hideExpansion() {
      var _this3 = this;

      if (this.hasAttribute('expandable') && !this._expanding) {
        this.expanded = false;
        this._expanding = true;

        var animator = this._animatorFactory.newAnimator();
        animator.hideExpansion(this, function () {
          _this3.classList.remove('expanded');
          _this3._expanding = false;
        });
      }
    }
  }, {
    key: 'toggleExpansion',
    value: function toggleExpansion() {
      this.classList.contains('expanded') ? this.hideExpansion() : this.showExpansion();
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$3,
        baseClass: ListItemAnimator,
        baseClassName: 'ListItemAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$6, scheme$10);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$10);
          break;
        case 'ripple':
          util$1.updateRipple(this);
          break;
        case 'animation':
          this._animatorFactory = this._updateAnimatorFactory();
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._setupListeners(true);
        _this4._originalBackgroundColor = _this4.style.backgroundColor;
        _this4.tapped = false;
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._setupListeners(false);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var action = (add ? 'add' : 'remove') + 'EventListener';
      util$1[action](this, 'touchstart', this._onTouch, { passive: true });
      util$1[action](this, 'touchmove', this._onRelease, { passive: true });
      this[action]('touchcancel', this._onRelease);
      this[action]('touchend', this._onRelease);
      this[action]('touchleave', this._onRelease);
      this[action]('drag', this._onDrag);
      this[action]('mousedown', this._onTouch);
      this[action]('mouseup', this._onRelease);
      this[action]('mouseout', this._onRelease);

      if (this._top) {
        this._top[action]('click', this.toggleExpansion);
      }
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var gesture = event.gesture;
      // Prevent vertical scrolling if the users pans left or right.
      if (this.hasAttribute('lock-on-drag') && ['left', 'right'].indexOf(gesture.direction) > -1) {
        gesture.preventDefault();
      }
    }
  }, {
    key: '_onTouch',
    value: function _onTouch(e) {
      var _this5 = this;

      if (this.tapped || this !== e.target && (this._shouldIgnoreTap(e.target) || util$1.findParent(e.target, this._shouldIgnoreTap, function (p) {
        return p === _this5;
      }))) {
        return; // Ignore tap
      }

      this.tapped = true;
      var touchStyle = { transition: 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s' };

      if (this.hasAttribute('tappable')) {
        if (this.style.backgroundColor) {
          this._originalBackgroundColor = this.style.backgroundColor;
        }

        touchStyle.backgroundColor = this.getAttribute('tap-background-color') || '#d9d9d9';
        touchStyle.boxShadow = '0px -1px 0px 0px ' + touchStyle.backgroundColor;
      }

      styler(this, touchStyle);
    }
  }, {
    key: '_onRelease',
    value: function _onRelease() {
      this.tapped = false;
      this.style.backgroundColor = this._originalBackgroundColor || '';
      styler.clear(this, 'transition boxShadow');
    }
  }, {
    key: 'expandableContent',
    get: function get$$1() {
      return this.querySelector('.list-item__expandable-content');
    }
  }, {
    key: 'expandChevron',
    get: function get$$1() {
      return this.querySelector('.list-item__expand-chevron');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class', 'ripple', 'animation'];
    }
  }]);
  return ListItemElement;
}(BaseElement);

onsElements.ListItem = ListItemElement;
customElements.define('ons-list-item', ListItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$7 = 'list';
var scheme$11 = { '': 'list--*' };

/**
 * @element ons-list
 * @category list
 * @modifier inset
 *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
 *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
 * @modifier noborder
 *   [en]A list with no borders at the top and bottom.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
 *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
 * @seealso ons-list-item
 *   [en]ons-list-item component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @seealso ons-lazy-repeat
 *   [en]ons-lazy-repeat component[/en]
 *   [ja]ons-lazy-repeatコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListElement = function (_BaseElement) {
  inherits(ListElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list.[/en]
   *   [ja]リストの表現を指定します。[/ja]
   */

  function ListElement() {
    classCallCheck(this, ListElement);

    var _this = possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$7);
      ModifierUtil.initModifier(this, scheme$11);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$7, scheme$11);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$11);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListElement;
}(BaseElement);

onsElements.List = ListElement;
customElements.define('ons-list', ListElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'step', 'validator', 'value'];

var BaseInputElement = function (_BaseElement) {
  inherits(BaseInputElement, _BaseElement);
  createClass(BaseInputElement, [{
    key: '_update',
    value: function _update() {} // Optionally implemented

  }, {
    key: '_scheme',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: '_template',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: 'type',
    get: function get$$1() {
      util$1.throwMember();
    }
  }]);

  function BaseInputElement() {
    classCallCheck(this, BaseInputElement);

    var _this = possibleConstructorReturn(this, (BaseInputElement.__proto__ || Object.getPrototypeOf(BaseInputElement)).call(this));

    if (_this.constructor === BaseInputElement) {
      util$1.throwAbstract();
    }

    contentReady(_this, function () {
      return _this._compile();
    });
    _this._boundDelegateEvent = _this._delegateEvent.bind(_this);
    return _this;
  }

  createClass(BaseInputElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._defaultClassName && this.classList.add(this._defaultClassName);

      if (this.children.length !== 0) {
        return;
      }

      this.appendChild(util$1.createFragment(this._template));

      this._setInputId();

      this._updateBoundAttributes();

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this2 = this;

      INPUT_ATTRIBUTES.forEach(function (attr) {
        if (_this2.hasAttribute(attr)) {
          _this2._input.setAttribute(attr, _this2.getAttribute(attr));
        } else {
          _this2._input.removeAttribute(attr);
        }
      });

      this._update();
    }
  }, {
    key: '_delegateEvent',
    value: function _delegateEvent(event) {
      var e = new CustomEvent(event.type, {
        bubbles: false,
        cancelable: true
      });

      return this.dispatchEvent(e);
    }
  }, {
    key: '_setInputId',
    value: function _setInputId() {
      if (this.hasAttribute('input-id')) {
        this._input.id = this.getAttribute('input-id');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._input.addEventListener('focus', _this3._boundDelegateEvent);
        _this3._input.addEventListener('blur', _this3._boundDelegateEvent);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._input.removeEventListener('focus', _this4._boundDelegateEvent);
        _this4._input.removeEventListener('blur', _this4._boundDelegateEvent);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, _this5._scheme);
          });
          break;
        case 'input-id':
          contentReady(this, function () {
            return _this5._setInputId();
          });
          break;
        case 'class':
          util$1.restoreClass(this, this._defaultClassName, this._scheme);
          break;
      }

      if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this5._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return '';
    }
  }, {
    key: '_input',
    get: function get$$1() {
      return this.querySelector('input');
    }
  }, {
    key: 'value',
    get: function get$$1() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set$$1(val) {
      var _this6 = this;

      contentReady(this, function () {
        if (val instanceof Date) {
          val = val.toISOString().substring(0, 10);
        }
        _this6._input.value = val;
        _this6._update();
      });
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'input-id', 'class'].concat(INPUT_ATTRIBUTES);
    }
  }]);
  return BaseInputElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$12 = {
  '.text-input': 'text-input--*',
  '.text-input__label': 'text-input--*__label'
};

/**
 * @element ons-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a text input.[/en]
 *  [ja][/ja]
 * @modifier transparent
 *  [en]Displays a transparent input. Works for Material Design.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    An input element. The `type` attribute can be used to change the input type. All text input types are supported.
 *
 *    The component will automatically render as a Material Design input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/input
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-input placeholder="Username" float></ons-input>
 */

var InputElement = function (_BaseInputElement) {
  inherits(InputElement, _BaseInputElement);

  function InputElement() {
    classCallCheck(this, InputElement);

    var _this = possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).call(this));

    _this._boundOnInput = _this._update.bind(_this);
    _this._boundOnFocusin = _this._update.bind(_this);
    return _this;
  }

  /* Inherited props */

  createClass(InputElement, [{
    key: '_update',
    value: function _update() {
      this._updateLabel();
      this._updateLabelClass();
    }
  }, {
    key: '_updateLabel',


    /* Own props */

    value: function _updateLabel() {
      var label = this.getAttribute('placeholder') || '';

      if (typeof this._helper.textContent !== 'undefined') {
        this._helper.textContent = label;
      } else {
        this._helper.innerText = label;
      }
    }
  }, {
    key: '_updateLabelClass',
    value: function _updateLabelClass() {
      if (this.value === '') {
        this._helper.classList.remove('text-input--material__label--active');
      } else {
        this._helper.classList.add('text-input--material__label--active');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'connectedCallback', this).call(this);

      contentReady(this, function () {
        _this2._input.addEventListener('input', _this2._boundOnInput);
        _this2._input.addEventListener('focusin', _this2._boundOnFocusin);
      });

      var type = this.getAttribute('type');
      if (['checkbox', 'radio'].indexOf(type) >= 0) {
        util$1.warn('Warn: <ons-input type="' + type + '"> is deprecated since v2.4.0. Use <ons-' + type + '> instead.');
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'disconnectedCallback', this).call(this);

      contentReady(this, function () {
        _this3._input.removeEventListener('input', _this3._boundOnInput);
        _this3._input.removeEventListener('focusin', _this3._boundOnFocusin);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this4 = this;

      switch (name) {
        case 'type':
          contentReady(this, function () {
            return _this4._input.setAttribute('type', _this4.type);
          });
          break;
        default:
          get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @attribute placeholder
     * @type {String}
     * @description
     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute float
     * @description
     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]
     */

    /**
     * @attribute type
     * @type {String}
     * @description
     *  [en]
     *    Specify the input type. This is the same as the "type" attribute for normal inputs. It expects strict text types such as `text`, `password`, etc. For checkbox, radio button, select or range, please have a look at the corresponding elements.
     *
     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
     *  [/en]
     *  [ja][/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$12;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="text-input">\n      <span class="text-input__label"></span>\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      var type = this.getAttribute('type');
      return ['checkbox', 'radio'].indexOf(type) < 0 && type || 'text';
    }
  }, {
    key: '_helper',
    get: function get$$1() {
      return this.querySelector('span');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(InputElement.__proto__ || Object.getPrototypeOf(InputElement), 'observedAttributes', this)), ['type']);
    }
  }]);
  return InputElement;
}(BaseInputElement);

onsElements.Input = InputElement;
customElements.define('ons-input', InputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var BaseCheckboxElement = function (_BaseInputElement) {
  inherits(BaseCheckboxElement, _BaseInputElement);

  function BaseCheckboxElement() {
    classCallCheck(this, BaseCheckboxElement);

    var _this = possibleConstructorReturn(this, (BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement)).call(this));

    if (_this.constructor === BaseCheckboxElement) {
      util.throwAbstract();
    }

    contentReady(_this, function () {
      _this.attributeChangedCallback('checked', null, _this.getAttribute('checked'));
    });
    return _this;
  }

  /* Inherited props */

  createClass(BaseCheckboxElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'checked':
          this.checked = current !== null;
          break;
        default:
          get(BaseCheckboxElement.prototype.__proto__ || Object.getPrototypeOf(BaseCheckboxElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <span class="' + this._defaultClassName + '__checkmark"></span>\n    ';
    }

    /* Own props */

  }, {
    key: '_helper',
    get: function get$$1() {
      return this.querySelector('span');
    }
  }, {
    key: 'checked',
    get: function get$$1() {
      return this._input.checked;
    },
    set: function set$$1(val) {
      var _this2 = this;

      contentReady(this, function () {
        _this2._input.checked = val;
      });
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement), 'observedAttributes', this)), ['checked']);
    }
  }]);
  return BaseCheckboxElement;
}(BaseInputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$13 = {
  '.checkbox': 'checkbox--*',
  '.checkbox__input': 'checkbox--*__input',
  '.checkbox__checkmark': 'checkbox--*__checkmark'
};

/**
 * @element ons-checkbox
 * @category form
 * @modifier material
 *  [en]Displays a Material Design checkbox.[/en]
 *  [ja][/ja]
 * @modifier noborder
 *  [en]iOS borderless checkbox.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A checkbox element. The component will automatically render as a Material Design checkbox on Android devices.
 *
 *    Most attributes that can be used for a normal `<input type="checkbox">` element can also be used on the `<ons-checkbox>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/checkbox
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-search-input
 *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-checkbox checked></ons-checkbox>
 */

var CheckboxElement = function (_BaseCheckboxElement) {
  inherits(CheckboxElement, _BaseCheckboxElement);

  function CheckboxElement() {
    classCallCheck(this, CheckboxElement);
    return possibleConstructorReturn(this, (CheckboxElement.__proto__ || Object.getPrototypeOf(CheckboxElement)).apply(this, arguments));
  }

  createClass(CheckboxElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$13;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'checkbox';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'checkbox';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the checkbox.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the checkbox is checked or not.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the checkbox is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return CheckboxElement;
}(BaseCheckboxElement);

onsElements.Checkbox = CheckboxElement;
customElements.define('ons-checkbox', CheckboxElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$14 = {
  '.radio-button': 'radio-button--*',
  '.radio-button__input': 'radio-button--*__input',
  '.radio-button__checkmark': 'radio-button--*__checkmark'
};

/**
 * @element ons-radio
 * @category form
 * @modifier material
 *  [en]Displays a Material Design radio button.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A radio button element. The component will automatically render as a Material Design radio button on Android devices.
 *
 *    Most attributes that can be used for a normal `<input type="radio">` element can also be used on the `<ons-radio>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/radio
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-search-input
 *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-radio checked></ons-radio>
 */

var RadioElement = function (_BaseCheckboxElement) {
  inherits(RadioElement, _BaseCheckboxElement);

  function RadioElement() {
    classCallCheck(this, RadioElement);
    return possibleConstructorReturn(this, (RadioElement.__proto__ || Object.getPrototypeOf(RadioElement)).apply(this, arguments));
  }

  createClass(RadioElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$14;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'radio-button';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'radio';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the radio button.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the radio button is checked or not.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the radio button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return RadioElement;
}(BaseCheckboxElement);

onsElements.Radio = RadioElement;
customElements.define('ons-radio', RadioElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$15 = {
  '.search-input': 'search-input--*'
};

/**
 * @element ons-search-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design search input.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A search input element. The component will automatically render as a Material Design search input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-search-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/search-input
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-search-input placeholder="Search"></ons-search-input>
 */

var SearchInputElement = function (_BaseInputElement) {
  inherits(SearchInputElement, _BaseInputElement);

  function SearchInputElement() {
    classCallCheck(this, SearchInputElement);
    return possibleConstructorReturn(this, (SearchInputElement.__proto__ || Object.getPrototypeOf(SearchInputElement)).apply(this, arguments));
  }

  createClass(SearchInputElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$15;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="search-input">\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'search';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return SearchInputElement;
}(BaseInputElement);

onsElements.SearchInput = SearchInputElement;
customElements.define('ons-search-input', SearchInputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModalAnimator = function (_BaseAnimator) {
  inherits(ModalAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ModalAnimator);
    return possibleConstructorReturn(this, (ModalAnimator.__proto__ || Object.getPrototypeOf(ModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ModalAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeModalAnimator = function (_ModalAnimator) {
  inherits(FadeModalAnimator, _ModalAnimator);

  function FadeModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeModalAnimator);
    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(FadeModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ opacity: 0 }, { opacity: 1 }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for modal.
 */

var LiftModalAnimator = function (_ModalAnimator) {
  inherits(LiftModalAnimator, _ModalAnimator);

  function LiftModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier( .1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, LiftModalAnimator);
    return possibleConstructorReturn(this, (LiftModalAnimator.__proto__ || Object.getPrototypeOf(LiftModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(LiftModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ transform: 'translate3d(0, 100%, 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, 100%, 0)' }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return LiftModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$16 = {
  '': 'modal--*',
  'modal__content': 'modal--*__content'
};

var defaultClassName$8 = 'modal';

var _animatorDict$4 = {
  'default': ModalAnimator,
  'fade': FadeModalAnimator,
  'lift': LiftModalAnimator,
  'none': ModalAnimator
};

/**
 * @element ons-modal
 * @category dialog
 * @description
 *   [en]
 *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
 *
 *     This component can be used to block user input while some operation is running or to show some information to the user.
 *   [/en]
 *   [ja]
 *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
 *     モーダルが表示されている間はイベント通知が行われません。
 *   [/ja]
 * @seealso ons-dialog
 *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
 *   [ja][/ja]
 * @codepen devIg
 * @tutorial vanilla/reference/modal
 * @example
 * <ons-modal id="modal">
 *   Modal content
 * </ons-modal>
 * <script>
 *   var modal = document.getElementById('modal');
 *   modal.show();
 * </script>
 */

var ModalElement = function (_BaseDialogElement) {
  inherits(ModalElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the modal is displayed.[/en]
   * [ja]モーダルが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the modal from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the modal is displayed.[/en]
   * [ja]モーダルが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the modal is hidden.[/en]
   * [ja]モーダルが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the modal from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the modal is hidden.[/en]
   * [ja]モーダルが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the modal. Can be either `"none"`, `"fade"` or `"lift"`.[/en]
   *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade","lift"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
   */

  function ModalElement() {
    classCallCheck(this, ModalElement);

    var _this = possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).call(this));

    _this._defaultDBB = function () {
      return undefined;
    };
    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ModalElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$4,
        baseClass: ModalAnimator,
        baseClassName: 'ModalAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      this.style.display = 'none';
      this.style.zIndex = 10001;
      this.classList.add(defaultClassName$8);

      if (!util$1.findChild(this, '.modal__content')) {
        var content = document.createElement('div');
        content.classList.add('modal__content');

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          content.insertBefore(node, null);
        }

        this.appendChild(content);
      }

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      this.style.display = shouldShow ? 'table' : 'none';
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'connectedCallback', this).call(this);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'disconnectedCallback', this).call(this);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Show modal.[/en]
     *   [ja]モーダルを表示します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Toggle modal visibility.[/en]
     *   [ja]モーダルの表示を切り替えます。[/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide modal.[/en]
     *   [ja]モーダルを非表示にします。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'class') {
        util$1.restoreClass(this, defaultClassName$8, scheme$16);
      } else {
        get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$16;
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ModalAnimator)) {
        util$1.throwAnimator('Modal');
      }
      _animatorDict$4[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(ModalElement.__proto__ || Object.getPrototypeOf(ModalElement), 'observedAttributes', this)), ['class']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$4;
    }
  }, {
    key: 'ModalAnimator',
    get: function get$$1() {
      return ModalAnimator;
    }
  }]);
  return ModalElement;
}(BaseDialogElement);

onsElements.Modal = ModalElement;
customElements.define('ons-modal', ModalElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var widthToPx = function widthToPx(width) {
  var _ref = [parseInt(width, 10), /px/.test(width)],
      value = _ref[0],
      px = _ref[1];

  return px ? value : Math.round(document.body.offsetWidth * value / 100);
};

var SwipeReveal = function () {
  function SwipeReveal(params) {
    var _this = this;

    classCallCheck(this, SwipeReveal);

    'element ignoreSwipe isInitialState onDragCallback swipeMax swipeMin swipeMid'.split(/\s+/).forEach(function (key) {
      return _this[key] = params[key];
    });

    this.elementHandler = params.elementHandler || params.element;
    this.getThreshold = params.getThreshold || function () {
      return .5;
    };
    this.getSide = params.getSide || function () {
      return 'left';
    };

    this.handleGesture = this.handleGesture.bind(this);

    this._shouldFixScroll = util$1.globals.actualMobileOS === 'ios';
  }

  createClass(SwipeReveal, [{
    key: 'update',
    value: function update() {
      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element.hasAttribute('swipeable');

      if (!this.gestureDetector) {
        this.gestureDetector = new GestureDetector(this.elementHandler, { dragMinDistance: 1, passive: !this._shouldFixScroll });
      }

      var action = swipeable ? 'on' : 'off';
      this.gestureDetector[action]('drag dragstart dragend', this.handleGesture);
    }
  }, {
    key: 'handleGesture',
    value: function handleGesture(e) {
      if (e.gesture) {
        if (e.type === 'dragstart') {
          this.onDragStart(e);
        } else if (!this._ignoreDrag) {
          e.type === 'dragend' ? this.onDragEnd(e) : this.onDrag(e);
        }
      }
    }
  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      var _this2 = this;

      var getDistance = function getDistance() {
        return _this2.getSide() === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
      };
      this._ignoreDrag = event.consumed || !util$1.isValidGesture(event) || this.ignoreSwipe(event, getDistance());

      if (!this._ignoreDrag) {
        event.consume && event.consume();
        event.consumed = true;

        this._width = widthToPx(this.element.style.width || '100%');
        this._startDistance = this._distance = !(this.isInitialState instanceof Function) || this.isInitialState() ? 0 : this._width;

        util$1.iosPreventScroll(this.gestureDetector);
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(event) {
      event.stopPropagation();

      var delta = this.getSide() === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
      if (distance !== this._distance) {
        this._distance = distance;
        this.swipeMid(this._distance, this._width);
      }
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(event) {
      event.stopPropagation();

      var direction = event.gesture.interimDirection;
      var isSwipeMax = this.getSide() !== direction && this._distance > this._width * this.getThreshold();
      isSwipeMax ? this.swipeMax() : this.swipeMin();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this.gestureDetector && this.gestureDetector.dispose();
      this.gestureDetector = this.element = this.elementHandler = null;
    }
  }]);
  return SwipeReveal;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NavigatorAnimator = function (_BaseAnimator) {
  inherits(NavigatorAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function NavigatorAnimator(options) {
    classCallCheck(this, NavigatorAnimator);

    options = util$1.extend({
      timing: 'linear',
      duration: '0.4',
      delay: '0'
    }, options || {});

    return possibleConstructorReturn(this, (NavigatorAnimator.__proto__ || Object.getPrototypeOf(NavigatorAnimator)).call(this, options));
  }

  createClass(NavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'block',
    value: function block(page) {
      var blocker = util$1.createElement('\n      <div style="position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000"></div>\n    ');
      page.parentNode.appendChild(blocker);
      return function () {
        return blocker.remove();
      };
    }
  }]);
  return NavigatorAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Abstract swipe animator for iOS navigator transition.
 */

var IOSSwipeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSSwipeNavigatorAnimator, _NavigatorAnimator);
  createClass(IOSSwipeNavigatorAnimator, null, [{
    key: 'swipeable',
    get: function get$$1() {
      return true;
    }
  }]);

  function IOSSwipeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$durationRestore = _ref.durationRestore,
        durationRestore = _ref$durationRestore === undefined ? 0.1 : _ref$durationRestore,
        _ref$durationSwipe = _ref.durationSwipe,
        durationSwipe = _ref$durationSwipe === undefined ? 0.15 : _ref$durationSwipe,
        _ref$timingSwipe = _ref.timingSwipe,
        timingSwipe = _ref$timingSwipe === undefined ? 'linear' : _ref$timingSwipe,
        rest = objectWithoutProperties(_ref, ['durationRestore', 'durationSwipe', 'timingSwipe']);
    classCallCheck(this, IOSSwipeNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSSwipeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator)).call(this, _extends({}, rest)));

    if (_this.constructor === IOSSwipeNavigatorAnimator) {
      util$1.throwAbstract();
    }

    _this.durationRestore = durationRestore;
    _this.durationSwipe = durationSwipe;
    _this.timingSwipe = timingSwipe;

    _this.optSwipe = { timing: timingSwipe, duration: durationSwipe };
    _this.optRestore = { timing: timingSwipe, duration: durationRestore };

    _this.swipeShadow = util$1.createElement('<div style="position: absolute; height: 100%; width: 12px; right: 100%; top: 0; bottom: 0; z-index: -1;' + 'background: linear-gradient(to right, transparent 0, rgba(0,0,0,.04) 40%, rgba(0,0,0,.12) 80%, rgba(0,0,0,.16) 100%);"></div>');

    _this.isDragStart = true;
    return _this;
  }

  createClass(IOSSwipeNavigatorAnimator, [{
    key: '_decompose',
    value: function _decompose() {
      util$1.throwMember();
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar() {
      util$1.throwMember();
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta() {
      util$1.throwMember();
    }
  }, {
    key: '_dragStartSetup',
    value: function _dragStartSetup(enterPage, leavePage) {
      this.isDragStart = false;

      // Avoid content clicks
      this.unblock = get(IOSSwipeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator.prototype), 'block', this).call(this, leavePage);

      // Mask
      enterPage.parentElement.insertBefore(this.backgroundMask, enterPage);

      // Decomposition
      this.target = {
        enter: util$1.findToolbarPage(enterPage) || enterPage,
        leave: util$1.findToolbarPage(leavePage) || leavePage
      };
      this.decomp = {
        enter: this._decompose(this.target.enter),
        leave: this._decompose(this.target.leave)
      };

      // Animation values
      this.delta = this._calculateDelta(leavePage, this.decomp.leave);
      this.shouldAnimateToolbar = this._shouldAnimateToolbar(this.target.enter, this.target.leave);

      // Shadow && styles
      if (this.shouldAnimateToolbar) {
        this.swipeShadow.style.top = this.decomp.leave.toolbar.offsetHeight + 'px';
        this.target.leave.appendChild(this.swipeShadow);
        this._saveStyle(this.target.enter, this.target.leave);
      } else {
        leavePage.appendChild(this.swipeShadow);
        this._saveStyle(enterPage, leavePage);
      }
      leavePage.classList.add('overflow-visible');
      this.overflowElement = leavePage;
      this.decomp.leave.content.classList.add('content-swiping');
    }
  }, {
    key: 'translate',
    value: function translate(distance, maxWidth, enterPage, leavePage) {
      this.isSwiping = true;

      if (enterPage.style.display === 'none') {
        enterPage.style.display = '';
      }

      if (this.isDragStart) {
        this.maxWidth = maxWidth;
        this._dragStartSetup(enterPage, leavePage);
      }

      var swipeRatio = (distance - maxWidth) / maxWidth;

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
        }), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(' + this.delta.title * swipeRatio + 'px, 0, 0)',
          opacity: 1 + swipeRatio // 0 -> 1
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          opacity: 1 + swipeRatio * 10 / 100, // 0.9 -> 1
          transform: 'translate3d(' + this.delta.label * swipeRatio + 'px, 0, 0)'
        }), Animit(this.decomp.enter.other).queue({
          opacity: 1 + swipeRatio // 0 -> 1
        }),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
          transform: 'translate3d(' + distance + 'px, 0, 0)'
        }), Animit(this.decomp.leave.toolbar).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(' + (1 + swipeRatio) * 125 + '%, 0, 0)'
        }), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: -1 * swipeRatio, // 1 -> 0
          transform: 'translate3d(' + this.delta.title * (1 + swipeRatio) + 'px, 0, 0)'
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }));
      } else {
        Animit.runAll(Animit(leavePage).queue({
          transform: 'translate3d(' + distance + 'px, 0, 0)'
        }), Animit(enterPage).queue({
          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
        }), Animit(this.swipeShadow).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }));
      }
    }
  }, {
    key: 'restore',
    value: function restore(enterPage, leavePage, callback) {
      var _this2 = this;

      if (this.isDragStart) {
        return;
      }

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(-25%, 0, 0)',
          opacity: 0.9
        }, this.optRestore), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(-' + this.delta.title + 'px, 0, 0)',
          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timingSwipe,
          opacity: 0
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          transform: 'translate3d(-' + this.delta.label + 'px, 0, 0)'
        }, this.optRestore), Animit(this.decomp.enter.other).queue({
          opacity: 0
        }, this.optRestore),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
          transform: 'translate3d(0, 0, 0)'
        }, this.optRestore), Animit(this.decomp.leave.toolbar).queue({
          opacity: 1
        }, this.optRestore), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(0, 0, 0)'
        }, this.optRestore), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: 1,
          transform: 'translate3d(0, 0, 0)',
          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timingSwipe
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: 0
        }, this.optRestore).queue(function (done) {
          _this2._reset(_this2.target.enter, _this2.target.leave);
          enterPage.style.display = 'none';
          callback && callback();
          done();
        }));
      } else {
        Animit.runAll(Animit(enterPage).queue({
          transform: 'translate3D(-25%, 0, 0)',
          opacity: 0.9
        }, this.optRestore), Animit(leavePage).queue({
          transform: 'translate3D(0, 0, 0)'
        }, this.optRestore).queue(function (done) {
          _this2._reset(enterPage, leavePage);
          enterPage.style.display = 'none';
          callback && callback();
          done();
        }));
      }
    }
  }, {
    key: 'popSwipe',
    value: function popSwipe(enterPage, leavePage, callback) {
      var _this3 = this;

      if (this.isDragStart) {
        return;
      }

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(0, 0, 0)',
          opacity: 1
        }, this.optSwipe), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(0, 0, 0)',
          transition: 'opacity ' + this.durationSwipe + 's linear, transform ' + this.durationSwipe + 's ' + this.timingSwipe,
          opacity: 1
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          transform: 'translate3d(0, 0, 0)'
        }, this.optSwipe), Animit(this.decomp.enter.other).queue({
          opacity: 1
        }, this.optSwipe),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background]).queue({
          transform: 'translate3d(100%, 0, 0)'
        }, this.optSwipe), Animit(this.decomp.leave.toolbar).queue({
          opacity: 0
        }, this.optSwipe), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(125%, 0, 0)'
        }, this.optSwipe), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: 0,
          transform: 'translate3d(' + this.delta.title + 'px, 0, 0)',
          transition: 'opacity ' + this.durationSwipe + 's linear, transform ' + this.durationSwipe + 's ' + this.timingSwipe
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: 0,
          transform: 'translate3d(' + this.maxWidth + 'px, 0, 0)'
        }, this.optSwipe).queue(function (done) {
          _this3._reset(_this3.target.enter, _this3.target.leave);
          callback && callback();
          done();
        }));
      } else {
        Animit.runAll(Animit(enterPage).queue({
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        }, this.optSwipe), Animit(leavePage).queue({
          transform: 'translate3D(100%, 0, 0)'
        }, this.optSwipe).queue(function (done) {
          _this3._reset(enterPage, leavePage);
          callback && callback();
          done();
        }));
      }
    }
  }, {
    key: '_saveStyle',
    value: function _saveStyle() {
      var _this4 = this;

      this._savedStyle = new WeakMap();
      var save = function save(el) {
        return _this4._savedStyle.set(el, el.getAttribute('style'));
      };

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.forEach(save);

      Object.keys(this.decomp).forEach(function (p) {
        Object.keys(_this4.decomp[p]).forEach(function (k) {
          (_this4.decomp[p][k] instanceof Array ? _this4.decomp[p][k] : [_this4.decomp[p][k]]).forEach(save);
        });
      });
    }
  }, {
    key: '_restoreStyle',
    value: function _restoreStyle() {
      var _this5 = this;

      var restore = function restore(el) {
        _this5._savedStyle.get(el) === null ? el.removeAttribute('style') : el.setAttribute('style', _this5._savedStyle.get(el));
        _this5._savedStyle.delete(el);
      };

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(restore);

      Object.keys(this.decomp).forEach(function (p) {
        Object.keys(_this5.decomp[p]).forEach(function (k) {
          (_this5.decomp[p][k] instanceof Array ? _this5.decomp[p][k] : [_this5.decomp[p][k]]).forEach(restore);
        });
      });
    }
  }, {
    key: '_reset',
    value: function _reset() {
      this.isSwiping = false;
      this._savedStyle && this._restoreStyle.apply(this, arguments);
      this.unblock && this.unblock();
      this.swipeShadow.remove();
      this.backgroundMask.remove();
      this.overflowElement.classList.remove('overflow-visible');
      this.decomp.leave.content.classList.remove('content-swiping');
      this.decomp = this.target = this.overflowElement = this._savedStyle = null;
      this.isDragStart = true;
    }
  }]);
  return IOSSwipeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var translate3d = function translate3d() {
  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return 'translate3d(' + x + ', ' + y + ', ' + z + ')';
};

/**
 * Slide animator for navigator transition like iOS's screen slide transition.
 */

var IOSSlideNavigatorAnimator = function (_IOSSwipeNavigatorAni) {
  inherits(IOSSlideNavigatorAnimator, _IOSSwipeNavigatorAni);

  function IOSSlideNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(0.3, .4, 0, .9)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration,
        rest = objectWithoutProperties(_ref, ['timing', 'delay', 'duration']);
    classCallCheck(this, IOSSlideNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator)).call(this, _extends({ timing: timing, delay: delay, duration: duration }, rest)));

    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background-color: black; z-index: 2"></div>');
    return _this;
  }

  createClass(IOSSlideNavigatorAnimator, [{
    key: '_decompose',
    value: function _decompose(page) {
      var toolbar = page._getToolbarElement();
      var left = toolbar._getToolbarLeftItemsElement();
      var right = toolbar._getToolbarRightItemsElement();

      var excludeBackButton = function excludeBackButton(elements) {
        var result = [];

        for (var i = 0; i < elements.length; i++) {
          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
            result.push(elements[i]);
          }
        }

        return result;
      };

      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));

      return {
        toolbarCenter: toolbar._getToolbarCenterItemsElement(),
        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
        other: other,
        content: page._getContentElement(),
        background: page._getBackgroundElement(),
        toolbar: toolbar,
        bottomToolbar: page._getBottomToolbarElement()
      };
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar(enterPage, leavePage) {
      var toolbars = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

      var enterToolbar = enterPage._getToolbarElement();
      var leaveToolbar = leavePage._getToolbarElement();

      var isStatic = enterToolbar.hasAttribute('static') || leaveToolbar.hasAttribute('static');
      var isMaterial = util$1.hasModifier(enterToolbar, 'material') || util$1.hasModifier(leaveToolbar, 'material');
      var isTransparent = util$1.hasModifier(enterToolbar, 'transparent') || util$1.hasModifier(leaveToolbar, 'transparent');

      return toolbars && !isStatic && !isMaterial && !isTransparent;
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta(element, decomposition) {
      var title = void 0,
          label = void 0;

      var pageRect = element.getBoundingClientRect();
      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
      } else {
        title = Math.round(pageRect.width / 2 * 0.6);
      }

      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
      }

      return { title: title, label: label };
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      contentReady(enterPage, function () {
        var enterPageTarget = util$1.findToolbarPage(enterPage) || enterPage;
        var leavePageTarget = util$1.findToolbarPage(leavePage) || leavePage;
        var enterPageDecomposition = _this2._decompose(enterPageTarget);
        var leavePageDecomposition = _this2._decompose(leavePageTarget);

        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);

        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

        if (shouldAnimateToolbar) {

          Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background], _this2.def).default({ transform: translate3d('100%') }, { transform: translate3d() }), Animit(enterPageDecomposition.toolbar, _this2.def).default({ opacity: 0 }, { opacity: 1 }), Animit(enterPageDecomposition.toolbarCenter, _this2.def).default({ transform: translate3d('125%'), opacity: 1 }, { transform: translate3d(), opacity: 1 }), Animit(enterPageDecomposition.backButtonLabel, _this2.def).default({ transform: translate3d(delta.title + 'px'), opacity: 0 }, {
            transform: translate3d(),
            opacity: 1,
            transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
          }), Animit(enterPageDecomposition.other, _this2.def).default({ opacity: 0 }, { css: { opacity: 1 }, timing: 'linear' }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background], _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-25%'), opacity: 0.9 }).queue(function (done) {
            _this2.backgroundMask.remove();
            unblock();
            callback();
            done();
          }), Animit(leavePageDecomposition.toolbarCenter, _this2.def).default({ transform: translate3d(), opacity: 1 }, {
            transform: translate3d('-' + delta.title + 'px'),
            opacity: 0,
            transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
          }), Animit(leavePageDecomposition.backButtonLabel, _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-' + delta.label + 'px'), opacity: 0 }), Animit(leavePageDecomposition.other, _this2.def).default({ opacity: 1 }, { css: { opacity: 0 }, timing: 'linear' }));
        } else {

          Animit.runAll(Animit(enterPage, _this2.def).default({ transform: translate3d('100%') }, { transform: translate3d() }), Animit(leavePage, _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-25%'), opacity: .9 }).queue(function (done) {
            _this2.backgroundMask.remove();
            unblock();
            callback();
            done();
          }));
        }
      });
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      if (this.isSwiping) {
        return this.popSwipe(enterPage, leavePage, callback);
      }

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      var enterPageTarget = util$1.findToolbarPage(enterPage) || enterPage;
      var leavePageTarget = util$1.findToolbarPage(leavePage) || leavePage;
      var enterPageDecomposition = this._decompose(enterPageTarget);
      var leavePageDecomposition = this._decompose(leavePageTarget);

      var delta = this._calculateDelta(leavePage, leavePageDecomposition);

      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

      if (shouldAnimateToolbar) {
        Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background], this.def).default({ transform: translate3d('-25%'), opacity: .9 }, { transform: translate3d(), opacity: 1 }), Animit(enterPageDecomposition.toolbarCenter, this.def).default({ transform: translate3d('-' + delta.title + 'px'), opacity: 0 }, {
          transform: translate3d(),
          opacity: 1,
          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
        }), Animit(enterPageDecomposition.backButtonLabel, this.def).default({ transform: translate3d('-' + delta.label + 'px') }, { transform: translate3d() }), Animit(enterPageDecomposition.other, this.def).default({ opacity: 0 }, { css: { opacity: 1 }, timing: 'linear' }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background], this.def).default({ transform: translate3d() }, { transform: translate3d('100%') }).wait(0).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }), Animit(leavePageDecomposition.toolbar, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(leavePageDecomposition.toolbarCenter, this.def).default({ transform: translate3d() }, { transform: translate3d('125%') }), Animit(leavePageDecomposition.backButtonLabel, this.def).default({ transform: translate3d(), opacity: 1 }, {
          transform: translate3d(delta.title + 'px'),
          opacity: 0,
          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
        }));
      } else {
        Animit.runAll(Animit(enterPage, this.def).default({ transform: translate3d('-25%'), opacity: .9 }, { transform: translate3d(), opacity: 1 }), Animit(leavePage, this.def).default({ transform: translate3d() }, { transform: translate3d('100%') }).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }));
      }
    }
  }]);
  return IOSSlideNavigatorAnimator;
}(IOSSwipeNavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var IOSLiftNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSLiftNavigatorAnimator, _NavigatorAnimator);

  function IOSLiftNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSLiftNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background: linear-gradient(black, white);"></div>');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSLiftNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, 100%, 0)' }, { transform: 'translate3D(0, 0, 0)' }), Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)', opacity: 1 }, { transform: 'translate3D(0, -10%, 0)', opacity: .9 }).queue(function (done) {
        _this2.backgroundMask.remove();
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, -43px, 0)', opacity: .9 }, { transform: 'translate3D(0, 0, 0)', opacity: 1 }).queue(function (done) {
        _this3.backgroundMask.remove();
        unblock();
        callback();
        done();
      }), Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)' }, { transform: 'translate3D(0, 100%, 0)' }));
    }
  }]);
  return IOSLiftNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var transform = 'translate3d(0, 0, 0)';

/**
 * Fade-in screen transition.
 */

var IOSFadeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSFadeNavigatorAnimator, _NavigatorAnimator);

  function IOSFadeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSFadeNavigatorAnimator);
    return possibleConstructorReturn(this, (IOSFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSFadeNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: transform, opacity: 0 }, { transform: transform, opacity: 1 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(leavePage, this.def).default({ transform: transform, opacity: 1 }, { transform: transform, opacity: 0 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return IOSFadeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition.
 */

var MDSlideNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDSlideNavigatorAnimator, _NavigatorAnimator);

  function MDSlideNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, MDSlideNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.blackMaskOpacity = 0.4;
    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%; z-index: 2;' + 'background-color: black; opacity: 0;"></div>');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDSlideNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 0 }, { opacity: this.blackMaskOpacity }).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      }), Animit(enterPage, this.def).default({ transform: 'translate3d(100%, 0, 0)' }, { transform: 'translate3d(0, 0, 0)' }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(-45%, 0, 0)' }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: this.blackMaskOpacity }, { opacity: 0 }).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage, this.def).default({ transform: 'translate3d(-45%, 0, 0)', opacity: .9 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(100%, 0, 0)' }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDSlideNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var MDLiftNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDLiftNavigatorAnimator, _NavigatorAnimator);

  function MDLiftNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0.05 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, MDLiftNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background-color: black;"></div>');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDLiftNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      Animit.runAll(maskClear, Animit(enterPage, this.def).default({ transform: 'translate3d(0, 100%, 0)' }, { transform: 'translate3d(0, 0, 0)' }), Animit(leavePage, this.def).default({ opacity: 1 }, { opacity: .4 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage, this.def).default({ opacity: .4 }, { opacity: 1 }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, 100%, 0)' }));
    }
  }]);
  return MDLiftNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in + Lift screen transition.
 */

var MDFadeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDFadeNavigatorAnimator, _NavigatorAnimator);

  function MDFadeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(0.4, 0, 0.2, 1)' : _ref$timing,
        _ref$timingPop = _ref.timingPop,
        timingPop = _ref$timingPop === undefined ? 'cubic-bezier(0.4, 0, 1, 1)' : _ref$timingPop,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, MDFadeNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.timingPop = timingPop;
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDFadeNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, 42px, 0)', opacity: 0 }, { transform: 'translate3D(0, 0, 0)', opacity: 1 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)', opacity: 1 }, { css: { transform: 'translate3D(0, 38px, 0)', opacity: 0 }, timing: this.timingPop }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDFadeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NoneNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(NoneNavigatorAnimator, _NavigatorAnimator);

  function NoneNavigatorAnimator(options) {
    classCallCheck(this, NoneNavigatorAnimator);
    return possibleConstructorReturn(this, (NoneNavigatorAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorAnimator)).call(this, options));
  }

  createClass(NoneNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }]);
  return NoneNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$5 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSSlideNavigatorAnimator;
  },
  'slide': function slide() {
    return platform.isAndroid() ? MDSlideNavigatorAnimator : IOSSlideNavigatorAnimator;
  },
  'lift': function lift() {
    return platform.isAndroid() ? MDLiftNavigatorAnimator : IOSLiftNavigatorAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSFadeNavigatorAnimator;
  },
  'slide-ios': IOSSlideNavigatorAnimator,
  'slide-md': MDSlideNavigatorAnimator,
  'lift-ios': IOSLiftNavigatorAnimator,
  'lift-md': MDLiftNavigatorAnimator,
  'fade-ios': IOSFadeNavigatorAnimator,
  'fade-md': MDFadeNavigatorAnimator,
  'none': NoneNavigatorAnimator
};

var rewritables = {
  /**
   * @param {Element} navigatorSideElement
   * @param {Function} callback
   */
  ready: function ready(navigatorElement, callback) {
    callback();
  }
};

var verifyPageElement = function verifyPageElement(el) {
  return el.nodeName !== 'ONS-PAGE' && util$1.throw('Only page elements can be children of navigator');
};

/**
 * @element ons-navigator
 * @category navigation
 * @description
 *   [en]
 *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
 *
 *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
 *   [/en]
 *   [ja][/ja]
 * @codepen yrhtv
 * @tutorial vanilla/Reference/navigator
 * @guide lifecycle.html#events
 *   [en]Overview of page events[/en]
 *   [ja]Overview of page events[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
 *   [ja][/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-navigator id="navigator">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="center">
 *         Title
 *       </div>
 *     </ons-toolbar>
 *     <p>
 *       <ons-button
 *         onclick="document.getElementById('navigator').pushPage('page.html')">
 *         Push page
 *       </ons-button>
 *     </p>
 *   </ons-page>
 * </ons-navigator>
 *
 * <template id="page.html">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="left">
 *         <ons-back-button>Back</ons-back-button>
 *       </div>
 *       <div class="center">
 *         Another page
 *       </div>
 *     </ons-toolbar>
 *   </ons-page>
 * </template>
 */

var NavigatorElement = function (_BaseElement) {
  inherits(NavigatorElement, _BaseElement);
  createClass(NavigatorElement, [{
    key: 'animatorFactory',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]First page to show when navigator is initialized.[/en]
     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
     */

    /**
     * @attribute swipeable
     * @type {Boolean}
     * @description
     *   [en]Enable iOS "swipe to pop" feature.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute swipe-target-width
     * @type {String}
     * @default 20px
     * @description
     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
     */

    /**
     * @attribute swipe-threshold
     * @type {Number}
     * @default 0.2
     * @description
     *  [en]Specify how much the page needs to be swiped before popping. A value between `0` and `1`.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @event prepush
     * @description
     *   [en]Fired just before a page is pushed.[/en]
     *   [ja]pageがpushされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the push.[/en]
     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
     */

    /**
     * @event prepop
     * @description
     *   [en]Fired just before a page is popped.[/en]
     *   [ja]pageがpopされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the pop.[/en]
     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
     */

    /**
     * @event postpush
     * @description
     *   [en]Fired just after a page is pushed.[/en]
     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]pushされたpageオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]以前のpageオブジェクト。[/ja]
     */

    /**
     * @event postpop
     * @description
     *   [en]Fired just after a page is popped.[/en]
     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]popされて表示されるページのオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]popされて消えるページのオブジェクト。[/ja]
     */

    get: function get$$1() {
      return this._animatorFactory;
    }
  }]);

  function NavigatorElement() {
    classCallCheck(this, NavigatorElement);

    var _this = possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).call(this));

    _this._isRunning = false;
    _this._initialized = false;
    _this._pageLoader = defaultPageLoader;
    _this._pageMap = new WeakMap();

    _this._updateAnimatorFactory();
    return _this;
  }

  /**
   * @property pageLoader
   * @type {PageLoader}
   * @description
   *   [en]PageLoader instance. It can be overriden to change the way pages are loaded by this element. Useful for lib developers.[/en]
   *   [ja]PageLoaderインスタンスを格納しています。[/ja]
   */


  createClass(NavigatorElement, [{
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Specify the page to be loaded during initialization. This value takes precedence over the `page` attribute. Useful for lib developers.[/en]
     *   [ja]初期化時に読み込むページを指定します。`page`属性で指定した値よりも`page`プロパティに指定した値を優先します。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

      if (!platform.isAndroid() || this.getAttribute('swipeable') === 'force') {
        var swipeAnimator = void 0;

        this._swipe = new SwipeReveal({
          element: this,
          getThreshold: function getThreshold() {
            return Math.max(0.2, parseFloat(_this2.getAttribute('swipe-threshold')) || 0);
          },

          swipeMax: function swipeMax() {
            _this2._onSwipe && _this2._onSwipe(1, { duration: swipeAnimator.durationSwipe, timing: swipeAnimator.timingSwipe });
            _this2[_this2.swipeMax ? 'swipeMax' : 'popPage']({ animator: swipeAnimator });
            swipeAnimator = null;
          },
          swipeMid: function swipeMid(distance, width) {
            _this2._onSwipe && _this2._onSwipe(distance / width);
            swipeAnimator.translate(distance, width, _this2.topPage.previousElementSibling, _this2.topPage);
          },
          swipeMin: function swipeMin() {
            _this2._onSwipe && _this2._onSwipe(0, { duration: swipeAnimator.durationRestore, timing: swipeAnimator.timingSwipe });
            swipeAnimator.restore(_this2.topPage.previousElementSibling, _this2.topPage);
            swipeAnimator = null;
          },

          ignoreSwipe: function ignoreSwipe(event, distance) {
            // Basic conditions
            if (!_this2._isRunning && _this2.children.length > 1) {

              // Area or directional issues
              var area = parseInt(_this2.getAttribute('swipe-target-width') || 25, 10);
              if (event.gesture.direction === 'right' && area > distance) {

                // Swipes on ons-back-button and its children
                var isBB = function isBB(el) {
                  return (/ons-back-button/i.test(el.tagName)
                  );
                };
                if (!isBB(event.target) && !util$1.findParent(event.target, isBB, function (p) {
                  return (/ons-page/i.test(p.tagName)
                  );
                })) {

                  // Animator is swipeable
                  var animation = (_this2.topPage.pushedOptions || {}).animation || _this2.animatorFactory._animation;
                  var Animator = _animatorDict$5[animation] instanceof Function ? _animatorDict$5[animation].call() : _animatorDict$5[animation];

                  if (typeof Animator !== 'undefined' && Animator.swipeable) {
                    swipeAnimator = new Animator(); // Prepare for the swipe
                    return false;
                  }
                }
              }
            }

            return true; // Ignore swipe
          }
        });

        this.attributeChangedCallback('swipeable');
      }

      if (this._initialized) {
        return;
      }

      this._initialized = true;

      var deferred = util$1.defer();
      this.loaded = deferred.promise;

      rewritables.ready(this, function () {
        var show = !util$1.hasAnyComponentAsParent(_this2);
        var options = { animation: 'none', show: show };

        if (_this2.pages.length === 0 && _this2._getPageTarget()) {
          _this2.pushPage(_this2._getPageTarget(), options).then(function () {
            return deferred.resolve();
          });
        } else if (_this2.pages.length > 0) {
          for (var i = 0; i < _this2.pages.length; i++) {
            verifyPageElement(_this2.pages[i]);
          }

          if (_this2.topPage) {
            contentReady(_this2.topPage, function () {
              return setTimeout(function () {
                deferred.resolve();
                show && _this2.topPage._show();
                _this2._updateLastPageBackButton();
              }, 0);
            });
          }
        } else {
          contentReady(_this2, function () {
            if (_this2.pages.length === 0 && _this2._getPageTarget()) {
              _this2.pushPage(_this2._getPageTarget(), options).then(function () {
                return deferred.resolve();
              });
            } else {
              deferred.resolve();
            }
          });
        }
      });
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$5,
        baseClass: NavigatorAnimator,
        baseClassName: 'NavigatorAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._swipe && this._swipe.dispose();
      this._swipe = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'animation':
          this._updateAnimatorFactory();
          break;
        case 'swipeable':
          this._swipe && this._swipe.update();
          break;
      }
    }

    /**
     * @method popPage
     * @signature popPage([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @param {Number} [options.times]
     *   [en]Number of pages to be popped. Only one animation will be shown.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
     */

  }, {
    key: 'popPage',
    value: function popPage() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _preparePageAndOption = this._preparePageAndOptions(null, options);

      options = _preparePageAndOption.options;


      if (util$1.isInteger(options.times) && options.times > 1) {
        this._removePages(options.times);
      }

      var popUpdate = function popUpdate() {
        return new Promise(function (resolve) {
          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);
          resolve();
        });
      };

      return this._popPage(options, popUpdate);
    }
  }, {
    key: '_popPage',
    value: function _popPage(options) {
      var _this4 = this;

      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('popPage is already running.');
      }

      if (this.pages.length <= 1) {
        return Promise.reject('ons-navigator\'s page stack is empty.');
      }

      if (this._emitPrePopEvent()) {
        return Promise.reject('Canceled in prepop event.');
      }

      var length = this.pages.length;

      this._isRunning = true;

      this.pages[length - 2].updateBackButton(length - 2 > 0);

      return new Promise(function (resolve) {
        var leavePage = _this4.pages[length - 1];
        var enterPage = _this4.pages[length - 2];

        options = util$1.extend({}, _this4.options || {}, leavePage.pushedOptions || {}, options);

        if (options.data) {
          enterPage.data = util$1.extend({}, enterPage.data || {}, options.data || {});
        }

        var done = function done() {
          update().then(function () {
            _this4._isRunning = false;

            enterPage._show();
            util$1.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

            options.callback && options.callback(enterPage);

            resolve(enterPage);
          });
        };

        leavePage._hide();
        enterPage.style.display = '';

        var animator = options.animator || _this4._animatorFactory.newAnimator(options);
        animator.pop(_this4.pages[length - 2], _this4.pages[length - 1], done);
      }).catch(function () {
        return _this4._isRunning = false;
      });
    }

    /**
     * @method pushPage
     * @signature pushPage(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either a HTML document or a template defined with the `<template>` tag.[/en]
     *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.page]
     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
     *   [ja][/ja]
     * @param {String} [options.pageHTML]
     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the pushed page.[/en]
     *   [ja]追加したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pushes the specified page into the stack.[/en]
     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]
     */

  }, {
    key: 'pushPage',
    value: function pushPage(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption2.page;
      options = _preparePageAndOption2.options;


      var prepare = function prepare(pageElement) {
        verifyPageElement(pageElement);
        _this5._pageMap.set(pageElement, page);
        pageElement = util$1.extend(pageElement, {
          data: options.data
        });
        pageElement.style.visibility = 'hidden';
      };

      if (options.pageHTML) {
        return this._pushPage(options, function () {
          return new Promise(function (resolve) {
            instantPageLoader.load({ page: options.pageHTML, parent: _this5, params: options.data }, function (pageElement) {
              prepare(pageElement);
              resolve();
            });
          });
        });
      }

      return this._pushPage(options, function () {
        return new Promise(function (resolve) {
          _this5._pageLoader.load({ page: page, parent: _this5, params: options.data }, function (pageElement) {
            prepare(pageElement);
            resolve();
          });
        });
      });
    }
  }, {
    key: '_pushPage',
    value: function _pushPage() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }

      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      this._isRunning = true;

      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
      options = util$1.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

      var animator = this._animatorFactory.newAnimator(options);

      return update().then(function () {
        var pageLength = _this6.pages.length;

        var enterPage = _this6.pages[pageLength - 1];
        var leavePage = options.leavePage || _this6.pages[pageLength - 2];

        verifyPageElement(enterPage);

        enterPage.updateBackButton(pageLength > (options._replacePage ? 2 : 1));

        enterPage.pushedOptions = util$1.extend({}, enterPage.pushedOptions || {}, options || {});
        enterPage.data = util$1.extend({}, enterPage.data || {}, options.data || {});
        enterPage.unload = enterPage.unload || options.unload;

        return new Promise(function (resolve) {
          var done = function done() {
            _this6._isRunning = false;

            options.show !== false && setImmediate(function () {
              return enterPage._show();
            });
            util$1.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

            if (leavePage) {
              leavePage.style.display = 'none';
            }

            options.callback && options.callback(enterPage);

            resolve(enterPage);
          };

          enterPage.style.visibility = '';
          if (leavePage) {
            leavePage._hide();
            animator.push(enterPage, leavePage, done);
          } else {
            done();
          }
        });
      }).catch(function (error) {
        _this6._isRunning = false;
        throw error;
      });
    }

    /**
     * @method replacePage
     * @signature replacePage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new page.[/en]
     *   [ja]新しいページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
     */

  }, {
    key: 'replacePage',
    value: function replacePage(page) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.pushPage(page, options).then(function (resolvedValue) {
        if (_this7.pages.length > 1) {
          _this7._pageLoader.unload(_this7.pages[_this7.pages.length - 2]);
        }
        _this7._updateLastPageBackButton();

        return Promise.resolve(resolvedValue);
      });
    }

    /**
     * @method insertPage
     * @signature insertPage(index, page, [options])
     * @param {Number} index
     *   [en]The index where it should be inserted.[/en]
     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the inserted page.[/en]
     *   [ja]指定したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]
     */

  }, {
    key: 'insertPage',
    value: function insertPage(index, page) {
      var _this8 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption3.page;
      options = _preparePageAndOption3.options;

      index = this._normalizeIndex(index);

      if (index >= this.pages.length) {
        return this.pushPage(page, options);
      }

      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;

      return new Promise(function (resolve) {
        loader.load({ page: page, parent: _this8 }, function (pageElement) {
          verifyPageElement(pageElement);
          _this8._pageMap.set(pageElement, page);
          pageElement = util$1.extend(pageElement, {
            data: options.data,
            pushedOptions: options
          });

          options.animationOptions = util$1.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

          pageElement.style.display = 'none';
          _this8.insertBefore(pageElement, _this8.pages[index]);
          _this8.topPage.updateBackButton(true);

          setTimeout(function () {
            pageElement = null;
            resolve(_this8.pages[index]);
          }, 1000 / 60);
        });
      });
    }

    /**
     * @method removePage
     * @signature removePage(index, [options])
     * @param {Number} index
     *   [en]The index where it should be removed.[/en]
     *   [ja]スタックから削除するページのインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]削除によって表示されたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Remove the specified page at a position in the stack defined by the `index` argument. Extends `popPage()` parameters.[/en]
     *   [ja]指定したインデックスにあるページを削除します。[/ja]
     */

  }, {
    key: 'removePage',
    value: function removePage(index) {
      var _this9 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      index = this._normalizeIndex(index);

      if (index < this.pages.length - 1) {
        return new Promise(function (resolve) {
          var leavePage = _this9.pages[index];
          var enterPage = _this9.topPage;

          _this9._pageMap.delete(leavePage);
          _this9._pageLoader.unload(leavePage);
          if (_this9.pages.length === 1) {
            // edge case
            _this9.topPage.updateBackButton(false);
          }

          resolve(enterPage);
        });
      } else {
        return this.popPage(options);
      }
    }

    /**
     * @method resetToPage
     * @signature resetToPage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @param {Boolean} [options.pop]
     *   [en]Performs 'pop' effect if `true` instead of 'push' or none. This also sets `options.animation` value to `default` instead of `none`.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
     */

  }, {
    key: 'resetToPage',
    value: function resetToPage(page) {
      var _this10 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption4.page;
      options = _preparePageAndOption4.options;


      if (!options.animator && !options.animation && !options.pop) {
        options.animation = 'none';
      }

      if (!options.page && !options.pageHTML && this._getPageTarget()) {
        page = options.page = this._getPageTarget();
      }

      if (options.pop) {
        this._removePages();
        return this.insertPage(0, page, { data: options.data }).then(function () {
          return _this10.popPage(options);
        });
      }

      // Tip: callback runs before resolved promise
      var callback = options.callback;
      options.callback = function (newPage) {
        _this10._removePages();
        newPage.updateBackButton(false);
        callback && callback(newPage);
      };

      return this.pushPage(page, options);
    }

    /**
     * @method bringPageTop
     * @signature bringPageTop(item, [options])
     * @param {String|Number} item
     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
     */

  }, {
    key: 'bringPageTop',
    value: function bringPageTop(item) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {
        util$1.throw('First argument must be a page name or the index of an existing page. You supplied ' + item);
      }
      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
      var page = this.pages[index];

      if (index < 0) {
        return this.pushPage(item, options);
      }

      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);

      options = _preparePageAndOption5.options;


      if (index === this.pages.length - 1) {
        return Promise.resolve(page);
      }
      if (!page) {
        util$1.throw('Failed to find item ' + item);
      }
      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }
      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      page.style.display = '';
      page.style.visibility = 'hidden';
      page.parentNode.appendChild(page);
      return this._pushPage(options);
    }
  }, {
    key: '_preparePageAndOptions',
    value: function _preparePageAndOptions(page) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        util$1.throw('options must be an object. You supplied ' + options);
      }

      if ((page === null || page === undefined) && options.page) {
        page = options.page;
      }

      options = util$1.extend({}, this.options || {}, options, { page: page });

      return { page: page, options: options };
    }
  }, {
    key: '_removePages',
    value: function _removePages(times) {
      var pages = this.pages;
      var until = times === undefined ? 0 : pages.length - times;
      until = until < 0 ? 1 : until;

      for (var i = pages.length - 2; i >= until; i--) {
        this._pageMap.delete(pages[i]);
        this._pageLoader.unload(pages[i]);
      }
    }
  }, {
    key: '_updateLastPageBackButton',
    value: function _updateLastPageBackButton() {
      var index = this.pages.length - 1;
      if (index >= 0) {
        this.pages[index].updateBackButton(index > 0);
      }
    }
  }, {
    key: '_normalizeIndex',
    value: function _normalizeIndex(index) {
      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
    }
  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      if (this.pages.length > 1) {
        this.popPage();
      } else {
        event.callParentHandler();
      }
    }
  }, {
    key: '_lastIndexOfPage',
    value: function _lastIndexOfPage(pageName) {
      var index = void 0;
      for (index = this.pages.length - 1; index >= 0; index--) {
        if (!this._pageMap.has(this.pages[index])) {
          util$1.throw('Incorrect state of pageMap');
        }

        if (pageName === this._pageMap.get(this.pages[index])) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_emitPreEvent',
    value: function _emitPreEvent(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isCanceled = false;

      util$1.triggerElementEvent(this, 'pre' + name, util$1.extend({
        navigator: this,
        currentPage: this.pages[this.pages.length - 1],
        cancel: function cancel() {
          return isCanceled = true;
        }
      }, data));

      return isCanceled;
    }
  }, {
    key: '_emitPrePushEvent',
    value: function _emitPrePushEvent() {
      return this._emitPreEvent('push');
    }
  }, {
    key: '_emitPrePopEvent',
    value: function _emitPrePopEvent() {
      var l = this.pages.length;
      return this._emitPreEvent('pop', {
        leavePage: this.pages[l - 1],
        enterPage: this.pages[l - 2]
      });
    }

    // TODO: 書き直す

  }, {
    key: '_createPageElement',
    value: function _createPageElement(templateHTML) {
      var pageElement = util$1.createElement(internal$1.normalizePageHTML(templateHTML));
      verifyPageElement(pageElement);
      return pageElement;
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      var _this11 = this;

      this.loaded.then(function () {
        return _this11.topPage && _this11.topPage._show();
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.topPage && this.topPage._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      for (var i = this.pages.length - 1; i >= 0; i--) {
        this._pageLoader.unload(this.pages[i]);
      }

      this.remove();
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(pageLoader) {
      if (!(pageLoader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = pageLoader;
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    },
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }

    /**
     * @property topPage
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
     */

  }, {
    key: 'topPage',
    get: function get$$1() {
      var last = this.lastElementChild;
      while (last && last.tagName !== 'ONS-PAGE') {
        last = last.previousElementSibling;
      }
      return last;
    }

    /**
     * @property pages
     * @readonly
     * @type {Array}
     * @description
     *   [en]Copy of the navigator's page stack.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pages',
    get: function get$$1() {
      return util$1.arrayFrom(this.children).filter(function (element) {
        return element.tagName === 'ONS-PAGE';
      });
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the navigator (swipe-to-pop). It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Default options object. Attributes have priority over this property.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

  }, {
    key: 'options',
    get: function get$$1() {
      return this._options;
    },
    set: function set$$1(object) {
      this._options = object;
    }
  }, {
    key: '_isRunning',
    set: function set$$1(value) {
      this.setAttribute('_is-running', value ? 'true' : 'false');
    },
    get: function get$$1() {
      return JSON.parse(this.getAttribute('_is-running'));
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof NavigatorAnimator)) {
        util$1.throwAnimator('Navigator');
      }

      _animatorDict$5[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return ['animation', 'swipeable'];
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$5;
    }
  }, {
    key: 'NavigatorAnimator',
    get: function get$$1() {
      return NavigatorAnimator;
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['prepush', 'postpush', 'prepop', 'postpop'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables;
    }
  }]);
  return NavigatorElement;
}(BaseElement);

onsElements.Navigator = NavigatorElement;
customElements.define('ons-navigator', NavigatorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$10 = 'toolbar';

var scheme$18 = {
  '': 'toolbar--*',
  '.toolbar__left': 'toolbar--*__left',
  '.toolbar__center': 'toolbar--*__center',
  '.toolbar__right': 'toolbar--*__right'
};

/**
 * @element ons-toolbar
 * @category page
 * @modifier material
 *   [en]Material Design toolbar.[/en]
 *   [ja][/ja]
 * @modifier transparent
 *   [en]Transparent toolbar.[/en]
 *   [ja]透明な背景を持つツールバーを表示します。[/ja]
 * @modifier cover-content
 *   [en]Displays the toolbar on top of the page's content. Should be combined with `transparent` modifier.[/en]
 *   [ja][/ja]
 * @modifier noshadow
 *   [en]Toolbar without shadow.[/en]
 *   [ja]ツールバーに影を付けずに表示します。[/ja]
 * @description
 *   [en]
 *     Toolbar component that can be used with navigation.
 *
 *     Left, center and right container can be specified by class names.
 *
 *     This component will automatically displays as a Material Design toolbar when running on Android devices.
 *   [/en]
 *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/toolbar
 * @guide compilation.html#toolbar-compilation [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
 * @seealso ons-bottom-toolbar
 *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
 *   [ja]ons-bottom-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @seealso ons-toolbar-button
 *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
 *   [ja]ons-toolbar-buttonコンポーネント[/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>
 *         Back
 *       </ons-back-button>
 *     </div>
 *     <div class="center">
 *       Title
 *     </div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 * </ons-page>
 */

var ToolbarElement = function (_BaseElement) {
  inherits(ToolbarElement, _BaseElement);

  /**
   * @attribute inline
   * @initonly
   * @description
   *   [en]Display the toolbar as an inline element.[/en]
   *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
   */

  /**
   * @attribute static
   * @description
   *   [en]Static toolbars are not animated by `ons-navigator` when pushing or popping pages. This can be useful to improve performance in some situations.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @description
   *   [en]The appearance of the toolbar.[/en]
   *   [ja]ツールバーの表現を指定します。[/ja]
   */

  function ToolbarElement() {
    classCallCheck(this, ToolbarElement);

    var _this = possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(ToolbarElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$10, scheme$18);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$18);
          break;
      }
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarLeftItemsElement',
    value: function _getToolbarLeftItemsElement() {
      return this.querySelector('.left') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarCenterItemsElement',
    value: function _getToolbarCenterItemsElement() {
      return this.querySelector('.center') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarRightItemsElement',
    value: function _getToolbarRightItemsElement() {
      return this.querySelector('.right') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonLabelElement',
    value: function _getToolbarBackButtonLabelElement() {
      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonIconElement',
    value: function _getToolbarBackButtonIconElement() {
      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$10);
      this._ensureToolbarItemElements();
      ModifierUtil.initModifier(this, scheme$18);
    }
  }, {
    key: '_ensureToolbarItemElements',
    value: function _ensureToolbarItemElements() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        // case of not element
        if (this.childNodes[i].nodeType != 1) {
          this.removeChild(this.childNodes[i]);
        }
      }

      var center = this._ensureToolbarElement('center');
      center.classList.add('toolbar__title');

      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
        var left = this._ensureToolbarElement('left');
        var right = this._ensureToolbarElement('right');

        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
          this.appendChild(left);
          this.appendChild(center);
          this.appendChild(right);
        }
      }
    }
  }, {
    key: '_ensureToolbarElement',
    value: function _ensureToolbarElement(name) {
      if (util$1.findChild(this, '.toolbar__' + name)) {
        var _element = util$1.findChild(this, '.toolbar__' + name);
        _element.classList.add(name);
        return _element;
      }

      var element = util$1.findChild(this, '.' + name) || util$1.create('.' + name);
      element.classList.add('toolbar__' + name);

      return element;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarElement;
}(BaseElement);

onsElements.Toolbar = ToolbarElement;
customElements.define('ons-toolbar', ToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$9 = 'page';
var scheme$17 = {
  '': 'page--*',
  '.page__content': 'page--*__content',
  '.page__background': 'page--*__background'
};

/**
 * @element ons-page
 * @category page
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     This component defines the root of each page. If the content is large it will become scrollable.
 *
 *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
 *   [/en]
 *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
 * @tutorial vanilla/Reference/page
 * @guide lifecycle.html#events
 *   [en]Overview of page events[/en]
 *   [ja]Overview of page events[/ja]
 * @guide fundamentals.html#managing-pages
 *   [en]Managing multiple pages[/en]
 *   [ja]複数のページを管理する[/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-toolbar
 *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>Back</ons-back-button>
 *     </div>
 *     <div class="center">Title</div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 *
 *   <p>Page content</p>
 * </ons-page>
 *
 * @example
 * <script>
 *   myApp.handler = function(done) {
 *     loadMore().then(done);
 *   }
 * </script>
 *
 * <ons-page on-infinite-scroll="myApp.handler">
 *   <ons-toolbar>
 *     <div class="center">List</div>
 *   </ons-toolbar>
 *
 *   <ons-list>
 *     <ons-list-item>#1</ons-list-item>
 *     <ons-list-item>#2</ons-list-item>
 *     <ons-list-item>#3</ons-list-item>
 *     ...
 *   </ons-list>
 * </ons-page>
 */

var PageElement = function (_BaseElement) {
  inherits(PageElement, _BaseElement);

  /**
   * @event init
   * @description
   *   [en]Fired right after the page is attached.[/en]
   *   [ja]ページがアタッチされた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event show
   * @description
   *   [en]Fired right after the page is shown.[/en]
   *   [ja]ページが表示された後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event hide
   * @description
   *   [en]Fired right after the page is hidden.[/en]
   *   [ja]ページが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event destroy
   * @description
   *   [en]Fired right before the page is destroyed.[/en]
   *   [ja]ページが破棄される前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Specify modifier name to specify custom styles.[/en]
   *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
   */

  /**
   * @attribute on-infinite-scroll
   * @type {String}
   * @description
   *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
   *   [ja][/ja]
   */

  function PageElement() {
    classCallCheck(this, PageElement);

    var _this = possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).call(this));

    _this._deriveHooks();

    _this._defaultClassName = defaultClassName$9;
    _this.classList.add(defaultClassName$9);

    _this._initialized = false;

    contentReady(_this, function () {
      _this._compile();

      _this._isShown = false;
      _this._contentElement = _this._getContentElement();
      _this._backgroundElement = _this._getBackgroundElement();
    });
    return _this;
  }

  createClass(PageElement, [{
    key: '_compile',
    value: function _compile() {
      var _this2 = this;

      autoStyle.prepare(this);

      var toolbar = util$1.findChild(this, 'ons-toolbar');

      var background = util$1.findChild(this, '.page__background') || util$1.findChild(this, '.background') || document.createElement('div');
      background.classList.add('page__background');
      this.insertBefore(background, !toolbar && this.firstChild || toolbar && toolbar.nextSibling);

      var content = util$1.findChild(this, '.page__content') || util$1.findChild(this, '.content') || document.createElement('div');
      content.classList.add('page__content');
      if (!content.parentElement) {
        util$1.arrayFrom(this.childNodes).forEach(function (node) {
          if (node.nodeType !== 1 || _this2._elementShouldBeMoved(node)) {
            content.appendChild(node); // Can trigger detached connectedCallbacks
          }
        });
      }

      this._tryToFillStatusBar(content); // Must run before child pages try to fill status bar.
      this.insertBefore(content, background.nextSibling); // Can trigger attached connectedCallbacks

      if ((!toolbar || !util$1.hasModifier(toolbar, 'transparent')) && content.children.length === 1 && util$1.isPageControl(content.children[0])) {
        this._defaultClassName += ' page--wrapper';
        this.attributeChangedCallback('class');
      }

      var bottomToolbar = util$1.findChild(this, 'ons-bottom-toolbar');
      if (bottomToolbar) {
        this._defaultClassName += ' page-with-bottom-toolbar';
        this.attributeChangedCallback('class');
      }

      ModifierUtil.initModifier(this, scheme$17);
    }
  }, {
    key: '_elementShouldBeMoved',
    value: function _elementShouldBeMoved(el) {
      if (el.classList.contains('page__background')) {
        return false;
      }
      var tagName = el.tagName.toLowerCase();
      if (tagName === 'ons-fab') {
        return !el.hasAttribute('position');
      }
      var fixedElements = ['script', 'ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial', 'ons-dialog', 'ons-alert-dialog', 'ons-popover', 'ons-action-sheet'];
      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
    }
  }, {
    key: '_tryToFillStatusBar',
    value: function _tryToFillStatusBar() {
      var _this3 = this;

      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;

      internal$1.autoStatusBarFill(function () {
        util$1.toggleAttribute(_this3, 'status-bar-fill', !util$1.findParent(_this3, function (e) {
          return e.hasAttribute('status-bar-fill');
        }) // Not already filled
        && (_this3._canAnimateToolbar(content) || !util$1.findChild(content, util$1.isPageControl)) // Has toolbar or cannot delegate
        );
      });
    }
  }, {
    key: '_canAnimateToolbar',
    value: function _canAnimateToolbar() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;

      if (util$1.findChild(this, 'ons-toolbar')) {
        return true;
      }

      return !!util$1.findChild(content, function (el) {
        return util$1.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      if (!util$1.isAttached(this)) {
        // Avoid detached calls
        return;
      }

      contentReady(this, function () {
        _this4._tryToFillStatusBar(); // Ensure status bar when the element was compiled before connected

        if (_this4.hasAttribute('on-infinite-scroll')) {
          _this4.attributeChangedCallback('on-infinite-scroll', null, _this4.getAttribute('on-infinite-scroll'));
        }

        if (!_this4._initialized) {
          _this4._initialized = true;

          setImmediate(function () {
            _this4.onInit && _this4.onInit();
            util$1.triggerElementEvent(_this4, 'init');
          });

          if (!util$1.hasAnyComponentAsParent(_this4)) {
            setImmediate(function () {
              return _this4._show();
            });
          }
        }
      });
    }
  }, {
    key: 'updateBackButton',
    value: function updateBackButton(show) {
      if (this.backButton) {
        show ? this.backButton.show() : this.backButton.hide();
      }
    }
  }, {
    key: '_onScroll',
    value: function _onScroll() {
      var _this5 = this;

      var c = this._contentElement,
          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
        this._loadingContent = true;
        this._onInfiniteScroll(function () {
          return _this5._loadingContent = false;
        });
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_getContentElement',
    value: function _getContentElement() {
      var result = util$1.findChild(this, '.page__content');
      if (result) {
        return result;
      }
      util$1.throw('Fail to get ".page__content" element');
    }
  }, {
    key: '_getBackgroundElement',
    value: function _getBackgroundElement() {
      var result = util$1.findChild(this, '.page__background');
      if (result) {
        return result;
      }
      util$1.throw('Fail to get ".page__background" element');
    }
  }, {
    key: '_getBottomToolbarElement',
    value: function _getBottomToolbarElement() {
      return util$1.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;
    }
  }, {
    key: '_getToolbarElement',
    value: function _getToolbarElement() {
      return util$1.findChild(this, 'ons-toolbar') || document.createElement('ons-toolbar');
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this6 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, this._defaultClassName, scheme$17);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$17);
          break;
        case 'on-infinite-scroll':
          if (current === null) {
            this.onInfiniteScroll = null;
          } else {
            this.onInfiniteScroll = function (done) {
              var f = util$1.findFromPath(current);
              _this6.onInfiniteScroll = f;
              f(done);
            };
          }
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this._isShown && util$1.isAttached(this)) {
        this._isShown = true;
        this.setAttribute('shown', '');
        this.onShow && this.onShow();
        util$1.triggerElementEvent(this, 'show');
        util$1.propagateAction(this, '_show');
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._isShown) {
        this._isShown = false;
        this.removeAttribute('shown');
        this.onHide && this.onHide();
        util$1.triggerElementEvent(this, 'hide');
        util$1.propagateAction(this, '_hide');
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._hide();

      this.onDestroy && this.onDestroy();
      util$1.triggerElementEvent(this, 'destroy');

      if (this.onDeviceBackButton) {
        this.onDeviceBackButton.destroy();
      }

      util$1.propagateAction(this, '_destroy');

      this.remove();
    }
  }, {
    key: '_deriveHooks',
    value: function _deriveHooks() {
      var _this7 = this;

      this.constructor.events.forEach(function (event) {
        var key = 'on' + event.charAt(0).toUpperCase() + event.slice(1);
        Object.defineProperty(_this7, key, {
          configurable: true,
          enumerable: true,
          get: function get$$1() {
            return _this7['_' + key];
          },
          set: function set$$1(value) {
            if (!(value instanceof Function)) {
              util$1.throw('"' + key + '" hook must be a function');
            }
            _this7['_' + key] = value.bind(_this7);
          }
        });
      });
    }
  }, {
    key: 'name',
    set: function set$$1(str) {
      this.setAttribute('name', str);
    },
    get: function get$$1() {
      return this.getAttribute('name');
    }
  }, {
    key: 'backButton',
    get: function get$$1() {
      return this.querySelector('ons-back-button');
    }

    /**
     * @property onInfiniteScroll
     * @description
     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'onInfiniteScroll',
    set: function set$$1(value) {
      var _this8 = this;

      if (value && !(value instanceof Function)) {
        util$1.throw('"onInfiniteScroll" must be function or null');
      }

      contentReady(this, function () {
        if (!value) {
          _this8._contentElement.removeEventListener('scroll', _this8._boundOnScroll);
        } else if (!_this8._onInfiniteScroll) {
          _this8._infiniteScrollLimit = 0.9;
          _this8._boundOnScroll = _this8._onScroll.bind(_this8);
          setImmediate(function () {
            return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);
          });
        }
        _this8._onInfiniteScroll = value;
      });
    },
    get: function get$$1() {
      return this._onInfiniteScroll;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'scrollTop',
    get: function get$$1() {
      return this._contentElement.scrollTop;
    },
    set: function set$$1(newValue) {
      this._contentElement.scrollTop = newValue;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'on-infinite-scroll', 'class'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['init', 'show', 'hide', 'destroy'];
    }

    /**
     * @property data
     * @type {*}
     * @description
     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
     *   [ja][/ja]
     */

  }]);
  return PageElement;
}(BaseElement);

onsElements.Page = PageElement;
customElements.define('ons-page', PageElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var PopoverAnimator = function (_BaseAnimator) {
  inherits(PopoverAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function PopoverAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, PopoverAnimator);
    return possibleConstructorReturn(this, (PopoverAnimator.__proto__ || Object.getPrototypeOf(PopoverAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  createClass(PopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      callback();
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      callback();
    }
  }, {
    key: '_animate',
    value: function _animate(element, _ref2) {
      var from = _ref2.from,
          to = _ref2.to,
          options = _ref2.options,
          callback = _ref2.callback,
          _ref2$restore = _ref2.restore,
          restore = _ref2$restore === undefined ? false : _ref2$restore,
          animation = _ref2.animation;

      options = util$1.extend({}, this.options, options);

      if (animation) {
        from = animation.from;
        to = animation.to;
      }

      animation = Animit(element);
      if (restore) {
        animation = animation.saveStyle();
      }
      animation = animation.queue(from).wait(this.delay).queue({
        css: to,
        duration: this.duration,
        timing: this.timing
      });
      if (restore) {
        animation = animation.restoreStyle();
      }
      if (callback) {
        animation = animation.queue(function (done) {
          callback();
          done();
        });
      }
      return animation;
    }
  }, {
    key: '_animateAll',
    value: function _animateAll(element, animations) {
      var _this2 = this;

      Object.keys(animations).forEach(function (key) {
        return _this2._animate(element[key], animations[key]).play();
      });
    }
  }]);
  return PopoverAnimator;
}(BaseAnimator);

var fade = {
  out: {
    from: { opacity: 1.0 },
    to: { opacity: 0 }
  },
  in: {
    from: { opacity: 0 },
    to: { opacity: 1.0 }
  }
};

var MDFadePopoverAnimator = function (_PopoverAnimator) {
  inherits(MDFadePopoverAnimator, _PopoverAnimator);

  function MDFadePopoverAnimator() {
    classCallCheck(this, MDFadePopoverAnimator);
    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(MDFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.in,
        _popover: { animation: fade.in, restore: true, callback: callback }
      });
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.out,
        _popover: { animation: fade.out, restore: true, callback: callback }
      });
    }
  }]);
  return MDFadePopoverAnimator;
}(PopoverAnimator);

var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

  function IOSFadePopoverAnimator() {
    classCallCheck(this, IOSFadePopoverAnimator);
    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(IOSFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.in,
        _popover: {
          from: {
            transform: 'scale3d(1.3, 1.3, 1.0)',
            opacity: 0
          },
          to: {
            transform: 'scale3d(1.0, 1.0,  1.0)',
            opacity: 1.0
          },
          restore: true,
          callback: callback
        }
      });
    }
  }]);
  return IOSFadePopoverAnimator;
}(MDFadePopoverAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$19 = {
  '.popover': 'popover--*',
  '.popover-mask': 'popover-mask--*',
  '.popover__content': 'popover--*__content',
  '.popover__arrow': 'popover--*__arrow'
};

var _animatorDict$6 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
  },
  'none': PopoverAnimator,
  'fade-ios': IOSFadePopoverAnimator,
  'fade-md': MDFadePopoverAnimator
};

var positions = {
  up: 'bottom',
  left: 'right',
  down: 'top',
  right: 'left'
};

/**
 * @element ons-popover
 * @category dialog
 * @description
 *  [en]
 *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
 *
 *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<template>` tag.
 *
 *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
 *  [/en]
 *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
 * @codepen ZYYRKo
 * @tutorial vanilla/Reference/popover
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-button onclick="showPopover(this)">
 *   Click me!
 * </ons-button>
 *
 * <ons-popover direction="down" id="popover">
 *   <p>This is a popover!</p>
 * </ons-popover>
 *
 * <script>
 *   var showPopover = function(element) {
 *     var popover = document.getElementById('popover');
 *     popover.show(element);
 *   };
 * </script>
 */

var PopoverElement = function (_BaseDialogElement) {
  inherits(PopoverElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   *   [en]Fired just before the popover is displayed.[/en]
   *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to stop the popover from being shown.[/en]
   *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   *   [en]Fired just after the popover is displayed.[/en]
   *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   *   [en]Fired just before the popover is hidden.[/en]
   *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to stop the popover from being hidden.[/en]
   *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
   */

  /**
   * @event posthide
   * @description
   *   [en]Fired just after the popover is hidden.[/en]
   *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the popover.[/en]
   *  [ja]ポップオーバーの表現を指定します。[/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *  [en]
   *    A space separated list of directions. If more than one direction is specified,
   *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
   *  [/en]
   *  [ja]
   *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
   *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
   *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
   *  [/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
   *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
   */

  /**
   * @attribute cover-target
   * @description
   *   [en]If set the popover will cover the target on the screen.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @description
   *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
   *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute mask-color
   * @type {Color}
   * @description
   *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
   */

  function PopoverElement() {
    classCallCheck(this, PopoverElement);

    var _this = possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).call(this));

    _this._boundOnChange = _this._onChange.bind(_this);

    contentReady(_this, function () {
      _this._compile();
      _this.style.display = 'none';
    });
    return _this;
  }

  createClass(PopoverElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$6,
        baseClass: PopoverAnimator,
        baseClassName: 'PopoverAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (shouldShow) {
        this.style.display = 'block';
        this._currentTarget = options.target;
        this._positionPopover(options.target);
      } else {
        this.style.display = 'none';
        this._clearStyles();
      }
    }
  }, {
    key: '_positionPopover',
    value: function _positionPopover(target) {
      var radius = this._radius,
          contentElement = this._content,
          margin = this._margin;

      var safeAreaLengths = iPhoneXPatch.getSafeAreaLengths();
      var safeAreaRect = iPhoneXPatch.getSafeAreaDOMRect();
      var targetRect = target.getBoundingClientRect();
      var isMD = util$1.hasModifier(this, 'material');
      var cover = isMD && this.hasAttribute('cover-target');
      var parent = util$1.findParent(this, 'ons-page') || document.body;
      var parentDimensions = parent.getBoundingClientRect();
      var maxPositions = {
        top: Math.max(parentDimensions.top, safeAreaRect.top),
        left: Math.max(parentDimensions.left, safeAreaRect.left),
        bottom: Math.min(parentDimensions.bottom, safeAreaRect.bottom),
        right: Math.min(parentDimensions.right, safeAreaRect.right)
      };

      // Distance from each side of the safe area (with margin) to the target element
      var targetDistance = {
        top: targetRect.top - (maxPositions.top + margin),
        left: targetRect.left - (maxPositions.left + margin),
        bottom: maxPositions.bottom - margin - targetRect.bottom,
        right: maxPositions.right - margin - targetRect.right
      };

      // Distance from each side of the safe area (with margin) to the geometric center of the target element
      var targetCenterDistanceFrom = {
        top: targetRect.top + Math.round(targetRect.height / 2) - (maxPositions.top + margin),
        left: targetRect.left + Math.round(targetRect.width / 2) - (maxPositions.left + margin),
        bottom: maxPositions.bottom - margin - targetRect.bottom + Math.round(targetRect.height / 2),
        right: maxPositions.right - margin - targetRect.right + Math.round(targetRect.width / 2)
      };

      var _calculateDirections2 = this._calculateDirections(targetDistance),
          vertical = _calculateDirections2.vertical,
          primaryDirection = _calculateDirections2.primary,
          secondaryDirection = _calculateDirections2.secondary;

      this._currentDirection = primaryDirection;
      util$1.addModifier(this, primaryDirection);

      var sizeName = vertical ? 'width' : 'height';
      // Get .popover__content size
      var contentSize = function (style) {
        return {
          width: parseInt(style.getPropertyValue('width'), 10),
          height: parseInt(style.getPropertyValue('height'), 10)
        };
      }(window.getComputedStyle(contentElement));

      // Setting .popover position.
      var targetAndArrowLength = cover ? 0 : (vertical ? targetRect.height : targetRect.width) + (isMD ? 0 : 14);
      var primaryOffset = Math.max(safeAreaLengths[primaryDirection] + margin, safeAreaLengths[primaryDirection] + margin + targetDistance[primaryDirection] + targetAndArrowLength);
      var secondaryOffset = Math.max(safeAreaLengths[secondaryDirection] + margin, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - contentSize[sizeName] / 2);
      this._popover.style[primaryDirection] = primaryOffset + 'px';
      this._popover.style[secondaryDirection] = secondaryOffset + 'px';

      // Setting .popover__arrow position.
      this._arrow.style[secondaryDirection] = Math.max(radius, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - secondaryOffset) + 'px';
    }
  }, {
    key: '_calculateDirections',
    value: function _calculateDirections(distance) {
      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
        return positions[e];
      });
      var primary = options.sort(function (a, b) {
        return distance[a] - distance[b];
      })[0];
      var vertical = 'top' == primary || 'bottom' == primary;
      var secondary = void 0;

      if (vertical) {
        secondary = distance.left < distance.right ? 'left' : 'right';
      } else {
        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
      }

      return { vertical: vertical, primary: primary, secondary: secondary };
    }
  }, {
    key: '_clearStyles',
    value: function _clearStyles() {
      var _this2 = this;

      this._currentDirection = null;
      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
        _this2._arrow.style[e] = _this2._content.style[e] = _this2._popover.style[e] = '';
        util$1.removeModifier(_this2, e);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      var _this3 = this;

      setImmediate(function () {
        if (_this3._currentTarget) {
          _this3._positionPopover(_this3._currentTarget);
        }
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this._popover && this._mask) {
        return;
      }

      var hasDefaultContainer = this._popover && this._content;

      if (hasDefaultContainer) {

        if (!this._mask) {
          var mask = document.createElement('div');
          mask.classList.add('popover-mask');
          this.insertBefore(mask, this.firstChild);
        }

        if (!this._arrow) {
          var arrow = document.createElement('div');
          arrow.classList.add('popover__arrow');
          this._popover.appendChild(arrow);
        }
      } else {

        var template = util$1.createFragment('\n        <div class="popover-mask"></div>\n        <div class="popover">\n          <div class="popover__content"></div>\n          <div class="popover__arrow"></div>\n        </div>\n      ');
        var content = template.querySelector('.popover__content');

        while (this.childNodes[0]) {
          content.appendChild(this.childNodes[0]);
        }

        this.appendChild(template);
      }

      // FIXME!
      if (this.hasAttribute('style')) {
        this._popover.setAttribute('style', this.getAttribute('style'));
        this.removeAttribute('style');
      }

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @method show
     * @signature show(target, [options])
     * @param {String|Event|HTMLElement} target
     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element. It can be also provided as 'options.target' instead. [/en]
     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the popover has been revealed.[/en]
     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show(target) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Copy options and include options.target
      if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && !(target instanceof Event) && !(target instanceof HTMLElement)) {
        options = _extends({}, target);
      } else {
        options = _extends({}, options, { target: target });
      }

      if (typeof options.target === 'string') {
        options.target = document.querySelector(options.target);
      } else if (options.target instanceof Event) {
        options.target = options.target.target;
      }

      if (!(options.target instanceof HTMLElement)) {
        util$1.throw('Invalid target type or undefined');
      }

      return get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'show', this).call(this, options);
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the popover has been hidden.[/en]
     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close the popover.[/en]
     *   [ja]ポップオーバーを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]
     *     A boolean value that specifies whether the popover is cancelable or not.
     *
     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'connectedCallback', this).call(this);

      window.addEventListener('resize', this._boundOnChange, false);
      this._margin = this._margin || parseInt(window.getComputedStyle(this).getPropertyValue('top'));
      this._margin = this._margin || 6; // Fix for iframes

      contentReady(this, function () {
        _this4._radius = parseInt(window.getComputedStyle(_this4._content).getPropertyValue('border-top-left-radius'));
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'disconnectedCallback', this).call(this);
      window.removeEventListener('resize', this._boundOnChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'direction') {
        return this._boundOnChange();
      } else if (name === 'modifier') {
        this._currentDirection && util$1.addModifier(this, this._currentDirection);
      }
      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @param {String} name
     * @param {PopoverAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$19;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.popover-mask');
    }
  }, {
    key: '_popover',
    get: function get$$1() {
      return util$1.findChild(this, '.popover');
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return util$1.findChild(this._popover, '.popover__content');
    }
  }, {
    key: '_arrow',
    get: function get$$1() {
      return util$1.findChild(this._popover, '.popover__arrow');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof PopoverAnimator)) {
        util$1.throwAnimator('Popover');
      }
      _animatorDict$6[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement), 'observedAttributes', this)), ['direction']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$6;
    }
  }, {
    key: 'PopoverAnimator',
    get: function get$$1() {
      return PopoverAnimator;
    }
  }]);
  return PopoverElement;
}(BaseDialogElement);

onsElements.Popover = PopoverElement;
customElements.define('ons-popover', PopoverElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$20 = {
  '.progress-bar': 'progress-bar--*',
  '.progress-bar__primary': 'progress-bar--*__primary',
  '.progress-bar__secondary': 'progress-bar--*__secondary'
};

var template = util$1.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

var INDET = 'indeterminate';

/**
 * @element ons-progress-bar
 * @category visual
 * @modifier material
 *   [en]Display a Material Design progress bar.[/en]
 *   [ja]マテリアルデザインのスタイルでプログレスバーを表示します。[/ja]
 * @description
 *   [en]
 *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
 *   [/en]
 *   [ja][/ja]
 * @codepen zvQbGj
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-circular
 *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-bar
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-bar>
 *
 * <ons-progress-bar
 *  indeterminate>
 * </ons-progress-bar>
 */

var ProgressBarElement = function (_BaseElement) {
  inherits(ProgressBarElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Change the appearance of the progress indicator.[/en]
   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
   */

  /**
   * @attribute value
   * @type {Number}
   * @description
   *   [en]Current progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute secondary-value
   * @type {Number}
   * @description
   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute indeterminate
   * @description
   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
   */

  function ProgressBarElement() {
    classCallCheck(this, ProgressBarElement);

    var _this = possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ProgressBarElement, [{
    key: '_compile',
    value: function _compile() {
      if (!this._isCompiled()) {
        this._template = template.cloneNode(true);
      } else {
        this._template = util$1.findChild(this, '.progress-bar');
      }

      this._primary = util$1.findChild(this._template, '.progress-bar__primary');
      this._secondary = util$1.findChild(this._template, '.progress-bar__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      autoStyle.prepare(this);
      ModifierUtil.initModifier(this, scheme$20);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util$1.findChild(this, '.progress-bar')) {
        return false;
      }

      var barElement = util$1.findChild(this, '.progress-bar');

      if (!util$1.findChild(barElement, '.progress-bar__secondary')) {
        return false;
      }

      if (!util$1.findChild(barElement, '.progress-bar__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$20);
        this.hasAttribute(INDET) && this._updateDeterminate();
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === INDET) {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this2 = this;

      contentReady(this, function () {
        return util$1.toggleModifier(_this2, INDET, { force: _this2.hasAttribute(INDET) });
      });
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._primary.style.width = _this3.hasAttribute('value') ? _this3.getAttribute('value') + '%' : '0%';
        _this3._secondary.style.width = _this3.hasAttribute('secondary-value') ? _this3.getAttribute('secondary-value') + '%' : '0%';
      });
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'value',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set$$1(value) {
      if (value) {
        this.setAttribute(INDET, '');
      } else {
        this.removeAttribute(INDET);
      }
    },
    get: function get$$1() {
      return this.hasAttribute(INDET);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'value', 'secondary-value', INDET];
    }
  }]);
  return ProgressBarElement;
}(BaseElement);

onsElements.ProgressBar = ProgressBarElement;
customElements.define('ons-progress-bar', ProgressBarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$21 = {
  '.progress-circular': 'progress-circular--*',
  '.progress-circular__background': 'progress-circular--*__background',
  '.progress-circular__primary': 'progress-circular--*__primary',
  '.progress-circular__secondary': 'progress-circular--*__secondary'
};

var template$1 = util$1.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__background" />\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" />\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" />\n  </svg>\n');

var INDET$1 = 'indeterminate';

/**
 * @element ons-progress-circular
 * @category visual
 * @description
 *   [en]
 *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
 *   [/en]
 *   [ja][/ja]
 * @codepen EVzMjR
 * @tutorial vanilla/Reference/progress-circular
 * @seealso ons-progress-bar
 *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-circular
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-circular>
 *
 * <ons-progress-circular
 *  indeterminate>
 * </ons-progress-circular>
 */

var ProgressCircularElement = function (_BaseElement) {
  inherits(ProgressCircularElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Change the appearance of the progress indicator.[/en]
   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
   */

  /**
   * @attribute value
   * @type {Number}
   * @description
   *   [en]Current progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute secondary-value
   * @type {Number}
   * @description
   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute indeterminate
   * @description
   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
   */

  function ProgressCircularElement() {
    classCallCheck(this, ProgressCircularElement);

    var _this = possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ProgressCircularElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$21);
        this.hasAttribute(INDET$1) && this._updateDeterminate();
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === INDET$1) {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this2 = this;

      contentReady(this, function () {
        return util$1.toggleModifier(_this2, INDET$1, { force: _this2.hasAttribute(INDET$1) });
      });
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this3 = this;

      if (this.hasAttribute('value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this3.getAttribute('value') * 251.32 * 0.01);
          _this3._primary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
      if (this.hasAttribute('secondary-value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this3.getAttribute('secondary-value') * 251.32 * 0.01);
          _this3._secondary.style.display = null;
          _this3._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      } else {
        contentReady(this, function () {
          _this3._secondary.style.display = 'none';
        });
      }
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      if (this._isCompiled()) {
        this._template = util$1.findChild(this, '.progress-circular');
      } else {
        this._template = template$1.cloneNode(true);
      }

      this._primary = util$1.findChild(this._template, '.progress-circular__primary');
      this._secondary = util$1.findChild(this._template, '.progress-circular__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      autoStyle.prepare(this);
      ModifierUtil.initModifier(this, scheme$21);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util$1.findChild(this, '.progress-circular')) {
        return false;
      }

      var svg = util$1.findChild(this, '.progress-circular');

      if (!util$1.findChild(svg, '.progress-circular__secondary')) {
        return false;
      }

      if (!util$1.findChild(svg, '.progress-circular__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'value',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set$$1(value) {
      if (value) {
        this.setAttribute(INDET$1, '');
      } else {
        this.removeAttribute(INDET$1);
      }
    },
    get: function get$$1() {
      return this.hasAttribute(INDET$1);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'value', 'secondary-value', INDET$1];
    }
  }]);
  return ProgressCircularElement;
}(BaseElement);

onsElements.ProgressCircular = ProgressCircularElement;
customElements.define('ons-progress-circular', ProgressCircularElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var STATE_INITIAL = 'initial';
var STATE_PREACTION = 'preaction';
var STATE_ACTION = 'action';

var throwType = function throwType(el, type) {
  return util$1.throw('"' + el + '" must be ' + type);
};

/**
 * @element ons-pull-hook
 * @category control
 * @description
 *   [en]
 *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
 *
 *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
 *   [/en]
 *   [ja][/ja]
 * @codepen WbJogM
 * @tutorial vanilla/Reference/pull-hook
 * @example
 * <ons-page>
 *   <ons-pull-hook>
 *     Release to refresh
 *   </ons-pull-hook>
 * </ons-page>
 *
 * <script>
 *   document.querySelector('ons-pull-hook').onAction = function(done) {
 *     setTimeout(done, 1000);
 *   };
 * </script>
 */

var PullHookElement = function (_BaseElement) {
  inherits(PullHookElement, _BaseElement);

  /**
   * @event changestate
   * @description
   *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
   *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Object} event.pullHook
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {String} event.state
   *   [en]Current state.[/en]
   *   [ja]現在の状態名を参照できます。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
   *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
   */

  /**
   * @attribute height
   * @type {String}
   * @description
   *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
   *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
   */

  /**
   * @attribute threshold-height
   * @type {String}
   * @description
   *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value will disable this property. If this value is lower than the height, it will skip "preaction" state.[/en]
   *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
   */

  /**
   * @attribute fixed-content
   * @description
   *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
   *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
   */

  function PullHookElement() {
    classCallCheck(this, PullHookElement);

    var _this = possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).call(this));

    _this._shouldFixScroll = util$1.globals.isUIWebView;

    _this._onDrag = _this._onDrag.bind(_this);
    _this._onDragStart = _this._onDragStart.bind(_this);
    _this._onDragEnd = _this._onDragEnd.bind(_this);
    _this._onScroll = _this._onScroll.bind(_this);

    _this._setState(STATE_INITIAL, true);
    _this._hide(); // Fix for transparent toolbar transitions
    return _this;
  }

  createClass(PullHookElement, [{
    key: '_setStyle',
    value: function _setStyle() {
      var height = this.height + 'px';
      styler(this, { height: height, lineHeight: height });
      this.style.display === '' && this._show();
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      var element = this._pageElement;

      if (element.scrollTop < 0) {
        element.scrollTop = 0;
      }
    }
  }, {
    key: '_canConsumeGesture',
    value: function _canConsumeGesture(gesture) {
      return gesture.direction === 'up' || gesture.direction === 'down';
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      var _this2 = this;

      if (!event.gesture || this.disabled) {
        return;
      }

      var tapY = event.gesture.center.clientY + this._pageElement.scrollTop;
      var maxY = window.innerHeight;
      // Only use drags that start near the pullHook to reduce flickerings
      var draggableAreaRatio = this._shouldFixScroll ? .8 : 1;

      this._ignoreDrag = event.consumed || tapY > maxY * draggableAreaRatio;

      if (!this._ignoreDrag) {
        var consume = event.consume;
        event.consume = function () {
          consume && consume();
          _this2._ignoreDrag = true;
          // This elements resizes .page__content so it is safer
          // to hide it when other components are dragged.
          _this2._hide();
        };

        if (this._canConsumeGesture(event.gesture)) {
          consume && consume();
          event.consumed = true;
          this._show(); // Not enough due to 'dragLockAxis'
        }
      }

      this._startScroll = this._pageElement.scrollTop;
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var _this3 = this;

      if (!event.gesture || this.disabled || this._ignoreDrag || !this._canConsumeGesture(event.gesture)) {
        return;
      }

      // Necessary due to 'dragLockAxis' (25px)
      if (this.style.display === 'none') {
        this._show();
      }

      event.stopPropagation();

      var tapY = event.gesture.center.clientY + this._pageElement.scrollTop;
      var maxY = window.innerHeight;

      // Hack to make it work on Android 4.4 WebView and iOS UIWebView. Scrolls manually
      // near the top of the page so there will be no inertial scroll when scrolling down.
      // Allowing default scrolling will kill all 'touchmove' events.
      if (this._shouldFixScroll) {
        this._pageElement.scrollTop = this._startScroll - event.gesture.deltaY;
        // Allow inertia when scrolling down below 50% of the view to reduce flickerings
        if (event.gesture.interimDirection !== 'up' || tapY <= maxY * .5) {
          event.gesture.preventDefault();
        }
      }

      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);
      if (scroll !== this._currentTranslation) {

        var th = this.thresholdHeight;
        if (th > 0 && scroll >= th) {
          event.gesture.stopDetect();
          setImmediate(function () {
            return _this3._finish();
          });
        } else if (scroll >= this.height) {
          this._setState(STATE_PREACTION);
        } else {
          this._setState(STATE_INITIAL);
        }

        this._translateTo(scroll);
      }
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      if (!event.gesture || this.disabled || this._ignoreDrag) {
        return;
      }

      event.stopPropagation();

      if (this._currentTranslation > 0) {
        var scroll = this._currentTranslation;

        if (scroll > this.height) {
          this._finish();
        } else {
          this._translateTo(0, { animate: true });
        }
      }
    }

    /**
     * @property onAction
     * @type {Function}
     * @description
     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_finish',
    value: function _finish() {
      var _this4 = this;

      this._setState(STATE_ACTION);
      this._translateTo(this.height, { animate: true });
      var action = this.onAction || function (done) {
        return done();
      };
      action(function () {
        _this4._translateTo(0, { animate: true });
        _this4._setState(STATE_INITIAL);
      });
    }

    /**
     * @property height
     * @type {Number}
     * @description
     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_setState',
    value: function _setState(state, noEvent) {
      var lastState = this.state;

      this.setAttribute('state', state);

      if (!noEvent && lastState !== this.state) {
        util$1.triggerElementEvent(this, 'changestate', {
          pullHook: this,
          state: state,
          lastState: lastState
        });
      }
    }

    /**
     * @property state
     * @readonly
     * @type {String}
     * @description
     *   [en]Current state of the element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      var _this5 = this;

      // Run asyncrhonously to avoid conflicts with Animit's style clean
      setImmediate(function () {
        _this5.style.display = '';
        if (_this5._pageElement) {
          _this5._pageElement.style.marginTop = '-' + _this5.height + 'px';
        }
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.style.display = 'none';
      if (this._pageElement) {
        this._pageElement.style.marginTop = '';
      }
    }

    /**
     * @param {Number} scroll
     * @param {Object} options
     * @param {Function} [options.callback]
     */

  }, {
    key: '_translateTo',
    value: function _translateTo(scroll) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._currentTranslation == 0 && scroll == 0) {
        return;
      }

      this._currentTranslation = scroll;
      var opt = options.animate ? { duration: .3, timing: 'cubic-bezier(.1, .7, .1, 1)' } : {};
      this._onPull && this._onPull((scroll / this.height).toFixed(2), opt);
      var scrollElement = this.hasAttribute('fixed-content') ? this : this._pageElement;

      Animit(scrollElement).queue({ transform: 'translate3d(0px, ' + scroll + 'px, 0px)' }, opt).play(function () {
        scroll === 0 && styler.clear(scrollElement, 'transition transform');
        options.callback instanceof Function && options.callback();
      });
    }
  }, {
    key: '_disableDragLock',
    value: function _disableDragLock() {
      // e2e tests need it
      this._dragLockDisabled = true;
      this._setupListeners(true);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var _this6 = this;

      var scrollToggle = function scrollToggle(action) {
        return _this6._pageElement[action + 'EventListener']('scroll', _this6._onScroll, false);
      };
      var gdToggle = function gdToggle(action) {
        var passive = { passive: true };
        _this6._gestureDetector[action]('drag', _this6._onDrag, passive);
        _this6._gestureDetector[action]('dragstart', _this6._onDragStart, passive);
        _this6._gestureDetector[action]('dragend', _this6._onDragEnd, passive);
      };

      if (this._gestureDetector) {
        gdToggle('off');
        this._gestureDetector.dispose();
        this._gestureDetector = null;
      }
      scrollToggle('remove');

      if (add) {
        this._gestureDetector = new GestureDetector(this._pageElement, {
          dragMinDistance: 1,
          dragDistanceCorrection: false,
          dragLockToAxis: !this._dragLockDisabled,
          passive: !this._shouldFixScroll
        });

        gdToggle('on');
        scrollToggle('add');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._currentTranslation = 0;
      this._pageElement = this.parentNode;

      this._setupListeners(true);
      this._setStyle();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._hide();
      this._setupListeners(false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'height' && this._pageElement) {
        this._setStyle();
      }
    }
  }, {
    key: 'onAction',
    get: function get$$1() {
      return this._onAction;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throwType('onAction', 'function or null');
      }
      this._onAction = value;
    }

    /**
     * @property onPull
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user pulls the element. It gets the pulled distance ratio (scroll / height) and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onPull',
    get: function get$$1() {
      return this._onPull;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throwType('onPull', 'function or null');
      }
      this._onPull = value;
    }
  }, {
    key: 'height',
    set: function set$$1(value) {
      if (!util$1.isInteger(value)) {
        throwType('height', 'integer');
      }

      this.setAttribute('height', value + 'px');
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('height') || '64', 10);
    }

    /**
     * @property thresholdHeight
     * @type {Number}
     * @description
     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'thresholdHeight',
    set: function set$$1(value) {
      if (!util$1.isInteger(value)) {
        throwType('thresholdHeight', 'integer');
      }

      this.setAttribute('threshold-height', value + 'px');
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('threshold-height') || '96', 10);
    }
  }, {
    key: 'state',
    get: function get$$1() {
      return this.getAttribute('state');
    }

    /**
     * @property pullDistance
     * @readonly
     * @type {Number}
     * @description
     *   [en]The current number of pixels the pull hook has moved.[/en]
     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]
     */

  }, {
    key: 'pullDistance',
    get: function get$$1() {
      return this._currentTranslation;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['height'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['changestate'];
    }
  }]);
  return PullHookElement;
}(BaseElement);

onsElements.PullHook = PullHookElement;
customElements.define('ons-pull-hook', PullHookElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$22 = {
  '': 'range--*',
  '.range__input': 'range--*__input',
  '.range__focus-ring': 'range--*__focus-ring'
};

var activeClassToken = 'range__input--active';

/**
 * @element ons-range
 * @category form
 * @modifier material
 *   [en]Material Design slider[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Range input component. Used to display a draggable slider.
 *
 *     Works very similar to the `<input type="range">` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xZQomM
 * @tutorial vanilla/Reference/range
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
 *   [ja][/ja]
 * @example
 * <ons-range value="20"></ons-range>
 * <ons-range modifier="material" value="10"></range>
 */

var RangeElement = function (_BaseInputElement) {
  inherits(RangeElement, _BaseInputElement);

  function RangeElement() {
    classCallCheck(this, RangeElement);

    var _this = possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).call(this));

    _this._onMouseDown = _this._onMouseDown.bind(_this);
    _this._onMouseUp = _this._onMouseUp.bind(_this);
    _this._onTouchStart = _this._onTouchStart.bind(_this);
    _this._onTouchEnd = _this._onTouchEnd.bind(_this);
    _this._onInput = _this._update.bind(_this);
    _this._onDragstart = _this._onDragstart.bind(_this);
    _this._onDragend = _this._onDragend.bind(_this);
    return _this;
  }

  createClass(RangeElement, [{
    key: '_compile',
    value: function _compile() {
      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), '_compile', this).call(this);
      this._updateDisabled(this.hasAttribute('disabled'));
    }

    /* Inherited props */

  }, {
    key: '_update',
    value: function _update() {
      var input = this._input;
      var focusRing = this._focusRing;

      input.style.backgroundSize = 100 * this._ratio + '% 2px';
      focusRing.value = this.value;

      // NOTE: "_zero" attribute is used for CSS styling.
      if (input.min === '' && input.value === '0' || input.min === input.value) {
        input.setAttribute('_zero', '');
      } else {
        input.removeAttribute('_zero');
      }

      ['min', 'max'].forEach(function (attr) {
        return focusRing[attr] = input[attr];
      });
    }
  }, {
    key: '_onMouseDown',


    /* Own props */

    value: function _onMouseDown(e) {
      var _this2 = this;

      this._input.classList.add(activeClassToken);
      setImmediate(function () {
        return _this2._input.focus();
      });
    }
  }, {
    key: '_onTouchStart',
    value: function _onTouchStart(e) {
      this._onMouseDown();
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(e) {
      this._input.classList.remove(activeClassToken);
    }
  }, {
    key: '_onTouchEnd',
    value: function _onTouchEnd(e) {
      this._onMouseUp(e);
    }
  }, {
    key: '_onDragstart',
    value: function _onDragstart(e) {
      e.consumed = true;
      e.gesture.stopPropagation();
      this._input.classList.add(activeClassToken);
      this.addEventListener('drag', this._onDrag);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.stopPropagation();
    }
  }, {
    key: '_onDragend',
    value: function _onDragend(e) {
      this._input.classList.remove(activeClassToken);
      this.removeEventListener('drag', this._onDrag);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'disabled') {
        this._updateDisabled(current);
      }
      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @param {boolean} disabled
     */

  }, {
    key: '_updateDisabled',
    value: function _updateDisabled(disabled) {
      if (disabled) {
        this.classList.add('range--disabled');
      } else {
        this.classList.remove('range--disabled');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._setupListeners(true);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._setupListeners(false);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var action = (add ? 'add' : 'remove') + 'EventListener';
      util$1[action](this, 'touchstart', this._onTouchStart, { passive: true });
      this[action]('mousedown', this._onMouseDown);
      this[action]('mouseup', this._onMouseUp);
      this[action]('touchend', this._onTouchEnd);
      this[action]('dragstart', this._onDragstart);
      this[action]('dragend', this._onDragend);
      this[action]('input', this._onInput);
    }

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current value.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$22;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <input type="range" class="range__focus-ring" tabIndex="-1">\n    ';
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'range';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'range';
    }
  }, {
    key: '_focusRing',
    get: function get$$1() {
      return this.children[1];
    }
  }, {
    key: '_ratio',
    get: function get$$1() {
      // Returns the current ratio.
      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
      var max = this._input.max === '' ? 100 : parseInt(this._input.max);

      return (this.value - min) / (max - min);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['disabled'].concat(toConsumableArray(BaseInputElement.observedAttributes));
    }
  }]);
  return RangeElement;
}(BaseInputElement);

onsElements.Range = RangeElement;
customElements.define('ons-range', RangeElement);

/*
Copyright 2013-2016 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @class AnimatorCSS - implementation of Animator class using css transitions
 */

var AnimatorCSS = function () {
  createClass(AnimatorCSS, [{
    key: 'animate',


    /**
     * @method animate
     * @desc main animation function
     * @param {Element} element
     * @param {Object} finalCSS
     * @param {number} [duration=200] - duration in milliseconds
     * @return {Object} result
     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
     * @example
     * ````
     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
     *
     *  el.addEventListener('click', function(e){
     *    result.speed(200).then(function(){
     *      console.log('done');
     *    });
     *  }, 300);
     * ````
     */
    value: function animate(el, final) {
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var start = new Date().getTime(),
          initial = {},
          stopped = false,
          next = false,
          timeout = false,
          properties = Object.keys(final);

      var updateStyles = function updateStyles() {
        var s = window.getComputedStyle(el);
        properties.forEach(s.getPropertyValue.bind(s));
        s = el.offsetHeight;
      };

      var result = {
        stop: function stop() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          timeout && clearTimeout(timeout);
          var k = Math.min(1, (new Date().getTime() - start) / duration);
          properties.forEach(function (i) {
            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
          });
          el.style.transitionDuration = '0s';

          if (options.stopNext) {
            next = false;
          } else if (!stopped) {
            stopped = true;
            next && next();
          }
          return result;
        },
        then: function then(cb) {
          next = cb;
          if (stopped) {
            next && next();
          }
          return result;
        },
        speed: function speed(newDuration) {
          if (internal$1.config.animationsDisabled) {
            newDuration = 0;
          }
          if (!stopped) {
            timeout && clearTimeout(timeout);

            var passed = new Date().getTime() - start;
            var k = passed / duration;
            var remaining = newDuration * (1 - k);

            properties.forEach(function (i) {
              el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
            });

            updateStyles();

            start = el.speedUpTime;
            duration = remaining;

            el.style.transitionDuration = duration / 1000 + 's';

            properties.forEach(function (i) {
              el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
            });

            timeout = setTimeout(result.stop, remaining);
          }
          return result;
        },
        finish: function finish() {
          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

          var k = (new Date().getTime() - start) / duration;

          result.speed(milliseconds / (1 - k));
          return result;
        }
      };

      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {
        return result;
      }

      var style = window.getComputedStyle(el);
      properties.forEach(function (e) {
        var v = parseFloat(style.getPropertyValue(e));
        initial[e] = isNaN(v) ? 0 : v;
      });

      if (!stopped) {
        el.style.transitionProperty = properties.join(',');
        el.style.transitionDuration = duration / 1000 + 's';

        properties.forEach(function (e) {
          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
        });
      }

      timeout = setTimeout(result.stop, duration);
      this._onStopAnimations(el, result.stop);

      return result;
    }
  }]);

  function AnimatorCSS() {
    classCallCheck(this, AnimatorCSS);

    this._queue = [];
    this._index = 0;
  }

  createClass(AnimatorCSS, [{
    key: '_onStopAnimations',
    value: function _onStopAnimations(el, listener) {
      var queue = this._queue;
      var i = this._index++;
      queue[el] = queue[el] || [];
      queue[el][i] = function (options) {
        delete queue[el][i];
        if (queue[el] && queue[el].length == 0) {
          delete queue[el];
        }
        return listener(options);
      };
    }

    /**
    * @method stopAnimations
    * @desc stops active animations on a specified element
    * @param {Element|Array} element - element or array of elements
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAnimations',
    value: function stopAnimations(el) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Array.isArray(el)) {
        return el.forEach(function (el) {
          _this.stopAnimations(el, options);
        });
      }

      (this._queue[el] || []).forEach(function (e) {
        e(options || {});
      });
    }

    /**
    * @method stopAll
    * @desc stops all active animations
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAll',
    value: function stopAll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.stopAnimations(Object.keys(this._queue), options);
    }

    /**
    * @method fade
    * @desc fades the element (short version for animate(el, {opacity: 0}))
    * @param {Element} element
    * @param {number} [duration=200]
    */

  }, {
    key: 'fade',
    value: function fade(el) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

      return this.animate(el, { opacity: 0 }, duration);
    }
  }]);
  return AnimatorCSS;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$11 = 'ripple';
var scheme$23 = {
  '': 'ripple--*',
  '.ripple__wave': 'ripple--*__wave',
  '.ripple__background': 'ripple--*__background'
};

/**
 * @element ons-ripple
 * @category visual
 * @description
 *   [en]
 *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
 *
 *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
 *   [/en]
 *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
 * @codepen wKQWdZ
 * @tutorial vanilla/Reference/ripple
 * @modifier light-gray
 *   [en]Change the color of effects to light gray.[/en]
 *   [ja]エフェクトの色が明るい灰色になります。[/ja]
 * @guide theming.html#cross-platform-styling-autostyling
 *  [en]Cross platform styling[/en]
 *  [ja]Cross platform styling[/ja]
 * @example
 * <div class="my-div">
 *  <ons-ripple></ons-ripple>
 * </div>
 *
 * @example
 * <ons-button ripple>Click me!</ons-button>
 */

var RippleElement = function (_BaseElement) {
  inherits(RippleElement, _BaseElement);

  /**
   * @attribute color
   * @type {String}
   * @description
   *   [en]Color of the ripple effect.[/en]
   *   [ja]リップルエフェクトの色を指定します。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the ripple effect.[/en]
   *   [ja]エフェクトの表現を指定します。[/ja]
   */

  /**
   * @attribute background
   * @type {String}
   * @description
   *   [en]Color of the background.[/en]
   *   [ja]背景の色を設定します。[/ja]
   */

  /**
   * @attribute size
   * @type {String}
   * @description
   *   [en]Sizing of the wave on ripple effect. Set "cover" or "contain". Default is "cover".[/en]
   *   [ja]エフェクトのサイズを指定します。"cover"もしくは"contain"を指定します。デフォルトは"cover"です。[/ja]
   */

  /**
   * @attribute center
   * @type {Boolean}
   * @description
   *   [en]If this attribute presents, change the position of wave effect to center of the target element.[/en]
   *   [ja]この要素を設定すると、エフェクトの位置が要素の真ん中から始まります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
   *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
   */

  function RippleElement() {
    classCallCheck(this, RippleElement);

    var _this = possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).call(this));

    _this._onTap = _this._onTap.bind(_this);
    _this._onHold = _this._onHold.bind(_this);
    _this._onDragStart = _this._onDragStart.bind(_this);
    _this._onRelease = _this._onRelease.bind(_this);

    contentReady(_this, function () {
      return _this._compile();
    });

    _this._animator = new AnimatorCSS();

    ['color', 'center', 'start-radius', 'background', 'modifier'].forEach(function (e) {
      _this.attributeChangedCallback(e, null, _this.getAttribute(e));
    });
    return _this;
  }

  createClass(RippleElement, [{
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$11);

      this._wave = this.getElementsByClassName('ripple__wave')[0];
      this._background = this.getElementsByClassName('ripple__background')[0];

      if (!(this._background && this._wave)) {
        this._wave = util$1.create('.ripple__wave');
        this._background = util$1.create('.ripple__background');

        this.appendChild(this._wave);
        this.appendChild(this._background);
      }

      ModifierUtil.initModifier(this, scheme$23);
    }
  }, {
    key: '_getEffectSize',
    value: function _getEffectSize() {
      var sizes = ['cover', 'contain'];
      if (this.hasAttribute('size')) {
        var size = this.getAttribute('size');
        if (sizes.indexOf(size) !== -1) {
          return size;
        }
      }

      return 'cover';
    }
  }, {
    key: '_calculateCoords',
    value: function _calculateCoords(e) {
      var x = void 0,
          y = void 0,
          h = void 0,
          w = void 0,
          r = void 0;
      var b = this.getBoundingClientRect();
      var size = this._getEffectSize();
      var error = function error() {
        return util$1.throw('Ripple invalid state');
      };

      if (this._center) {
        x = b.width / 2;
        y = b.height / 2;

        if (size === 'cover') {
          r = Math.sqrt(x * x + y * y);
        } else if (size === 'contain') {
          r = Math.min(x, y);
        } else {
          error();
        }
      } else {
        x = (typeof e.clientX === 'number' ? e.clientX : e.changedTouches[0].clientX) - b.left;
        y = (typeof e.clientY === 'number' ? e.clientY : e.changedTouches[0].clientY) - b.top;
        h = Math.max(y, b.height - y);
        w = Math.max(x, b.width - x);

        if (size === 'cover') {
          r = Math.sqrt(h * h + w * w);
        } else if (size === 'contain') {
          r = Math.min(Math.round(h / 2), Math.round(w / 2));
        } else {
          error();
        }
      }

      return { x: x, y: y, r: r };
    }
  }, {
    key: '_rippleAnimation',
    value: function _rippleAnimation(e) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
      var _animator = this._animator,
          _wave = this._wave,
          _background = this._background,
          _minR = this._minR;

      var _calculateCoords2 = this._calculateCoords(e),
          x = _calculateCoords2.x,
          y = _calculateCoords2.y,
          r = _calculateCoords2.r;

      _animator.stopAll({ stopNext: 1 });
      _animator.animate(_background, { opacity: 1 }, duration);

      util$1.extend(_wave.style, {
        opacity: 1,
        top: y - _minR + 'px',
        left: x - _minR + 'px',
        width: 2 * _minR + 'px',
        height: 2 * _minR + 'px'
      });

      return _animator.animate(_wave, {
        top: y - r,
        left: x - r,
        height: 2 * r,
        width: 2 * r
      }, duration);
    }
  }, {
    key: '_updateParent',
    value: function _updateParent() {
      if (!this._parentUpdated && this.parentNode) {
        var computedStyle = window.getComputedStyle(this.parentNode);
        if (computedStyle.getPropertyValue('position') === 'static') {
          this.parentNode.style.position = 'relative';
        }
        this._parentUpdated = true;
      }
    }
  }, {
    key: '_onTap',
    value: function _onTap(e) {
      var _this2 = this;

      if (!this.disabled && !e.ripple) {
        e.ripple = true;
        this._updateParent();
        this._rippleAnimation(e.gesture.srcEvent).then(function () {
          _this2._animator.fade(_this2._wave);
          _this2._animator.fade(_this2._background);
        });
      }
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled && !e.ripple) {
        e.ripple = true;
        this._updateParent();
        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
        document.addEventListener('release', this._onRelease);
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var _this3 = this;

      if (this._holding && !e.ripple) {
        e.ripple = true;
        this._holding.speed(300).then(function () {
          _this3._animator.stopAll({ stopNext: true });
          _this3._animator.fade(_this3._wave);
          _this3._animator.fade(_this3._background);
        });

        this._holding = false;
      }

      document.removeEventListener('release', this._onRelease);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this._holding) {
        return this._onRelease(e);
      }
      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
        this._onTap(e);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._parentNode = this.parentNode;

      if (internal$1.config.animationsDisabled) {
        this.disabled = true;
      } else {
        this._parentNode.addEventListener('tap', this._onTap);
        this._parentNode.addEventListener('hold', this._onHold);
        this._parentNode.addEventListener('dragstart', this._onDragStart);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var pn = this._parentNode || this.parentNode;
      pn.removeEventListener('tap', this._onTap);
      pn.removeEventListener('hold', this._onHold);
      pn.removeEventListener('dragstart', this._onDragStart);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this4 = this;

      switch (name) {

        case 'class':
          util$1.restoreClass(this, defaultClassName$11, scheme$23);
          break;

        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$23);
          break;

        case 'start-radius':
          this._minR = Math.max(0, parseFloat(current) || 0);
          break;

        case 'color':
          if (current) {
            contentReady(this, function () {
              _this4._wave.style.background = current;
              if (!_this4.hasAttribute('background')) {
                _this4._background.style.background = current;
              }
            });
          }
          break;

        case 'background':
          if (current || last) {
            if (current === 'none') {
              contentReady(this, function () {
                _this4._background.setAttribute('disabled', 'disabled');
                _this4._background.style.background = 'transparent';
              });
            } else {
              contentReady(this, function () {
                if (_this4._background.hasAttribute('disabled')) {
                  _this4._background.removeAttribute('disabled');
                }
                _this4._background.style.background = current;
              });
            }
          }
          break;

        case 'center':
          if (name === 'center') {
            this._center = current != null && current != 'false';
          }
          break;

      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['start-radius', 'color', 'background', 'center', 'class', 'modifier'];
    }
  }]);
  return RippleElement;
}(BaseElement);

onsElements.Ripple = RippleElement;
customElements.define('ons-ripple', RippleElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-row
 * @category grid
 * @description
 *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
 *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
 * @codepen GgujC {wide}
 * @guide theming.html
 *   [en]Layouting guide[/en]
 *   [ja]レイアウト調整[/ja]
 * @seealso ons-col
 *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
 *   [ja]ons-colコンポーネント[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
 *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
 */

var RowElement = function (_BaseElement) {
  inherits(RowElement, _BaseElement);

  function RowElement() {
    classCallCheck(this, RowElement);
    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));
  }

  return RowElement;
}(BaseElement);

onsElements.Row = RowElement;
customElements.define('ons-row', RowElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$12 = 'segment';
var scheme$24 = {
  '': 'segment--*',
  '.segment__item': 'segment--*__item',
  '.segment__input': 'segment--*__input',
  '.segment__button': 'segment--*__button'
};

var generateId$1 = function () {
  var i = 0;
  return function () {
    return 'ons-segment-gen-' + i++;
  };
}();

/**
 * @element ons-segment
 * @category control
 * @modifier material
 *   [en]Material Design segment[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Segment component. Use this component to have a button bar with automatic styles that switch on click of another button.
 *
 *     Will automatically display as a Material Design segment on Android.
 *   [/en]
 *   [ja][/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/segment
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-segment>
 *   <ons-button>Label 1</ons-button>
 *   <ons-button>Label 2</ons-button>
 *   <ons-button>Label 3</ons-button>
 * </ons-segment>
 */

var SegmentElement = function (_BaseElement) {
  inherits(SegmentElement, _BaseElement);

  /**
   * @event postchange
   * @description
   *   [en]Fires after the active button is changed.[/en]
   *   [ja][/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja][/ja]
   * @param {Number} event.index
   *   [en]Tapped button index.[/en]
   *   [ja][/ja]
   * @param {Object} event.segmentItem
   *   [en]Segment item object.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the segment.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute tabbar-id
   * @initonly
   * @type {String}
   * @description
   *  [en]ID of the tabbar element to "connect" to the segment. Must be inside the same page.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute active-index
   * @initonly
   * @default 0
   * @type {Number}
   * @description
   *  [en]Index of the first active button, only works if there is no connected tabbar (in which case the active tab sets the active button).[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if segment should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定します。[/ja]
   */

  function SegmentElement() {
    classCallCheck(this, SegmentElement);

    var _this = possibleConstructorReturn(this, (SegmentElement.__proto__ || Object.getPrototypeOf(SegmentElement)).call(this));

    _this._segmentId = generateId$1();
    _this._tabbar = null;
    _this._onChange = _this._onChange.bind(_this);
    _this._onTabbarPreChange = _this._onTabbarPreChange.bind(_this);

    contentReady(_this, function () {
      _this._compile();
      setImmediate(function () {
        return _this._lastActiveIndex = _this._tabbar ? _this._tabbar.getActiveTabIndex() : _this.getActiveButtonIndex();
      });
    });
    return _this;
  }

  createClass(SegmentElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$12);

      for (var index = this.children.length - 1; index >= 0; index--) {
        var item = this.children[index];
        item.classList.add('segment__item');

        var input = util$1.findChild(item, '.segment__input') || util$1.create('input.segment__input');
        input.type = 'radio';
        input.value = index;
        input.name = input.name || this._segmentId;
        input.checked = !this.hasAttribute('tabbar-id') && index === (parseInt(this.getAttribute('active-index')) || 0);

        var button = util$1.findChild(item, '.segment__button') || util$1.create('.segment__button');
        if (button.parentElement !== item) {
          while (item.firstChild) {
            button.appendChild(item.firstChild);
          }
        }

        item.appendChild(input);
        item.appendChild(button);
      }

      ModifierUtil.initModifier(this, scheme$24);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (this.hasAttribute('tabbar-id')) {
        contentReady(this, function () {
          var page = util$1.findParent(_this2, 'ons-page');
          _this2._tabbar = page && page.querySelector('#' + _this2.getAttribute('tabbar-id'));
          if (!_this2._tabbar || _this2._tabbar.tagName !== 'ONS-TABBAR') {
            util$1.throw('No tabbar with id ' + _this2.getAttribute('tabbar-id') + ' was found.');
          }

          _this2._tabbar.setAttribute('hide-tabs', '');
          setImmediate(function () {
            return _this2._setChecked(_this2._tabbar.getActiveTabIndex());
          });

          _this2._tabbar.addEventListener('prechange', _this2._onTabbarPreChange);
        });
      }

      this.addEventListener('change', this._onChange);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        if (_this3._tabbar) {
          _this3._tabbar.removeEventListener('prechange', _this3._onTabbarPreChange);
          _this3._tabbar = null;
        }
      });
      this.removeEventListener('change', this._onChange);
    }
  }, {
    key: '_setChecked',
    value: function _setChecked(index) {
      this.children[index].firstElementChild.checked = true;
    }

    /**
     * @method setActiveButton
     * @signature setActiveButton(index, [options])
     * @param {Number} index
     *   [en]Button index.[/en]
     *   [ja][/ja]
     * @param {Object} [options]
     *   [en]Parameter object, works only if there is a connected tabbar. Supports the same options as `ons-tabbar`'s `setActiveTab` method.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Make button with the specified index active. If there is a connected tabbar it shows the corresponding tab page. In this case animations and their options can be specified by the second parameter.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the selected index or to the new page element if there is a connected tabbar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveButton',
    value: function setActiveButton(index, options) {
      if (this._tabbar) {
        return this._tabbar.setActiveTab(index, options);
      }

      this._setChecked(index);
      this._postChange(index);
      return Promise.resolve(index);
    }

    /**
     * @method getActiveButtonIndex
     * @signature getActiveButtonIndex()
     * @return {Number}
     *   [en]The index of the currently active button.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Returns button index of current active button. If active button is not found, returns -1.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'getActiveButtonIndex',
    value: function getActiveButtonIndex() {
      for (var i = this.children.length - 1; i >= 0; i--) {
        // Array.findIndex
        if (this.children[i].firstElementChild.checked) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      event.stopPropagation();
      this._tabbar ? this._tabbar.setActiveTab(this.getActiveButtonIndex(), { reject: false }) : this._postChange(this.getActiveButtonIndex());
    }
  }, {
    key: '_onTabbarPreChange',
    value: function _onTabbarPreChange(event) {
      var _this4 = this;

      setImmediate(function () {
        if (!event.detail.canceled) {
          _this4._setChecked(event.index);
          _this4._postChange(event.index);
        }
      });
    }
  }, {
    key: '_postChange',
    value: function _postChange(index) {
      util$1.triggerElementEvent(this, 'postchange', {
        index: index,
        activeIndex: index,
        lastActiveIndex: this._lastActiveIndex,
        segmentItem: this.children[index]
      });
      this._lastActiveIndex = index;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the segment is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$12, scheme$24);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$24);
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['class', 'modifier'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['postchange'];
    }
  }]);
  return SegmentElement;
}(BaseElement);

onsElements.Segment = SegmentElement;
customElements.define('ons-segment', SegmentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$25 = {
  '': 'select-* select--*',
  '.select-input': 'select-input--*'
};

var defaultClassName$13 = 'select';

var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'];

/**
 * @element ons-select
 * @category form
 * @modifier material
 *  [en]Displays a Material Design select input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a select input.[/en]
 *  [ja][/ja]
 * @description
 *   [en]
 *     Select component. If you want to place a select with an ID of `my-id` on a page, use `<ons-select select-id="my-id">`.
 *
 *     The component will automatically display as a Material Design select on Android.
 *
 *     Most attributes that can be used for a normal `<select>` element can also be used on the `<ons-select>` element.
 *   [/en]
 *   [ja]セレクトボックスを表示するコンポーネントです。`select` 要素に使用できる属性の多くが `ons-select` 要素でも利用できます。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/select
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-select>
 *   <option value="1">1</option>
 *   <option value="2">2nd</option>
 *   <option value="3">3rd option</option>
 * </ons-select>
 */

var SelectElement = function (_BaseElement) {
  inherits(SelectElement, _BaseElement);

  /**
   * @attribute autofocus
   * @type {Boolean}
   * @default false
   * @description
   *  [en]Element automatically gains focus on page load.[/en]
   *  [ja]ページロード時にこのセレクトボックスにフォーカスが移るようにします。[/ja]
   */

  /**
   * @attribute disabled
   * @type {Boolean}
   * @default false
   * @description
   *   [en]Specify if select input should be disabled.[/en]
   *   [ja]このセレクトボックスを無効化する場合に指定します。[/ja]
   */

  /**
   * @attribute form
   * @type {String}
   * @description
   *   [en]Associate a select element to an existing form on the page, even if not nested.[/en]
   *   [ja]このセレクトボックスを、指定した `form` 要素に紐付けます。セレクトボックスを `form` 要素の外側に配置する際に使用します。[/ja]
   */

  /**
   * @attribute multiple
   * @type {Boolean}
   * @default false
   * @description
   *  [en]If this attribute is defined, multiple options can be selected at once.[/en]
   *  [ja]選択肢の複数選択を有効にします。[/ja]
   */

  /**
   * @attribute name
   * @type {String}
   * @description
   *   [en]Name the select element, useful for instance if it is part of a form.[/en]
   *   [ja]このセレクトボックスの名前を指定します。通常 `form` 要素と共に使用します。[/ja]
   */

  /**
   * @attribute required
   * @type {Boolean}
   * @description
   *   [en]Make the select input required for submitting the form it is part of.[/en]
   *   [ja]このセレクトボックスを入力必須にする場合に指定します。通常 `form` 要素と共に使用します。[/ja]
   */

  /**
   * @attribute select-id
   * @type {String}
   * @description
   *   [en]ID given to the inner select, useful for dynamic manipulation.[/en]
   *   [ja]このセレクトボックスが内部に持つ select 要素に与える ID を指定します。セレクトボックスの内容を動的に変更する必要がある場合に使用します。[/ja]
   */

  /**
   * @attribute size
   * @type {Number}
   * @default 1
   * @description
   *   [en]How many options are displayed; if there are more than the size then a scroll appears to navigate them.[/en]
   *   [ja]一度に表示する選択肢の個数を指定します。選択肢がこの属性で指定した個数よりも多い場合、スクロールが有効になります。[/ja]
   */

  function SelectElement() {
    classCallCheck(this, SelectElement);

    var _this = possibleConstructorReturn(this, (SelectElement.__proto__ || Object.getPrototypeOf(SelectElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });

    _this._deriveGetters();
    return _this;
  }

  createClass(SelectElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this2 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$13, scheme$25);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$25);
          break;
      }

      if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this2._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this3 = this;

      INPUT_ATTRIBUTES$1.forEach(function (attr) {
        if (_this3.hasAttribute(attr)) {
          _this3._select.setAttribute(attr, _this3.getAttribute(attr));
        } else {
          _this3._select.removeAttribute(attr);
        }
      });
    }

    /**
     * @property length
     * @description
     *   [en]Number of options in the select box.[/en]
     *   [ja]このセレクトボックスに含まれる選択肢の個数を返します。 `select` 要素[/ja]
     */

    /**
     * @property options
     * @description
     *   [en]Several options for handling the select DOM object.[/en]
     *   [ja]このセレクトボックスに含まれる `option` 要素の配列を返します。[/ja]
     */

    /**
     * @property selectedIndex
     * @description
     *   [en]Index of the currently selected option.[/en]
     *   [ja]現在選択されている選択肢のインデックスを返します。[/ja]
     */

    /**
     * @property value
     * @description
     *   [en]Value of the currently selected option.[/en]
     *   [ja]現在選択されている選択肢の値を返します。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$13);
      var sel = this._select || document.createElement('select');
      if (!sel.id && this.hasAttribute('select-id')) {
        sel.id = this.getAttribute('select-id');
      }
      sel.classList.add('select-input');
      if (!this._select) {
        util$1.arrayFrom(this.childNodes).forEach(function (element) {
          return sel.appendChild(element);
        });
        this.appendChild(sel);
      }

      ModifierUtil.initModifier(this, scheme$25);
    }
  }, {
    key: '_deriveGetters',
    value: function _deriveGetters() {
      var _this4 = this;

      ['disabled', 'length', 'multiple', 'name', 'options', 'selectedIndex', 'size', 'value', 'form', 'type'].forEach(function (key) {
        Object.defineProperty(_this4, key, {
          configurable: true,
          enumerable: true,
          get: function get$$1() {
            return _this4._select[key];
          },
          set: ['form', 'type'].indexOf(key) === -1 ? function (value) {
            return contentReady(_this4, function () {
              return _this4._select[key] = value;
            });
          } : undefined
        });
      });
    }
  }, {
    key: 'add',
    value: function add(option) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._select.add(option, index);
    }
  }, {
    key: 'remove',
    value: function remove(index) {
      this._select.remove(index);
    }
  }, {
    key: '_select',
    get: function get$$1() {
      return this.querySelector('select');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'].concat(INPUT_ATTRIBUTES$1);
    }
  }]);
  return SelectElement;
}(BaseElement);

onsElements.Select = SelectElement;
customElements.define('ons-select', SelectElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$14 = 'fab fab--mini speed-dial__item';

var scheme$26 = {
  '': 'fab--* speed-dial__item--*'
};

/**
 * @element ons-speed-dial-item
 * @category control
 * @description
 *   [en]
 *     This component displays the child elements of the Material Design Speed dial component.
 *   [/en]
 *   [ja]
 *     Material DesignのSpeed dialの子要素を表現する要素です。
 *   [/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component.[/en]
 *   [ja]ons-speed-dialコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialItemElement = function (_BaseElement) {
  inherits(SpeedDialItemElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the component.[/en]
   *   [ja]このコンポーネントの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  function SpeedDialItemElement() {
    classCallCheck(this, SpeedDialItemElement);

    var _this = possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).call(this));

    _this._compile();
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(SpeedDialItemElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$14, scheme$26);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$26);
          util$1.addModifier(this, 'mini');
          break;
        case 'ripple':
          this._updateRipple();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util$1.updateRipple(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      e.stopPropagation();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this2 = this;

      autoStyle.prepare(this);

      defaultClassName$14.split(/\s+/).forEach(function (token) {
        return _this2.classList.add(token);
      });

      util$1.addModifier(this, 'mini');
      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$26);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return SpeedDialItemElement;
}(BaseElement);

onsElements.SpeedDialItem = SpeedDialItemElement;
customElements.define('ons-speed-dial-item', SpeedDialItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$15 = 'speed-dial';
var scheme$27 = {
  '': 'speed-dial--*'
};

/**
 * @element ons-speed-dial
 * @category control
 * @description
 *   [en]
 *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
 *
 *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
 *   [/en]
 *   [ja][/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial-item
 *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
 *   [ja]ons-speed-dial-itemコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialElement = function (_BaseElement) {
  inherits(SpeedDialElement, _BaseElement);

  /**
   * @event open
   * @description
   *   [en]Fired when the menu items are shown.[/en]
   *   [ja][/ja]
   */

  /**
   * @event close
   * @description
   *   [en]Fired when the menu items are hidden.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the component.[/en]
   *   [ja]このコンポーネントの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute position
   * @type {String}
   * @description
   *   [en]
   *     Specify the vertical and horizontal position of the component.
   *     I.e. to display it in the top right corner specify "right top".
   *     Choose from "right", "left", "top" and "bottom".
   *   [/en]
   *   [ja]
   *     この要素を表示する左右と上下の位置を指定します。
   *     例えば、右上に表示する場合には"right top"を指定します。
   *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
   *   [/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
   *   [ja]
   *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
   *   [/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]無効化する場合に指定します。[/ja]
   */

  function SpeedDialElement() {
    classCallCheck(this, SpeedDialElement);

    var _this = possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });

    _this._itemShown = false;
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(SpeedDialElement, [{
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$15);
      autoStyle.prepare(this);
      this._updateRipple();
      ModifierUtil.initModifier(this, scheme$27);

      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      this._updatePosition();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this2 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$15, scheme$27);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$27);
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this2._updateRipple();
          });
          break;
        case 'direction':
          contentReady(this, function () {
            return _this2._updateDirection(current);
          });
          break;
        case 'position':
          contentReady(this, function () {
            return _this2._updatePosition();
          });
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      if (this.onClick) {
        this.onClick.apply(this);
        return Promise.resolve();
      } else if (!this.disabled && this.visible) {
        return this.toggleItems();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this.inline) {
        return this.show();
      }
      return Promise.resolve();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this3 = this;

      return new Promise(function (resolve) {
        if (!_this3.inline) {
          setImmediate(function () {
            return _this3.hide().then(resolve);
          });
        } else {
          resolve();
        }
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      if (this._fab) {
        this.hasAttribute('ripple') ? this._fab.setAttribute('ripple', '') : this._fab.removeAttribute('ripple');
      }
    }
  }, {
    key: '_updateDirection',
    value: function _updateDirection(direction) {
      var children = this.items;
      for (var i = 0; i < children.length; i++) {
        styler(children[i], {
          transitionDelay: 25 * i + 'ms',
          bottom: 'auto',
          right: 'auto',
          top: 'auto',
          left: 'auto'
        });
      }
      switch (direction) {
        case 'up':
          for (var _i = 0; _i < children.length; _i++) {
            children[_i].style.bottom = 72 + 56 * _i + 'px';
            children[_i].style.right = '8px';
          }
          break;
        case 'down':
          for (var _i2 = 0; _i2 < children.length; _i2++) {
            children[_i2].style.top = 72 + 56 * _i2 + 'px';
            children[_i2].style.left = '8px';
          }
          break;
        case 'left':
          for (var _i3 = 0; _i3 < children.length; _i3++) {
            children[_i3].style.top = '8px';
            children[_i3].style.right = 72 + 56 * _i3 + 'px';
          }
          break;
        case 'right':
          for (var _i4 = 0; _i4 < children.length; _i4++) {
            children[_i4].style.top = '8px';
            children[_i4].style.left = 72 + 56 * _i4 + 'px';
          }
          break;
        default:
          util$1.throw('Argument must be one of up, down, left or right.');
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }
  }, {
    key: '_getTranslate',
    value: function _getTranslate() {
      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
      var translate = isBottom ? 'translate3d(0px, -' + (util$1.globals.fabOffset || 0) + 'px, 0px) ' : '';
      return translate;
    }

    /**
     * @method show
     * @signature show()
     * @description
     *   [en]Show the speed dial.[/en]
     *   [ja]Speed dialを表示します。[/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this._fab.show();
      styler(this, { transform: this._getTranslate });
      return Promise.resolve();
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *   [en]Hide the speed dial.[/en]
     *   [ja]Speed dialを非表示にします。[/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      return this.hideItems().then(function () {
        return _this4._fab.hide();
      });
    }

    /**
     * @method showItems
     * @signature showItems()
     * @description
     *   [en]Show the speed dial items.[/en]
     *   [ja]Speed dialの子要素を表示します。[/ja]
     */

  }, {
    key: 'showItems',
    value: function showItems() {
      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      var totalDelay = 0;
      if (!this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * i;
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(1)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = true;
        util$1.triggerElementEvent(this, 'open');
      }

      var deferred = util$1.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @method hideItems
     * @signature hideItems()
     * @description
     *   [en]Hide the speed dial items.[/en]
     *   [ja]Speed dialの子要素を非表示にします。[/ja]
     */

  }, {
    key: 'hideItems',
    value: function hideItems() {
      var totalDelay = 0;
      if (this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * (children.length - i);
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(0)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = false;
        util$1.triggerElementEvent(this, 'close');
      }

      var deferred = util$1.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'isOpen',


    /**
     * @method isOpen
     * @signature isOpen()
     * @description
     *   [en]Returns whether the menu is open or not.[/en]
     *   [ja][/ja]
     */
    value: function isOpen() {
      return this._itemShown;
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle visibility.[/en]
     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      return this.visible ? this.hide() : this.show();
    }

    /**
     * @method toggleItems
     * @signature toggleItems()
     * @description
     *   [en]Toggle item visibility.[/en]
     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggleItems',
    value: function toggleItems() {
      return this.isOpen() ? this.hideItems() : this.showItems();
    }
  }, {
    key: 'items',
    get: function get$$1() {
      return util$1.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
    }
  }, {
    key: '_fab',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-fab');
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      if (value) {
        this.hideItems();
      }
      util$1.arrayFrom(this.children).forEach(function (e) {
        util$1.match(e, '.fab') && util$1.toggleAttribute(e, 'disabled', value);
      });

      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property inline
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is inline or not.[/en]
     *   [ja]インライン要素の場合に`true`。[/ja]
     */

  }, {
    key: 'inline',
    get: function get$$1() {
      return this.hasAttribute('inline');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return this._fab.visible && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['class', 'modifier', 'ripple', 'direction', 'position'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['open', 'close'];
    }
  }]);
  return SpeedDialElement;
}(BaseElement);

onsElements.SpeedDial = SpeedDialElement;
customElements.define('ons-speed-dial', SpeedDialElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var rewritables$1 = {
  /**
   * @param {Element} element
   * @param {Function} callback
   */
  ready: function ready(element, callback) {
    setImmediate(callback);
  }
};

/**
 * @element ons-splitter-content
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
 *
 *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
 *  [/en]
 *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` component is the parent element.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterContentElement = function (_BaseElement) {
  inherits(SplitterContentElement, _BaseElement);

  /**
   * @attribute page
   * @type {String}
   * @description
   *   [en]
   *     The url of the content page. If this attribute is used the content will be loaded from a `<template>` tag or a remote file.
   *
   *     It is also possible to put `<ons-page>` element as a child of the element.
   *   [/en]
   *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]
   */

  function SplitterContentElement() {
    classCallCheck(this, SplitterContentElement);

    var _this = possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).call(this));

    _this._page = null;
    _this._pageLoader = defaultPageLoader;

    contentReady(_this, function () {
      rewritables$1.ready(_this, function () {
        var page = _this._getPageTarget();

        if (page) {
          _this.load(page);
        }
      });
    });
    return _this;
  }

  createClass(SplitterContentElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (!util$1.match(this.parentNode, 'ons-splitter')) {
        util$1.throw('"ons-splitter-content" must have "ons-splitter" as parent');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}

    /**
     * @property page
     * @type {HTMLElement}
     * @description
     *   [en]The page to load in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'load',


    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page, [options]
     *   [en]Page URL. Can be either an HTML document or an `<template>` id.[/en]
     *   [ja]pageのURLか、`<template>`で宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in `page` in the content.[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new `<ons-page>` element[/en]
     *   [ja]`<ons-page>`要素を解決するPromiseオブジェクトを返します。[/ja]
     */
    value: function load(page) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this2._content || null;

        _this2._pageLoader.load({ page: page, parent: _this2 }, function (pageElement) {
          if (oldContent) {
            _this2._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this2._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @type {Function}
     * @description
     *   [en]Page element loaded in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = loader;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$1;
    }
  }]);
  return SplitterContentElement;
}(BaseElement);

onsElements.SplitterContent = SplitterContentElement;
customElements.define('ons-splitter-content', SplitterContentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterMaskElement = function (_BaseElement) {
  inherits(SplitterMaskElement, _BaseElement);

  function SplitterMaskElement() {
    classCallCheck(this, SplitterMaskElement);

    var _this = possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).call(this));

    _this._boundOnClick = _this._onClick.bind(_this);
    contentReady(_this, function () {
      if (_this.parentNode._sides.every(function (side) {
        return side.mode === 'split';
      })) {
        _this.setAttribute('style', 'display: none !important');
      }
    });
    return _this;
  }

  createClass(SplitterMaskElement, [{
    key: '_onClick',
    value: function _onClick(event) {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else if (util$1.match(this.parentNode, 'ons-splitter')) {
        this.parentNode._sides.forEach(function (side) {
          return side.close('left').catch(function () {});
        });
      }
      event.stopPropagation();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick);
      util$1.iosMaskScrollFix(this, true);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick);
      util$1.iosMaskScrollFix(this, false);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [];
    }
  }]);
  return SplitterMaskElement;
}(BaseElement);

onsElements.SplitterMask = SplitterMaskElement;
customElements.define('ons-splitter-mask', SplitterMaskElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterAnimator$1 = function (_BaseAnimator) {
  inherits(SplitterAnimator, _BaseAnimator);

  function SplitterAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, SplitterAnimator);
    return possibleConstructorReturn(this, (SplitterAnimator.__proto__ || Object.getPrototypeOf(SplitterAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  createClass(SplitterAnimator, [{
    key: 'updateOptions',
    value: function updateOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      util$1.extend(this, {
        timing: this.timing, duration: this.duration, delay: this.delay
      }, options);
    }

    /**
     * @param {Element} sideElement
     */

  }, {
    key: 'activate',
    value: function activate(sideElement) {
      var _this2 = this;

      var splitter = sideElement.parentNode;

      contentReady(splitter, function () {
        _this2._side = sideElement;
        _this2._oppositeSide = splitter.right !== sideElement && splitter.right || splitter.left !== sideElement && splitter.left;
        _this2._content = splitter.content;
        _this2._mask = splitter.mask;
      });
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.clearTransition();
      this._mask && this.clearMask();
      this._content = this._side = this._oppositeSide = this._mask = null;
    }
  }, {
    key: 'clearTransition',
    value: function clearTransition() {
      var _this3 = this;

      'side mask content'.split(/\s+/).forEach(function (e) {
        return _this3['_' + e] && styler.clear(_this3['_' + e], 'transform transition');
      });
    }
  }, {
    key: 'clearMask',
    value: function clearMask() {
      // Check if the other side needs the mask before clearing
      if (!this._oppositeSide || this._oppositeSide.mode === 'split' || !this._oppositeSide.isOpen) {
        this._mask.style.opacity = '';
        this._mask.style.display = 'none';
      }
    }

    /**
     * @param {Number} distance
     */

  }, {
    key: 'translate',
    value: function translate(distance) {}

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      done();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      done();
    }
  }, {
    key: 'minus',
    get: function get$$1() {
      return this._side.side === 'right' ? '-' : '';
    }
  }]);
  return SplitterAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var OverlaySplitterAnimator = function (_SplitterAnimator) {
  inherits(OverlaySplitterAnimator, _SplitterAnimator);

  function OverlaySplitterAnimator() {
    classCallCheck(this, OverlaySplitterAnimator);
    return possibleConstructorReturn(this, (OverlaySplitterAnimator.__proto__ || Object.getPrototypeOf(OverlaySplitterAnimator)).apply(this, arguments));
  }

  createClass(OverlaySplitterAnimator, [{
    key: 'translate',
    value: function translate(distance) {
      this._mask.style.display = 'block'; // Avoid content clicks

      Animit(this._side).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(' + this.minus + '100%, 0, 0)'
      }, this.def).queue(function (callback) {
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }).queue({
        opacity: '1'
      }, {
        duration: this.duration,
        timing: 'linear'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {

      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)'
      }, this.def).queue(function (callback) {
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        opacity: '0'
      }, {
        duration: this.duration,
        timing: 'linear'
      }).queue({
        display: 'none'
      }));
    }
  }]);
  return OverlaySplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var PushSplitterAnimator = function (_SplitterAnimator) {
  inherits(PushSplitterAnimator, _SplitterAnimator);

  function PushSplitterAnimator() {
    classCallCheck(this, PushSplitterAnimator);
    return possibleConstructorReturn(this, (PushSplitterAnimator.__proto__ || Object.getPrototypeOf(PushSplitterAnimator)).apply(this, arguments));
  }

  createClass(PushSplitterAnimator, [{
    key: '_getSlidingElements',
    value: function _getSlidingElements() {
      var slidingElements = [this._side, this._content];
      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
        slidingElements.push(this._oppositeSide);
      }

      return slidingElements;
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      if (!this._slidingElements) {
        this._slidingElements = this._getSlidingElements();
      }

      this._mask.style.display = 'block'; // Avoid content clicks

      Animit(this._slidingElements).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      var _this2 = this;

      var max = this._side.offsetWidth;
      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(' + (this.minus + max) + 'px, 0, 0)'
      }, this.def).queue(function (callback) {
        _this2._slidingElements = null;
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)'
      }, this.def).queue(function (callback) {
        _this3._slidingElements = null;
        get(PushSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(PushSplitterAnimator.prototype), 'clearTransition', _this3).call(_this3);
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'none'
      }));
    }
  }]);
  return PushSplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var RevealSplitterAnimator = function (_SplitterAnimator) {
  inherits(RevealSplitterAnimator, _SplitterAnimator);

  function RevealSplitterAnimator() {
    classCallCheck(this, RevealSplitterAnimator);
    return possibleConstructorReturn(this, (RevealSplitterAnimator.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator)).apply(this, arguments));
  }

  createClass(RevealSplitterAnimator, [{
    key: '_getSlidingElements',
    value: function _getSlidingElements() {
      var slidingElements = [this._content, this._mask];
      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
        slidingElements.push(this._oppositeSide);
      }

      return slidingElements;
    }
  }, {
    key: 'activate',
    value: function activate(sideElement) {
      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'activate', this).call(this, sideElement);
      if (sideElement.mode === 'collapse') {
        this._setStyles(sideElement);
      }
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this._side && this._unsetStyles(this._side);
      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'deactivate', this).call(this);
    }
  }, {
    key: '_setStyles',
    value: function _setStyles(sideElement) {
      styler(sideElement, {
        left: sideElement.side === 'right' ? 'auto' : 0,
        right: sideElement.side === 'right' ? 0 : 'auto',
        zIndex: 0,
        backgroundColor: 'black',
        transform: this._generateBehindPageStyle(0).container.transform,
        display: 'none'
      });

      var splitter = sideElement.parentElement;
      contentReady(splitter, function () {
        return splitter.content && styler(splitter.content, { boxShadow: '0 0 12px 0 rgba(0, 0, 0, 0.2)' });
      });
    }
  }, {
    key: '_unsetStyles',
    value: function _unsetStyles(sideElement) {
      styler.clear(sideElement, 'left right zIndex backgroundColor display');
      if (sideElement._content) {
        sideElement._content.style.opacity = '';
      }

      // Check if the other side needs the common styles
      if (!this._oppositeSide || this._oppositeSide.mode === 'split') {
        sideElement.parentElement.content && styler.clear(sideElement.parentElement.content, 'boxShadow');
      }
    }
  }, {
    key: '_generateBehindPageStyle',
    value: function _generateBehindPageStyle(distance) {
      var max = this.maxWidth;

      var behindDistance = (distance - max) / max * 10;
      behindDistance = isNaN(behindDistance) ? 0 : Math.max(Math.min(behindDistance, 0), -10);

      var behindTransform = 'translate3d(' + (this.minus ? -1 : 1) * behindDistance + '%, 0, 0)';
      var opacity = 1 + behindDistance / 100;

      return {
        content: {
          opacity: opacity
        },
        container: {
          transform: behindTransform
        }
      };
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      this._side.style.display = '';
      this._side.style.zIndex = 1;
      this.maxWidth = this.maxWidth || this._getMaxWidth();
      var menuStyle = this._generateBehindPageStyle(Math.min(distance, this.maxWidth));

      if (!this._slidingElements) {
        this._slidingElements = this._getSlidingElements();
      }

      this._mask.style.display = 'block'; // Avoid content clicks

      Animit.runAll(Animit(this._slidingElements).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
      }), Animit(this._side._content).queue(menuStyle.content), Animit(this._side).queue(menuStyle.container));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      var _this2 = this;

      this._side.style.display = '';
      this._side.style.zIndex = 1;
      this.maxWidth = this.maxWidth || this._getMaxWidth();
      var menuStyle = this._generateBehindPageStyle(this.maxWidth);
      this._slidingElements = this._getSlidingElements();

      setTimeout(function () {
        // Fix: Time to update previous translate3d after changing style.display
        Animit.runAll(Animit(_this2._slidingElements).wait(_this2.delay).queue({
          transform: 'translate3d(' + (_this2.minus + _this2.maxWidth) + 'px, 0, 0)'
        }, _this2.def), Animit(_this2._mask).wait(_this2.delay).queue({
          display: 'block'
        }), Animit(_this2._side._content).wait(_this2.delay).queue(menuStyle.content, _this2.def), Animit(_this2._side).wait(_this2.delay).queue(menuStyle.container, _this2.def).queue(function (callback) {
          _this2._slidingElements = null;
          callback();
          done && done();
        }));
      }, 1000 / 60);
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      var menuStyle = this._generateBehindPageStyle(0);
      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)'
      }, this.def), Animit(this._mask).wait(this.delay).queue({
        display: 'none'
      }), Animit(this._side._content).wait(this.delay).queue(menuStyle.content, this.def), Animit(this._side).wait(this.delay).queue(menuStyle.container, this.def).queue(function (callback) {
        _this3._slidingElements = null;
        _this3._side.style.zIndex = 0;
        _this3._side.style.display = 'none';
        _this3._side._content.style.opacity = '';
        done && done();
        callback();
      }));
    }
  }, {
    key: '_getMaxWidth',
    value: function _getMaxWidth() {
      return this._side.offsetWidth;
    }
  }]);
  return RevealSplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$7 = {
  default: OverlaySplitterAnimator,
  overlay: OverlaySplitterAnimator,
  push: PushSplitterAnimator,
  reveal: RevealSplitterAnimator
};

/**
 * @element ons-splitter
 * @category menu
 * @description
 *  [en]
 *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
 *
 *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
 *  [/en]
 *  [ja][/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter id="splitter">
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse swipeable>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 *
 * <script>
 *   var splitter = document.getElementById('splitter');
 *   splitter.left.open();
 * </script>
 */

var SplitterElement = function (_BaseElement) {
  inherits(SplitterElement, _BaseElement);
  createClass(SplitterElement, [{
    key: '_getSide',
    value: function _getSide(side) {
      var element = util$1.findChild(this, function (e) {
        return util$1.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
      });
      return element;
    }

    /**
     * @property left
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Left `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      this._sides.some(function (s) {
        return s.isOpen ? s.close() : false;
      }) || event.callParentHandler();
    }
  }, {
    key: '_onModeChange',
    value: function _onModeChange(e) {
      var _this2 = this;

      if (e.target.parentNode) {
        contentReady(this, function () {
          _this2._layout();
        });
      }
    }
  }, {
    key: '_layout',
    value: function _layout() {
      var _this3 = this;

      this._sides.forEach(function (side) {
        if (_this3.content) {
          _this3.content.style[side.side] = side.mode === 'split' ? side.style.width : 0;
        }
      });
    }
  }, {
    key: 'left',
    get: function get$$1() {
      return this._getSide('left');
    }
    /**
     * @property right
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Right `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'right',
    get: function get$$1() {
      return this._getSide('right');
    }

    /**
     * @property side
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]First `<ons-splitter-side>` element regardless the actual side.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'side',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-splitter-side');
    }
  }, {
    key: '_sides',
    get: function get$$1() {
      return [this.left, this.right].filter(function (e) {
        return e;
      });
    }
    /**
     * @property content
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The `<ons-splitter-content>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'content',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-splitter-content');
    }
  }, {
    key: 'topPage',
    get: function get$$1() {
      return this.content._content;
    }
  }, {
    key: 'mask',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-splitter-mask');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }]);

  function SplitterElement() {
    classCallCheck(this, SplitterElement);

    var _this = possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).call(this));

    _this._onModeChange = _this._onModeChange.bind(_this);

    contentReady(_this, function () {
      !_this.mask && _this.appendChild(document.createElement('ons-splitter-mask'));
      _this._layout();
    });
    return _this;
  }

  createClass(SplitterElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
      this.addEventListener('modechange', this._onModeChange, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
      this.removeEventListener('modechange', this._onModeChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: '_show',
    value: function _show() {
      util$1.propagateAction(this, '_show');
    }
  }, {
    key: '_hide',
    value: function _hide() {
      util$1.propagateAction(this, '_hide');
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      util$1.propagateAction(this, '_destroy');
      this.remove();
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator instanceof SplitterAnimator)) {
        util$1.throwAnimator('Splitter');
      }
      _animatorDict$7[name] = Animator;
    }
  }, {
    key: 'SplitterAnimator',
    get: function get$$1() {
      return SplitterAnimator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$7;
    }
  }]);
  return SplitterElement;
}(BaseElement);

onsElements.Splitter = SplitterElement;
customElements.define('ons-splitter', SplitterElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SPLIT_MODE = 'split';
var COLLAPSE_MODE = 'collapse';
var CLOSED_STATE = 'closed';
var OPEN_STATE = 'open';
var CHANGING_STATE = 'changing';

var rewritables$2 = {
  /**
   * @param {Element} splitterSideElement
   * @param {Function} callback
   */
  ready: function ready(splitterSideElement, callback) {
    setImmediate(callback);
  }
};

var CollapseDetection = function () {
  function CollapseDetection(element, target) {
    classCallCheck(this, CollapseDetection);

    this._element = element;
    this._onChange = this._onChange.bind(this);
    target && this.changeTarget(target);
  }

  createClass(CollapseDetection, [{
    key: 'changeTarget',
    value: function changeTarget(target) {
      this.disable();
      this._target = target;
      if (target) {
        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
        this.activate();
      }
    }
  }, {
    key: '_match',
    value: function _match(value) {
      if (this._orientation) {
        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
      }
      return value.matches;
    }
  }, {
    key: '_onChange',
    value: function _onChange(value) {
      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
    }
  }, {
    key: 'activate',
    value: function activate() {
      if (this._orientation) {
        orientation.on('change', this._onChange);
        this._onChange({ isPortrait: orientation.isPortrait() });
      } else {
        this._queryResult = window.matchMedia(this._target);
        this._queryResult.addListener(this._onChange);
        this._onChange(this._queryResult);
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      if (this._orientation) {
        orientation.off('change', this._onChange);
      } else if (this._queryResult) {
        this._queryResult.removeListener(this._onChange);
        this._queryResult = null;
      }
    }
  }]);
  return CollapseDetection;
}();

/**
 * @element ons-splitter-side
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
 *
 *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
 *
 *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
 *  [/en]
 *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` is the parent component.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterSideElement = function (_BaseElement) {
  inherits(SplitterSideElement, _BaseElement);

  /**
   * @event modechange
   * @description
   *   [en]Fired just after the component's mode changes.[/en]
   *   [ja]この要素のモードが変化した際に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {String} event.mode
   *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
   *   [ja]現在のモードを返します。[/ja]
   */

  /**
   * @event preopen
   * @description
   *   [en]Fired just before the sliding menu is opened.[/en]
   *   [ja]スライディングメニューが開く前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Function} event.cancel
   *   [en]Call to cancel opening sliding menu.[/en]
   *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event postopen
   * @description
   *   [en]Fired just after the sliding menu is opened.[/en]
   *   [ja]スライディングメニューが開いた後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event preclose
   * @description
   *   [en]Fired just before the sliding menu is closed.[/en]
   *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call to cancel opening sliding-menu.[/en]
   *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
   */

  /**
   * @event postclose
   * @description
   *   [en]Fired just after the sliding menu is closed.[/en]
   *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default  default
   * @description
   *  [en]Specify the animation. Use one of `overlay`, `push`, `reveal` or  `default`.[/en]
   *  [ja]アニメーションを指定します。"overlay", "push", "reveal", "default"のいずれかを指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute open-threshold
   * @type {Number}
   * @default  0.3
   * @description
   *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
   *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
   */

  /**
   * @attribute collapse
   * @type {String}
   * @description
   *   [en]
   *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
   *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
   *     If the value is a media query, the view will collapse when the media query resolves to `true`.
   *     If the value is not defined, the view always be in `"collapse"` mode.
   *   [/en]
   *   [ja]
   *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
   *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
   *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
   *     値に何も指定しない場合には、常にcollapseモードになります。
   *   [/ja]
   */

  /**
   * @attribute swipe-target-width
   * @type {String}
   * @description
   *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
   *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
   */

  /**
   * @attribute width
   * @type {String}
   * @description
   *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
   *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
   */

  /**
   * @attribute side
   * @type {String}
   * @default left
   * @description
   *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
   *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
   */

  /**
   * @attribute mode
   * @type {String}
   * @description
   *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
   *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
   */

  /**
   * @attribute page
   * @initonly
   * @type {String}
   * @description
   *   [en]The URL of the menu page.[/en]
   *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
   */

  /**
   * @attribute swipeable
   * @type {Boolean}
   * @description
   *   [en]Whether to enable swipe interaction on collapse mode.[/en]
   *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
   */

  function SplitterSideElement() {
    classCallCheck(this, SplitterSideElement);

    var _this = possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).call(this));

    _this._page = null;
    _this._state = CLOSED_STATE;
    _this._lock = new DoorLock();
    _this._pageLoader = defaultPageLoader;
    _this._collapseDetection = new CollapseDetection(_this);

    _this._animatorFactory = new AnimatorFactory({
      animators: SplitterElement.animators,
      baseClass: SplitterAnimator$1,
      baseClassName: 'SplitterAnimator',
      defaultAnimation: _this.getAttribute('animation')
    });

    contentReady(_this, function () {
      // These attributes are used early by the parent element
      _this.attributeChangedCallback('width');
      if (!_this.hasAttribute('side')) {
        _this.setAttribute('side', 'left');
      }

      rewritables$2.ready(_this, function () {
        var page = _this._page || _this.getAttribute('page');
        page && _this.load(page);
      });
    });
    return _this;
  }

  createClass(SplitterSideElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!util$1.match(this.parentNode, 'ons-splitter')) {
        util$1.throw('Parent must be an ons-splitter element');
      }

      this._swipe = new SwipeReveal({
        element: this,
        elementHandler: this.parentElement,
        swipeMax: function swipeMax() {
          _this2._onSwipe && _this2._onSwipe(1, _this2._animationOpt);
          _this2.open();
        },
        swipeMid: function swipeMid(distance, width) {
          _this2._onSwipe && _this2._onSwipe(distance / width);
          _this2._animator.translate(distance);
        },
        swipeMin: function swipeMin() {
          _this2._onSwipe && _this2._onSwipe(0, _this2._animationOpt);
          _this2.close();
        },
        getThreshold: function getThreshold() {
          return Math.max(0, Math.min(1, parseFloat(_this2.getAttribute('open-threshold')) || 0.3));
        },
        getSide: function getSide() {
          return _this2.side;
        },
        isInitialState: function isInitialState() {
          var closed = _this2._state === CLOSED_STATE;
          _this2._state = CHANGING_STATE;
          return closed;
        },
        ignoreSwipe: function ignoreSwipe(event, distance) {
          var isOpen = _this2.isOpen;
          var validDrag = function validDrag(d) {
            return _this2.side === 'left' ? d === 'left' && isOpen || d === 'right' && !isOpen : d === 'left' && !isOpen || d === 'right' && isOpen;
          };

          var area = Math.max(0, parseInt(_this2.getAttribute('swipe-target-width'), 10) || 0);

          return _this2._mode === SPLIT_MODE || _this2._lock.isLocked() || _this2._isOtherSideOpen() || !validDrag(event.gesture.direction) || !isOpen && area !== 0 && distance > area;
        }
      });

      this.attributeChangedCallback('swipeable');

      contentReady(this, function () {
        _this2.constructor.observedAttributes.forEach(function (attr) {
          return _this2.attributeChangedCallback(attr, null, _this2.getAttribute(attr));
        });
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._swipe && this._swipe.dispose();
      this._animator = this._animationOpt = this._swipe = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'swipeable':
          this._swipe && this._swipe.update();
          break;
        case 'width':
          current = this.getAttribute('width'); // Sometimes undefined. CE bug?
          this.style.width = /^\d+(px|%)$/.test(current) ? current : '80%';
          break;
        default:
          this[util$1.camelize('_update-' + name)](current);
      }
    }
  }, {
    key: '_emitEvent',
    value: function _emitEvent(name) {
      if (name.slice(0, 3) !== 'pre') {
        return util$1.triggerElementEvent(this, name, { side: this });
      }
      var isCanceled = false;

      util$1.triggerElementEvent(this, name, {
        side: this,
        cancel: function cancel() {
          return isCanceled = true;
        }
      });

      return isCanceled;
    }
  }, {
    key: '_isOtherSideOpen',
    value: function _isOtherSideOpen() {
      var _this3 = this;

      return !!util$1.findChild(this.parentElement, function (el) {
        return el instanceof _this3.constructor && el !== _this3 && el._mode === COLLAPSE_MODE && el.isOpen;
      });
    }
  }, {
    key: '_updateCollapse',
    value: function _updateCollapse() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');

      if (value === null || value === 'split') {
        this._collapseDetection.disable();
        return this._updateMode(SPLIT_MODE);
      }
      if (value === '' || value === 'collapse') {
        this._collapseDetection.disable();
        return this._updateMode(COLLAPSE_MODE);
      }

      this._collapseDetection.changeTarget(value);
    }
  }, {
    key: '_updateMode',
    value: function _updateMode(mode) {
      if (mode !== this._mode) {
        this._mode = mode;
        this.setAttribute('mode', mode); // readonly attribute for the users

        if (mode === SPLIT_MODE) {
          this._animator && this._animator.deactivate();
          this._state = CLOSED_STATE;
        } else {
          this._animator && this._animator.activate(this);
          this._state === OPEN_STATE && this._animator.open();
        }

        util$1.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
      }
    }
  }, {
    key: '_updateAnimation',
    value: function _updateAnimation() {
      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');

      if (this.parentNode) {
        this._animator && this._animator.deactivate();
        this._animator = this._animatorFactory.newAnimator({ animation: animation });
        this._animator.activate(this);
        this._animationOpt = {
          timing: this._animator.duration,
          duration: this._animator.duration
        };
      }
    }
  }, {
    key: '_updateAnimationOptions',
    value: function _updateAnimationOptions() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');

      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Page location to load in the splitter side.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'open',


    /**
     * @method open
     * @signature open([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been opened.[/en]
     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */
    value: function open(options) {
      return this.toggle(options, true);
    }

    /**
     * @method close
     * @signature close([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been closed.[/en]
     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'close',
    value: function close(options) {
      return this.toggle(options, false);
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     * @description
     *   [en]Opens if it's closed. Closes if it's open.[/en]
     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var force = arguments[1];

      var shouldOpen = typeof force === 'boolean' ? force : !this.isOpen;
      var action = shouldOpen ? 'open' : 'close',
          FINAL_STATE = shouldOpen ? OPEN_STATE : CLOSED_STATE;

      if (this._mode === SPLIT_MODE) {
        return Promise.resolve(false);
      }
      if (this._state === FINAL_STATE) {
        return Promise.resolve(this);
      }
      if (this._lock.isLocked()) {
        return Promise.reject('Another splitter-side action is already running.');
      }
      if (shouldOpen && this._isOtherSideOpen()) {
        return Promise.reject('Another menu is already open.');
      }
      if (this._emitEvent('pre' + action)) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      var unlock = this._lock.lock();
      this._state = CHANGING_STATE;

      return new Promise(function (resolve) {
        _this4._animator[action](function () {
          util$1.iosPageScrollFix(shouldOpen);
          _this4._state = FINAL_STATE;
          unlock();
          _this4._emitEvent('post' + action);
          options.callback instanceof Function && options.callback(_this4);
          resolve(_this4);
        });
      });
    }

    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either an HTML document or a `<template>`.[/en]
     *   [ja]pageのURLか、`<template>`で宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in pageUrl in the right section[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'load',
    value: function load(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this5._content || null;

        _this5._pageLoader.load({ page: page, parent: _this5 }, function (pageElement) {
          if (oldContent) {
            _this5._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this5._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'side',
    get: function get$$1() {
      return this.getAttribute('side') === 'right' ? 'right' : 'left';
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @description
     *   [en][/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = loader;
    }

    /**
     * @property mode
     * @readonly
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'mode',
    get: function get$$1() {
      return this._mode;
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the splitter. It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }

    /**
     * @property isOpen
     * @type {Boolean}
     * @readonly
     * @description
     *   [en]This value is `true` when the menu is open.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'isOpen',
    get: function get$$1() {
      return this._mode === COLLAPSE_MODE && this._state !== CLOSED_STATE;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['animation', 'width', 'collapse', 'swipeable', 'animation-options'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['preopen', 'postopen', 'preclose', 'postclose', 'modechange'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$2;
    }
  }]);
  return SplitterSideElement;
}(BaseElement);

onsElements.SplitterSide = SplitterSideElement;
customElements.define('ons-splitter-side', SplitterSideElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$28 = {
  '': 'switch--*',
  '.switch__input': 'switch--*__input',
  '.switch__handle': 'switch--*__handle',
  '.switch__toggle': 'switch--*__toggle'
};

var locations = {
  ios: [1, 21],
  material: [0, 16]
};

/**
 * @element ons-switch
 * @category form
 * @description
 *   [en]
 *     Switch component. The switch can be toggled both by dragging and tapping.
 *
 *     Will automatically displays a Material Design switch on Android devices.
 *   [/en]
 *   [ja]スイッチを表示するコンポーネントです。[/ja]
 * @modifier material
 *   [en]Material Design switch[/en]
 *   [ja][/ja]
 * @codepen LpXZQQ
 * @tutorial vanilla/Reference/switch
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-switch checked></ons-switch>
 * <ons-switch disabled></ons-switch>
 * <ons-switch modifier="material"></ons-switch>
 */

var SwitchElement = function (_BaseCheckboxElement) {
  inherits(SwitchElement, _BaseCheckboxElement);

  function SwitchElement() {
    classCallCheck(this, SwitchElement);

    var _this = possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).call(this));

    contentReady(_this, function () {
      _this.attributeChangedCallback('modifier', null, _this.getAttribute('modifier'));
    });

    _this._onChange = _this._onChange.bind(_this);
    _this._onRelease = _this._onRelease.bind(_this);
    _this._lastTimeStamp = 0;
    return _this;
  }

  createClass(SwitchElement, [{
    key: '_getPosition',


    /* Own props */

    value: function _getPosition(e) {
      var l = this._locations;
      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
    }
  }, {
    key: '_emitChangeEvent',
    value: function _emitChangeEvent() {
      util$1.triggerElementEvent(this, 'change', {
        value: this.checked,
        switch: this,
        isInteractive: true
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      if (event && event.stopPropagation) {
        event.stopPropagation();
      }

      this._emitChangeEvent();
    }
  }, {
    key: '_onClick',
    value: function _onClick(ev) {
      if (ev.target.classList.contains(this.defaultElementClass + '__touch') || ev.timeStamp - this._lastTimeStamp < 50 // Prevent second click triggered by <label>
      ) {
          ev.preventDefault();
        }
      this._lastTimeStamp = ev.timeStamp;
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        ModifierUtil.addModifier(this, 'active');
        document.addEventListener('release', this._onRelease);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
        ModifierUtil.removeModifier(this, 'active');
        return;
      }

      e.consumed = true;

      ModifierUtil.addModifier(this, 'active');
      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

      this.addEventListener('drag', this._onDrag);
      document.addEventListener('release', this._onRelease);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.stopPropagation();
      this._handle.style.left = this._getPosition(e) + 'px';
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var l = this._locations;
      var position = this._getPosition(e);
      var previousValue = this.checked;

      this.checked = position >= (l[0] + l[1]) / 2;

      if (this.checked !== previousValue) {
        this._emitChangeEvent();
      }

      this.removeEventListener('drag', this._onDrag);
      document.removeEventListener('release', this._onRelease);

      this._handle.style.left = '';
      ModifierUtil.removeModifier(this, 'active');
    }
  }, {
    key: 'click',
    value: function click() {
      var ev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.disabled) {
        this.checked = !this.checked;
        this._emitChangeEvent();
        this._lastTimeStamp = ev.timeStamp || 0;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._input.addEventListener('change', _this2._onChange);
      });

      this.addEventListener('dragstart', this._onDragStart);
      this.addEventListener('hold', this._onHold);
      this.addEventListener('tap', this.click);
      this.addEventListener('click', this._onClick);
      this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251, passive: true });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._input.removeEventListener('change', _this3._onChange);
      });

      this.removeEventListener('dragstart', this._onDragStart);
      this.removeEventListener('hold', this._onHold);
      this.removeEventListener('tap', this.click);
      this.removeEventListener('click', this._onClick);
      if (this._gestureDetector) {
        this._gestureDetector.dispose();
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        var md = (current || '').indexOf('material') !== -1;
        this._locations = locations[md ? 'material' : 'ios'];
      }

      get(SwitchElement.prototype.__proto__ || Object.getPrototypeOf(SwitchElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @event change
     * @description
     *   [en]Fired when the switch is toggled.[/en]
     *   [ja]ON/OFFが変わった時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Object} event.switch
     *   [en]Switch object.[/en]
     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
     * @param {Boolean} event.value
     *   [en]Current value.[/en]
     *   [ja]現在の値を返します。[/ja]
     * @param {Boolean} event.isInteractive
     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the switch.[/en]
     *  [ja]スイッチの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the switch is be disabled.[/en]
     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
     */

    /**
     * @attribute checked
     * @description
     *   [en]Whether the switch is checked.[/en]
     *   [ja]スイッチがONの状態にするときに指定します。[/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]This value is `true` if the switch is checked.[/en]
     *   [ja]スイッチがONの場合に`true`。[/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property checkbox
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The underlying checkbox element.[/en]
     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$28;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'switch';
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <div class="' + this._defaultClassName + '__toggle">\n        <div class="' + this._defaultClassName + '__handle">\n          <div class="' + this._defaultClassName + '__touch"></div>\n        </div>\n      </div>\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'checkbox';
    }
  }, {
    key: '_handle',
    get: function get$$1() {
      return this.querySelector('.' + this._defaultClassName + '__handle');
    }
  }, {
    key: 'checkbox',
    get: function get$$1() {
      return this._input;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement), 'observedAttributes', this)), ['modifier']);
    }
  }]);
  return SwitchElement;
}(BaseCheckboxElement);

onsElements.Switch = SwitchElement;
customElements.define('ons-switch', SwitchElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$30 = {
  '.tabbar__content': 'tabbar--*__content',
  '.tabbar__border': 'tabbar--*__border',
  '.tabbar': 'tabbar--*'
};

var rewritables$3 = {
  /**
   * @param {Element} tabbarElement
   * @param {Function} callback
   */
  ready: function ready(tabbarElement, callback) {
    callback();
  }
};

var lerp = function lerp(x0, x1, t) {
  return (1 - t) * x0 + t * x1;
};

/**
 * @element ons-tabbar
 * @category tabbar
 * @description
 *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
 *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @modifier material
 *   [en]A tabbar in Material Design.[/en]
 *   [ja][/ja]
 * @modifier autogrow
 *   [en]Tabs automatically grow depending on their content instead of having a fixed width.[/en]
 *   [ja][/ja]
 * @modifier top-border
 *   [en]Shows a static border-bottom in tabs for iOS top tabbars.[/en]
 *   [ja][/ja]
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-tab
 *   [en]The `<ons-tab>` component.[/en]
 *   [ja]ons-tabコンポーネント[/ja]
 * @seealso ons-page
 *   [en]The `<ons-page>` component.[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <template id="home.html">
 *   ...
 * </template>
 *
 * <template id="settings.html">
 *   ...
 * </template>
 */

var TabbarElement = function (_BaseElement) {
  inherits(TabbarElement, _BaseElement);

  /**
   * @event prechange
   * @description
   *   [en]Fires just before the tab is changed.[/en]
   *   [ja]アクティブなタブが変わる前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to cancel the change event.[/en]
   *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
   */

  /**
   * @event postchange
   * @description
   *   [en]Fires just after the tab is changed.[/en]
   *   [ja]アクティブなタブが変わった後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   */

  /**
   * @event reactive
   * @description
   *   [en]Fires if the already open tab is tapped again.[/en]
   *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default none
   * @description
   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute position
   * @initonly
   * @type {String}
   * @default bottom
   * @description
   *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (bottom for iOS flat design, top for Material Design).[/en]
   *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
   */

  /**
   * @attribute swipeable
   * @description
   *   [en]If this attribute is set the tab bar can be scrolled by drag or swipe.[/en]
   *   [ja]この属性がある時、タブバーをスワイプやドラッグで移動できるようになります。[/ja]
   */

  /**
   * @attribute ignore-edge-width
   * @type {Number}
   * @default 20
   * @description
   *   [en]Distance in pixels from both edges. Swiping on these areas will prioritize parent components such as `ons-splitter` or `ons-navigator`.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute hide-tabs
   * @description
   *   [en]Whether to hide the tabs.[/en]
   *   [ja]タブを非表示にする場合に指定します。[/ja]
   */

  /**
   * @attribute tab-border
   * @description
   *   [en]If this attribute is set the tabs show a dynamic bottom border. Only works for iOS flat design since the border is always visible in Material Design.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the tabbar.[/en]
   *   [ja]タブバーの表現を指定します。[/ja]
   */

  function TabbarElement() {
    classCallCheck(this, TabbarElement);

    var _this = possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).call(this));

    _this._loadInactive = util$1.defer(); // Improves #2324
    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(TabbarElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!this._swiper) {
        this._swiper = new Swiper({
          getElement: function getElement() {
            return _this2._contentElement;
          },
          getInitialIndex: function getInitialIndex() {
            return _this2.getAttribute('activeIndex') || _this2.getAttribute('active-index');
          },
          getAutoScrollRatio: this._getAutoScrollRatio.bind(this),
          getBubbleWidth: function getBubbleWidth() {
            return parseInt(_this2.getAttribute('ignore-edge-width') || 25, 10);
          },
          isAutoScrollable: function isAutoScrollable() {
            return true;
          },
          preChangeHook: this._onPreChange.bind(this),
          postChangeHook: this._onPostChange.bind(this),
          refreshHook: this._onRefresh.bind(this),
          scrollHook: this._onScroll.bind(this)
        });

        contentReady(this, function () {
          _this2._tabbarBorder = util$1.findChild(_this2._tabbarElement, '.tabbar__border');
          _this2._swiper.init({ swipeable: _this2.hasAttribute('swipeable') });
        });
      }

      contentReady(this, function () {
        _this2._updatePosition();

        if (!util$1.findParent(_this2, 'ons-page', function (p) {
          return p === document.body;
        })) {
          _this2._show(); // This tabbar is the top component
        }
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._swiper && this._swiper.initialized) {
        this._swiper.dispose();
        this._swiper = null;
        this._tabbarBorder = null;
        this._tabsRect = null;
      }
    }
  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      return _extends({}, event, { index: event.activeIndex, tabItem: this.tabs[event.activeIndex] });
    }
  }, {
    key: '_onPostChange',
    value: function _onPostChange(event) {
      event = this._normalizeEvent(event);
      util$1.triggerElementEvent(this, 'postchange', event);
      var page = event.tabItem.pageElement;
      page && page._show();
    }
  }, {
    key: '_onPreChange',
    value: function _onPreChange(event) {
      event = this._normalizeEvent(event);
      event.cancel = function () {
        return event.canceled = true;
      };

      util$1.triggerElementEvent(this, 'prechange', event);

      if (!event.canceled) {
        var _event = event,
            activeIndex = _event.activeIndex,
            lastActiveIndex = _event.lastActiveIndex;

        var tabs = this.tabs;

        tabs[activeIndex].setActive(true);
        if (lastActiveIndex >= 0) {
          var prevTab = tabs[lastActiveIndex];
          prevTab.setActive(false);
          prevTab.pageElement && prevTab.pageElement._hide();
        }
      }

      return event.canceled;
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._tabbarBorder) {
        this._tabbarBorder.style.transition = 'all ' + (options.duration || 0) + 's ' + (options.timing || '');

        if (this._autogrow && this._tabsRect.length > 0) {
          var a = Math.floor(index),
              b = Math.ceil(index),
              r = index % 1;
          this._tabbarBorder.style.width = lerp(this._tabsRect[a].width, this._tabsRect[b].width, r) + 'px';
          this._tabbarBorder.style.transform = 'translate3d(' + lerp(this._tabsRect[a].left, this._tabsRect[b].left, r) + 'px, 0, 0)';
        } else {
          this._tabbarBorder.style.transform = 'translate3d(' + index * 100 + '%, 0, 0)';
        }
      }

      this._onSwipe && this._onSwipe(index, options);
    }
  }, {
    key: '_onRefresh',
    value: function _onRefresh() {
      this._autogrow = util$1.hasModifier(this, 'autogrow');
      this._tabsRect = this.tabs.map(function (tab) {
        return tab.getBoundingClientRect();
      });
      if (this._tabbarBorder) {
        this._tabbarBorder.style.display = this.hasAttribute('tab-border') || util$1.hasModifier(this, 'material') ? 'block' : 'none';
        var index = this.getActiveTabIndex();
        if (this._tabsRect.length > 0 && index >= 0) {
          this._tabbarBorder.style.width = this._tabsRect[index].width + 'px';
        }
      }
    }
  }, {
    key: '_getAutoScrollRatio',
    value: function _getAutoScrollRatio(matches, velocity, size) {
      var ratio = .6; // Base ratio
      var modifier = size / 300 * (matches ? -1 : 1); // Based on screen size
      return Math.min(1, Math.max(0, ratio + velocity * modifier));
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      var content = this._contentElement || util$1.create('.tabbar__content');
      content.classList.add('ons-tabbar__content');
      var tabbar = this._tabbarElement || util$1.create('.tabbar');
      tabbar.classList.add('ons-tabbar__footer');

      if (!tabbar.parentNode) {
        while (this.firstChild) {
          tabbar.appendChild(this.firstChild);
        }
      }

      var activeIndex = Number(this.getAttribute('activeIndex')); // 0 by default
      if (tabbar.children.length > activeIndex && !util$1.findChild(tabbar, '[active]')) {
        tabbar.children[activeIndex].setAttribute('active', '');
      }

      this._tabbarBorder = util$1.findChild(tabbar, '.tabbar__border') || util$1.create('.tabbar__border');
      tabbar.appendChild(this._tabbarBorder);
      tabbar.classList.add('ons-swiper-tabbar'); // Hides material border

      !content.children[0] && content.appendChild(document.createElement('div'));
      !content.children[1] && content.appendChild(document.createElement('div'));
      content.appendChild = content.appendChild.bind(content.children[0]);
      content.insertBefore = content.insertBefore.bind(content.children[0]);

      this.appendChild(content);
      this.appendChild(tabbar); // Triggers ons-tab connectedCallback

      ModifierUtil.initModifier(this, scheme$30);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var _this3 = this;

      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');

      var top = this._top = position === 'top' || position === 'auto' && util$1.hasModifier(this, 'material');
      var action = top ? util$1.addModifier : util$1.removeModifier;

      action(this, 'top');

      var page = util$1.findParent(this, 'ons-page');
      if (page) {
        contentReady(page, function () {
          var p = 0;
          if (page.children[0] && util$1.match(page.children[0], 'ons-toolbar')) {
            action(page.children[0], 'noshadow');
            p = 1; // Visual fix for some devices
          }

          var content = page._getContentElement();
          var cs = window.getComputedStyle(page._getContentElement(), null);

          _this3.style.top = top ? parseInt(cs.getPropertyValue('padding-top'), 10) - p + 'px' : '';

          // Refresh content top - Fix for iOS 8
          content.style.top = cs.top;
          content.style.top = '';
        });
      }

      internal$1.autoStatusBarFill(function () {
        var filled = util$1.findParent(_this3, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util$1.toggleAttribute(_this3, 'status-bar-fill', top && !filled);
      });
    }
  }, {
    key: 'setActiveTab',


    /**
     * @method setActiveTab
     * @signature setActiveTab(index, [options])
     * @param {Number} index
     *   [en]Tab index.[/en]
     *   [ja]タブのインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that runs when the new page has loaded.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this option is "none", the transition won't slide.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show specified tab page. Animations and their options can be specified by the second parameter.[/en]
     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
     * @return {Promise}
     *   [en]A promise that resolves to the new page element.[/en]
     *   [ja][/ja]
     */
    value: function setActiveTab(nextIndex) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var prevIndex = this.getActiveTabIndex();
      var prevTab = this.tabs[prevIndex],
          nextTab = this.tabs[nextIndex];

      if (!nextTab) {
        return Promise.reject('Specified index does not match any tab.');
      }

      if (nextIndex === prevIndex) {
        util$1.triggerElementEvent(this, 'reactive', { index: nextIndex, activeIndex: nextIndex, tabItem: nextTab });
        return Promise.resolve(nextTab.pageElement);
      }

      // FIXME: nextTab.loaded is broken in Zone.js promises (Angular2)
      var nextPage = nextTab.pageElement;
      return (nextPage ? Promise.resolve(nextPage) : nextTab.loaded).then(function (nextPage) {
        return _this4._swiper.setActiveIndex(nextIndex, _extends({
          reject: true
        }, options, {
          animation: prevTab && nextPage ? options.animation || _this4.getAttribute('animation') : 'none',
          animationOptions: util$1.extend({ duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }, _this4.hasAttribute('animation-options') ? util$1.animationOptionsParse(_this4.getAttribute('animation-options')) : {}, options.animationOptions || {})
        })).then(function () {
          options.callback instanceof Function && options.callback(nextPage);
          return nextPage;
        });
      });
    }

    /**
     * @method setTabbarVisibility
     * @signature setTabbarVisibility(visible)
     * @param {Boolean} visible
     * @description
     *   [en]Used to hide or show the tab bar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setTabbarVisibility',
    value: function setTabbarVisibility(visible) {
      var _this5 = this;

      contentReady(this, function () {
        _this5._contentElement.style[_this5._top ? 'top' : 'bottom'] = visible ? '' : '0px';
        _this5._tabbarElement.style.display = visible ? '' : 'none';
        visible && _this5._onRefresh();
      });
    }
  }, {
    key: 'show',
    value: function show() {
      this.setTabbarVisibility(true);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setTabbarVisibility(false);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the tabbar is visible or not.[/en]
     *   [ja]タブバーが見える場合に`true`。[/ja]
     */

  }, {
    key: 'getActiveTabIndex',


    /**
     * @method getActiveTabIndex
     * @signature getActiveTabIndex()
     * @return {Number}
     *   [en]The index of the currently active tab.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
     * @description
     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
     */
    value: function getActiveTabIndex() {
      var tabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tabs;

      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i] && tabs[i].tagName === 'ONS-TAB' && tabs[i].isActive()) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: '_show',
    value: function _show() {
      var _this6 = this;

      this._swiper.show();

      setImmediate(function () {
        var tabs = _this6.tabs;
        var activeIndex = _this6.getActiveTabIndex(tabs);
        _this6._loadInactive.resolve();
        if (tabs.length > 0 && activeIndex >= 0) {
          tabs[activeIndex].loaded.then(function (el) {
            return el && setImmediate(function () {
              return el._show();
            });
          });
        }
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._swiper.hide();
      var topPage = this.topPage;
      topPage && topPage._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this.tabs.forEach(function (tab) {
        return tab.remove();
      });
      this.remove();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$30);
        var isTop = function isTop(m) {
          return (/(^|\s+)top($|\s+)/i.test(m)
          );
        };
        isTop(last) !== isTop(current) && this._updatePosition();
      } else if (name === 'position') {
        util$1.isAttached(this) && this._updatePosition();
      } else if (name === 'swipeable') {
        this._swiper && this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
      } else if (name === 'hide-tabs') {
        this.setTabbarVisibility(!this.hasAttribute('hide-tabs') || current === 'false');
      }
    }
  }, {
    key: '_tabbarElement',
    get: function get$$1() {
      return util$1.findChild(this, '.tabbar');
    }
  }, {
    key: '_contentElement',
    get: function get$$1() {
      return util$1.findChild(this, '.tabbar__content');
    }
  }, {
    key: '_targetElement',
    get: function get$$1() {
      var content = this._contentElement;
      return content && content.children[0] || null;
    }
  }, {
    key: 'topPage',
    get: function get$$1() {
      var tabs = this.tabs,
          index = this.getActiveTabIndex();
      return tabs[index] ? tabs[index].pageElement || this.pages[0] || null : null;
    }
  }, {
    key: 'pages',
    get: function get$$1() {
      return util$1.arrayFrom(this._targetElement.children);
    }
  }, {
    key: 'tabs',
    get: function get$$1() {
      return Array.prototype.filter.call(this._tabbarElement.children, function (e) {
        return e.tagName === 'ONS-TAB';
      });
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      return this._tabbarElement.style.display !== 'none';
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]Enable swipe interaction.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get$$1() {
      return this.hasAttribute('swipeable');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the tabbar. It gets a decimal index and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'position', 'swipeable', 'tab-border', 'hide-tabs'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$3;
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['prechange', 'postchange', 'reactive'];
    }
  }]);
  return TabbarElement;
}(BaseElement);

onsElements.Tabbar = TabbarElement;
customElements.define('ons-tabbar', TabbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$16 = 'tabbar__item';

var scheme$29 = {
  '': 'tabbar--*__item',
  '.tabbar__button': 'tabbar--*__button'
};

/**
 * @element ons-tab
 * @category tabbar
 * @description
 *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
 *   [ja]
 *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
 *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
 *   [/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide fundamentals.html#managing-pages
 *   [en]Managing multiple pages.[/en]
 *   [ja]複数のページを管理する[/ja]]
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @seealso ons-tabbar
 *   [en]ons-tabbar component[/en]
 *   [ja]ons-tabbarコンポーネント[/ja]
 * @seealso ons-page
 *   [en]ons-page component[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]ons-icon component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <template id="home.html">
 *   ...
 * </template>
 *
 * <template id="settings.html">
 *   ...
 * </template>

 */

var TabElement = function (_BaseElement) {
  inherits(TabElement, _BaseElement);

  /**
   * @attribute page
   * @initonly
   * @type {String}
   * @description
   *   [en]The page that is displayed when the tab is tapped.[/en]
   *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]
   */

  /**
   * @attribute icon
   * @type {String}
   * @description
   *   [en]
   *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`. Check [See also](#seealso) section for more information.
   *   [/en]
   *   [ja]
   *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。
   *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
   *   [/ja]
   */

  /**
   * @attribute active-icon
   * @type {String}
   * @description
   *   [en]The name of the icon when the tab is active.[/en]
   *   [ja]アクティブの際のアイコン名を指定します。[/ja]
   */

  /**
   * @attribute label
   * @type {String}
   * @description
   *   [en]The label of the tab item.[/en]
   *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
   */

  /**
   * @attribute badge
   * @type {String}
   * @description
   *   [en]Display a notification badge on top of the tab.[/en]
   *   [ja]バッジに表示する内容を指定します。[/ja]
   */

  /**
   * @attribute active
   * @description
   *   [en]This attribute should be set to the tab that is active by default.[/en]
   *   [ja][/ja]
   */

  function TabElement() {
    classCallCheck(this, TabElement);

    var _this = possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).call(this));

    if (['label', 'icon', 'badge'].some(_this.hasAttribute.bind(_this))) {
      _this._compile();
    } else {
      contentReady(_this, function () {
        return _this._compile();
      });
    }

    _this._pageLoader = defaultPageLoader;
    _this._onClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(TabElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$16);

      if (this._button) {
        return;
      }

      var button = util$1.create('button.tabbar__button');
      while (this.childNodes[0]) {
        button.appendChild(this.childNodes[0]);
      }

      var input = util$1.create('input', { display: 'none' });
      input.type = 'radio';

      this.appendChild(input);
      this.appendChild(button);

      this._updateButtonContent();
      ModifierUtil.initModifier(this, scheme$29);
      this._updateRipple();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      this._button && util$1.updateRipple(this._button, this.hasAttribute('ripple'));
    }
  }, {
    key: '_updateButtonContent',
    value: function _updateButtonContent() {
      var _this2 = this;

      var button = this._button;

      var iconWrapper = this._icon;
      if (this.hasAttribute('icon')) {
        iconWrapper = iconWrapper || util$1.createElement('<div class="tabbar__icon"><ons-icon></ons-icon></div>');
        var icon = iconWrapper.children[0];
        var fix = function (last) {
          return function () {
            return icon.attributeChangedCallback('icon', last, _this2.getAttribute('icon'));
          };
        }(icon.getAttribute('icon'));
        icon.setAttribute('icon', this.getAttribute('icon'));
        iconWrapper.parentElement !== button && button.insertBefore(iconWrapper, button.firstChild);

        // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654
        icon.attributeChangedCallback instanceof Function ? fix() : setImmediate(function () {
          return icon.attributeChangedCallback instanceof Function && fix();
        });
      } else {
        iconWrapper && iconWrapper.remove();
      }

      ['label', 'badge'].forEach(function (attr, index) {
        var prop = _this2.querySelector('.tabbar__' + attr);
        if (_this2.hasAttribute(attr)) {
          prop = prop || util$1.create('.tabbar__' + attr + (attr === 'badge' ? ' notification' : ''));
          prop.textContent = _this2.getAttribute(attr);
          prop.parentElement !== button && button.appendChild(prop);
        } else {
          prop && prop.remove();
        }
      });
    }
  }, {
    key: '_onClick',
    value: function _onClick() {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else {
        this._tabbar.setActiveTab(this.index, { reject: false });
      }
    }
  }, {
    key: 'setActive',
    value: function setActive() {
      var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._input.checked = active;
      this.classList.toggle('active', active);
      util$1.toggleAttribute(this, 'active', active);

      if (this.hasAttribute('icon') && this.hasAttribute('active-icon')) {
        this._icon.children[0].setAttribute('icon', this.getAttribute(active ? 'active-icon' : 'icon'));
      }
    }
  }, {
    key: '_loadPageElement',
    value: function _loadPageElement(parent, page) {
      var _this3 = this;

      this._hasLoaded = true;

      return new Promise(function (resolve) {
        _this3._pageLoader.load({ parent: parent, page: page }, function (pageElement) {
          parent.replaceChild(pageElement, parent.children[_this3.index]); // Ensure position
          _this3._loadedPage = pageElement;
          resolve(pageElement);
        });
      });
    }
  }, {
    key: 'isActive',


    /**
     * @return {Boolean}
     */
    value: function isActive() {
      return this.classList.contains('active');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._onClick, false);
      if (this._loadedPage) {
        this._pageLoader.unload(this._loadedPage);
        this._loadedPage = null;
        this._hasLoaded = false;
        this.loaded = null;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      this.addEventListener('click', this._onClick, false);

      if (!util$1.isAttached(this) || this.loaded) {
        return; // ons-tabbar compilation may trigger this
      }

      var deferred = util$1.defer();
      this.loaded = deferred.promise;

      contentReady(this, function () {
        var index = _this4.index;
        var tabbar = _this4._tabbar;
        if (!tabbar) {
          util$1.throw('Tab elements must be children of Tabbar');
        }

        if (tabbar.hasAttribute('modifier')) {
          util$1.addModifier(_this4, tabbar.getAttribute('modifier'));
        }

        if (!_this4._hasLoaded) {
          if (_this4.hasAttribute('active')) {
            _this4.setActive(true);
            tabbar.setAttribute('activeIndex', index);
          }

          if (index === tabbar.tabs.length - 1) {
            tabbar._onRefresh();
            setImmediate(function () {
              return tabbar._onRefresh();
            });
          }

          TabbarElement.rewritables.ready(tabbar, function () {
            var pageTarget = _this4.page || _this4.getAttribute('page');
            if (!_this4.pageElement && pageTarget) {
              var parentTarget = tabbar._targetElement;
              var dummyPage = util$1.create('div', { height: '100%', width: '100%', visibility: 'hidden' });
              parentTarget.insertBefore(dummyPage, parentTarget.children[index]); // Ensure position

              var load = function load() {
                return _this4._loadPageElement(parentTarget, pageTarget).then(deferred.resolve);
              };
              return _this4.isActive() ? load() : tabbar._loadInactive.promise.then(load);
            }

            return deferred.resolve(_this4.pageElement);
          });
        }
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$16, scheme$29);
          break;
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$29);
          });
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this5._updateRipple();
          });
          break;
        case 'icon':
        case 'label':
        case 'badge':
          contentReady(this, function () {
            return _this5._updateButtonContent();
          });
          break;
        case 'page':
          this.page = current || '';
          break;
      }
    }
  }, {
    key: 'pageLoader',
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = loader;
    },
    get: function get$$1() {
      return this._pageLoader;
    }
  }, {
    key: '_input',
    get: function get$$1() {
      return util$1.findChild(this, 'input');
    }
  }, {
    key: '_button',
    get: function get$$1() {
      return util$1.findChild(this, '.tabbar__button');
    }
  }, {
    key: '_icon',
    get: function get$$1() {
      return this.querySelector('.tabbar__icon');
    }
  }, {
    key: '_tabbar',
    get: function get$$1() {
      return util$1.findParent(this, 'ons-tabbar');
    }
  }, {
    key: 'index',
    get: function get$$1() {
      return Array.prototype.indexOf.call(this.parentElement.children, this);
    }
  }, {
    key: 'pageElement',
    get: function get$$1() {
      // It has been loaded by ons-tab
      if (this._loadedPage) {
        return this._loadedPage;
      }
      // Manually attached to DOM, 1 per tab
      var tabbar = this._tabbar;
      if (tabbar.pages.length === tabbar.tabs.length) {
        return tabbar.pages[this.index];
      }
      // Loaded in another way
      return null;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge', 'class'];
    }
  }]);
  return TabElement;
}(BaseElement);

onsElements.Tab = TabElement;
customElements.define('ons-tab', TabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ToastAnimator = function (_BaseAnimator) {
  inherits(ToastAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ToastAnimator);
    return possibleConstructorReturn(this, (ToastAnimator.__proto__ || Object.getPrototypeOf(ToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ToastAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ToastAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeToastAnimator = function (_ToastAnimator) {
  inherits(FadeToastAnimator, _ToastAnimator);

  function FadeToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeToastAnimator);
    return possibleConstructorReturn(this, (FadeToastAnimator.__proto__ || Object.getPrototypeOf(FadeToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(FadeToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      callback = callback ? callback : function () {};

      Animit(toast, this.def).default({ opacity: 0 }, { opacity: 1 }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      callback = callback ? callback : function () {};

      Animit(toast, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Ascend Toast Animator.
 */

var AscendToastAnimator = function (_ToastAnimator) {
  inherits(AscendToastAnimator, _ToastAnimator);

  function AscendToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.25 : _ref$duration;

    classCallCheck(this, AscendToastAnimator);

    var _this = possibleConstructorReturn(this, (AscendToastAnimator.__proto__ || Object.getPrototypeOf(AscendToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.messageDelay = _this.duration * 0.4 + _this.delay; // Delay message opacity change
    if (platform.isAndroid()) {
      _this.ascension = 48; // Toasts are always 1 line
    } else {
      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
        _this.ascension = 98; // 64 + 34
      } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
        _this.ascension = 85; // 64 + 21
      } else {
        _this.ascension = 64;
      }
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(AscendToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;
      util$1.globals.fabOffset = this.ascension;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.ascension + 'px, 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
        callback && callback();
        done();
      }), Animit(this._getFabs()).wait(this.delay).queue({ transform: 'translate3d(0, -' + this.ascension + 'px, 0) scale(1)' }, this.def), Animit(util$1.arrayFrom(toast.children), this.def).default({ opacity: 0 }, { opacity: 1 }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      toast = toast._toast;
      util$1.globals.fabOffset = 0;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, ' + this.ascension + 'px, 0)' }).queue(function (done) {
        callback && callback();
        done();
      }), Animit(this._getFabs(), this.def).wait(this.delay).queue({ transform: 'translate3d(0, 0, 0) scale(1)' }, this.def), Animit(util$1.arrayFrom(toast.children), this.def).default({ opacity: 1 }, { opacity: 0 }));
    }
  }, {
    key: '_getFabs',
    value: function _getFabs() {
      return util$1.arrayFrom(document.querySelectorAll('ons-fab[position~=bottom], ons-speed-dial[position~=bottom]')).filter(function (fab) {
        return fab.visible;
      });
    }
  }]);
  return AscendToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift-fade Toast Animator
 */

var LiftToastAnimator = function (_ToastAnimator) {
  inherits(LiftToastAnimator, _ToastAnimator);

  function LiftToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.35 : _ref$duration;

    classCallCheck(this, LiftToastAnimator);

    var _this = possibleConstructorReturn(this, (LiftToastAnimator.__proto__ || Object.getPrototypeOf(LiftToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this.liftAmount = 'calc(100% + 34px)';
    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
      _this.liftAmount = 'calc(100% + 21px)';
    } else {
      _this.liftAmount = '100%';
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(LiftToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.liftAmount + ', 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      toast = toast._toast;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, ' + this.liftAmount + ', 0)', opacity: 0 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(toast) {
      if (parseInt(toast.style.top, 10) === 0) {
        toast.style.top = toast.style.bottom = '';
      }
    }
  }]);
  return LiftToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fall-fade Toast Animator
 */

var FallToastAnimator = function (_ToastAnimator) {
  inherits(FallToastAnimator, _ToastAnimator);

  function FallToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.35 : _ref$duration;

    classCallCheck(this, FallToastAnimator);

    var _this = possibleConstructorReturn(this, (FallToastAnimator.__proto__ || Object.getPrototypeOf(FallToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this.fallAmount = 'calc(-100% - 44px)';
    } else {
      _this.fallAmount = '-100%';
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(FallToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;
      this._updatePosition(toast);

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.fallAmount + ', 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      var _this2 = this;

      toast = toast._toast;
      this._updatePosition(toast);

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, ' + this.fallAmount + ', 0)', opacity: 0 }).queue(function (done) {
        _this2._updatePosition(toast, true);
        callback && callback();
        done();
      }));
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(toast, cleanUp) {
      var correctTop = void 0;
      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
        correctTop = '44px';
      } else {
        correctTop = '0';
      }

      if (toast.style.top !== correctTop) {
        toast.style.top = correctTop;
        toast.style.bottom = 'initial';
      }
    }
  }]);
  return FallToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$31 = {
  '.toast': 'toast--*',
  '.toast__message': 'toast--*__message',
  '.toast__button': 'toast--*__button'
};

var defaultClassName$17 = 'toast';

var _animatorDict$8 = {
  'default': platform.isAndroid() ? AscendToastAnimator : LiftToastAnimator,
  'fade': FadeToastAnimator,
  'ascend': AscendToastAnimator,
  'lift': LiftToastAnimator,
  'fall': FallToastAnimator,
  'none': ToastAnimator
};

/**
 * @element ons-toast
 * @category dialog
 * @description
 *   [en]
 *     The Toast or Snackbar component is useful for displaying dismissable information or simple actions at (normally) the bottom of the page.
 *
 *     This component does not block user input, allowing the app to continue its flow. For simple toasts, consider `ons.notification.toast` instead.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/toast
 * @seealso ons-alert-dialog
 *   [en]The `<ons-alert-dialog>` component is preferred for displaying undismissable information.[/en]
 *   [ja][/ja]
 */

var ToastElement = function (_BaseDialogElement) {
  inherits(ToastElement, _BaseDialogElement);

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the toast. Can be either `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
   */

  function ToastElement() {
    classCallCheck(this, ToastElement);

    var _this = possibleConstructorReturn(this, (ToastElement.__proto__ || Object.getPrototypeOf(ToastElement)).call(this));

    _this._defaultDBB = function (e) {
      return e.callParentHandler();
    };
    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ToastElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      // Reset position style
      this._toast && (this._toast.style.top = this._toast.style.bottom = '');

      return new AnimatorFactory({
        animators: _animatorDict$8,
        baseClass: ToastAnimator,
        baseClassName: 'ToastAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10000; // Lower than dialogs

      var messageClassName = 'toast__message';
      var buttonClassName = 'toast__button';

      var toast = util$1.findChild(this, '.' + defaultClassName$17);
      if (!toast) {
        toast = document.createElement('div');
        toast.classList.add(defaultClassName$17);
        while (this.childNodes[0]) {
          toast.appendChild(this.childNodes[0]);
        }
      }

      var button = util$1.findChild(toast, '.' + buttonClassName);
      if (!button) {
        button = util$1.findChild(toast, function (e) {
          return util$1.match(e, '.button') || util$1.match(e, 'button');
        });
        if (button) {
          button.classList.remove('button');
          button.classList.add(buttonClassName);
          toast.appendChild(button);
        }
      }

      if (!util$1.findChild(toast, '.' + messageClassName)) {
        var message = util$1.findChild(toast, '.message');
        if (!message) {
          message = document.createElement('div');
          for (var i = toast.childNodes.length - 1; i >= 0; i--) {
            if (toast.childNodes[i] !== button) {
              message.insertBefore(toast.childNodes[i], message.firstChild);
            }
          }
        }
        message.classList.add(messageClassName);

        toast.insertBefore(message, toast.firstChild);
      }

      if (toast.parentNode !== this) {
        this.appendChild(toast);
      }

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show the element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Toggle toast visibility.[/en]
     *   [ja][/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Hide toast.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$31;
    }
  }, {
    key: '_toast',
    get: function get$$1() {
      return util$1.findChild(this, '.' + defaultClassName$17);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ToastAnimator)) {
        util$1.throw('"Animator" param must inherit OnsToastElement.ToastAnimator');
      }
      _animatorDict$8[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$8;
    }
  }, {
    key: 'ToastAnimator',
    get: function get$$1() {
      return ToastAnimator;
    }
  }]);
  return ToastElement;
}(BaseDialogElement);

onsElements.Toast = ToastElement;
customElements.define('ons-toast', ToastElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-toolbar-button
 * @category page
 * @modifier material
 *   [en]Material Design toolbar button.[/en]
 *   [ja][/ja]
 * @modifier outline
 *   [en]A button with an outline.[/en]
 *   [ja]アウトラインをもったボタンを表示します。[/ja]
 * @description
 *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
 *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide compilation.html#toolbar-compilation
 *   [en]Adding a toolbar[/en]
 *   [ja]ツールバーの追加[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-toolbar-button>
 *       Button
 *     </ons-toolbar-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   </div>
 *   <div class="right">
 *     <ons-toolbar-button>
 *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
 *     </ons-toolbar-button>
 *   </div>
 * </ons-toolbar>
 */

var ToolbarButtonElement = function (_BaseButtonElement) {
  inherits(ToolbarButtonElement, _BaseButtonElement);

  function ToolbarButtonElement() {
    classCallCheck(this, ToolbarButtonElement);
    return possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).apply(this, arguments));
  }

  createClass(ToolbarButtonElement, [{
    key: '_scheme',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the button.[/en]
     *   [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute icon
     * @type {String}
     * @description
     *  [en]Creates an `ons-icon` component with this string.[/en]
     *  [ja]`ons-icon`コンポーネントを悪性します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    get: function get$$1() {
      return { '': 'toolbar-button--*' };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'toolbar-button';
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return [this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' }];
    }
  }]);
  return ToolbarButtonElement;
}(BaseButtonElement);

onsElements.ToolbarButton = ToolbarButtonElement;
customElements.define('ons-toolbar-button', ToolbarButtonElement);

// Add and register Custom Elements
setup$1(ons$1); // Setup initial listeners
window._superSecretOns = ons$1;

return ons$1;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25zZW51aS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vY29yZS9zcmMvb25zL2VsZW1lbnRzLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3N0eWxlci5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wbGF0Zm9ybS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2ludGVybmFsLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnkuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYXV0b3N0eWxlLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3V0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWl0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvY29udGVudC1yZWFkeS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC90b2FzdC1xdWV1ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9ub3RpZmljYXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYWN0aW9uLXNoZWV0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL21pY3JvZXZlbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvb3JpZW50YXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvbW9kaWZpZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvZG9vcmxvY2suanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvcGFnZS1sb2FkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvZmFzdGNsaWNrL2xpYi9mYXN0Y2xpY2suanMiLCIuLi8uLi9jb3JlL3NyYy9wb2x5ZmlsbHMvcG9seWZpbGwtc3dpdGNoZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQub2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi93ZWFrLW1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9hcnJheS9mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvVXRpbGl0aWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudFN0YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9EZWZlcnJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0N1c3RvbUVsZW1lbnRSZWdpc3RyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05hdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL0hUTUxFbGVtZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvSW50ZXJmYWNlL1BhcmVudE5vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9Eb2N1bWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9JbnRlcmZhY2UvQ2hpbGROb2RlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvRWxlbWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL2N1c3RvbS1lbGVtZW50cy5qcyIsIi4uLy4uL2NvcmUvc3JjL3BvbHlmaWxscy9NdXRhdGlvbk9ic2VydmVyQDAuNy4yMi9NdXRhdGlvbk9ic2VydmVyLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL3NldEltbWVkaWF0ZUAxLjAuMittb2Qvc2V0SW1tZWRpYXRlLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvdmVuZG9yL3ZpZXdwb3J0LmpzIiwiLi4vLi4vY29yZS9zcmMvc2V0dXAuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtZWxlbWVudC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10ZW1wbGF0ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1pZi5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9iYXNlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2lwaG9uZXgtcGF0Y2guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0L2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvYmFzZS9iYXNlLWRpYWxvZy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hY3Rpb24tc2hlZXQvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldC1idXR0b24uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2ctYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJhY2stYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1jYXJkLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvc3dpcGVyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNhcm91c2VsLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNvbC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1kaWFsb2cvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtZGlhbG9nL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWZhYi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWljb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC10aXRsZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0vYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC1pdGVtL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxpc3QuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmFkaW8uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc2VhcmNoLWlucHV0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2ZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbW9kYWwvbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1tb2RhbC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC9zd2lwZS1yZXZlYWwuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc3dpcGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1zbGlkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWxpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1mYWRlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1zbGlkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtZmFkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3Ivbm9uZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wYWdlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXBvcG92ZXIvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcG9wb3Zlci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcHVsbC1ob29rLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJhbmdlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJpcHBsZS9hbmltYXRvci1jc3MuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmlwcGxlL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJvdy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zZWdtZW50LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNlbGVjdC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGVlZC1kaWFsLWl0ZW0uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyLW1hc2suanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvb3ZlcmxheS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9wdXNoLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyL3JldmVhbC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci1zaWRlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXN3aXRjaC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10YWJiYXIvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdGFiLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2ZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvYXNjZW5kLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2xpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvZmFsbC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2luZGV4LnVtZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7IH07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgcHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgY29uc3QgcHJlZml4ID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgIC5jYWxsKHN0eWxlcylcbiAgICAuam9pbignJylcbiAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICApWzFdO1xuXG4gIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuICctJyArIHByZWZpeCArICctJyArIHV0aWwuaHlwaGVuYXRlKG5hbWUpO1xuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIE1pbmltYWwgdXRpbGl0eSBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgZWxlbWVudCdzIHN0eWxlLlxuICogU2V0IGVsZW1lbnQncyBzdHlsZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmNvbnN0IHN0eWxlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeChrZXkpIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJlZml4KGtleSldID0gc3R5bGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC53YXJuKCdObyBzdWNoIHN0eWxlIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGVzIFNwYWNlLXNlcGFyYXRlZCBDU1MgcHJvcGVydGllcyB0byByZW1vdmVcbiAqL1xuc3R5bGVyLmNsZWFyID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVzID0gJycpIHtcbiAgY29uc3QgY2xlYXJsaXN0ID0gc3R5bGVzLnNwbGl0KC9cXHMrLykucmVkdWNlKChyLCBzKSA9PiByLmNvbmNhdChbdXRpbC5oeXBoZW5hdGUocyksIHByZWZpeChzKV0pLCBbXSksXG4gICAga2V5cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSBlbGVtZW50LnN0eWxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qga2V5ID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICBpZiAoY2xlYXJsaXN0Lmxlbmd0aCA9PT0gMCB8fCBjbGVhcmxpc3Quc29tZShzID0+IGtleS5pbmRleE9mKHMpID09PSAwKSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7IC8vIFN0b3JlIHRoZSBrZXkgdG8gZml4IFNhZmFyaSBzdHlsZSBpbmRleGVzXG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGtleSA9PiBlbGVtZW50LnN0eWxlW2tleV0gPSAnJyk7XG4gIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpID09PSAnJyAmJiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8vIFNhdmUgSFRNTEVsZW1lbnQgb2JqZWN0IGJlZm9yZSBDdXN0b20gRWxlbWVudHMgcG9seWZpbGwgcGF0Y2ggZ2xvYmFsIEhUTUxFbGVtZW50LlxuY29uc3QgTmF0aXZlSFRNTEVsZW1lbnQgPSB3aW5kb3cuSFRNTEVsZW1lbnQ7XG5cbi8qKlxuICogQG9iamVjdCBvbnMucGxhdGZvcm1cbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyB0byBkZXRlY3QgY3VycmVudCBwbGF0Zm9ybS5bL2VuXVxuICogICBbamFd54++5Zyo5a6f6KGM44GV44KM44Gm44GE44KL44OX44Op44OD44OI44OV44Kp44O844Og44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqL1xuY2xhc3MgUGxhdGZvcm0ge1xuXG4gIC8qKlxuICAgKiBBbGwgZWxlbWVudHMgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiB0aGUgYXBwIHdhcyBydW5uaW5nIG9uIHRoaXMgcGxhdGZvcm0uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zZWxlY3RlZFBsYXRmb3JtID0gbnVsbDtcbiAgICB0aGlzLl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2VsZWN0XG4gICAqIEBzaWduYXR1cmUgc2VsZWN0KHBsYXRmb3JtKVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBsYXRmb3JtIE5hbWUgb2YgdGhlIHBsYXRmb3JtLlxuICAgKiAgIFtlbl1Qb3NzaWJsZSB2YWx1ZXMgYXJlOiBcIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiBvciBcIndwXCIuWy9lbl1cbiAgICogICBbamFdXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIsIFwid3BcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TZXRzIHRoZSBwbGF0Zm9ybSB1c2VkIHRvIHJlbmRlciB0aGUgZWxlbWVudHMuIFVzZWZ1bCBmb3IgdGVzdGluZy5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgpLmj4/nlLvjgZnjgovjgZ/jgoHjgavliKnnlKjjgZnjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DlkI3jgpLoqK3lrprjgZfjgb7jgZnjgILjg4bjgrnjg4jjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICAgKi9cbiAgc2VsZWN0KHBsYXRmb3JtKSB7XG4gICAgaWYgKHR5cGVvZiBwbGF0Zm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkUGxhdGZvcm0gPSBwbGF0Zm9ybS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPyBudWxsIDogdGhpcy5fc2VsZWN0ZWRQbGF0Zm9ybTtcbiAgfVxuXG4gIF9ydW5PbkFjdHVhbFBsYXRmb3JtKGZuKSB7XG4gICAgdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPSB0cnVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gR2VuZXJhbFxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNXZWJWaWV3XG4gICAqIEBzaWduYXR1cmUgaXNXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gICAqICAgW2phXUNvcmRvdmHlhoXjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNXZWJWaWV3KCkge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXNXZWJWaWV3KCkgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBkb20gY29udGVudHMgbG9hZGVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiAhISh3aW5kb3cuY29yZG92YSB8fCB3aW5kb3cucGhvbmVnYXAgfHwgd2luZG93LlBob25lR2FwKTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBpT1MgZGV2aWNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJUGhvbmVcbiAgICogQHNpZ25hdHVyZSBpc0lQaG9uZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUuWy9lbl1cbiAgICogICBbamFdaVBob25l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBob25lKCkge1xuICAgIHJldHVybiAvaVBob25lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBob25lWFxuICAgKiBAc2lnbmF0dXJlIGlzSVBob25lWCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUgWC5bL2VuXVxuICAgKiAgIFtqYV1pUGhvbmUgWOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQaG9uZVgoKSB7XG4gICAgLy8gaVBob25lIDggYW5kIGlQaG9uZSBYIGhhdmUgYSBzYW1lIHVzZXIgYWdlbnQuIFdlIGNhbm5vdCBhdm9pZCB1c2luZyB3aW5kb3cuc2NyZWVuLlxuICAgIC8vIFRoaXMgd29ya3Mgd2VsbCBib3RoIGluIGlPUyBTYWZhcmkgYW5kIChVSXxXSylXZWJWaWV3IG9mIGlQaG9uZSBYLlxuICAgIHJldHVybiB0aGlzLmlzSVBob25lKCkgJiZcbiAgICAgICh3aW5kb3cuc2NyZWVuLndpZHRoID09PSAzNzUgJiYgd2luZG93LnNjcmVlbi5oZWlnaHQgPT09IDgxMlxuICAgIHx8IHdpbmRvdy5zY3JlZW4ud2lkdGggPT09IDgxMiAmJiB3aW5kb3cuc2NyZWVuLmhlaWdodCA9PT0gMzc1KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBhZFxuICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGFkLlsvZW5dXG4gICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGFkKCkge1xuICAgIHJldHVybiAvaVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBvZCgpIHtcbiAgICByZXR1cm4gL2lQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGlPUyB2ZXJzaW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NcbiAgICogQHNpZ25hdHVyZSBpc0lPUygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy5bL2VuXVxuICAgKiAgIFtqYV1pT1PkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1MoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2lvcyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1M3YWJvdmVcbiAgICogQHNpZ25hdHVyZSBpc0lPUzdhYm92ZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGlPUyB2ZXJzaW9uIGlzIDcgb3IgYWJvdmUuWy9lbl1cbiAgICogICBbamFdaU9TN+S7peS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPUzdhYm92ZSgpIHtcbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gKC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkgJiYgKHBhcnNlSW50KGRldmljZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pID49IDcpKTtcbiAgICB9IGVsc2UgaWYgKC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc3QgdmVyID0gKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcYlswLTldK19bMC05XSsoPzpfWzAtOV0rKT9cXGIvKSB8fCBbJyddKVswXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICByZXR1cm4gKHBhcnNlSW50KHZlci5zcGxpdCgnLicpWzBdKSA+PSA3KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGlPUyBicm93c2Vyc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NTYWZhcmlcbiAgICogQHNpZ25hdHVyZSBpc0lPU1NhZmFyaSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgYXBwIGlzIHJ1bm5pbmcgaW4gaU9TIFNhZmFyaS5bL2VuXVxuICAgKiAgIFtqYV1pT1MgU2FmYXJp44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TU2FmYXJpKCkge1xuICAgIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gICAgcmV0dXJuICEhKHRoaXMuaXNJT1MoKSAmJiB1YS5pbmRleE9mKCdTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignVmVyc2lvbicpICE9PSAtMSAmJiAhbmF2aWdhdG9yLnN0YW5kYWxvbmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNXS1dlYlZpZXdcbiAgICogQHNpZ25hdHVyZSBpc1dLV2ViVmlldygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgYXBwIGlzIHJ1bm5pbmcgaW4gV0tXZWJWaWV3LlsvZW5dXG4gICAqICAgW2phXVdLV2ViVmlld+OBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dLV2ViVmlldygpIHtcbiAgICBjb25zdCBsdGU5ID0gL2NvbnN0cnVjdG9yL2kudGVzdChOYXRpdmVIVE1MRWxlbWVudCk7XG4gICAgcmV0dXJuICEhKHRoaXMuaXNJT1MoKSAmJiB3aW5kb3cud2Via2l0ICYmIHdpbmRvdy53ZWJraXQubWVzc2FnZUhhbmRsZXJzICYmIHdpbmRvdy5pbmRleGVkREIgJiYgIWx0ZTkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNVSVdlYlZpZXdcbiAgICogQHNpZ25hdHVyZSBpc1VJV2ViVmlldygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgYXBwIGlzIHJ1bm5pbmcgaW4gVUlXZWJWaWV3LlsvZW5dXG4gICAqICAgW2phXVVJV2ViVmlld+OBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1VJV2ViVmlldygpIHtcbiAgICByZXR1cm4gISEodGhpcy5pc0lPUygpICYmICF0aGlzLmlzSU9TU2FmYXJpKCkgJiYgIXRoaXMuaXNXS1dlYlZpZXcoKSk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQW5kcm9pZCBkZXZpY2VzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRQaG9uZVxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFBob25lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgcGhvbmUuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOaQuuW4r+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRQaG9uZSgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkVGFibGV0XG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkVGFibGV0KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEFuZHJvaWQgdGFibGV0LlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTjgr/jg5bjg6zjg4Pjg4jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkVGFibGV0KCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIS9Nb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFuZHJvaWQgdmVyc2lvbnNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQW5kcm9pZFxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIEFuZHJvaWQuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWQoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2FuZHJvaWQnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gT3RoZXIgZGV2aWNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1dQKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICd3cCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9XaW4zMk5UfFdpbkNFL2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gL1dpbmRvd3MgUGhvbmV8SUVNb2JpbGV8V1BEZXNrdG9wL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0JsYWNrQmVycnlcbiAgICogQHNpZ25hdHVyZSBpc0JsYWNrQmVycnkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQmxhY2tCZXJyeS5bL2VuXVxuICAgKiAgIFtqYV1CbGFja0JlcnJ55LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQmxhY2tCZXJyeSgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnYmxhY2tiZXJyeSc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9CbGFja0JlcnJ5L2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gL0JsYWNrQmVycnl8UklNIFRhYmxldCBPU3xCQjEwL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gT3RoZXIgYnJvd3NlcnNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzT3BlcmFcbiAgICogQHNpZ25hdHVyZSBpc09wZXJhKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBPcGVyYS5bL2VuXVxuICAgKiAgIFtqYV1PcGVyYeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc09wZXJhKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdvcGVyYSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICghIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0ZpcmVmb3hcbiAgICogQHNpZ25hdHVyZSBpc0ZpcmVmb3goKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEZpcmVmb3guWy9lbl1cbiAgICogICBbamFdRmlyZWZveOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0ZpcmVmb3goKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2ZpcmVmb3gnO1xuICAgIH1cblxuICAgIHJldHVybiAodHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzU2FmYXJpKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBTYWZhcmkuWy9lbl1cbiAgICogICBbamFdU2FmYXJp5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU2FmYXJpKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdzYWZhcmknO1xuICAgIH1cblxuICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5IVE1MRWxlbWVudCkuaW5kZXhPZignQ29uc3RydWN0b3InKSA+IDApIHx8IChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC50b1N0cmluZygpID09PSAnW29iamVjdCBTYWZhcmlSZW1vdGVOb3RpZmljYXRpb25dJyB9KSghd2luZG93WydzYWZhcmknXSB8fCBzYWZhcmkucHVzaE5vdGlmaWNhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0Nocm9tZVxuICAgKiBAc2lnbmF0dXJlIGlzQ2hyb21lKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBDaHJvbWUuWy9lbl1cbiAgICogICBbamFdQ2hyb21l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQ2hyb21lKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdjaHJvbWUnO1xuICAgIH1cblxuICAgIHJldHVybiAoISF3aW5kb3cuY2hyb21lICYmICEoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApICYmICEobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lFXG4gICAqIEBzaWduYXR1cmUgaXNJRSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXIuWy9lbl1cbiAgICogICBbamFdSW50ZXJuZXQgRXhwbG9yZXLkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJRSgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnaWUnO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSB8fCAhIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRWRnZVxuICAgKiBAc2lnbmF0dXJlIGlzRWRnZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRWRnZS5bL2VuXVxuICAgKiAgIFtqYV1FZGdl5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRWRnZSgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnZWRnZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMDtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldE1vYmlsZU9TKCkge1xuICAgIGlmICh0aGlzLmlzQW5kcm9pZCgpKSB7XG4gICAgICByZXR1cm4gJ2FuZHJvaWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSU9TKCkpIHtcbiAgICAgIHJldHVybiAnaW9zJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc1dQKCkpIHtcbiAgICAgIHJldHVybiAnd3AnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRJT1NEZXZpY2UoKSB7XG4gICAgaWYgKHRoaXMuaXNJUGhvbmUoKSkge1xuICAgICAgcmV0dXJuICdpcGhvbmUnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBhZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwYWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzSVBvZCgpKSB7XG4gICAgICByZXR1cm4gJ2lwb2QnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAnbmEnO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBQbGF0Zm9ybSgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuY29uc3QgZXJyb3IgPSBtZXNzYWdlID0+IHV0aWwudGhyb3coYEluIFBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uOiAke21lc3NhZ2V9YCk7XG5cbmNvbnN0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uID0ge1xuICBfdmFyaWFibGVzOiB7fSxcblxuICAvKipcbiAgICogRGVmaW5lIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSB2YWx1ZSBWYWx1ZSBvZiB0aGUgdmFyaWFibGUuIENhbiBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3ZlcndyaXRlIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIHdoZW4gdHJ5aW5nIHRvIGRlZmluZSBhIHZhcmlhYmxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlxuICAgKi9cbiAgZGVmaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvdmVyd3JpdGU9ZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignVmFyaWFibGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignVmFyaWFibGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICBlcnJvcihgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBkZWZpbmVkYCk7XG4gICAgfVxuICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAqIEByZXR1cm4ge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZ2V0VmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHZhcmFpYmxlLlxuICAgKi9cbiAgcmVtb3ZlVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QWxsVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzO1xuICB9LFxuICBfcGFyc2VQYXJ0OiBmdW5jdGlvbihwYXJ0KSB7XG4gICAgbGV0IGMsXG4gICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZSxcbiAgICAgIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcblxuICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBlbXB0eSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGMgPSBwYXJ0LmNoYXJBdChpKTtcblxuICAgICAgaWYgKGMgPT09ICckJyAmJiBwYXJ0LmNoYXJBdChpICsgMSkgPT09ICd7Jykge1xuICAgICAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgZXJyb3IoJ05lc3RlZCBpbnRlcnBvbGF0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKTtcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGk7XG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICAgICAgaWYgKCFpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICBlcnJvcignfSBtdXN0IGJlIHByZWNlZWRlZCBieSAkeycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkgKyAxKTtcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkgKyAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBpICsgMTtcbiAgICAgICAgaW5JbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluSW50ZXJwb2xhdGlvbikge1xuICAgICAgZXJyb3IoJ1VudGVybWluYXRlZCBpbnRlcnBvbGF0aW9uJyk7XG4gICAgfVxuXG4gICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBwYXJ0Lmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfSxcbiAgX3JlcGxhY2VUb2tlbjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBjb25zdCByZSA9IC9eXFwkeyguKj8pfSQvLFxuICAgICAgbWF0Y2ggPSB0b2tlbi5tYXRjaChyZSk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZ2V0VmFyaWFibGUobmFtZSk7XG5cbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gbnVsbCkge1xuICAgICAgICBlcnJvcihgVmFyaWFibGUgXCIke25hbWV9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gdmFyaWFibGUoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9yKCdNdXN0IHJldHVybiBhIHN0cmluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gIH0sXG4gIF9yZXBsYWNlVG9rZW5zOiBmdW5jdGlvbih0b2tlbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zLm1hcCh0aGlzLl9yZXBsYWNlVG9rZW4uYmluZCh0aGlzKSk7XG4gIH0sXG4gIF9wYXJzZUV4cHJlc3Npb246IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbi5zcGxpdCgnLCcpXG4gICAgICAubWFwKFxuICAgICAgICBmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQudHJpbSgpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgICAubWFwKHRoaXMuX3BhcnNlUGFydC5iaW5kKHRoaXMpKVxuICAgICAgLm1hcCh0aGlzLl9yZXBsYWNlVG9rZW5zLmJpbmQodGhpcykpXG4gICAgICAubWFwKChwYXJ0KSA9PiBwYXJ0LmpvaW4oJycpKTtcbiAgfSxcblxuICAvKipcbiAgICogRXZhbHVhdGUgYW4gZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb24gQW4gcGFnZSBhdHRyaWJ1dGUgZXhwcmVzc2lvbi5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBldmFsdWF0ZTogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wYXJzZUV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gIH1cbn07XG5cbi8vIERlZmluZSBkZWZhdWx0IHZhcmlhYmxlcy5cbnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdtb2JpbGVPUycsIHBsYXRmb3JtLmdldE1vYmlsZU9TKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ2lPU0RldmljZScsIHBsYXRmb3JtLmdldElPU0RldmljZSgpKTtcbnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdydW50aW1lJywgKCkgPT4ge1xuICByZXR1cm4gcGxhdGZvcm0uaXNXZWJWaWV3KCkgPyAnY29yZG92YScgOiAnYnJvd3Nlcic7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb247XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5pbXBvcnQgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gZnJvbSAnLi4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5cbmNvbnN0IGludGVybmFsID0ge307XG5cbmludGVybmFsLmNvbmZpZyA9IHtcbiAgYXV0b1N0YXR1c0JhckZpbGw6IHRydWUsXG4gIGFuaW1hdGlvbnNEaXNhYmxlZDogZmFsc2UsXG4gIHdhcm5pbmdzRGlzYWJsZWQ6IGZhbHNlXG59O1xuXG5pbnRlcm5hbC5udWxsRWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5pbnRlcm5hbC5pc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgcmV0dXJuICEhaW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5pbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTCA9IGh0bWwgPT4gKCcnICsgaHRtbCkudHJpbSgpO1xuXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgd2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgd3JhcHBlZENhbGxiYWNrKTtcbiAgICB9O1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgd3JhcHBlZENhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG5pbnRlcm5hbC5hdXRvU3RhdHVzQmFyRmlsbCA9IGFjdGlvbiA9PiB7XG4gIGNvbnN0IG9uUmVhZHkgPSAoKSA9PiB7XG4gICAgaWYgKGludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIoKSkge1xuICAgICAgYWN0aW9uKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5Jywgb25SZWFkeSk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBvblJlYWR5KTtcbiAgfSBlbHNlIGlmIChbJ2NvbXBsZXRlJywgJ2ludGVyYWN0aXZlJ10uaW5kZXhPZihkb2N1bWVudC5yZWFkeVN0YXRlKSA9PT0gLTEpIHtcbiAgICBpbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZChvblJlYWR5KTtcbiAgfSBlbHNlIHtcbiAgICBvblJlYWR5KCk7XG4gIH1cbn07XG5cbmludGVybmFsLnNob3VsZEZpbGxTdGF0dXNCYXIgPSAoKSA9PiBpbnRlcm5hbC5pc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCgpICYmXG4gIChwbGF0Zm9ybS5pc1dlYlZpZXcoKSAmJiBwbGF0Zm9ybS5pc0lPUzdhYm92ZSgpICYmICFwbGF0Zm9ybS5pc0lQaG9uZVgoKSB8fCBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5vbnMtc3RhdHVzLWJhci1tb2NrLmlvcycpKTtcblxuaW50ZXJuYWwudGVtcGxhdGVTdG9yZSA9IHtcbiAgX3N0b3JhZ2U6IHt9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge1N0cmluZy9udWxsfSB0ZW1wbGF0ZVxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLl9zdG9yYWdlW2tleV0gfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHNldChrZXksIHRlbXBsYXRlKSB7XG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldID0gdGVtcGxhdGU7XG4gIH1cbn07XG5cbndpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdfdGVtcGxhdGVsb2FkZWQnLCBmdW5jdGlvbihlKSB7XG4gIGlmIChlLnRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXRlbXBsYXRlJykge1xuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KGUudGVtcGxhdGVJZCwgZS50ZW1wbGF0ZSk7XG4gIH1cbn0sIGZhbHNlKTtcblxuaW50ZXJuYWwud2FpdERPTUNvbnRlbnRMb2FkZWQoZnVuY3Rpb24oKSB7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvb25zLXRlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9uZy10ZW1wbGF0ZVwiXScpO1xuICByZWdpc3RlcigndGVtcGxhdGUnKTtcblxuICBmdW5jdGlvbiByZWdpc3RlcihxdWVyeSkge1xuICAgIGNvbnN0IHRlbXBsYXRlcyA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBsYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5zZXQodGVtcGxhdGVzW2ldLmdldEF0dHJpYnV0ZSgnaWQnKSwgdGVtcGxhdGVzW2ldLnRleHRDb250ZW50IHx8IHRlbXBsYXRlc1tpXS5jb250ZW50KTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5pbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZCgoKSA9PiB7XG4gICAgICBjb25zdCBjYWNoZSA9IGludGVybmFsLnRlbXBsYXRlU3RvcmUuZ2V0KHBhZ2UpO1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGlmIChjYWNoZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjYWNoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBodG1sID0gdHlwZW9mIGNhY2hlID09PSAnc3RyaW5nJyA/IGNhY2hlIDogY2FjaGVbMV07XG4gICAgICAgIHJldHVybiByZXNvbHZlKGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKGh0bWwpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWwgPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocGFnZSk7XG4gICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IGxvY2FsLnRleHRDb250ZW50IHx8IGxvY2FsLmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGh0bWwpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBwYWdlLCB0cnVlKTtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDQwMCAmJiB4aHIuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgcmVqZWN0KGh0bWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlZnJlc2ggc2NyaXB0IHRhZ3NcbiAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHV0aWwuY3JlYXRlRnJhZ21lbnQoaHRtbCk7XG4gICAgICAgICAgdXRpbC5hcnJheUZyb20oZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0JykpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBzY3JpcHQudHlwZSA9IGVsLnR5cGUgfHwgJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgICAgICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZWwudGV4dCB8fCBlbC50ZXh0Q29udGVudCB8fCBlbC5pbm5lckhUTUwpKTtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHNjcmlwdCwgZWwpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5zZXQocGFnZSwgZnJhZ21lbnQpO1xuICAgICAgICAgIHJlc29sdmUoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdXRpbC50aHJvdyhgUGFnZSB0ZW1wbGF0ZSBub3QgZm91bmQ6ICR7cGFnZX1gKTtcbiAgICAgIH07XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5pbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICBjb25zdCBwYWdlcyA9IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmV2YWx1YXRlKHBhZ2UpO1xuXG4gIGNvbnN0IGdldFBhZ2UgPSAocGFnZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcGFnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTXVzdCBzcGVjaWZ5IGEgcGFnZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0VGVtcGxhdGVIVE1MQXN5bmMocGFnZSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAocGFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL2ludGVybmFsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0b3JGYWN0b3J5IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYW5pbWF0b3JzIFRoZSBkaWN0aW9uYXJ5IGZvciBhbmltYXRvciBjbGFzc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMuYmFzZUNsYXNzIFRoZSBiYXNlIGNsYXNzIG9mIGFuaW1hdG9yc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuYmFzZUNsYXNzTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uXSBUaGUgZGVmYXVsdCBhbmltYXRpb24gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZGVmYXVsdEFuaW1hdGlvbk9wdGlvbnNdIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JzID0gb3B0cy5hbmltYXRvcnM7XG4gICAgdGhpcy5fYmFzZUNsYXNzID0gb3B0cy5iYXNlQ2xhc3M7XG4gICAgdGhpcy5fYmFzZUNsYXNzTmFtZSA9IG9wdHMuYmFzZUNsYXNzTmFtZSB8fCBvcHRzLmJhc2VDbGFzcy5uYW1lO1xuICAgIHRoaXMuX2FuaW1hdGlvbiA9IG9wdHMuZGVmYXVsdEFuaW1hdGlvbiB8fCAnZGVmYXVsdCc7XG4gICAgdGhpcy5fYW5pbWF0aW9uT3B0aW9ucyA9IG9wdHMuZGVmYXVsdEFuaW1hdGlvbk9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIXRoaXMuX2FuaW1hdG9yc1t0aGlzLl9hbmltYXRpb25dKSB7XG4gICAgICB1dGlsLnRocm93KCdObyBzdWNoIGFuaW1hdGlvbjogJyArIHRoaXMuX2FuaW1hdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdC9udWxsfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyhqc29uU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignXCJhbmltYXRpb24tb3B0aW9uc1wiIGF0dHJpYnV0ZSBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgc3RyaW5nOiAnICsganNvblN0cmluZyk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBzZXRBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXSBUaGUgYW5pbWF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdIFRoZSBhbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdEFuaW1hdG9yIFRoZSBkZWZhdWx0IGFuaW1hdG9yIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gYW5pbWF0b3IgaW5zdGFuY2VcbiAgICovXG4gIG5ld0FuaW1hdG9yKG9wdGlvbnMgPSB7fSwgZGVmYXVsdEFuaW1hdG9yKSB7XG5cbiAgICBsZXQgYW5pbWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5hbmltYXRpb247XG4gICAgfVxuXG4gICAgbGV0IEFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbmltYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBBbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yc1tvcHRpb25zLmFuaW1hdGlvbl07XG4gICAgfVxuXG4gICAgaWYgKCFBbmltYXRvciAmJiBkZWZhdWx0QW5pbWF0b3IpIHtcbiAgICAgIGFuaW1hdG9yID0gZGVmYXVsdEFuaW1hdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBBbmltYXRvciA9IEFuaW1hdG9yIHx8IHRoaXMuX2FuaW1hdG9yc1t0aGlzLl9hbmltYXRpb25dO1xuXG4gICAgICBjb25zdCBhbmltYXRpb25PcHRzID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zLFxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICAgIGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPyB7ZHVyYXRpb246IDAsIGRlbGF5OiAwfSA6IHt9XG4gICAgICApO1xuXG4gICAgICBhbmltYXRvciA9IG5ldyBBbmltYXRvcihhbmltYXRpb25PcHRzKTtcblxuICAgICAgaWYgKHR5cGVvZiBhbmltYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhbmltYXRvciA9IG5ldyBhbmltYXRvcihhbmltYXRpb25PcHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYW5pbWF0b3IgaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpKSB7XG4gICAgICB1dGlsLnRocm93KGBcImFuaW1hdG9yXCIgaXMgbm90IGFuIGluc3RhbmNlIG9mICR7dGhpcy5fYmFzZUNsYXNzTmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmxldCBhdXRvU3R5bGVFbmFibGVkID0gdHJ1ZTtcblxuLy8gTW9kaWZpZXJzXG5jb25zdCBtb2RpZmllcnNNYXAgPSB7XG4gICdxdWlldCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdsaWdodCc6ICdtYXRlcmlhbC0tZmxhdCcsXG4gICdvdXRsaW5lJzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2N0YSc6ICcnLFxuICAnbGFyZ2UtLXF1aWV0JzogJ21hdGVyaWFsLS1mbGF0IGxhcmdlJyxcbiAgJ2xhcmdlLS1jdGEnOiAnbGFyZ2UnLFxuICAnbm9ib3JkZXInOiAnJyxcbiAgJ3RhcHBhYmxlJzogJydcbn07XG5cbmNvbnN0IHBsYXRmb3JtcyA9IHt9O1xuXG5wbGF0Zm9ybXMuYW5kcm9pZCA9IGVsZW1lbnQgPT4ge1xuXG4gIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKCF1dGlsLmhhc01vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpKSB7XG4gICAgY29uc3Qgb2xkTW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcblxuICAgIGNvbnN0IG5ld01vZGlmaWVyID0gb2xkTW9kaWZpZXIudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGUgPT4gbW9kaWZpZXJzTWFwLmhhc093blByb3BlcnR5KGUpID8gbW9kaWZpZXJzTWFwW2VdIDogZSk7XG4gICAgbmV3TW9kaWZpZXIudW5zaGlmdCgnbWF0ZXJpYWwnKTtcblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVyLmpvaW4oJyAnKS50cmltKCkpO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudHMgPSBbXG4gICAgJ29ucy1hbGVydC1kaWFsb2ctYnV0dG9uJyxcbiAgICAnb25zLXRvb2xiYXItYnV0dG9uJyxcbiAgICAnb25zLWJhY2stYnV0dG9uJyxcbiAgICAnb25zLWJ1dHRvbicsXG4gICAgJ29ucy1saXN0LWl0ZW0nLFxuICAgICdvbnMtZmFiJyxcbiAgICAnb25zLXNwZWVkLWRpYWwnLFxuICAgICdvbnMtc3BlZWQtZGlhbC1pdGVtJyxcbiAgICAnb25zLXRhYidcbiAgXTtcblxuXG4gIC8vIEVmZmVjdHNcbiAgaWYgKGVsZW1lbnRzLmluZGV4T2YoZWxlbWVudE5hbWUpICE9PSAtMVxuICAgICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJylcbiAgICAmJiAhZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdvbnMtcmlwcGxlJykpIHtcblxuICAgIGlmIChlbGVtZW50TmFtZSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhcHBhYmxlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyaXBwbGUnLCAnJyk7XG4gICAgfVxuICB9XG59O1xuXG5wbGF0Zm9ybXMuaW9zID0gZWxlbWVudCA9PiB7XG5cbiAvLyBNb2RpZmllcnNcbiBpZiAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwnKSkge1xuICAgaWYgKHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsLS1mbGF0JykpIHtcbiAgICAgdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbGFyZ2UnKSkgPyAnbGFyZ2UtLXF1aWV0JyA6ICdxdWlldCcpO1xuICAgfVxuXG4gICBpZiAoIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgfVxuIH1cblxuIC8vIEVmZmVjdHNcbiBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKSB7XG4gICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdC1pdGVtJykge1xuICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFwcGFibGUnLCAnJyk7XG4gICB9XG5cbiAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyaXBwbGUnKTtcbiB9XG59O1xuXG5jb25zdCB1bmxvY2tlZCA9IHtcbiAgYW5kcm9pZDogdHJ1ZVxufTtcblxuY29uc3QgZ2V0UGxhdGZvcm0gPSAoZWxlbWVudCwgZm9yY2UpID0+IHtcbiAgaWYgKGF1dG9TdHlsZUVuYWJsZWQgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlLWF1dG8tc3R5bGluZycpKSB7XG4gICAgY29uc3QgbW9iaWxlT1MgPSBvbnNQbGF0Zm9ybS5nZXRNb2JpbGVPUygpO1xuICAgIGlmIChwbGF0Zm9ybXMuaGFzT3duUHJvcGVydHkobW9iaWxlT1MpICYmICh1bmxvY2tlZC5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgfHwgZm9yY2UpKSB7XG4gICAgICByZXR1cm4gbW9iaWxlT1M7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgcHJlcGFyZSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBjb25zdCBwID0gZ2V0UGxhdGZvcm0oZWxlbWVudCwgZm9yY2UpO1xuICBwICYmIHBsYXRmb3Jtc1twXShlbGVtZW50KTtcbn07XG5cbmNvbnN0IG1hcE1vZGlmaWVyID0gKG1vZGlmaWVyLCBlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoZ2V0UGxhdGZvcm0oZWxlbWVudCwgZm9yY2UpKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLnNwbGl0KC9cXHMrLykubWFwKG0gPT4gbW9kaWZpZXJzTWFwLmhhc093blByb3BlcnR5KG0pID8gbW9kaWZpZXJzTWFwW21dIDogbSkuam9pbignICcpO1xuICB9XG4gIHJldHVybiBtb2RpZmllcjtcbn07XG5cbmNvbnN0IHJlc3RvcmVNb2RpZmllciA9IGVsZW1lbnQgPT4ge1xuICBpZiAoZ2V0UGxhdGZvcm0oZWxlbWVudCkgPT09ICdhbmRyb2lkJykge1xuICAgIGNvbnN0IG1vZGlmaWVyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJyc7XG4gICAgbGV0IG5ld01vZGlmaWVyID0gbWFwTW9kaWZpZXIobW9kaWZpZXIsIGVsZW1lbnQpO1xuXG4gICAgaWYgKCEvKF58XFxzKyltYXRlcmlhbCgkfFxccyspL2kudGVzdChtb2RpZmllcikpIHtcbiAgICAgIG5ld01vZGlmaWVyID0gJ21hdGVyaWFsICcgKyBuZXdNb2RpZmllcjtcbiAgICB9XG5cbiAgICBpZiAobmV3TW9kaWZpZXIgIT09IG1vZGlmaWVyKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllci50cmltKCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNFbmFibGVkOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkLFxuICBlbmFibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlLFxuICBkaXNhYmxlOiAoKSA9PiBhdXRvU3R5bGVFbmFibGVkID0gZmFsc2UsXG4gIHByZXBhcmUsXG4gIG1hcE1vZGlmaWVyLFxuICBnZXRQbGF0Zm9ybSxcbiAgcmVzdG9yZU1vZGlmaWVyXG59O1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL2F1dG9zdHlsZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGlmaWVyVXRpbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFxuICAgKi9cbiAgc3RhdGljIGRpZmYobGFzdCwgY3VycmVudCkge1xuICAgIGxhc3QgPSBtYWtlRGljdCgoJycgKyBsYXN0KS50cmltKCkpO1xuICAgIGN1cnJlbnQgPSBtYWtlRGljdCgoJycgKyBjdXJyZW50KS50cmltKCkpO1xuXG4gICAgY29uc3QgcmVtb3ZlZCA9IE9iamVjdC5rZXlzKGxhc3QpLnJlZHVjZSgocmVzdWx0LCB0b2tlbikgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50W3Rva2VuXSkge1xuICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGFkZGVkID0gT2JqZWN0LmtleXMoY3VycmVudCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWxhc3RbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHthZGRlZCwgcmVtb3ZlZH07XG5cbiAgICBmdW5jdGlvbiBtYWtlRGljdChtb2RpZmllcikge1xuICAgICAgY29uc3QgZGljdCA9IHt9O1xuICAgICAgTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKS5mb3JFYWNoKHRva2VuID0+IGRpY3RbdG9rZW5dID0gdG9rZW4pO1xuICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYucmVtb3ZlZFxuICAgKiBAcGFyYW0ge0FycmF5fSBkaWZmLmFkZGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc0xpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9DbGFzc0xpc3QoZGlmZiwgY2xhc3NMaXN0LCB0ZW1wbGF0ZSkge1xuICAgIGRpZmYuYWRkZWRcbiAgICAgIC5tYXAobW9kaWZpZXIgPT4gdGVtcGxhdGUucmVwbGFjZSgvXFwqL2csIG1vZGlmaWVyKSlcbiAgICAgIC5mb3JFYWNoKGtsYXNzID0+IGtsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChrID0+IGNsYXNzTGlzdC5hZGQoaykpKTtcblxuICAgIGRpZmYucmVtb3ZlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4ga2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGsgPT4gY2xhc3NMaXN0LnJlbW92ZShrKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWZmXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYucmVtb3ZlZFxuICAgKiBAcGFyYW0ge0FycmF5fSBkaWZmLmFkZGVkXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGFwcGx5RGlmZlRvRWxlbWVudChkaWZmLCBlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBPYmplY3Qua2V5cyhzY2hlbWUpLmZvckVhY2goc2VsZWN0b3IgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHMgPSAhc2VsZWN0b3IgfHwgdXRpbC5tYXRjaChlbGVtZW50LCBzZWxlY3RvcilcbiAgICAgICAgPyBbZWxlbWVudF1cbiAgICAgICAgOiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoXG4gICAgICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9PiAhdXRpbC5maW5kUGFyZW50KHRhcmdldEVsZW1lbnQsIGVsZW1lbnQudGFnTmFtZSwgcGFyZW50ID0+IHBhcmVudCA9PT0gZWxlbWVudClcbiAgICAgICAgICApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCB0YXJnZXRFbGVtZW50c1tpXS5jbGFzc0xpc3QsIHNjaGVtZVtzZWxlY3Rvcl0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIG9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoTW9kaWZpZXJVdGlsLmRpZmYobGFzdCwgY3VycmVudCksIGVsZW1lbnQsIHNjaGVtZSk7XG4gICAgYXV0b1N0eWxlLnJlc3RvcmVNb2RpZmllcihlbGVtZW50KTtcbiAgfVxuXG4gIHN0YXRpYyByZWZyZXNoKGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoTW9kaWZpZXJVdGlsLmRpZmYoJycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnKSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAgICovXG4gIHN0YXRpYyBpbml0TW9kaWZpZXIoZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5hcHBseURpZmZUb0VsZW1lbnQoe1xuICAgICAgcmVtb3ZlZDogW10sXG4gICAgICBhZGRlZDogTW9kaWZpZXJVdGlsLnNwbGl0KG1vZGlmaWVyKVxuICAgIH0sIGVsZW1lbnQsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgc3BsaXQobW9kaWZpZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZGlmaWVyICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllci50cmltKCkuc3BsaXQoLyArLykuZmlsdGVyKHRva2VuID0+IHRva2VuICE9PSAnJyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG1vZGlmaWVyIHRva2VuIHRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICBzdGF0aWMgYWRkTW9kaWZpZXIoZWxlbWVudCwgbW9kaWZpZXJUb2tlbikge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG1vZGlmaWVyVG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBNb2RpZmllclV0aWwuc3BsaXQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgaWYgKHRva2Vucy5pbmRleE9mKG1vZGlmaWVyVG9rZW4pID09IC0xKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKG1vZGlmaWVyVG9rZW4pO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCB0b2tlbnMuam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG1vZGlmaWVyIHRva2VuIGZyb20gYW4gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyByZW1vdmVNb2RpZmllcihlbGVtZW50LCBtb2RpZmllclRva2VuKSB7XG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBNb2RpZmllclV0aWwuc3BsaXQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgY29uc3QgaW5kZXggPSB0b2tlbnMuaW5kZXhPZihtb2RpZmllclRva2VuKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIHRva2Vucy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcblxuY29uc3QgdXRpbCA9IHtcbiAgX3JlYWR5OiBmYWxzZSxcblxuICBfZG9tQ29udGVudExvYWRlZDogZmFsc2UsXG5cbiAgX29uRE9NQ29udGVudExvYWRlZDogKCkgPT4ge1xuICAgIHV0aWwuX2RvbUNvbnRlbnRMb2FkZWQgPSB0cnVlO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzV2ViVmlldygpKSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHV0aWwuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBhZGRCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyOiBmdW5jdGlvbihmbikge1xuICAgIGlmICghdGhpcy5fZG9tQ29udGVudExvYWRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgRE9NQ29udGVudExvYWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JhY2tidXR0b24nLCBmbiwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB1dGlsLl9vbkRPTUNvbnRlbnRMb2FkZWQoKSwgZmFsc2UpO1xuXG5jb25zdCBIYW5kbGVyUmVwb3NpdG9yeSA9IHtcbiAgX3N0b3JlOiB7fSxcblxuICBfZ2VuSWQ6ICgoKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiAoKSA9PiBpKys7XG4gIH0pKCksXG5cbiAgc2V0OiBmdW5jdGlvbihlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCA9IEhhbmRsZXJSZXBvc2l0b3J5Ll9nZW5JZCgpO1xuICAgIHRoaXMuX3N0b3JlW2lkXSA9IGhhbmRsZXI7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RvcmVbZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWRdO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuICAgIH1cbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG5cbiAgICBpZiAoIXRoaXMuX3N0b3JlW2lkXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0b3JlW2lkXTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG5cbiAgICByZXR1cm4gISF0aGlzLl9zdG9yZVtpZF07XG4gIH1cbn07XG5cbmNsYXNzIERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRDYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFbmFibGUgdG8gaGFuZGxlICdiYWNrYnV0dG9uJyBldmVudHMuXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHV0aWwuYWRkQmFja0J1dHRvbkxpc3RlbmVyKHRoaXMuX2JvdW5kQ2FsbGJhY2spO1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5yZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZSBhICdiYWNrYnV0dG9uJyBldmVudCBtYW51YWxseS5cbiAgICovXG4gIGZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2JhY2tidXR0b24nLCB0cnVlLCB0cnVlKTtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIF9jYWxsYmFjaygpIHtcbiAgICB0aGlzLl9kaXNwYXRjaERldmljZUJhY2tCdXR0b25FdmVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGNyZWF0ZUhhbmRsZXIoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudCcpO1xuICAgIH1cblxuICAgIGlmICghKGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgX2NhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgfSxcblxuICAgICAgc2V0TGlzdGVuZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9LFxuXG4gICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5zZXQoZWxlbWVudCwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpID09PSB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaGFuZGxlci5lbmFibGUoKTtcblxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9XG5cbiAgX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCkge1xuICAgIGNvbnN0IHRyZWUgPSB0aGlzLl9jYXB0dXJlVHJlZSgpO1xuXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2ZpbmRIYW5kbGVyTGVhZkVsZW1lbnQodHJlZSk7XG5cbiAgICBsZXQgaGFuZGxlciA9IEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KTtcbiAgICBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChlbGVtZW50KSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgY2FsbFBhcmVudEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQocGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIF9jYXB0dXJlVHJlZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlVHJlZShkb2N1bWVudC5ib2R5KTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRyZWUoZWxlbWVudCkge1xuICAgICAgY29uc3QgdHJlZSA9IHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgY2hpbGRyZW46IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycmF5T2YoZWxlbWVudC5jaGlsZHJlbikubWFwKGZ1bmN0aW9uKGNoaWxkRWxlbWVudCkge1xuXG4gICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgY2hpbGRFbGVtZW50Ll9pc1Nob3duID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMoY2hpbGRFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRyZWUoY2hpbGRFbGVtZW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmICFIYW5kbGVyUmVwb3NpdG9yeS5oYXMocmVzdWx0LmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgICAgICB9KSlcbiAgICAgIH07XG5cbiAgICAgIGlmICghSGFuZGxlclJlcG9zaXRvcnkuaGFzKHRyZWUuZWxlbWVudCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICBpZiAoSGFuZGxlclJlcG9zaXRvcnkuaGFzKHN1YlRyZWUuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJUcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcnJheU9mKHRhcmdldCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh0YXJnZXRbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyZWVcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKSB7XG4gICAgcmV0dXJuIGZpbmQodHJlZSk7XG5cbiAgICBmdW5jdGlvbiBmaW5kKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZpbmQobm9kZS5jaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkTm9kZS5lbGVtZW50O1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmICghbGVmdCkge1xuICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlZnRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobGVmdCwgJycpLnpJbmRleCwgMTApO1xuICAgICAgICBjb25zdCByaWdodFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyaWdodCwgJycpLnpJbmRleCwgMTApO1xuXG4gICAgICAgIGlmICghaXNOYU4obGVmdFopICYmICFpc05hTihyaWdodFopKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnRaID4gcmlnaHRaID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXB0dXJpbmcgYmFja2J1dHRvbi1oYW5kbGVyIGlzIGZhaWx1cmUuJyk7XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IERldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4vZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuXG5pbnRlcm5hbC5BbmltYXRvckZhY3RvcnkgPSBBbmltYXRvckZhY3Rvcnk7XG5pbnRlcm5hbC5Nb2RpZmllclV0aWwgPSBNb2RpZmllclV0aWw7XG5pbnRlcm5hbC5kYmJEaXNwYXRjaGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN0YXJ0c1dpdGggPSAocywgYykgPT4gcy5zdWJzdHIoMCwgYy5sZW5ndGgpID09PSBjO1xuY29uc3QgZW5kc1dpdGggPSAocywgYykgPT4gcy5zdWJzdHIocy5sZW5ndGggLSBjLmxlbmd0aCwgYy5sZW5ndGgpID09PSBjO1xuY29uc3QgdW53cmFwID0gcyA9PiBzLnNsaWNlKDEsIC0xKTtcbmNvbnN0IGlzT2JqZWN0U3RyaW5nID0gcyA9PiBzdGFydHNXaXRoKHMsICd7JykgJiYgZW5kc1dpdGgocywgJ30nKTtcbmNvbnN0IGlzQXJyYXlTdHJpbmcgPSBzID0+IHN0YXJ0c1dpdGgocywgJ1snKSAmJiBlbmRzV2l0aChzLCAnXScpO1xuY29uc3QgaXNRdW90ZWRTdHJpbmcgPSBzID0+IChzdGFydHNXaXRoKHMsICdcXCcnKSAmJiBlbmRzV2l0aChzLCAnXFwnJykpIHx8IChzdGFydHNXaXRoKHMsICdcIicpICYmIGVuZHNXaXRoKHMsICdcIicpKTtcblxuY29uc3QgZXJyb3IgPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHRva2VuIFxcJycgKyB0b2tlbiArICdcXCcgYXQgcG9zaXRpb24gJyArIChvcmlnaW5hbFN0cmluZy5sZW5ndGggLSBzdHJpbmcubGVuZ3RoIC0gMSkgKyAnIGluIHN0cmluZzogXFwnJyArIG9yaWdpbmFsU3RyaW5nICsgJ1xcJycpO1xufTtcblxuY29uc3QgcHJvY2Vzc1Rva2VuID0gKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSA9PiB7XG4gIGlmICh0b2tlbiA9PT0gJ3RydWUnIHx8IHRva2VuID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIHRva2VuID09PSAndHJ1ZSc7XG4gIH0gZWxzZSBpZiAoaXNRdW90ZWRTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHVud3JhcCh0b2tlbik7XG4gIH0gZWxzZSBpZiAoIWlzTmFOKHRva2VuKSkge1xuICAgIHJldHVybiArKHRva2VuKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHRva2VuKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheSh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cbn07XG5cbmNvbnN0IG5leHRUb2tlbiA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgbGV0IGxpbWl0ID0gc3RyaW5nLmxlbmd0aDtcblxuICBpZiAoc3RyaW5nWzBdID09PSAnOicgfHwgc3RyaW5nWzBdID09PSAnLCcpIHtcblxuICAgIGxpbWl0ID0gMTtcblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ3snIHx8IHN0cmluZ1swXSA9PT0gJ1snKSB7XG5cbiAgICBjb25zdCBjID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgbGV0IG5lc3RlZE9iamVjdCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYykge1xuICAgICAgICBuZXN0ZWRPYmplY3QrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMgKyAyKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdC0tO1xuICAgICAgICBpZiAobmVzdGVkT2JqZWN0ID09PSAwKSB7XG4gICAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0cmluZ1swXSA9PT0gJ1xcJycgfHwgc3RyaW5nWzBdID09PSAnXCInKSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZ1tpXSA9PT0gc3RyaW5nWzBdKSB7XG4gICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChbJyAnLCAnLCcsICc6J10uaW5kZXhPZihzdHJpbmdbaV0pICE9PSAtMSkge1xuICAgICAgICBsaW1pdCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBsaW1pdCk7XG59O1xuXG5jb25zdCBwYXJzZU9iamVjdCA9IChzdHJpbmcpID0+IHtcbiAgY29uc3QgaXNWYWxpZEtleSA9IGtleSA9PiAvXltBLVpfJF1bQS1aMC05XyRdKiQvaS50ZXN0KGtleSk7XG5cbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuICBsZXQgcmVhZGluZ0tleSA9IHRydWUsIGtleSwgcHJldmlvdXNUb2tlbiwgdG9rZW47XG5cbiAgd2hpbGUgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbSgpO1xuXG4gICAgaWYgKCh0b2tlbiA9PT0gJzonICYmICghcmVhZGluZ0tleSB8fCAhcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKVxuICAgICAgIHx8ICh0b2tlbiA9PT0gJywnICYmIHJlYWRpbmdLZXkpXG4gICAgICAgfHwgKHRva2VuICE9PSAnOicgJiYgdG9rZW4gIT09ICcsJyAmJiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuICE9PSAnLCcgJiYgcHJldmlvdXNUb2tlbiAhPT0gJzonKSkpIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnOicgJiYgcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBwcmV2aW91c1Rva2VuID0gaXNRdW90ZWRTdHJpbmcocHJldmlvdXNUb2tlbikgPyB1bndyYXAocHJldmlvdXNUb2tlbikgOiBwcmV2aW91c1Rva2VuO1xuICAgICAgaWYgKGlzVmFsaWRLZXkocHJldmlvdXNUb2tlbikpIHtcbiAgICAgICAga2V5ID0gcHJldmlvdXNUb2tlbjtcbiAgICAgICAgcmVhZGluZ0tleSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSB0b2tlbiBcXCcnICsgcHJldmlvdXNUb2tlbiArICdcXCcgYXQgcG9zaXRpb24gMCBpbiBzdHJpbmc6IFxcJycgKyBvcmlnaW5hbFN0cmluZyArICdcXCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnLCcgJiYgIXJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xuICAgICAgb2JqZWN0W2tleV0gPSBwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgICByZWFkaW5nS2V5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgcGFyc2VBcnJheSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGxldCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcblxuICB3aGlsZSAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltKCk7XG5cbiAgICBpZiAodG9rZW4gPT09ICcsJyAmJiAoIXByZXZpb3VzVG9rZW4gfHwgcHJldmlvdXNUb2tlbiA9PT0gJywnKSkge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJykge1xuICAgICAgYXJyYXkucHVzaChwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIGlmICh0b2tlbiAhPT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuY29uc3QgcGFyc2UgPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG5cbiAgaWYgKGlzT2JqZWN0U3RyaW5nKHN0cmluZykpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcChzdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHN0cmluZyBtdXN0IGJlIG9iamVjdCBvciBhcnJheSBsaWtlOiAnICsgc3RyaW5nKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cyc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4vc3R5bGVyJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IGFuaW1hdGlvbk9wdGlvbnNQYXJzZSBmcm9tICcuL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5cbmNvbnN0IHV0aWwgPSB7fTtcbmNvbnN0IGVycm9yUHJlZml4ID0gJ1tPbnNlbiBVSV0nO1xuXG51dGlsLmdsb2JhbHMgPSB7XG4gIGZhYk9mZnNldDogMCxcbiAgZXJyb3JQcmVmaXgsXG4gIHN1cHBvcnRzUGFzc2l2ZTogZmFsc2Vcbn07XG5cbnBsYXRmb3JtLl9ydW5PbkFjdHVhbFBsYXRmb3JtKCgpID0+IHtcbiAgdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID0gcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKTtcbiAgdXRpbC5nbG9iYWxzLmlzVUlXZWJWaWV3ID0gcGxhdGZvcm0uaXNVSVdlYlZpZXcoKTtcbiAgdXRpbC5nbG9iYWxzLmlzV0tXZWJWaWV3ID0gcGxhdGZvcm0uaXNXS1dlYlZpZXcoKTtcbn0pO1xuXG50cnkge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICBnZXQoKSB7IHV0aWwuZ2xvYmFscy5zdXBwb3J0c1Bhc3NpdmUgPSB0cnVlOyB9XG4gIH0pO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3RQYXNzaXZlJywgbnVsbCwgb3B0cyk7XG59IGNhdGNoIChlKSB7IG51bGw7IH1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgRXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdF0gRXZlbnQgb3B0aW9ucyAocGFzc2l2ZSwgY2FwdHVyZS4uLilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzR0RdIElmIGNvbWVzIGZyb20gR2VzdHVyZURldGVjdG9yLiBKdXN0IGZvciB0ZXN0aW5nLlxuICovXG51dGlsLmFkZEV2ZW50TGlzdGVuZXIgPSAoZWwsIG5hbWUsIGhhbmRsZXIsIG9wdCwgaXNHRCkgPT4ge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHV0aWwuZ2xvYmFscy5zdXBwb3J0c1Bhc3NpdmUgPyBvcHQgOiAob3B0IHx8IHt9KS5jYXB0dXJlKTtcbn07XG51dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSAoZWwsIG5hbWUsIGhhbmRsZXIsIG9wdCwgaXNHRCkgPT4ge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHV0aWwuZ2xvYmFscy5zdXBwb3J0c1Bhc3NpdmUgPyBvcHQgOiAob3B0IHx8IHt9KS5jYXB0dXJlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnV0aWwucHJlcGFyZVF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XG4gIHJldHVybiBxdWVyeSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcXVlcnkgOiAoZWxlbWVudCkgPT4gdXRpbC5tYXRjaChlbGVtZW50LCBxdWVyeSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZVxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHMgQ1NTIFNlbGVjdG9yLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5tYXRjaCA9IChlLCBzKSA9PiAoZS5tYXRjaGVzIHx8IGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGUubXNNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZSwgcyk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRDaGlsZCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICAvLyBDYXV0aW9uOiBgZWxlbWVudC5jaGlsZHJlbmAgaXMgYHVuZGVmaW5lZGAgaW4gc29tZSBlbnZpcm9ubWVudHMgaWYgYGVsZW1lbnRgIGlzIGBzdmdgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHsgLy8gcHJvY2VzcyBvbmx5IGVsZW1lbnQgbm9kZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2gobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRQYXJlbnQgPSAoZWxlbWVudCwgcXVlcnksIHVudGlsKSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IGRvY3VtZW50IHx8IHBhcmVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgfHwgKHVudGlsICYmIHVudGlsKHBhcmVudCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG1hdGNoKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc0F0dGFjaGVkID0gZWxlbWVudCA9PiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsZW1lbnQpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCA9IChlbGVtZW50KSA9PiB7XG4gIHdoaWxlIChlbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC8ob25zLW5hdmlnYXRvcnxvbnMtdGFiYmFyfG9ucy1tb2RhbCkvKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG51dGlsLmdldEFsbENoaWxkTm9kZXMgPSAoZWxlbWVudCkgPT4ge1xuICByZXR1cm4gW2VsZW1lbnRdLmNvbmNhdChcbiAgICAuLi5BcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLm1hcChjaGlsZEVsID0+IHtcbiAgICAgIHJldHVybiB1dGlsLmdldEFsbENoaWxkTm9kZXMoY2hpbGRFbCk7XG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNQYWdlQ29udHJvbCA9IGVsZW1lbnQgPT4gZWxlbWVudC5ub2RlTmFtZS5tYXRjaCgvXm9ucy0obmF2aWdhdG9yfHNwbGl0dGVyfHRhYmJhcnxwYWdlKSQvaSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIHRvIHByb3BhZ2F0ZVxuICovXG51dGlsLnByb3BhZ2F0ZUFjdGlvbiA9IChlbGVtZW50LCBhY3Rpb24pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICBpZiAoY2hpbGRbYWN0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjaGlsZFthY3Rpb25dKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKGNoaWxkLCBhY3Rpb24pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIGJlIGNhbWVsaXplZFxuICogQHJldHVybiB7U3RyaW5nfSBDYW1lbGl6ZWQgc3RyaW5nXG4gKi9cbnV0aWwuY2FtZWxpemUgPSBzdHJpbmcgPT4gc3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShbYS16XSkvZywgKG0sIGwpID0+IGwudG9VcHBlckNhc2UoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIHN0cmluZyB0byBiZSBoeXBoZW5hdGVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEh5cGhlbmF0ZWQgc3RyaW5nXG4gKi9cbnV0aWwuaHlwaGVuYXRlID0gc3RyaW5nID0+IHN0cmluZy5yZXBsYWNlKC8oW2EtekEtWl0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIHRhZyBhbmQgY2xhc3Mgb25seVxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9XG4gKi9cbnV0aWwuY3JlYXRlID0gKHNlbGVjdG9yID0gJycsIHN0eWxlID0ge30pID0+IHtcbiAgY29uc3QgY2xhc3NMaXN0ID0gc2VsZWN0b3Iuc3BsaXQoJy4nKTtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2xhc3NMaXN0LnNoaWZ0KCkgfHwgJ2RpdicpO1xuXG4gIGlmIChjbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc0xpc3Quam9pbignICcpO1xuICB9XG5cbiAgc3R5bGVyKGVsZW1lbnQsIHN0eWxlKTtcblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnV0aWwuY3JlYXRlRWxlbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICBpZiAoaHRtbCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmltcG9ydE5vZGUoaHRtbCwgdHJ1ZSkpO1xuICB9IGVsc2Uge1xuICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gaHRtbC50cmltKCk7XG4gIH1cblxuICBpZiAod3JhcHBlci5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgdXRpbC50aHJvdygnSFRNTCB0ZW1wbGF0ZSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgcm9vdCBlbGVtZW50JylcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnQgPSB3cmFwcGVyLmNoaWxkcmVuWzBdO1xuICB3cmFwcGVyLmNoaWxkcmVuWzBdLnJlbW92ZSgpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxGcmFnbWVudH1cbiAqL1xudXRpbC5jcmVhdGVGcmFnbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGUuY29udGVudCwgdHJ1ZSk7XG59O1xuXG4vKlxuICogQHBhcmFtIHtPYmplY3R9IGRzdCBEZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc3JjIFNvdXJjZSBvYmplY3QocykuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZWZlcmVuY2UgdG8gYGRzdGAuXG4gKi9cbnV0aWwuZXh0ZW5kID0gKGRzdCwgLi4uYXJncykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJnc1tpXSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZ3NbaV0pO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbal07XG4gICAgICAgIGRzdFtrZXldID0gYXJnc1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG51dGlsLmFycmF5RnJvbSA9IChhcnJheUxpa2UpID0+IHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheUxpa2UpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtmYWlsU2FmZV1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudXRpbC5wYXJzZUpTT05PYmplY3RTYWZlbHkgPSAoanNvblN0cmluZywgZmFpbFNhZmUgPSB7fSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoJycgKyBqc29uU3RyaW5nKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWlsU2FmZTtcbiAgfVxuICByZXR1cm4gZmFpbFNhZmU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gcGF0aCBzdWNoIGFzICdteUFwcC5jb250cm9sbGVycy5kYXRhLmxvYWREYXRhJ1xuICogQHJldHVybiB7QW55fSAtIHdoYXRldmVyIGlzIGxvY2F0ZWQgYXQgdGhhdCBwYXRoXG4gKi9cbnV0aWwuZmluZEZyb21QYXRoID0gKHBhdGgpID0+IHtcbiAgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgdmFyIGVsID0gd2luZG93LCBrZXk7XG4gIHdoaWxlIChrZXkgPSBwYXRoLnNoaWZ0KCkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgIGVsID0gZWxba2V5XTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIFBhZ2Ugb3IgcGFnZS1jb250YWluZXIgdGhhdCBpbXBsZW1lbnRzICd0b3BQYWdlJ1xuICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gLSBWaXNpYmxlIHBhZ2UgZWxlbWVudCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAqL1xudXRpbC5nZXRUb3BQYWdlID0gY29udGFpbmVyID0+IGNvbnRhaW5lciAmJiAoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1wYWdlJyA/IGNvbnRhaW5lciA6IGNvbnRhaW5lci50b3BQYWdlKSB8fCBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIEVsZW1lbnQgd2hlcmUgdGhlIHNlYXJjaCBiZWdpbnNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IC0gUGFnZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHZpc2libGUgdG9vbGJhciBvciBudWxsLlxuICovXG51dGlsLmZpbmRUb29sYmFyUGFnZSA9IGNvbnRhaW5lciA9PiB7XG4gIGNvbnN0IHBhZ2UgPSB1dGlsLmdldFRvcFBhZ2UoY29udGFpbmVyKTtcblxuICBpZiAocGFnZSkge1xuICAgIGlmIChwYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpKSB7XG4gICAgICByZXR1cm4gcGFnZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2UuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuZXh0UGFnZSA9IHV0aWwuZ2V0VG9wUGFnZShwYWdlLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXSk7XG4gICAgICBpZiAobmV4dFBhZ2UgJiYgIS9vbnMtdGFiYmFyL2kudGVzdChwYWdlLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbltpXS50YWdOYW1lKSkge1xuICAgICAgICByZXR1cm4gdXRpbC5maW5kVG9vbGJhclBhZ2UobmV4dFBhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZGV0YWlsXVxuICogQHJldHVybiB7Q3VzdG9tRXZlbnR9XG4gKi9cbnV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCA9ICh0YXJnZXQsIGV2ZW50TmFtZSwgZGV0YWlsID0ge30pID0+IHtcblxuICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZGV0YWlsKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZXZlbnRba2V5XSA9IGRldGFpbFtrZXldO1xuICB9KTtcblxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgcmV0dXJuIGV2ZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5oYXNNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSkgPT4ge1xuICBpZiAoIXRhcmdldC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gUmVnRXhwKGAoXnxcXFxccyspJHttb2RpZmllck5hbWV9KCR8XFxcXHMrKWAsICdpJykudGVzdCh0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF1dG9TdHlsZSBNYXBzIHRoZSBtb2RpZmllck5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGVkIG1vZGlmaWVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUgSWdub3JlcyBwbGF0Zm9ybSBsaW1pdGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgYWRkZWQgb3Igbm90LlxuICovXG51dGlsLmFkZE1vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKG9wdGlvbnMuYXV0b1N0eWxlKSB7XG4gICAgbW9kaWZpZXJOYW1lID0gYXV0b1N0eWxlLm1hcE1vZGlmaWVyKG1vZGlmaWVyTmFtZSwgdGFyZ2V0LCBvcHRpb25zLmZvcmNlQXV0b1N0eWxlKTtcbiAgfVxuXG4gIGlmICh1dGlsLmhhc01vZGlmaWVyKHRhcmdldCwgbW9kaWZpZXJOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgKCh0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnKSArICcgJyArIG1vZGlmaWVyTmFtZSkudHJpbSgpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hdXRvU3R5bGUgTWFwcyB0aGUgbW9kaWZpZXJOYW1lIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlZCBtb2RpZmllci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmZvcmNlQXV0b1N0eWxlIElnbm9yZXMgcGxhdGZvcm0gbGltaXRhdGlvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cbiAqL1xudXRpbC5yZW1vdmVNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChvcHRpb25zLmF1dG9TdHlsZSkge1xuICAgIG1vZGlmaWVyTmFtZSA9IGF1dG9TdHlsZS5tYXBNb2RpZmllcihtb2RpZmllck5hbWUsIHRhcmdldCwgb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSk7XG4gIH1cblxuICBpZiAoIXRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgIXV0aWwuaGFzTW9kaWZpZXIodGFyZ2V0LCBtb2RpZmllck5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbmV3TW9kaWZpZXJzID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKS5zcGxpdCgvXFxzKy8pLmZpbHRlcihtID0+IG0gJiYgbSAhPT0gbW9kaWZpZXJOYW1lKTtcbiAgbmV3TW9kaWZpZXJzLmxlbmd0aCA/IHRhcmdldC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXJzLmpvaW4oJyAnKSkgOiB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKCdtb2RpZmllcicpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5mb3JjZSBGb3JjZXMgbW9kaWZpZXIgdG8gYmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF1dG9TdHlsZSBNYXBzIHRoZSBtb2RpZmllck5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGVkIG1vZGlmaWVyLlxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZvcmNlQXV0b1N0eWxlIElnbm9yZXMgcGxhdGZvcm0gbGltaXRhdGlvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGZvdW5kIG9yIG5vdC5cbiAqL1xudXRpbC50b2dnbGVNb2RpZmllciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcmdzLmxlbmd0aCA+IDIgPyBhcmdzWzJdIDoge307XG4gIGNvbnN0IGZvcmNlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zLmZvcmNlO1xuXG4gIGNvbnN0IHRvZ2dsZSA9IHR5cGVvZiBmb3JjZSA9PT0gJ2Jvb2xlYW4nID8gZm9yY2UgOiAhdXRpbC5oYXNNb2RpZmllciguLi5hcmdzKTtcbiAgdG9nZ2xlID8gdXRpbC5hZGRNb2RpZmllciguLi5hcmdzKSA6IHV0aWwucmVtb3ZlTW9kaWZpZXIoLi4uYXJncylcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRDbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICovXG51dGlsLnJlc3RvcmVDbGFzcyA9IChlbCwgZGVmYXVsdENsYXNzLCBzY2hlbWUpID0+IHtcbiAgZGVmYXVsdENsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgIT09ICcnICYmICFlbC5jbGFzc0xpc3QuY29udGFpbnMoYykgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gIGVsLmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSAmJiBNb2RpZmllclV0aWwucmVmcmVzaChlbCwgc2NoZW1lKTtcbn1cblxuLy8gVE9ETzogRklYXG51dGlsLnVwZGF0ZVBhcmVudFBvc2l0aW9uID0gKGVsKSA9PiB7XG4gIGlmICghZWwuX3BhcmVudFVwZGF0ZWQgJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbC5wYXJlbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgZWwucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGVsLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgfVxufTtcblxudXRpbC50b2dnbGVBdHRyaWJ1dGUgPSAoZWxlbWVudCwgbmFtZSwgdmFsdWUpID0+IHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgPyAnJyA6IHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufTtcblxudXRpbC5iaW5kTGlzdGVuZXJzID0gKGVsZW1lbnQsIGxpc3RlbmVyTmFtZXMpID0+IHtcbiAgbGlzdGVuZXJOYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IGJvdW5kTmFtZSA9IG5hbWUucmVwbGFjZSgvXl9bYS16XS8sICdfYm91bmQnICsgbmFtZVsxXS50b1VwcGVyQ2FzZSgpKTtcbiAgICBlbGVtZW50W2JvdW5kTmFtZV0gPSBlbGVtZW50W2JvdW5kTmFtZV0gfHwgZWxlbWVudFtuYW1lXS5iaW5kKGVsZW1lbnQpO1xuICB9KTtcbn07XG5cbnV0aWwuZWFjaCA9IChvYmosIGYpID0+IE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4gZihrZXksIG9ialtrZXldKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtib29sZWFufSBoYXNSaXBwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xuICovXG51dGlsLnVwZGF0ZVJpcHBsZSA9ICh0YXJnZXQsIGhhc1JpcHBsZSwgYXR0cnMgPSB7fSkgPT4ge1xuICBpZiAoaGFzUmlwcGxlID09PSB1bmRlZmluZWQpIHtcbiAgICBoYXNSaXBwbGUgPSB0YXJnZXQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKTtcbiAgfVxuXG4gIGNvbnN0IHJpcHBsZUVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0YXJnZXQsICdvbnMtcmlwcGxlJyk7XG5cbiAgaWYgKGhhc1JpcHBsZSkge1xuICAgIGlmICghcmlwcGxlRWxlbWVudCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy1yaXBwbGUnKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGtleSA9PiBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pKTtcbiAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyaXBwbGVFbGVtZW50KSB7XG4gICAgcmlwcGxlRWxlbWVudC5yZW1vdmUoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ31cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UgPSBhbmltYXRpb25PcHRpb25zUGFyc2U7XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG51dGlsLmlzSW50ZWdlciA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgIGlzRmluaXRlKHZhbHVlKSAmJlxuICAgIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7T2JqZWN0fSBEZWZlcnJlZCBwcm9taXNlLlxuICovXG51dGlsLmRlZmVyID0gKCkgPT4ge1xuICBjb25zdCBkZWZlcnJlZCA9IHt9O1xuICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gIHJldHVybiBkZWZlcnJlZDtcbn07XG5cbi8qKlxuICogU2hvdyB3YXJuaW5ncyB3aGVuIHRoZXkgYXJlIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHsqfSBhcmd1bWVudHMgdG8gY29uc29sZS53YXJuXG4gKi9cbnV0aWwud2FybiA9ICguLi5hcmdzKSA9PiB7XG4gIGlmICghaW50ZXJuYWwuY29uZmlnLndhcm5pbmdzRGlzYWJsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyb3JQcmVmaXgsIC4uLmFyZ3MpO1xuICB9XG59O1xuXG51dGlsLnRocm93ID0gKG1lc3NhZ2UpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yUHJlZml4fSAke21lc3NhZ2V9YCk7XG59O1xuXG51dGlsLnRocm93QWJzdHJhY3QgPSAoKSA9PiB1dGlsLnRocm93KCdDYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MnKTtcbnV0aWwudGhyb3dNZW1iZXIgPSAoKSA9PiB1dGlsLnRocm93KCdDbGFzcyBtZW1iZXIgbXVzdCBiZSBpbXBsZW1lbnRlZCcpO1xudXRpbC50aHJvd1BhZ2VMb2FkZXIgPSAoKSA9PiB1dGlsLnRocm93KCdGaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIFBhZ2VMb2FkZXInKTtcbnV0aWwudGhyb3dBbmltYXRvciA9IChlbCkgPT4gdXRpbC50aHJvdyhgXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCAke2VsfUFuaW1hdG9yYCk7XG5cblxuY29uc3QgcHJldmVudCA9IGUgPT4gZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKTtcblxuLyoqXG4gKiBQcmV2ZW50IHNjcm9sbGluZyB3aGlsZSBkcmFnaW5nIGhvcml6b250YWxseSBvbiBpT1MuXG4gKlxuICogQHBhcmFtIHtnZH0gR2VzdHVyZURldGVjdG9yIGluc3RhbmNlXG4gKi9cbnV0aWwuaW9zUHJldmVudFNjcm9sbCA9IGdkID0+IHtcbiAgaWYgKHV0aWwuZ2xvYmFscy5hY3R1YWxNb2JpbGVPUyA9PT0gJ2lvcycpIHtcbiAgICBjb25zdCBjbGVhbiA9IChlKSA9PiB7XG4gICAgICBnZC5vZmYoJ3RvdWNobW92ZScsIHByZXZlbnQpO1xuICAgICAgZ2Qub2ZmKCdkcmFnZW5kJywgY2xlYW4pO1xuICAgIH07XG5cbiAgICBnZC5vbigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgZ2Qub24oJ2RyYWdlbmQnLCBjbGVhbik7XG4gIH1cbn07XG5cbi8qKlxuICogUHJldmVudHMgc2Nyb2xsIGluIHVuZGVybHlpbmcgcGFnZXMgb24gaU9TLiBTZWUgIzIyMjAgIzIyNzQgIzE5NDlcbiAqXG4gKiBAcGFyYW0ge2VsfSBIVE1MRWxlbWVudCB0aGF0IHByZXZlbnRzIHRoZSBldmVudHNcbiAqIEBwYXJhbSB7YWRkfSBCb29sZWFuIEFkZCBvciByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnV0aWwuaW9zUGFnZVNjcm9sbEZpeCA9IChhZGQpID0+IHsgLy8gRnVsbCBmaXggLSBNYXkgY2F1c2UgaXNzdWVzIHdpdGggVUlXZWJWaWV3J3MgbW9tZW50dW0gc2Nyb2xsXG4gIGlmICh1dGlsLmdsb2JhbHMuYWN0dWFsTW9iaWxlT1MgPT09ICdpb3MnKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QudG9nZ2xlKCdvbnMtaW9zLXNjcm9sbCcsIGFkZCk7IC8vIEFsbG93cyBjdXN0b20gYW5kIGxvY2FsaXplZCBmaXhlcyAoIzIyNzQpXG4gICAgaWYgKCF1dGlsLmdsb2JhbHMuaXNVSVdlYlZpZXcgfHwgaW50ZXJuYWwuY29uZmlnLmZvcmNlVUlXZWJWaWV3U2Nyb2xsRml4KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1pb3Mtc2Nyb2xsLWZpeCcsIGFkZCk7XG4gICAgfVxuICB9XG59O1xudXRpbC5pb3NNYXNrU2Nyb2xsRml4ID0gKGVsLCBhZGQpID0+IHsgLy8gSGFsZiBmaXggLSBvbmx5IHByZXZlbnRzIHNjcm9sbCBvbiBtYXNrc1xuICBpZiAodXRpbC5nbG9iYWxzLmlzVUlXZWJWaWV3KSB7XG4gICAgY29uc3QgYWN0aW9uID0gKGFkZCA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0V2ZW50TGlzdGVuZXInO1xuICAgIGVsW2FjdGlvbl0oJ3RvdWNobW92ZScsIHByZXZlbnQsIGZhbHNlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEaXN0YW5jZSBhbmQgZGVsdGFUaW1lIGZpbHRlciBzb21lIHdlaXJkIGRyYWdzdGFydCBldmVudHMgdGhhdCBhcmUgbm90IGZpcmVkIGltbWVkaWF0ZWx5LlxuICpcbiAqIEBwYXJhbSB7ZXZlbnR9XG4gKi9cbnV0aWwuaXNWYWxpZEdlc3R1cmUgPSBldmVudCA9PiBldmVudC5nZXN0dXJlICE9PSB1bmRlZmluZWQgJiYgKGV2ZW50Lmdlc3R1cmUuZGlzdGFuY2UgPD0gMTUgfHwgZXZlbnQuZ2VzdHVyZS5kZWx0YVRpbWUgPD0gMTAwKTtcblxudXRpbC5jaGVja01pc3NpbmdJbXBvcnQgPSAoLi4uZWxlbWVudE5hbWVzKSA9PiB7XG4gIGVsZW1lbnROYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGlmICghb25zRWxlbWVudHNbbmFtZV0pIHtcbiAgICAgIHV0aWwudGhyb3coYE9ucyR7bmFtZX0gaXMgcmVxdWlyZWQgYnV0IHdhcyBub3QgaW1wb3J0ZWQgKEN1c3RvbSBFbGVtZW50cylgKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1dGlsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuXG4vKipcbiAqIE1pbmltYWwgYW5pbWF0aW9uIGxpYnJhcnkgZm9yIG1hbmFnaW5nIGNzcyB0cmFuc2l0aW9uIG9uIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVElNRU9VVF9SQVRJTyA9IDEuNDtcblxudmFyIHV0aWwgPSB7XG59O1xuXG4vLyBjYXBpdGFsaXplIHN0cmluZ1xudXRpbC5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvcGVydHlcbiAqIEBwYXJhbSB7RmxvYXR9IHBhcmFtcy5kdXJhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy50aW1pbmdcbiAqL1xudXRpbC5idWlsZFRyYW5zaXRpb25WYWx1ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBwYXJhbXMucHJvcGVydHkgPSBwYXJhbXMucHJvcGVydHkgfHwgJ2FsbCc7XG4gIHBhcmFtcy5kdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbiB8fCAwLjQ7XG4gIHBhcmFtcy50aW1pbmcgPSBwYXJhbXMudGltaW5nIHx8ICdsaW5lYXInO1xuXG4gIHZhciBwcm9wcyA9IHBhcmFtcy5wcm9wZXJ0eS5zcGxpdCgvICsvKTtcblxuICByZXR1cm4gcHJvcHMubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCArICcgJyArIHBhcmFtcy5kdXJhdGlvbiArICdzICcgKyBwYXJhbXMudGltaW5nO1xuICB9KS5qb2luKCcsICcpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgaGFuZGxlciBvbiBcInRyYW5zaXRpb25lbmRcIiBldmVudC5cbiAqL1xudXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gIH1cblxuICB2YXIgZm4gPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChlbGVtZW50ID09IGV2ZW50LnRhcmdldCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZW1vdmVMaXN0ZW5lcnM7XG59O1xuXG51dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gIGlmICgnb250cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICByZXR1cm4gWyd0cmFuc2l0aW9uZW5kJ107XG4gIH1cblxuICBpZiAoJ29ud2Via2l0dHJhbnNpdGlvbmVuZCcgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuIFsnd2Via2l0VHJhbnNpdGlvbkVuZCddO1xuICB9XG5cbiAgaWYgKHV0aWwudmVuZG9yUHJlZml4ID09PSAnd2Via2l0JyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ28nIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbW96JyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21zJykge1xuICAgIHJldHVybiBbdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG4gIH1cblxuICByZXR1cm4gW107XG59KSgpO1xuXG51dGlsLl9jc3NQcm9wZXJ0eURpY3QgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgdmFyIGRpY3QgPSB7fTtcbiAgdmFyIGEgPSAnQScuY2hhckNvZGVBdCgwKTtcbiAgdmFyIHogPSAneicuY2hhckNvZGVBdCgwKTtcblxuICB2YXIgdXBwZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHMuc3Vic3RyKDEpLnRvVXBwZXJDYXNlKCk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgIHZhciBrZXkgPSBzdHlsZXNbaV1cbiAgICAucmVwbGFjZSgvXlstXSsvLCAnJylcbiAgICAucmVwbGFjZSgvWy1dW2Etel0vZywgdXBwZXIpXG4gICAgLnJlcGxhY2UoL15tb3ovLCAnTW96Jyk7XG5cbiAgICBpZiAoYSA8PSBrZXkuY2hhckNvZGVBdCgwKSAmJiB6ID49IGtleS5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBpZiAoa2V5ICE9PSAnY3NzVGV4dCcgJiYga2V5ICE9PSAncGFyZW50VGV4dCcpIHtcbiAgICAgICAgZGljdFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGljdDtcbn0pKCk7XG5cbnV0aWwuaGFzQ3NzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBuYW1lIGluIHV0aWwuX2Nzc1Byb3BlcnR5RGljdDtcbn07XG5cbi8qKlxuICogVmVuZG9yIHByZWZpeCBmb3IgY3NzIHByb3BlcnR5LlxuICovXG51dGlsLnZlbmRvclByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpLFxuICAgIHByZSA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5jYWxsKHN0eWxlcylcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgICApWzFdO1xuICAgIHJldHVybiBwcmU7XG59KSgpO1xuXG51dGlsLmZvcmNlTGF5b3V0QXRPbmNlID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKSB7XG4gIHRoaXMuYmF0Y2hJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAvLyBmb3JjZSBsYXlvdXRcbiAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH0pO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcblxudXRpbC5iYXRjaEltbWVkaWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xufSkoKTtcblxudXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgdmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xufSkoKTtcblxudXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSgndHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICByZXR1cm4gJ3RyYW5zaXRpb24nO1xuICB9XG5cbiAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkodXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICByZXR1cm4gdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbic7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbnZhciBBbmltaXQgPSBmdW5jdGlvbihlbGVtZW50LCBkZWZhdWx0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQW5pbWl0KSkge1xuICAgIHJldHVybiBuZXcgQW5pbWl0KGVsZW1lbnQsIGRlZmF1bHRzKTtcbiAgfVxuXG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gW2VsZW1lbnRdO1xuICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50O1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5IG9yIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50LicpO1xuICB9XG5cbiAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICB0aGlzLnRyYW5zaXRpb25RdWV1ZSA9IFtdO1xuICB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3QgPSBbXTtcbn07XG5cbkFuaW1pdC5wcm90b3R5cGUgPSB7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXl9XG4gICAqL1xuICB0cmFuc2l0aW9uUXVldWU6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICovXG4gIGVsZW1lbnRzOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fVxuICAgKi9cbiAgZGVmYXVsdHM6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlIHdpdGggcGFzc2VkIGFuaW1hdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwbGF5OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW9zdCBvZiB0aGUgYW5pbWF0aW9ucyBmb2xsb3cgdGhpcyBkZWZhdWx0IHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnJvbX0gY3NzIG9yIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgY3NzXG4gICAqIEBwYXJhbSB7dG99IGNzcyBvciBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIGNzc1xuICAgKiBAcGFyYW0ge2RlbGF5fSBkZWxheSB0byB3YWl0XG4gICAqL1xuICBkZWZhdWx0OiBmdW5jdGlvbihmcm9tLCB0bywgZGVsYXkpIHtcbiAgICBmdW5jdGlvbiBzdGVwKHBhcmFtcywgZHVyYXRpb24sIHRpbWluZykge1xuICAgICAgaWYgKHBhcmFtcy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy50aW1pbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1pbmcgPSBwYXJhbXMudGltaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjc3M6IHBhcmFtcy5jc3MgfHwgcGFyYW1zLFxuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGltaW5nXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoc3RlcChmcm9tLCAwLCB0aGlzLmRlZmF1bHRzLnRpbWluZykpXG4gICAgICAud2FpdChkZWxheSA9PT0gdW5kZWZpbmVkID8gdGhpcy5kZWZhdWx0cy5kZWxheSA6IGRlbGF5KVxuICAgICAgLnF1ZXVlKHN0ZXAodG8sIHRoaXMuZGVmYXVsdHMuZHVyYXRpb24sIHRoaXMuZGVmYXVsdHMudGltaW5nKSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zIG9yIG90aGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9KVxuICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9LCB7ZHVyYXRpb246IDAuNH0pXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2Nzczoge2NvbG9yOiAncmVkJ30sIGR1cmF0aW9uOiAwLjJ9KVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxBbmltaXQuVHJhbnNpdGlvbnxGdW5jdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBxdWV1ZTogZnVuY3Rpb24odHJhbnNpdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMudHJhbnNpdGlvblF1ZXVlO1xuXG4gICAgaWYgKHRyYW5zaXRpb24gJiYgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5jc3MgPSB0cmFuc2l0aW9uO1xuICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbihvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSkge1xuICAgICAgaWYgKHRyYW5zaXRpb24uY3NzKSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHtcbiAgICAgICAgICBjc3M6IHRyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBbmltaXQuVHJhbnNpdGlvbikge1xuICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uLmJ1aWxkKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtGbG9hdH0gc2Vjb25kc1xuICAgKi9cbiAgd2FpdDogZnVuY3Rpb24oc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzID4gMCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCAqIHNlY29uZHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBjc3MgPSB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gZWxlbWVudC5zdHlsZVtlbGVtZW50LnN0eWxlW2ldXTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgZWxlbWVudCdzIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNpdGlvbl1cbiAgICovXG4gIHJlc3RvcmVTdHlsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmR1cmF0aW9uXCIgaXMgcmVxdWlyZWQgd2hlbiBcIm9wdGlvbnMudHJhbnNpdGlvblwiIGlzIGVuYWJsZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiB8fCAob3B0aW9ucy5kdXJhdGlvbiAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSBvcHRpb25zLnRyYW5zaXRpb24gfHwgKCdhbGwgJyArIG9wdGlvbnMuZHVyYXRpb24gKyAncyAnICsgKG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInKSk7XG5cbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgIHZhciBjbGVhclRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gJyc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmb3IgZmFpbCBzYWZlLlxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIGNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDAgKiBUSU1FT1VUX1JBVElPKTtcblxuICAgICAgICAvLyB0cmFuc2l0aW9uIGFuZCBzdHlsZSBzZXR0aW5nc1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cbiAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XG4gICAgICAgICAgICBpZiAoY3NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3NzW25hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB0cmFuc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIC8vIENsZWFyIHRyYW5zaXRpb24gYW5pbWF0aW9uIHNldHRpbmdzLlxuICAgICAgc2VsZi5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gJ25vbmUnO1xuXG4gICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXN0b3JlU3R5bGUoKTogVGhlIHN0eWxlIGlzIG5vdCBzYXZlZC4gSW52b2tlIHNhdmVTdHlsZSgpIGJlZm9yZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5hbWUgPSAnJzsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlLlxuICAgKi9cbiAgc3RhcnRBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfZGVxdWV1ZVRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uUXVldWUuc2hpZnQoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zaXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCB0cmFuc2l0aW9uIGV4aXN0cy4nKTtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fY3VycmVudFRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGYuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHR3aWNlLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdHJhbnNpdGlvbi5jYWxsKHRoaXMsIGRvbmUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QW5pbWl0fSBhcmd1bWVudHNcbiAqL1xuQW5pbWl0LnJ1bkFsbCA9IGZ1bmN0aW9uKC8qIGFyZ3VtZW50cy4uLiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXS5wbGF5KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvcGVydHldXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICovXG5BbmltaXQuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5vcHRpb25zLmR1cmF0aW9uID0gdGhpcy5vcHRpb25zLmR1cmF0aW9uIHx8IDA7XG4gIHRoaXMub3B0aW9ucy50aW1pbmcgPSB0aGlzLm9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICB0aGlzLm9wdGlvbnMuY3NzID0gdGhpcy5vcHRpb25zLmNzcyB8fCB7fTtcbiAgdGhpcy5vcHRpb25zLnByb3BlcnR5ID0gdGhpcy5vcHRpb25zLnByb3BlcnR5IHx8ICdhbGwnO1xufTtcblxuQW5pbWl0LlRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jc3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLmNzcyBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgY3NzID0gY3JlYXRlQWN0dWFsQ3NzUHJvcHModGhpcy5vcHRpb25zLmNzcyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uID4gMCkge1xuICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUodGhpcy5vcHRpb25zKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5vcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU87XG4gICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtuYW1lXSA9IGNzc1tuYW1lXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA8PSAwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSAnJztcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHV0aWwuZm9yY2VMYXlvdXRBdE9uY2UoZWxlbWVudHMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdHVhbENzc1Byb3BzKGNzcykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlZml4ZWQgPSB1dGlsLnZlbmRvclByZWZpeCArIHV0aWwuY2FwaXRhbGl6ZShuYW1lKTtcbiAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkocHJlZml4ZWQpKSB7XG4gICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1pdDtcblxuIiwiLypcbiAqIEdlc3R1cmUgZGV0ZWN0b3IgbGlicmFyeSB0aGF0IGZvcmtlZCBmcm9tIGdpdGh1Yi5jb20vRWlnaHRNZWRpYS9oYW1tZXIuanMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG52YXIgRXZlbnQsIFV0aWxzLCBEZXRlY3Rpb24sIFBvaW50ZXJFdmVudDtcblxuLyoqXG4gKiBAb2JqZWN0IG9ucy5HZXN0dXJlRGV0ZWN0b3JcbiAqIEBjYXRlZ29yeSBnZXN0dXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgY2xhc3MgZm9yIGdlc3R1cmUgZGV0ZWN0aW9uLlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgovjgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjgq/jg6njgrnjgafjgZnjgIJbL2phXVxuICovXG5cbi8qKlxuICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICogQHNpZ25hdHVyZSBjb25zdHJ1Y3RvcihlbGVtZW50Wywgb3B0aW9uc10pXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dQ3JlYXRlIGEgbmV3IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZS5bL2VuXVxuICogIFtqYV1HZXN0dXJlRGV0ZWN0b3Ljga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KLRE9N6KaB57Sg44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7b25zLkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cbiAqL1xudmFyIEdlc3R1cmVEZXRlY3RvciA9IGZ1bmN0aW9uIEdlc3R1cmVEZXRlY3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgR2VzdHVyZURldGVjdG9yLkluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMgfHwge30pO1xufTtcblxuXG4vKipcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gKiBtb3JlIHNldHRpbmdzIGFyZSBkZWZpbmVkIHBlciBnZXN0dXJlIGF0IGAvZ2VzdHVyZXNgLiBFYWNoIGdlc3R1cmUgY2FuIGJlIGRpc2FibGVkL2VuYWJsZWRcbiAqIGJ5IHNldHRpbmcgaXQncyBuYW1lIChsaWtlIGBzd2lwZWApIHRvIGZhbHNlLlxuICogWW91IGNhbiBzZXQgdGhlIGRlZmF1bHRzIGZvciBhbGwgaW5zdGFuY2VzIGJ5IGNoYW5naW5nIHRoaXMgb2JqZWN0IGJlZm9yZSBjcmVhdGluZyBhbiBpbnN0YW5jZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBgXG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmRyYWcgPSBmYWxzZTtcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudG91Y2hBY3Rpb24gPSAncGFuLXknO1xuICogIGRlbGV0ZSBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuYmVoYXZpb3IudXNlclNlbGVjdDtcbiAqIGBgYGBcbiAqIEBwcm9wZXJ0eSBkZWZhdWx0c1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzID0ge1xuICBiZWhhdmlvcjoge1xuICAgIC8vIHVzZXJTZWxlY3Q6ICdub25lJywgLy8gQWxzbyBkaXNhYmxlcyBzZWxlY3Rpb24gaW4gYGlucHV0YCBjaGlsZHJlblxuICAgIHRvdWNoQWN0aW9uOiAncGFuLXknLFxuICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuICAgIGNvbnRlbnRab29taW5nOiAnbm9uZScsXG4gICAgdXNlckRyYWc6ICdub25lJyxcbiAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gIH1cbn07XG5cbi8qKlxuICogR2VzdHVyZURldGVjdG9yIGRvY3VtZW50IHdoZXJlIHRoZSBiYXNlIGV2ZW50cyBhcmUgYWRkZWQgYXRcbiAqIEBwcm9wZXJ0eSBET0NVTUVOVFxuICogQHR5cGUge0hUTUxFbGVtZW50fVxuICogQGRlZmF1bHQgd2luZG93LmRvY3VtZW50XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCA9IGRvY3VtZW50O1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciBwb2ludGVyIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19QT0lOVEVSRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTID0gbmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuXG4vKipcbiAqIGRldGVjdCBzdXBwb3J0IGZvciB0b3VjaCBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfVE9VQ0hFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5cbi8qKlxuICogZGV0ZWN0IG1vYmlsZSBicm93c2Vyc1xuICogQHByb3BlcnR5IElTX01PQklMRVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUgPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIGRldGVjdCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgbW91c2VldmVudHMgYXQgYWxsXG4gKiBAcHJvcGVydHkgTk9fTU9VU0VFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMgPSAoR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyAmJiBHZXN0dXJlRGV0ZWN0b3IuSVNfTU9CSUxFKSB8fCBHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFM7XG5cbi8qKlxuICogaW50ZXJ2YWwgaW4gd2hpY2ggR2VzdHVyZURldGVjdG9yIHJlY2FsY3VsYXRlcyBjdXJyZW50IHZlbG9jaXR5L2RpcmVjdGlvbi9hbmdsZSBpbiBtc1xuICogQHByb3BlcnR5IENBTENVTEFURV9JTlRFUlZBTFxuICogQHR5cGUge051bWJlcn1cbiAqIEBkZWZhdWx0IDI1XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwgPSAyNTtcblxuLyoqXG4gKiBldmVudHR5cGVzIHBlciB0b3VjaGV2ZW50IChzdGFydCwgbW92ZSwgZW5kKSBhcmUgZmlsbGVkIGJ5IGBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzYCBvbiBgc2V0dXBgXG4gKiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gZXZlbnQgbmFtZXMgcGVyIHR5cGUgKGBFVkVOVF9TVEFSVGAsIGBFVkVOVF9NT1ZFYCwgYEVWRU5UX0VORGApXG4gKiBAcHJvcGVydHkgRVZFTlRfVFlQRVNcbiAqIEBwcml2YXRlXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7fTtcblxuLyoqXG4gKiBkaXJlY3Rpb24gc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBESVJFQ1RJT05fRE9XTnxMRUZUfFVQfFJJR0hUXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnZG93bicgJ2xlZnQnICd1cCcgJ3JpZ2h0J1xuICovXG52YXIgRElSRUNUSU9OX0RPV04gPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0RPV04gPSAnZG93bic7XG52YXIgRElSRUNUSU9OX0xFRlQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XG52YXIgRElSRUNUSU9OX1VQID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9VUCA9ICd1cCc7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5cbi8qKlxuICogcG9pbnRlcnR5cGUgc3RyaW5ncywgZm9yIHNhZmUgY29tcGFyaXNvbnNcbiAqIEBwcm9wZXJ0eSBQT0lOVEVSX01PVVNFfFRPVUNIfFBFTlxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ21vdXNlJyAndG91Y2gnICdwZW4nXG4gKi9cbnZhciBQT0lOVEVSX01PVVNFID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfTU9VU0UgPSAnbW91c2UnO1xudmFyIFBPSU5URVJfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG52YXIgUE9JTlRFUl9QRU4gPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuLyoqXG4gKiBldmVudHR5cGVzXG4gKiBAcHJvcGVydHkgRVZFTlRfU1RBUlR8TU9WRXxFTkR8UkVMRUFTRXxUT1VDSFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ3N0YXJ0JyAnY2hhbmdlJyAnbW92ZScgJ2VuZCcgJ3JlbGVhc2UnICd0b3VjaCdcbiAqL1xudmFyIEVWRU5UX1NUQVJUID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbnZhciBFVkVOVF9NT1ZFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX01PVkUgPSAnbW92ZSc7XG52YXIgRVZFTlRfRU5EID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX0VORCA9ICdlbmQnO1xudmFyIEVWRU5UX1JFTEVBU0UgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfUkVMRUFTRSA9ICdyZWxlYXNlJztcbnZhciBFVkVOVF9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9UT1VDSCA9ICd0b3VjaCc7XG5cbi8qKlxuICogaWYgdGhlIHdpbmRvdyBldmVudHMgYXJlIHNldC4uLlxuICogQHByb3BlcnR5IFJFQURZXG4gKiBAd3JpdGVPbmNlXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IGZhbHNlO1xuXG4vKipcbiAqIHBsdWdpbnMgbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgPSBHZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyB8fCB7fTtcblxuLyoqXG4gKiBnZXN0dXJlcyBuYW1lc3BhY2VcbiAqIHNlZSBgL2dlc3R1cmVzYCBmb3IgdGhlIGRlZmluaXRpb25zXG4gKiBAcHJvcGVydHkgZ2VzdHVyZXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyA9IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyB8fCB7fTtcblxuLyoqXG4gKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBjcmVhdGluZyBhbiBuZXcgaW5zdGFuY2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwKG9wdHMpIHtcbiAgaWYgKEdlc3R1cmVEZXRlY3Rvci5SRUFEWSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGZpbmQgd2hhdCBldmVudHR5cGVzIHdlIGFkZCBsaXN0ZW5lcnMgdG9cbiAgRXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlcygpO1xuXG4gIC8vIFJlZ2lzdGVyIGFsbCBnZXN0dXJlcyBpbnNpZGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzXG4gIFV0aWxzLmVhY2goR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLCBmdW5jdGlvbihnZXN0dXJlKSB7XG4gICAgRGV0ZWN0aW9uLnJlZ2lzdGVyKGdlc3R1cmUpO1xuICB9KTtcblxuICAvLyBBZGQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudFxuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfTU9WRSwgRGV0ZWN0aW9uLmRldGVjdCwgb3B0cyk7XG4gIEV2ZW50Lm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9FTkQsIERldGVjdGlvbi5kZXRlY3QsIG9wdHMpO1xuXG4gIC8vIEdlc3R1cmVEZXRlY3RvciBpcyByZWFkeS4uLiFcbiAgR2VzdHVyZURldGVjdG9yLlJFQURZID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBVdGlsc1xuICogQHN0YXRpY1xuICovXG5VdGlscyA9IEdlc3R1cmVEZXRlY3Rvci51dGlscyA9IHtcbiAgLyoqXG4gICAqIGV4dGVuZCBtZXRob2QsIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgY2xvbmluZyB3aGVuIGBkZXN0YCBpcyBhbiBlbXB0eSBvYmplY3QuXG4gICAqIGNoYW5nZXMgdGhlIGRlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdICBkbyBhIG1lcmdlXG4gICAqIEByZXR1cm4ge09iamVjdH0gZGVzdFxuICAgKi9cbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZGVzdFtrZXldID09PSB1bmRlZmluZWQgfHwgIW1lcmdlKSkge1xuICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBhZGRFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0KSB7XG4gICAgdXRpbC5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSByZW1vdmVFdmVudExpc3RlbmVyIHdyYXBwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHQpIHtcbiAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0LCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogZm9yRWFjaCBvdmVyIGFycmF5cyBhbmQgb2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEBwYXJhbSB7YW55fSBpdGVyYXRvci5pdGVtXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvci5pbmRleFxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gaXRlcmF0b3Iub2JqIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IHZhbHVlIHRvIHVzZSBhcyBgdGhpc2AgaW4gdGhlIGl0ZXJhdG9yXG4gICAqL1xuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgLy8gbmF0aXZlIGZvckVhY2ggb24gYXJyYXlzXG4gICAgaWYgKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIC8vIGFycmF5c1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gb2JqZWN0c1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkgJiZcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBzdHJpbmcgY29udGFpbnMgdGhlIHN0cmluZyB1c2luZyBpbmRleE9mXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAgICovXG4gIGluU3RyOiBmdW5jdGlvbiBpblN0cihzcmMsIGZpbmQpIHtcbiAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCkgPiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5ZmlsbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gICAqL1xuICBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZGVlcCkge1xuICAgIGlmIChkZWVwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3JjLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IC8vIEFycmF5LmZpbmRJbmRleFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmluZCkuZXZlcnkoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBzcmNbaV1ba2V5XSA9PT0gZmluZFtrZXldOyB9KSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKHNyYy5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzcmMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0IChgYXJndW1lbnRzYCwgYHRvdWNobGlzdGApIHRvIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBoYXNQYXJlbnQ6IGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgcGFnZVhgLCBgcGFnZVlgLCBgY2xpZW50WGAgYW5kIGBjbGllbnRZYCBwcm9wZXJ0aWVzXG4gICAqL1xuICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgdmFyIHBhZ2VYID0gW10sXG4gICAgICAgIHBhZ2VZID0gW10sXG4gICAgICAgIGNsaWVudFggPSBbXSxcbiAgICAgICAgY2xpZW50WSA9IFtdLFxuICAgICAgICBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXg7XG5cbiAgICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVg6IHRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgIHBhZ2VZOiB0b3VjaGVzWzBdLnBhZ2VZLFxuICAgICAgICBjbGllbnRYOiB0b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IHRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBVdGlscy5lYWNoKHRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICBwYWdlWC5wdXNoKHRvdWNoLnBhZ2VYKTtcbiAgICAgIHBhZ2VZLnB1c2godG91Y2gucGFnZVkpO1xuICAgICAgY2xpZW50WC5wdXNoKHRvdWNoLmNsaWVudFgpO1xuICAgICAgY2xpZW50WS5wdXNoKHRvdWNoLmNsaWVudFkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VYOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VYKSArIG1heC5hcHBseShNYXRoLCBwYWdlWCkpIC8gMixcbiAgICAgIHBhZ2VZOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VZKSArIG1heC5hcHBseShNYXRoLCBwYWdlWSkpIC8gMixcbiAgICAgIGNsaWVudFg6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WCkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WCkpIC8gMixcbiAgICAgIGNsaWVudFk6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WSkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WSkpIC8gMlxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cbiAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5hYnMoZGVsdGFYIC8gZGVsdGFUaW1lKSB8fCAwLFxuICAgICAgeTogTWF0aC5hYnMoZGVsdGFZIC8gZGVsdGFUaW1lKSB8fCAwXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICovXG4gIGdldEFuZ2xlOiBmdW5jdGlvbiBnZXRBbmdsZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGRvIGEgc21hbGwgY29tcGFyaXNvbiB0byBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byB0b3VjaGVzLlxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9MRUZUfFJJR0hUfFVQfERPV05gXG4gICAqL1xuICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbih0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXG4gICAgICAgIHkgPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZKTtcblxuICAgIGlmICh4ID49IHkpIHtcbiAgICAgIHJldHVybiB0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYID4gMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4gdG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9dG91Y2gxXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICBnZXREaXN0YW5jZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2UodG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgKi9cbiAgZ2V0U2NhbGU6IGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBuZWVkIHR3byBmaW5nZXJzLi4uXG4gICAgaWYgKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0pIC8gdGhpcy5nZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICBpZiAoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZShlbmRbMV0sIGVuZFswXSkgLSB0aGlzLmdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIG91dCBpZiB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9VUHxET1dOYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc192ZXJ0aWNhbFxuICAgKi9cbiAgaXNWZXJ0aWNhbDogZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCB8fCBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCBjc3MgcHJvcGVydGllcyB3aXRoIHRoZWlyIHByZWZpeGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2V0UHJlZml4ZWRDc3M6IGZ1bmN0aW9uIHNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpIHtcbiAgICB2YXIgcHJlZml4ZXMgPSBbJycsICdXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcbiAgICBwcm9wID0gVXRpbHMudG9DYW1lbENhc2UocHJvcCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHByb3A7XG4gICAgICAvLyBwcmVmaXhlc1xuICAgICAgaWYgKHByZWZpeGVzW2ldKSB7XG4gICAgICAgIHAgPSBwcmVmaXhlc1tpXSArIHAuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHAuc2xpY2UoMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRlc3QgdGhlIHN0eWxlXG4gICAgICBpZiAocCBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcF0gPSAodG9nZ2xlID09PSBudWxsIHx8IHRvZ2dsZSkgJiYgdmFsdWUgfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogdG9nZ2xlIGJyb3dzZXIgZGVmYXVsdCBiZWhhdmlvciBieSBzZXR0aW5nIGNzcyBwcm9wZXJ0aWVzLlxuICAgKiBgdXNlclNlbGVjdD0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbnNlbGVjdHN0YXJ0YCB0byBmYWxzZVxuICAgKiBgdXNlckRyYWc9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25kcmFnc3RhcnRgIHRvIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKi9cbiAgdG9nZ2xlQmVoYXZpb3I6IGZ1bmN0aW9uIHRvZ2dsZUJlaGF2aW9yKGVsZW1lbnQsIHByb3BzLCB0b2dnbGUpIHtcbiAgICBpZiAoIXByb3BzIHx8ICFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjc3MgcHJvcGVydGllc1xuICAgIFV0aWxzLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwcm9wKSB7XG4gICAgICBVdGlscy5zZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKTtcbiAgICB9KTtcblxuICAgIHZhciBmYWxzZUZuID0gdG9nZ2xlICYmIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBhbHNvIHRoZSBkaXNhYmxlIG9uc2VsZWN0c3RhcnRcbiAgICBpZiAocHJvcHMudXNlclNlbGVjdCA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgaWYgKHByb3BzLnVzZXJEcmFnID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbmRyYWdzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGEgc3RyaW5nIHdpdGggdW5kZXJzY29yZXMgdG8gY2FtZWxDYXNlXG4gICAqIHNvIHByZXZlbnRfZGVmYXVsdCBiZWNvbWVzIHByZXZlbnREZWZhdWx0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7U3RyaW5nfSBjYW1lbENhc2VTdHJcbiAgICovXG4gIHRvQ2FtZWxDYXNlOiBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tfLV0oW2Etel0pL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG4vKipcbiAqIEBjbGFzcyBFdmVudFxuICogQHN0YXRpY1xuICovXG5FdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ldmVudCA9IHtcbiAgLyoqXG4gICAqIHdoZW4gdG91Y2ggZXZlbnRzIGhhdmUgYmVlbiBmaXJlZCwgdGhpcyBpcyB0cnVlXG4gICAqIHRoaXMgaXMgdXNlZCB0byBzdG9wIG1vdXNlIGV2ZW50c1xuICAgKiBAcHJvcGVydHkgcHJldmVudF9tb3VzZWV2ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHByZXZlbnRNb3VzZUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIGlmIEVWRU5UX1NUQVJUIGhhcyBiZWVuIGZpcmVkXG4gICAqIEBwcm9wZXJ0eSBzdGFydGVkXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhcnRlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHdoZW4gdGhlIG1vdXNlIGlzIGhvbGQgZG93biwgdGhpcyBpcyB0cnVlXG4gICAqIEBwcm9wZXJ0eSBzaG91bGRfZGV0ZWN0XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkRGV0ZWN0OiBmYWxzZSxcblxuICAvKipcbiAgICogc2ltcGxlIGV2ZW50IGJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHQpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0KTtcbiAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogdGhlIGNvcmUgdG91Y2ggZXZlbnQgaGFuZGxlci5cbiAgICogdGhpcyBmaW5kcyBvdXQgaWYgd2Ugc2hvdWxkIHRvIGRldGVjdCBnZXN0dXJlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiBvblRvdWNoSGFuZGxlciB7RnVuY3Rpb259IHRoZSBjb3JlIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goZWxlbWVudCwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgb25Ub3VjaEhhbmRsZXIgPSBmdW5jdGlvbiBvblRvdWNoSGFuZGxlcihldikge1xuICAgICAgdmFyIHNyY1R5cGUgPSBldi50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgaXNQb2ludGVyID0gR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTLFxuICAgICAgICAgIGlzTW91c2UgPSBVdGlscy5pblN0cihzcmNUeXBlLCAnbW91c2UnKSxcbiAgICAgICAgICB0cmlnZ2VyVHlwZTtcblxuICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbW91c2VldmVudCwgYnV0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hldmVudCB0cmlnZ2VyZWQgaW4gdGhpcyBzZXNzaW9uXG4gICAgICAvLyB3ZSB3YW50IHRvIGRvIG5vdGhpbmcuIHNpbXBseSBicmVhayBvdXQgb2YgdGhlIGV2ZW50LlxuICAgICAgaWYgKGlzTW91c2UgJiYgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIG1vdXNlYnV0dG9uIG11c3QgYmUgZG93blxuICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gKGV2LmJ1dHRvbnMgPT09IDEgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1RPVUNILCBldikpO1xuICAgICAgICAvLyBqdXN0IGEgdmFsaWQgc3RhcnQgZXZlbnQsIGJ1dCBubyBtb3VzZVxuICAgICAgfSBlbHNlIGlmICghaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlciBldmVudCBiZWZvcmUgZW50ZXJpbmcgdGhlIGRldGVjdGlvblxuICAgICAgaWYgKGlzUG9pbnRlciAmJiBldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBhcmUgaW4gYSB0b3VjaC9kb3duIHN0YXRlLCBzbyBhbGxvd2VkIGRldGVjdGlvbiBvZiBnZXN0dXJlc1xuICAgICAgaWYgKHNlbGYuc2hvdWxkRGV0ZWN0KSB7XG4gICAgICAgIHRyaWdnZXJUeXBlID0gc2VsZi5kb0RldGVjdC5jYWxsKHNlbGYsIGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgIGlmICh0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgUG9pbnRlckV2ZW50LnJlc2V0KCk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlcmV2ZW50IG9iamVjdCBhZnRlciB0aGUgZGV0ZWN0aW9uXG4gICAgICB9XG5cbiAgICAgIGlmIChpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbihlbGVtZW50LCBFVkVOVF9UWVBFU1tldmVudFR5cGVdLCBvblRvdWNoSGFuZGxlciwgb3B0KTtcbiAgICByZXR1cm4gb25Ub3VjaEhhbmRsZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRoZSBjb3JlIGRldGVjdGlvbiBtZXRob2RcbiAgICogdGhpcyBmaW5kcyBvdXQgd2hhdCBHZXN0dXJlRGV0ZWN0b3ItdG91Y2gtZXZlbnRzIHRvIHRyaWdnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyaWdnZXJUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKi9cbiAgZG9EZXRlY3Q6IGZ1bmN0aW9uIGRvRGV0ZWN0KGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICB2YXIgdG91Y2hMaXN0ID0gdGhpcy5nZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSk7XG4gICAgdmFyIHRvdWNoTGlzdExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGg7XG4gICAgdmFyIHRyaWdnZXJUeXBlID0gZXZlbnRUeXBlO1xuICAgIHZhciB0cmlnZ2VyQ2hhbmdlID0gdG91Y2hMaXN0LnRyaWdnZXI7IC8vIHVzZWQgYnkgZmFrZU11bHRpdG91Y2ggcGx1Z2luXG4gICAgdmFyIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3RMZW5ndGg7XG5cbiAgICAvLyBhdCBlYWNoIHRvdWNoc3RhcnQtbGlrZSBldmVudCB3ZSB3YW50IGFsc28gd2FudCB0byB0cmlnZ2VyIGEgVE9VQ0ggZXZlbnQuLi5cbiAgICBpZiAoZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfVE9VQ0g7XG4gICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfUkVMRUFTRTtcblxuICAgICAgLy8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0b3VjaGVzIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0Lmxlbmd0aCAtICgoZXYuY2hhbmdlZFRvdWNoZXMpID8gZXYuY2hhbmdlZFRvdWNoZXMubGVuZ3RoIDogMSk7XG4gICAgfVxuXG4gICAgLy8gYWZ0ZXIgdGhlcmUgYXJlIHN0aWxsIHRvdWNoZXMgb24gdGhlIHNjcmVlbixcbiAgICAvLyB3ZSBqdXN0IHdhbnQgdG8gdHJpZ2dlciBhIE1PVkUgZXZlbnQuIHNvIGNoYW5nZSB0aGUgU1RBUlQgb3IgRU5EIHRvIGEgTU9WRVxuICAgIC8vIGJ1dCBvbmx5IGFmdGVyIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB0aGUgZmlyc3QgdGltZSB3ZSBhY3R1YWxseSB3YW50IGEgU1RBUlRcbiAgICBpZiAoY2hhbmdlZExlbmd0aCA+IDAgJiYgdGhpcy5zdGFydGVkKSB7XG4gICAgICB0cmlnZ2VyVHlwZSA9IEVWRU5UX01PVkU7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhpcywgc2VlIGFib3ZlXG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgIC8vIGdlbmVyYXRlIHNvbWUgZXZlbnQgZGF0YSwgc29tZSBiYXNpYyBpbmZvcm1hdGlvblxuICAgIHZhciBldkRhdGEgPSB0aGlzLmNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgdHJpZ2dlclR5cGUsIHRvdWNoTGlzdCwgZXYpO1xuXG4gICAgLy8gdHJpZ2dlciB0aGUgdHJpZ2dlclR5cGUgZXZlbnQgYmVmb3JlIHRoZSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudHNcbiAgICAvLyBidXQgdGhlIEVORCBldmVudCBzaG91bGQgYmUgYXQgbGFzdFxuICAgIGlmIChldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xuICAgICAgZXZEYXRhLmNoYW5nZWRMZW5ndGggPSBjaGFuZ2VkTGVuZ3RoO1xuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJDaGFuZ2U7XG5cbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG5cbiAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyVHlwZTtcbiAgICAgIGRlbGV0ZSBldkRhdGEuY2hhbmdlZExlbmd0aDtcbiAgICB9XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSBFTkQgZXZlbnRcbiAgICBpZiAodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cmlnZ2VyVHlwZTtcbiAgfSxcblxuICAvKipcbiAgICogd2UgaGF2ZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBlYWNoIGRldmljZS9icm93c2VyXG4gICAqIGRldGVybWluZSB3aGF0IHdlIG5lZWQgYW5kIHNldCB0aGVtIGluIHRoZSBFVkVOVF9UWVBFUyBjb25zdGFudFxuICAgKiB0aGUgYG9uVG91Y2hgIG1ldGhvZCBpcyBiaW5kIHRvIHRoZXNlIHByb3BlcnRpZXMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZlbnRzXG4gICAqL1xuICBkZXRlcm1pbmVFdmVudFR5cGVzOiBmdW5jdGlvbiBkZXRlcm1pbmVFdmVudFR5cGVzKCkge1xuICAgIHZhciB0eXBlcztcbiAgICBpZiAoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICB0eXBlcyA9IFtcbiAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICdwb2ludGVybW92ZScsXG4gICAgICAgICAgJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIGxvc3Rwb2ludGVyY2FwdHVyZSdcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAnTVNQb2ludGVyTW92ZScsXG4gICAgICAgICAgJ01TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCBNU0xvc3RQb2ludGVyQ2FwdHVyZSdcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUykge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCdcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCBtb3VzZWRvd24nLFxuICAgICAgICAndG91Y2htb3ZlIG1vdXNlbW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwJ1xuICAgICAgXTtcbiAgICB9XG5cbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9TVEFSVF0gPSB0eXBlc1swXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9NT1ZFXSA9IHR5cGVzWzFdO1xuICAgIEVWRU5UX1RZUEVTW0VWRU5UX0VORF0gPSB0eXBlc1syXTtcbiAgICByZXR1cm4gRVZFTlRfVFlQRVM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSB0b3VjaExpc3QgZGVwZW5kaW5nIG9uIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hlc1xuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSkge1xuICAgIC8vIGdldCB0aGUgZmFrZSBwb2ludGVyRXZlbnQgdG91Y2hsaXN0XG4gICAgaWYgKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudC5nZXRUb3VjaExpc3QoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHRvdWNobGlzdFxuICAgIGlmIChldi50b3VjaGVzKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09IEVWRU5UX01PVkUpIHtcbiAgICAgICAgcmV0dXJuIGV2LnRvdWNoZXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgdmFyIGNvbmNhdCA9IFtdLmNvbmNhdChVdGlscy50b0FycmF5KGV2LnRvdWNoZXMpLCBVdGlscy50b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSk7XG4gICAgICB2YXIgdG91Y2hMaXN0ID0gW107XG5cbiAgICAgIFV0aWxzLmVhY2goY29uY2F0LCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICBpZiAoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IC0xKSB7XG4gICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGZha2UgdG91Y2hMaXN0IGZyb20gbW91c2UgcG9zaXRpb25cbiAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICByZXR1cm4gW2V2XTtcbiAgfSxcblxuICAvKipcbiAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1RPVUNIO1xuICAgIGlmIChVdGlscy5pblN0cihldi50eXBlLCAnbW91c2UnKSB8fCBQb2ludGVyRXZlbnQubWF0Y2hUeXBlKFBPSU5URVJfTU9VU0UsIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX01PVVNFO1xuICAgIH0gZWxzZSBpZiAoUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1BFTiwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfUEVOO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXI6IFV0aWxzLmdldENlbnRlcih0b3VjaGVzKSxcbiAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQ6IGV2LFxuXG4gICAgICAvKipcbiAgICAgICAqIHByZXZlbnQgdGhlIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zXG4gICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IHRoaXMuc3JjRXZlbnQ7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24gJiYgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xuICAgICAgICovXG4gICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBpbW1lZGlhdGVseSBzdG9wIGdlc3R1cmUgZGV0ZWN0aW9uXG4gICAgICAgKiBtaWdodCBiZSB1c2VmdWwgYWZ0ZXIgYSBzd2lwZSB3YXMgZGV0ZWN0ZWRcbiAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgKi9cbiAgICAgIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRGV0ZWN0aW9uLnN0b3BEZXRlY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgUG9pbnRlckV2ZW50XG4gKiBAc3RhdGljXG4gKi9cblBvaW50ZXJFdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5Qb2ludGVyRXZlbnQgPSB7XG4gIC8qKlxuICAgKiBob2xkcyBhbGwgcG9pbnRlcnMsIGJ5IGBpZGVudGlmaWVyYFxuICAgKiBAcHJvcGVydHkgcG9pbnRlcnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBvaW50ZXJzOiB7fSxcblxuICAvKipcbiAgICogZ2V0IHRoZSBwb2ludGVycyBhcyBhbiBhcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hsaXN0XG4gICAqL1xuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdCgpIHtcbiAgICB2YXIgdG91Y2hsaXN0ID0gW107XG4gICAgLy8gd2UgY2FuIHVzZSBmb3JFYWNoIHNpbmNlIHBvaW50ZXJFdmVudHMgb25seSBpcyBpbiBJRTEwXG4gICAgVXRpbHMuZWFjaCh0aGlzLnBvaW50ZXJzLCBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB0b3VjaGxpc3QucHVzaChwb2ludGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hsaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgcG9pbnRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlckV2ZW50XG4gICAqL1xuICB1cGRhdGVQb2ludGVyOiBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgcG9pbnRlckV2ZW50KSB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQgfHwgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbnMgIT09IDEpKSB7XG4gICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICovXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgIGlmICghZXYucG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHQgPSBldi5wb2ludGVyVHlwZSxcbiAgICAgICAgdHlwZXMgPSB7fTtcblxuICAgIHR5cGVzW1BPSU5URVJfTU9VU0VdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgUE9JTlRFUl9NT1VTRSkpO1xuICAgIHR5cGVzW1BPSU5URVJfVE9VQ0hdID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgUE9JTlRFUl9UT1VDSCkpO1xuICAgIHR5cGVzW1BPSU5URVJfUEVOXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX1BFTiB8fCBQT0lOVEVSX1BFTikpO1xuICAgIHJldHVybiB0eXBlc1twb2ludGVyVHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlc2V0IHRoZSBzdG9yZWQgcG9pbnRlcnNcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldExpc3QoKSB7XG4gICAgdGhpcy5wb2ludGVycyA9IHt9O1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgRGV0ZWN0aW9uXG4gKiBAc3RhdGljXG4gKi9cbkRldGVjdGlvbiA9IEdlc3R1cmVEZXRlY3Rvci5kZXRlY3Rpb24gPSB7XG4gIC8vIGNvbnRhaW5zIGFsbCByZWdpc3RlcmVkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuICBnZXN0dXJlczogW10sXG5cbiAgLy8gZGF0YSBvZiB0aGUgY3VycmVudCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb24gc2Vzc2lvblxuICBjdXJyZW50OiBudWxsLFxuXG4gIC8vIHRoZSBwcmV2aW91cyBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBzZXNzaW9uIGRhdGFcbiAgLy8gaXMgYSBmdWxsIGNsb25lIG9mIHRoZSBwcmV2aW91cyBnZXN0dXJlLmN1cnJlbnQgb2JqZWN0XG4gIHByZXZpb3VzOiBudWxsLFxuXG4gIC8vIHdoZW4gdGhpcyBiZWNvbWVzIHRydWUsIG5vIGdlc3R1cmVzIGFyZSBmaXJlZFxuICBzdG9wcGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogc3RhcnQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSB7R2VzdHVyZURldGVjdG9yLkluc3RhbmNlfSBpbnN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudERhdGFcbiAgICovXG4gIHN0YXJ0RGV0ZWN0OiBmdW5jdGlvbiBzdGFydERldGVjdChpbnN0LCBldmVudERhdGEpIHtcbiAgICAvLyBhbHJlYWR5IGJ1c3kgd2l0aCBhIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBvbiBhbiBlbGVtZW50XG4gICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgLy8gaG9sZHMgY3VycmVudCBzZXNzaW9uXG4gICAgdGhpcy5jdXJyZW50ID0ge1xuICAgICAgaW5zdDogaW5zdCwgLy8gcmVmZXJlbmNlIHRvIEdlc3R1cmVEZXRlY3Rvckluc3RhbmNlIHdlJ3JlIHdvcmtpbmcgZm9yXG4gICAgICBzdGFydEV2ZW50OiBVdGlscy5leHRlbmQoe30sIGV2ZW50RGF0YSksIC8vIHN0YXJ0IGV2ZW50RGF0YSBmb3IgZGlzdGFuY2VzLCB0aW1pbmcgZXRjXG4gICAgICBsYXN0RXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YVxuICAgICAgbGFzdENhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICBmdXR1cmVDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgbGFzdENhbGNEYXRhOiB7fSwgLy8gbGFzdCBsYXN0Q2FsY0RhdGFcbiAgICAgIG5hbWU6ICcnIC8vIGN1cnJlbnQgZ2VzdHVyZSB3ZSdyZSBpbi9kZXRlY3RlZCwgY2FuIGJlICd0YXAnLCAnaG9sZCcgZXRjXG4gICAgfTtcblxuICAgIHRoaXMuZGV0ZWN0KGV2ZW50RGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGRldGVjdDogZnVuY3Rpb24gZGV0ZWN0KGV2ZW50RGF0YSkge1xuICAgIGlmICghdGhpcy5jdXJyZW50IHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBldmVudCBkYXRhIHdpdGggY2FsY3VsYXRpb25zIGFib3V0IHNjYWxlLCBkaXN0YW5jZSBldGNcbiAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xuXG4gICAgLy8gR2VzdHVyZURldGVjdG9yIGluc3RhbmNlIGFuZCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcbiAgICAgICAgaW5zdE9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAvLyBjYWxsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgVXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbiB0cmlnZ2VyR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgaWYgKCF0aGlzLnN0b3BwZWQgJiYgaW5zdC5lbmFibGVkICYmIGluc3RPcHRpb25zW2dlc3R1cmUubmFtZV0pIHtcbiAgICAgICAgZ2VzdHVyZS5oYW5kbGVyLmNhbGwoZ2VzdHVyZSwgZXZlbnREYXRhLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIHN0b3JlIGFzIHByZXZpb3VzIGV2ZW50IGV2ZW50XG4gICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgdGhpcy5jdXJyZW50Lmxhc3RFdmVudCA9IGV2ZW50RGF0YTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnREYXRhLmV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudERhdGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgfSxcblxuICAvKipcbiAgICogY2xlYXIgdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHZhcnNcbiAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICogdG8gc3RvcCBvdGhlciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgKi9cbiAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgdGhpcy5wcmV2aW91cyA9IFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICovXG4gIGdldENhbGN1bGF0ZWREYXRhOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkRGF0YShldiwgY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgcmVjYWxjID0gZmFsc2UsXG4gICAgICAgIGNhbGNFdiA9IGN1ci5sYXN0Q2FsY0V2ZW50LFxuICAgICAgICBjYWxjRGF0YSA9IGN1ci5sYXN0Q2FsY0RhdGE7XG5cbiAgICBpZiAoY2FsY0V2ICYmIGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXAgPiBHZXN0dXJlRGV0ZWN0b3IuQ0FMQ1VMQVRFX0lOVEVSVkFMKSB7XG4gICAgICBjZW50ZXIgPSBjYWxjRXYuY2VudGVyO1xuICAgICAgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcDtcbiAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gY2FsY0V2LmNlbnRlci5jbGllbnRYO1xuICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBjYWxjRXYuY2VudGVyLmNsaWVudFk7XG4gICAgICByZWNhbGMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICB9XG5cbiAgICBpZiAoIWN1ci5sYXN0Q2FsY0V2ZW50IHx8IHJlY2FsYykge1xuICAgICAgY2FsY0RhdGEudmVsb2NpdHkgPSBVdGlscy5nZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgY2FsY0RhdGEuZGlyZWN0aW9uID0gVXRpbHMuZ2V0RGlyZWN0aW9uKGNlbnRlciwgZXYuY2VudGVyKTtcblxuICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGV2LnZlbG9jaXR5WCA9IGNhbGNEYXRhLnZlbG9jaXR5Lng7XG4gICAgZXYudmVsb2NpdHlZID0gY2FsY0RhdGEudmVsb2NpdHkueTtcbiAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcbiAgICBldi5pbnRlcmltRGlyZWN0aW9uID0gY2FsY0RhdGEuZGlyZWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgc3RhcnRFdiA9IGN1ci5zdGFydEV2ZW50LFxuICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHN0YXJ0IHRvdWNobGlzdCB0byBjYWxjdWxhdGUgdGhlIHNjYWxlL3JvdGF0aW9uXG4gICAgaWYgKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCB8fCBldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgc3RhcnRFdi50b3VjaGVzID0gW107XG4gICAgICBVdGlscy5lYWNoKGV2LnRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHN0YXJ0RXYudG91Y2hlcy5wdXNoKHtcbiAgICAgICAgICBjbGllbnRYOiB0b3VjaC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFUaW1lID0gZXYudGltZVN0YW1wIC0gc3RhcnRFdi50aW1lU3RhbXAsXG4gICAgICAgIGRlbHRhWCA9IGV2LmNlbnRlci5jbGllbnRYIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WCxcbiAgICAgICAgZGVsdGFZID0gZXYuY2VudGVyLmNsaWVudFkgLSBzdGFydEV2LmNlbnRlci5jbGllbnRZO1xuXG4gICAgdGhpcy5nZXRDYWxjdWxhdGVkRGF0YShldiwgbGFzdEV2LmNlbnRlciwgZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICBVdGlscy5leHRlbmQoZXYsIHtcbiAgICAgIHN0YXJ0RXZlbnQ6IHN0YXJ0RXYsXG5cbiAgICAgIGRlbHRhVGltZTogZGVsdGFUaW1lLFxuICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICBkZWx0YVk6IGRlbHRhWSxcblxuICAgICAgZGlzdGFuY2U6IFV0aWxzLmdldERpc3RhbmNlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgYW5nbGU6IFV0aWxzLmdldEFuZ2xlKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgZGlyZWN0aW9uOiBVdGlscy5nZXREaXJlY3Rpb24oc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBzY2FsZTogVXRpbHMuZ2V0U2NhbGUoc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKSxcbiAgICAgIHJvdGF0aW9uOiBVdGlscy5nZXRSb3RhdGlvbihzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlZ2lzdGVyIG5ldyBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnZXN0dXJlIG9iamVjdCwgc2VlIGBnZXN0dXJlcy9gIGZvciBkb2N1bWVudGF0aW9uXG4gICAqIEByZXR1cm4ge0FycmF5fSBnZXN0dXJlc1xuICAgKi9cbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGdlc3R1cmUpIHtcbiAgICAvLyBhZGQgYW4gZW5hYmxlIGdlc3R1cmUgb3B0aW9ucyBpZiB0aGVyZSBpcyBubyBnaXZlblxuICAgIHZhciBvcHRpb25zID0gZ2VzdHVyZS5kZWZhdWx0cyB8fCB7fTtcbiAgICBpZiAob3B0aW9uc1tnZXN0dXJlLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIEdlc3R1cmVEZXRlY3RvciBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgb3B0aW9uc1xuICAgIFV0aWxzLmV4dGVuZChHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgLy8gc2V0IGl0cyBpbmRleFxuICAgIGdlc3R1cmUuaW5kZXggPSBnZXN0dXJlLmluZGV4IHx8IDEwMDA7XG5cbiAgICAvLyBhZGQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgdG8gdGhlIGxpc3RcbiAgICB0aGlzLmdlc3R1cmVzLnB1c2goZ2VzdHVyZSk7XG5cbiAgICAvLyBzb3J0IHRoZSBsaXN0IGJ5IGluZGV4XG4gICAgdGhpcy5nZXN0dXJlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAoYS5pbmRleCA+IGIuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmdlc3R1cmVzO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqL1xuXG4vKipcbiAqIGNyZWF0ZSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlXG4gKiBhbGwgbWV0aG9kcyBzaG91bGQgcmV0dXJuIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHNvIGl0IGlzIGNoYWluYWJsZS5cbiAqXG4gKiBAY2xhc3MgSW5zdGFuY2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzYFxuICogQHJldHVybiB7R2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxpc3RlbmVyT3B0aW9ucyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFzc2l2ZSkgPyB7IHBhc3NpdmU6IHRydWUgfSA6IHVuZGVmaW5lZDtcblxuICAvLyBzZXR1cCBHZXN0dXJlRGV0ZWN0b3JKUyB3aW5kb3cgZXZlbnRzIGFuZCByZWdpc3RlciBhbGwgZ2VzdHVyZXNcbiAgLy8gdGhpcyBhbHNvIHNldHMgdXAgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICBzZXR1cChsaXN0ZW5lck9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZWxlbWVudFxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZW5hYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAvKipcbiAgICogb3B0aW9ucywgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHRzXG4gICAqIG9wdGlvbnMgd2l0aCBhbiBfIGFyZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBVdGlscy5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgZGVsZXRlIG9wdGlvbnNbbmFtZV07XG4gICAgb3B0aW9uc1tVdGlscy50b0NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgdGhpcy5vcHRpb25zID0gVXRpbHMuZXh0ZW5kKFV0aWxzLmV4dGVuZCh7fSwgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzKSwgb3B0aW9ucyB8fCB7fSk7XG4gIHRoaXMub3B0aW9ucy5saXN0ZW5lck9wdGlvbnMgPSBsaXN0ZW5lck9wdGlvbnM7XG5cbiAgLy8gYWRkIHNvbWUgY3NzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZyBpdHMgbmF0aXZlIGJlaGF2aW9yXG4gIGlmICh0aGlzLm9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogZXZlbnQgc3RhcnQgaGFuZGxlciBvbiB0aGUgZWxlbWVudCB0byBzdGFydCB0aGUgZGV0ZWN0aW9uXG4gICAqIEBwcm9wZXJ0eSBldmVudFN0YXJ0SGFuZGxlclxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5ldmVudFN0YXJ0SGFuZGxlciA9IEV2ZW50Lm9uVG91Y2goZWxlbWVudCwgRVZFTlRfU1RBUlQsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgfSBlbHNlIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0gpIHtcbiAgICAgIERldGVjdGlvbi5kZXRlY3QoZXYpO1xuICAgIH1cbiAgfSwgbGlzdGVuZXJPcHRpb25zKTtcblxuICAvKipcbiAgICoga2VlcCBhIGxpc3Qgb2YgdXNlciBldmVudCBoYW5kbGVycyB3aGljaCBuZWVkcyB0byBiZSByZW1vdmVkIHdoZW4gY2FsbGluZyAnZGlzcG9zZSdcbiAgICogQHByb3BlcnR5IGV2ZW50SGFuZGxlcnNcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG59O1xuXG5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQG1ldGhvZCBvblxuICAgKiBAc2lnbmF0dXJlIG9uKGdlc3R1cmVzLCBoYW5kbGVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1BZGRzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2VzdHVyZS4gQXZhaWxhYmxlIGdlc3R1cmVzIGFyZTogZHJhZywgZHJhZ2xlZnQsIGRyYWdyaWdodCwgZHJhZ3VwLCBkcmFnZG93biwgaG9sZCwgcmVsZWFzZSwgc3dpcGUsIHN3aXBlbGVmdCwgc3dpcGVyaWdodCwgc3dpcGV1cCwgc3dpcGVkb3duLCB0YXAsIGRvdWJsZXRhcCwgdG91Y2gsIHRyYW5zZm9ybSwgcGluY2gsIHBpbmNoaW4sIHBpbmNob3V0IGFuZCByb3RhdGUuIFsvZW5dXG4gICAqICBbamFd44K444Kn44K544OB44Oj44Gr5a++44GZ44KL44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44KS6L+95Yqg44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL44K444Kn44K544OB44Oj5ZCN44Gv44CBZHJhZyBkcmFnbGVmdCBkcmFncmlnaHQgZHJhZ3VwIGRyYWdkb3duIGhvbGQgcmVsZWFzZSBzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodCBzd2lwZXVwIHN3aXBlZG93biB0YXAgZG91YmxldGFwIHRvdWNoIHRyYW5zZm9ybSBwaW5jaCBwaW5jaGluIHBpbmNob3V0IHJvdGF0ZSDjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZXNcbiAgICogICBbZW5dQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBnZXN0dXJlcy5bL2VuXVxuICAgKiAgIFtqYV3mpJznn6XjgZnjgovjgrjjgqfjgrnjg4Hjg6PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg5rjg7zjgrnjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqICAgW2VuXUFuIGV2ZW50IGhhbmRsaW5nIGZ1bmN0aW9uLlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOODj+ODs+ODieODqeOBqOOBquOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb25FdmVudChnZXN0dXJlcywgaGFuZGxlciwgb3B0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgRXZlbnQub24oc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgdXRpbC5leHRlbmQoe30sIHNlbGYub3B0aW9ucy5saXN0ZW5lck9wdGlvbnMsIG9wdCksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5wdXNoKHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBvZmZcbiAgICogQHNpZ25hdHVyZSBvZmYoZ2VzdHVyZXMsIGhhbmRsZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5bL2VuXVxuICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXG4gICAqICAgW2phXeOCuOOCp+OCueODgeODo+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODmuODvOOCueOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44Go44Gq44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIsIG9wdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIEV2ZW50Lm9mZihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCB1dGlsLmV4dGVuZCh7fSwgc2VsZi5vcHRpb25zLmxpc3RlbmVyT3B0aW9ucywgb3B0KSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGluZGV4ID0gVXRpbHMuaW5BcnJheShzZWxmLmV2ZW50SGFuZGxlcnMsIHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9LCB0cnVlKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGdlc3R1cmUgZXZlbnRcbiAgICogQG1ldGhvZCB0cmlnZ2VyXG4gICAqIEBzaWduYXR1cmUgdHJpZ2dlcihnZXN0dXJlLCBldmVudERhdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXVxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGdlc3R1cmUsIGV2ZW50RGF0YSkge1xuICAgIC8vIG9wdGlvbmFsXG4gICAgaWYgKCFldmVudERhdGEpIHtcbiAgICAgIGV2ZW50RGF0YSA9IHt9O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBET00gZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGdlc3R1cmUsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50Lmdlc3R1cmUgPSBldmVudERhdGE7XG5cbiAgICAvLyB0cmlnZ2VyIG9uIHRoZSB0YXJnZXQgaWYgaXQgaXMgaW4gdGhlIGluc3RhbmNlIGVsZW1lbnQsXG4gICAgLy8gdGhpcyBpcyBmb3IgZXZlbnQgZGVsZWdhdGlvbiB0cmlja3NcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoVXRpbHMuaGFzUGFyZW50KGV2ZW50RGF0YS50YXJnZXQsIGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50ID0gZXZlbnREYXRhLnRhcmdldDtcbiAgICB9XG5cbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgKiBAc2lnbmF0dXJlIGVuYWJsZShzdGF0ZSlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRW5hYmxlIG9yIGRpc2FibGUgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAgICogIFtqYV3jgrjjgqfjgrnjg4Hjg6PmpJznn6XjgpLmnInlirnljJYv54Sh5Yq55YyW44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0ZVxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSBlbmFibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3mnInlirnjgavjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBzdGF0ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAqIEBzaWduYXR1cmUgZGlzcG9zZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVJlbW92ZSBhbmQgZGVzdHJveSBhbGwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2UuWy9lbl1cbiAgICogIFtqYV3jgZPjga7jgqTjg7Pjgrnjgr/jg7Pjgrnjgafjga7jgrjjgqfjgrnjg4Hjg6Pjga7mpJznn6XjgoTjgIHjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgpLlhajjgabop6PpmaTjgZfjgablu4Pmo4TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB2YXIgaSwgZWg7XG5cbiAgICAvLyB1bmRvIGFsbCBjaGFuZ2VzIG1hZGUgYnkgc3RvcF9icm93c2VyX2JlaGF2aW9yXG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIGZhbHNlKTtcblxuICAgIC8vIHVuYmluZCBhbGwgY3VzdG9tIGV2ZW50IGhhbmRsZXJzXG4gICAgZm9yIChpID0gLTE7IChlaCA9IHRoaXMuZXZlbnRIYW5kbGVyc1srK2ldKTspIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgVXRpbHMub2ZmKHRoaXMuZWxlbWVudCwgZWguZ2VzdHVyZSwgZWguaGFuZGxlcik7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyB1bmJpbmQgdGhlIHN0YXJ0IGV2ZW50IGxpc3RlbmVyXG4gICAgRXZlbnQub2ZmKHRoaXMuZWxlbWVudCwgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdLCB0aGlzLmV2ZW50U3RhcnRIYW5kbGVyKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBnZXN0dXJlc1xuICovXG4vKipcbiAqIE1vdmUgd2l0aCB4IGZpbmdlcnMgKGRlZmF1bHQgMSkgYXJvdW5kIG9uIHRoZSBwYWdlLlxuICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLlxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnXCIsIGZ1bmN0aW9uKGV2KSB7XG4gKiAgICBjb25zb2xlLmxvZyhldik7XG4gKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gKiAgfSk7XG4gKiBgYGBgXG4gKlxuICogQGNsYXNzIERyYWdcbiAqIEBzdGF0aWNcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ1xuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdzdGFydFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFwbGVmdFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdyaWdodFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWd1cFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdkb3duXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKi9cbihmdW5jdGlvbihuYW1lKSB7XG4gIHZhciB0cmlnZ2VyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBkcmFnR2VzdHVyZShldiwgaW5zdCkge1xuICAgIHZhciBjdXIgPSBEZXRlY3Rpb24uY3VycmVudDtcblxuICAgIC8vIG1heCB0b3VjaGVzXG4gICAgaWYgKGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcyA+IDAgJiZcbiAgICAgIGV2LnRvdWNoZXMubGVuZ3RoID4gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChldi5ldmVudFR5cGUpIHtcbiAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgIGlmIChldi5kaXN0YW5jZSA8IGluc3Qub3B0aW9ucy5kcmFnTWluRGlzdGFuY2UgJiZcbiAgICAgICAgY3VyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENlbnRlciA9IGN1ci5zdGFydEV2ZW50LmNlbnRlcjtcblxuICAgICAgLy8gd2UgYXJlIGRyYWdnaW5nIVxuICAgICAgaWYgKGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgY3VyLm5hbWUgPSBuYW1lO1xuICAgICAgICBpZiAoaW5zdC5vcHRpb25zLmRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gJiYgZXYuZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIGRyYWcgaXMgdHJpZ2dlcmVkLCBzZXQgdGhlIGV2ZW50IGNlbnRlciB0byBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGZyb20gdGhlIG9yaWdpbmFsIGV2ZW50IGNlbnRlci5cbiAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgY29ycmVjdGlvbiwgdGhlIGRyYWdnZWQgZGlzdGFuY2Ugd291bGQganVtcHN0YXJ0IGF0IGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgaW5zdGVhZCBvZiBhdCAwLlxuICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBzYXZlIHRoZSBvcmlnaW5hbCBzdGFydCBwb2ludCBzb21ld2hlcmVcbiAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5hYnMoaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAvIGV2LmRpc3RhbmNlKTtcbiAgICAgICAgICBzdGFydENlbnRlci5wYWdlWCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuXG4gICAgICAgICAgLy8gcmVjYWxjdWxhdGUgZXZlbnQgZGF0YSB1c2luZyBuZXcgc3RhcnQgcG9pbnRcbiAgICAgICAgICBldiA9IERldGVjdGlvbi5leHRlbmRFdmVudERhdGEoZXYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2sgZHJhZyB0byBheGlzP1xuICAgICAgaWYgKGN1ci5sYXN0RXZlbnQuZHJhZ0xvY2tUb0F4aXMgfHxcbiAgICAgICAgKCBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tUb0F4aXMgJiZcbiAgICAgICAgICBpbnN0Lm9wdGlvbnMuZHJhZ0xvY2tNaW5EaXN0YW5jZSA8PSBldi5kaXN0YW5jZVxuICAgICAgICApKSB7XG4gICAgICAgICAgZXYuZHJhZ0xvY2tUb0F4aXMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgdmFyIGxhc3REaXJlY3Rpb24gPSBjdXIubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgaWYgKGV2LmRyYWdMb2NrVG9BeGlzICYmIGxhc3REaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xuICAgICAgICAgIGlmIChVdGlscy5pc1ZlcnRpY2FsKGxhc3REaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFZIDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgaWYgKCF0cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdzdGFydCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudHNcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcblxuICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IFV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBibG9jayB0aGUgYnJvd3NlciBldmVudHNcbiAgICAgICAgaWYgKChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrVmVydGljYWwgJiYgaXNWZXJ0aWNhbCkgfHxcbiAgICAgICAgICAoaW5zdC5vcHRpb25zLmRyYWdCbG9ja0hvcml6b250YWwgJiYgIWlzVmVydGljYWwpKSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZiAodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPD0gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5EcmFnID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiA1MCxcbiAgICAgIGhhbmRsZXI6IGRyYWdHZXN0dXJlLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltYWwgbW92ZW1lbnQgdGhhdCBoYXZlIHRvIGJlIG1hZGUgYmVmb3JlIHRoZSBkcmFnIGV2ZW50IGdldHMgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWluRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdNaW5EaXN0YW5jZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uIHRvIHRydWUgdG8gbWFrZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGRyYWdcbiAgICAgICAgICogYmUgY2FsY3VsYXRlZCBmcm9tIHdoZXJlIHRoZSBkcmFnIHdhcyB0cmlnZ2VyZWQsIG5vdCBmcm9tIHdoZXJlIHRoZSB0b3VjaCBzdGFydGVkLlxuICAgICAgICAgKiBVc2VmdWwgdG8gYXZvaWQgYSBqZXJrLXN0YXJ0aW5nIGRyYWcsIHdoaWNoIGNhbiBtYWtlIGZpbmUtYWRqdXN0bWVudHNcbiAgICAgICAgICogdGhyb3VnaCBkcmFnZ2luZyBkaWZmaWN1bHQsIGFuZCBiZSB2aXN1YWxseSB1bmFwcGVhbGluZy5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb25cbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCAwIGZvciB1bmxpbWl0ZWQsIGJ1dCB0aGlzIGNhbiBjb25mbGljdCB3aXRoIHRyYW5zZm9ybVxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01heFRvdWNoZXNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ01heFRvdWNoZXM6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIHdoZW4gZHJhZ2dpbmcgb2NjdXJzXG4gICAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCBpdCwgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XG4gICAgICAgICAqIHdoZW4geW91IGFyZSB1c2luZyB0aGUgZHJhZyBnZXN0dXJlLCBpdCBpcyBhIGdvb2QgcHJhY3RpY2UgdG8gc2V0IHRoaXMgdHJ1ZVxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrSG9yaXpvbnRhbFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdCbG9ja0hvcml6b250YWw6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzYW1lIGFzIGBkcmFnQmxvY2tIb3Jpem9udGFsYCwgYnV0IGZvciB2ZXJ0aWNhbCBtb3ZlbWVudFxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrVmVydGljYWxcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnQmxvY2tWZXJ0aWNhbDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWdMb2NrVG9BeGlzIGtlZXBzIHRoZSBkcmFnIGdlc3R1cmUgb24gdGhlIGF4aXMgdGhhdCBpdCBzdGFydGVkIG9uLFxuICAgICAgICAgKiBJdCBkaXNhbGxvd3MgdmVydGljYWwgZGlyZWN0aW9ucyBpZiB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gd2FzIGhvcml6b250YWwsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tUb0F4aXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTG9ja1RvQXhpczogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWcgbG9jayBvbmx5IGtpY2tzIGluIHdoZW4gZGlzdGFuY2UgPiBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAqIFRoaXMgd2F5LCBsb2NraW5nIG9jY3VycyBvbmx5IHdoZW4gdGhlIGRpc3RhbmNlIGhhcyBiZWNvbWUgbGFyZ2UgZW5vdWdoIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDI1XG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTG9ja01pbkRpc3RhbmNlOiAyNVxuICAgICAgfVxuICAgIH07XG4gIH0pKCdkcmFnJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGEgc2ltcGxlIGdlc3R1cmUgZXZlbnQsIHNvIHlvdSBjYW4gZG8gYW55dGhpbmcgaW4geW91ciBoYW5kbGVyLlxuICAgKiBvbmx5IHVzYWJsZSBpZiB5b3Uga25vdyB3aGF0IHlvdXIgZG9pbmcuLi5cbiAgICpcbiAgICogQGNsYXNzIEdlc3R1cmVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkdlc3R1cmUgPSB7XG4gICAgbmFtZTogJ2dlc3R1cmUnLFxuICAgIGluZGV4OiAxMzM3LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogVG91Y2ggc3RheXMgYXQgdGhlIHNhbWUgcGxhY2UgZm9yIHggdGltZVxuICAgKlxuICAgKiBAY2xhc3MgSG9sZFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGhvbGRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdGltZXI7XG5cbiAgICBmdW5jdGlvbiBob2xkR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgICBzd2l0Y2ggKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGdlc3R1cmUgc28gd2UgY2FuIGNoZWNrIGluIHRoZSB0aW1lb3V0IGlmIGl0IHN0aWxsIGlzXG4gICAgICAgIGN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gc2V0IHRpbWVyIGFuZCBpZiBhZnRlciB0aGUgdGltZW91dCBpdCBzdGlsbCBpcyBob2xkLFxuICAgICAgICAvLyB3ZSB0cmlnZ2VyIHRoZSBob2xkIGV2ZW50XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50Lm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuaG9sZFRpbWVvdXQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBpZiAoZXYuZGlzdGFuY2UgPiBvcHRpb25zLmhvbGRUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ib2xkID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiAxMCxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRpbWVvdXRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgNTAwXG4gICAgICAgICAqL1xuICAgICAgICBob2xkVGltZW91dDogNTAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtb3ZlbWVudCBhbGxvd2VkIHdoaWxlIGhvbGRpbmdcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaHJlc2hvbGRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMlxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZFRocmVzaG9sZDogMlxuICAgICAgfSxcbiAgICAgIGhhbmRsZXI6IGhvbGRHZXN0dXJlXG4gICAgfTtcbiAgfSkoJ2hvbGQnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyByZWxlYXNlZCBmcm9tIHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBSZWxlYXNlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVsZWFzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5SZWxlYXNlID0ge1xuICAgIG5hbWU6ICdyZWxlYXNlJyxcbiAgICBpbmRleDogSW5maW5pdHksXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmIChldi5ldmVudFR5cGUgPT0gRVZFTlRfUkVMRUFTRSkge1xuICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogdHJpZ2dlcnMgc3dpcGUgZXZlbnRzIHdoZW4gdGhlIGVuZCB2ZWxvY2l0eSBpcyBhYm92ZSB0aGUgdGhyZXNob2xkXG4gICAqIGZvciBiZXN0IHVzYWdlLCBzZXQgYHByZXZlbnREZWZhdWx0YCAob24gdGhlIGRyYWcgZ2VzdHVyZSkgdG8gYHRydWVgXG4gICAqIGBgYGBcbiAgICogIEdlc3R1cmVEZXRlY3RvcnRpbWUub24oXCJkcmFnbGVmdCBzd2lwZWxlZnRcIiwgZnVuY3Rpb24oZXYpIHtcbiAgICogICAgY29uc29sZS5sb2coZXYpO1xuICAgKiAgICBldi5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqICB9KTtcbiAgICogYGBgYFxuICAgKlxuICAgKiBAY2xhc3MgU3dpcGVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVsZWZ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXJpZ2h0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZXVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuU3dpcGUgPSB7XG4gICAgbmFtZTogJ3N3aXBlJyxcbiAgICBpbmRleDogNDAsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWluVG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNaW5Ub3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1heFRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWF4VG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBob3Jpem9udGFsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVhcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVg6IDAuNixcblxuICAgICAgLyoqXG4gICAgICAgKiB2ZXJ0aWNhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlZXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlZOiAwLjZcbiAgICB9LFxuXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gc3dpcGVHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpZiAoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgICAgaWYgKHRvdWNoZXMgPCBvcHRpb25zLnN3aXBlTWluVG91Y2hlcyB8fFxuICAgICAgICAgIHRvdWNoZXMgPiBvcHRpb25zLnN3aXBlTWF4VG91Y2hlcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICBpZiAoZXYudmVsb2NpdHlYID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WCB8fFxuICAgICAgICAgIGV2LnZlbG9jaXR5WSA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVkpIHtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHN3aXBlIGV2ZW50c1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBTaW5nbGUgdGFwIGFuZCBhIGRvdWJsZSB0YXAgb24gYSBwbGFjZVxuICAgKlxuICAgKiBAY2xhc3MgVGFwXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBkb3VibGV0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaGFzTW92ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdC5vcHRpb25zLFxuICAgICAgICAgIGN1cnJlbnQgPSBEZXRlY3Rpb24uY3VycmVudCxcbiAgICAgICAgICBwcmV2ID0gRGV0ZWN0aW9uLnByZXZpb3VzLFxuICAgICAgICAgIHNpbmNlUHJldixcbiAgICAgICAgICBkaWREb3VibGVUYXA7XG5cbiAgICAgIHN3aXRjaCAoZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICBoYXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBoYXNNb3ZlZCA9IGhhc01vdmVkIHx8IChldi5kaXN0YW5jZSA+IG9wdGlvbnMudGFwTWF4RGlzdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIGlmICghVXRpbHMuaW5TdHIoZXYuc3JjRXZlbnQudHlwZSwgJ2NhbmNlbCcpICYmIGV2LmRlbHRhVGltZSA8IG9wdGlvbnMudGFwTWF4VGltZSAmJiAhaGFzTW92ZWQpIHtcbiAgICAgICAgICAvLyBwcmV2aW91cyBnZXN0dXJlLCBmb3IgdGhlIGRvdWJsZSB0YXAgc2luY2UgdGhlc2UgYXJlIHR3byBkaWZmZXJlbnQgZ2VzdHVyZSBkZXRlY3Rpb25zXG4gICAgICAgICAgc2luY2VQcmV2ID0gcHJldiAmJiBwcmV2Lmxhc3RFdmVudCAmJiBldi50aW1lU3RhbXAgLSBwcmV2Lmxhc3RFdmVudC50aW1lU3RhbXA7XG4gICAgICAgICAgZGlkRG91YmxlVGFwID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBjaGVjayBpZiBkb3VibGUgdGFwXG4gICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5uYW1lID09IG5hbWUgJiZcbiAgICAgICAgICAgIChzaW5jZVByZXYgJiYgc2luY2VQcmV2IDwgb3B0aW9ucy5kb3VibGVUYXBJbnRlcnZhbCkgJiZcbiAgICAgICAgICAgIGV2LmRpc3RhbmNlIDwgb3B0aW9ucy5kb3VibGVUYXBEaXN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKCdkb3VibGV0YXAnLCBldik7XG4gICAgICAgICAgICBkaWREb3VibGVUYXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxuICAgICAgICAgIGlmICghZGlkRG91YmxlVGFwIHx8IG9wdGlvbnMudGFwQWx3YXlzKSB7XG4gICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKGN1cnJlbnQubmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVGFwID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiAxMDAsXG4gICAgICBoYW5kbGVyOiB0YXBHZXN0dXJlLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhUaW1lXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDI1MFxuICAgICAgICAgKi9cbiAgICAgICAgdGFwTWF4VGltZTogMjUwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggZGlzdGFuY2Ugb2YgbW92ZW1lbnQgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhEaXN0YW5jZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFsd2F5cyB0cmlnZ2VyIHRoZSBgdGFwYCBldmVudCwgZXZlbiB3aGlsZSBkb3VibGUtdGFwcGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwQWx3YXlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0YXBBbHdheXM6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBEaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwRGlzdGFuY2U6IDIwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggdGltZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBJbnRlcnZhbFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAzMDBcbiAgICAgICAgICovXG4gICAgICAgIGRvdWJsZVRhcEludGVydmFsOiAzMDBcbiAgICAgIH1cbiAgICB9O1xuICB9KSgndGFwJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgdG91Y2hlZCBhdCB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgVG91Y2hcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0b3VjaFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ub3VjaCA9IHtcbiAgICBuYW1lOiAndG91Y2gnLFxuICAgIGluZGV4OiAtSW5maW5pdHksXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCBhdCB0b3VjaHN0YXJ0LCBhbmQgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgYnkgZGlzYWJsaW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHBhZ2UsXG4gICAgICAgKiBidXQgaXQgaW1wcm92ZXMgZ2VzdHVyZXMgbGlrZSB0cmFuc2Zvcm1pbmcgYW5kIGRyYWdnaW5nLlxuICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIHVzaW5nIHRoaXMsIGl0IGNhbiBiZSB2ZXJ5IGFubm95aW5nIGZvciB1c2VycyB0byBiZSBzdHVjayBvbiB0aGUgcGFnZVxuICAgICAgICogQHByb3BlcnR5IHByZXZlbnREZWZhdWx0XG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkaXNhYmxlIG1vdXNlIGV2ZW50cywgc28gb25seSB0b3VjaCAob3IgcGVuISkgaW5wdXQgdHJpZ2dlcnMgZXZlbnRzXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudE1vdXNlXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnRNb3VzZTogZmFsc2VcbiAgICB9LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHRvdWNoR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYgKGluc3Qub3B0aW9ucy5wcmV2ZW50TW91c2UgJiYgZXYucG9pbnRlclR5cGUgPT0gUE9JTlRFUl9NT1VTRSkge1xuICAgICAgICBldi5zdG9wRGV0ZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3Qub3B0aW9ucy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICAgIGluc3QudHJpZ2dlcigndG91Y2gnLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xuICAgKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCB0aGVcbiAgICogYHByZXZlbnREZWZhdWx0YCBvcHRpb24uXG4gICAqXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybXN0YXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1lbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNoaW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNob3V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByb3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1HZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBzd2l0Y2ggKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIC8vIGF0IGxlYXN0IG11bHRpdG91Y2hcbiAgICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZVRocmVzaG9sZCA9IE1hdGguYWJzKDEgLSBldi5zY2FsZSk7XG4gICAgICAgIHZhciByb3RhdGlvblRocmVzaG9sZCA9IE1hdGguYWJzKGV2LnJvdGF0aW9uKTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYgKHNjYWxlVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlICYmXG4gICAgICAgICAgcm90YXRpb25UaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxuICAgICAgICBEZXRlY3Rpb24uY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZiAoIXRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpOyAvLyBiYXNpYyB0cmFuc2Zvcm0gZXZlbnRcblxuICAgICAgICAvLyB0cmlnZ2VyIHJvdGF0ZSBldmVudFxuICAgICAgICBpZiAocm90YXRpb25UaHJlc2hvbGQgPiBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgaWYgKHNjYWxlVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJyArIChldi5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCcpLCBldik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgaWYgKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDwgMikge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVHJhbnNmb3JtID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiA0NSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW5pbWFsIHNjYWxlIGZhY3Rvciwgbm8gc2NhbGUgaXMgMSwgem9vbWluIGlzIHRvIDAgYW5kIHpvb21vdXQgdW50aWwgaGlnaGVyIHRoZW4gMVxuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluU2NhbGVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtTWluU2NhbGU6IDAuMDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblJvdGF0aW9uXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zZm9ybU1pblJvdGF0aW9uOiAxXG4gICAgICB9LFxuXG4gICAgICBoYW5kbGVyOiB0cmFuc2Zvcm1HZXN0dXJlXG4gICAgfTtcbiAgfSkoJ3RyYW5zZm9ybScpO1xuXG5leHBvcnQgZGVmYXVsdCBHZXN0dXJlRGV0ZWN0b3I7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5sZXQgcmVhZHlNYXAsIHF1ZXVlTWFwO1xuXG5mdW5jdGlvbiBpc0NvbnRlbnRSZWFkeShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gcmVhZHlNYXAuaGFzKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBzZXRDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICByZWFkeU1hcC5zZXQoZWxlbWVudCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENhbGxiYWNrKGVsZW1lbnQsIGZuKSB7XG4gIGlmICghcXVldWVNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgcXVldWVNYXAuc2V0KGVsZW1lbnQsIFtdKTtcbiAgfVxuICBxdWV1ZU1hcC5nZXQoZWxlbWVudCkucHVzaChmbik7XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVRdWV1ZShlbGVtZW50KSB7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlTWFwLmdldChlbGVtZW50LCBbXSkgfHwgW107XG4gIHF1ZXVlTWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRlbnRSZWFkeShlbGVtZW50LCBmbiA9ICgpID0+IHt9KSB7XG4gIGlmIChyZWFkeU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVhZHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHF1ZXVlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIGFkZENhbGxiYWNrKGVsZW1lbnQsIGZuKTtcblxuICBpZiAoaXNDb250ZW50UmVhZHkoZWxlbWVudCkpIHtcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjaGFuZ2VzID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG5cbiAgLy8gZmFpbGJhY2sgZm9yIGVsZW1lbnRzIGhhcyBlbXB0eSBjb250ZW50LlxuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XG4gIH0pO1xufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY2xhc3MgVG9hc3RRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuXG4gIGFkZChmbiwgcHJvbWlzZSkge1xuICAgIHRoaXMucXVldWUucHVzaChmbik7XG5cbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNldEltbWVkaWF0ZSh0aGlzLnF1ZXVlWzBdKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5xdWV1ZVswXSwgMTAwMC8zMCk7IC8vIEFwcGx5IHNvbWUgdmlzdWFsIGRlbGF5XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFRvYXN0UXVldWUoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4vY29udGVudC1yZWFkeSc7XG5pbXBvcnQgVG9hc3RRdWV1ZSBmcm9tICcuL2ludGVybmFsL3RvYXN0LXF1ZXVlJztcblxuY29uc3QgX3NldEF0dHJpYnV0ZXMgPSAoZWxlbWVudCwgb3B0aW9ucykgPT4ge1xuICBbJ2lkJywgJ2NsYXNzJywgJ2FuaW1hdGlvbiddXG4gICAgLmZvckVhY2goYSA9PiBvcHRpb25zLmhhc093blByb3BlcnR5KGEpICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKGEsIG9wdGlvbnNbYV0pKTtcblxuICBpZiAob3B0aW9ucy5tb2RpZmllcikge1xuICAgIHV0aWwuYWRkTW9kaWZpZXIoZWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcik7XG4gIH1cbn07XG5cbmNvbnN0IF9ub3JtYWxpemVBcmd1bWVudHMgPSAobWVzc2FnZSwgb3B0aW9ucyA9IHt9LCBkZWZhdWx0cyA9IHt9KSA9PiB7XG4gIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gKG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2UpIDogKG9wdGlvbnMgPSBtZXNzYWdlKTtcbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm1lc3NhZ2UgJiYgIW9wdGlvbnMubWVzc2FnZUhUTUwpIHtcbiAgICB1dGlsLnRocm93KCdOb3RpZmljYXRpb25zIG11c3QgY29udGFpbiBhIG1lc3NhZ2UnKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbHMnKSB8fCBvcHRpb25zLmhhc093blByb3BlcnR5KCdidXR0b25MYWJlbCcpKSB7XG4gICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBvcHRpb25zLmJ1dHRvbkxhYmVscyB8fCBvcHRpb25zLmJ1dHRvbkxhYmVsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmJ1dHRvbkxhYmVscykpIHtcbiAgICAgIG9wdGlvbnMuYnV0dG9uTGFiZWxzID0gW29wdGlvbnMuYnV0dG9uTGFiZWxzIHx8ICcnXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1dGlsLmV4dGVuZCh7XG4gICAgICBjb21waWxlOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGNhbGxiYWNrOiBwYXJhbSA9PiBwYXJhbSxcbiAgICAgIGFuaW1hdGlvbjogJ2RlZmF1bHQnLFxuICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICBwcmltYXJ5QnV0dG9uSW5kZXg6IChvcHRpb25zLmJ1dHRvbkxhYmVscyB8fCBkZWZhdWx0cy5idXR0b25MYWJlbHMgfHwgW10pLmxlbmd0aCAtIDFcbiAgICB9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLm5vdGlmaWNhdGlvblxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25vdGlmaWNhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBVdGlsaXR5IG1ldGhvZHMgdG8gY3JlYXRlIGRpZmZlcmVudCBraW5kcyBvZiBub3RpZmljYXRpb25zLiBUaGVyZSBhcmUgdGhyZWUgbWV0aG9kcyBhdmFpbGFibGU6XG4gKlxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uYWxlcnQoKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0oKWBcbiAqICAgICAqIGBvbnMubm90aWZpY2F0aW9uLnByb21wdCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24udG9hc3QoKWBcbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOBhOOBj+OBpOOBi+OBrueorumhnuOBruOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuS9nOaIkOOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBn+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnSGVsbG8sIHdvcmxkIScpO1xuICpcbiAqIG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgnQXJlIHlvdSByZWFkeT8nKVxuICogICAudGhlbihcbiAqICAgICBmdW5jdGlvbihhbnN3ZXIpIHtcbiAqICAgICAgIGlmIChhbnN3ZXIgPT09IDEpIHtcbiAqICAgICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnTGV0XFwncyBnbyEnKTtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgICk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5wcm9tcHQoJ0hvdyBvbGQgYXJlID8nKVxuICogICAudGhlbihcbiAqICAgICBmdW5jdGlvbihhZ2UpIHtcbiAqICAgICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQoJ1lvdSBhcmUgJyArIGFnZSArICcgeWVhcnMgb2xkLicpO1xuICogICAgIH1cbiAqICAgKTtcbiAqL1xuY29uc3Qgbm90aWZpY2F0aW9uID0ge307XG5cbm5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cgPSAoLi4ucGFyYW1zKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMoLi4ucGFyYW1zKTtcbiAgdXRpbC5jaGVja01pc3NpbmdJbXBvcnQoJ0FsZXJ0RGlhbG9nJywgJ0FsZXJ0RGlhbG9nQnV0dG9uJyk7XG5cbiAgLy8gUHJvbXB0IGlucHV0IHN0cmluZ1xuICBsZXQgaW5wdXRTdHJpbmcgPSAnJztcbiAgaWYgKG9wdGlvbnMuaXNQcm9tcHQpIHtcbiAgICBpbnB1dFN0cmluZyA9IGBcbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzcz1cInRleHQtaW5wdXQgdGV4dC1pbnB1dC0tdW5kZXJiYXJcIlxuICAgICAgICB0eXBlPVwiJHtvcHRpb25zLmlucHV0VHlwZSB8fCAndGV4dCd9XCJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCIke29wdGlvbnMucGxhY2Vob2xkZXIgfHwgJyd9XCJcbiAgICAgICAgdmFsdWU9XCIke29wdGlvbnMuZGVmYXVsdFZhbHVlIHx8ICcnfVwiXG4gICAgICAgIHN0eWxlPVwid2lkdGg6IDEwMCU7IG1hcmdpbi10b3A6IDEwcHg7XCJcbiAgICAgIC8+XG4gICAgYDtcbiAgfVxuXG4gIC8vIEJ1dHRvbnMgc3RyaW5nXG4gIGxldCBidXR0b25zID0gJyc7XG4gIG9wdGlvbnMuYnV0dG9uTGFiZWxzLmZvckVhY2goKGxhYmVsLCBpbmRleCkgPT4ge1xuICAgIGJ1dHRvbnMgKz0gYFxuICAgICAgPG9ucy1hbGVydC1kaWFsb2ctYnV0dG9uXG4gICAgICAgIGNsYXNzPVwiXG4gICAgICAgICAgJHtpbmRleCA9PT0gb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXggPyAnIGFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCcgOiAnJ31cbiAgICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXInIDogJyd9XG4gICAgICAgIFwiXG4gICAgICAgIHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlO1wiPlxuICAgICAgICAke2xhYmVsfVxuICAgICAgPC9vbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbj5cbiAgICBgO1xuICB9KTtcblxuICAvLyBEaWFsb2cgRWxlbWVudFxuICBsZXQgZWwgPSB7fTtcbiAgY29uc3QgX2Rlc3Ryb3lEaWFsb2cgPSAoKSA9PiB7XG4gICAgaWYgKGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCkge1xuICAgICAgZWwuZGlhbG9nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKGVsKS5mb3JFYWNoKGtleSA9PiBkZWxldGUgZWxba2V5XSk7XG4gICAgZWwgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmRlc3Ryb3koKTtcbiAgICB9XG4gIH07XG5cbiAgZWwuZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLWFsZXJ0LWRpYWxvZycpO1xuICBlbC5kaWFsb2cuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctbWFza1wiXG4gICAgICBzdHlsZT1cIlxuICAgICAgICAke29wdGlvbnMubWFza0NvbG9yID8gJ2JhY2tncm91bmQtY29sb3I6ICcgKyBvcHRpb25zLm1hc2tDb2xvciA6ICcnfVxuICAgICAgXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy10aXRsZVwiPlxuICAgICAgICAgICR7b3B0aW9ucy50aXRsZSB8fCAnJ31cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICAgICAgICAgICR7b3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMubWVzc2FnZUhUTUx9XG4gICAgICAgICAgJHtpbnB1dFN0cmluZ31cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJcbiAgICAgICAgICBhbGVydC1kaWFsb2ctZm9vdGVyXG4gICAgICAgICAgJHtvcHRpb25zLmJ1dHRvbkxhYmVscy5sZW5ndGggPD0gMiA/ICcgYWxlcnQtZGlhbG9nLWZvb3Rlci0tcm93Zm9vdGVyJyA6ICcnfVxuICAgICAgICBcIj5cbiAgICAgICAgICAke2J1dHRvbnN9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG4gIGNvbnRlbnRSZWFkeShlbC5kaWFsb2cpO1xuXG4gIC8vIFNldCBhdHRyaWJ1dGVzXG4gIF9zZXRBdHRyaWJ1dGVzKGVsLmRpYWxvZywgb3B0aW9ucyk7XG5cbiAgLy8gUHJvbXB0IGV2ZW50c1xuICBpZiAob3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLnN1Ym1pdE9uRW50ZXIpIHtcbiAgICBlbC5pbnB1dCA9IGVsLmRpYWxvZy5xdWVyeVNlbGVjdG9yKCcudGV4dC1pbnB1dCcpO1xuICAgIGVsLmlucHV0Lm9ua2V5cHJlc3MgPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBlbC5pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEJ1dHRvbiBldmVudHNcbiAgZWwuZm9vdGVyID0gZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJy5hbGVydC1kaWFsb2ctZm9vdGVyJyk7XG4gIHV0aWwuYXJyYXlGcm9tKGVsLmRpYWxvZy5xdWVyeVNlbGVjdG9yQWxsKCcuYWxlcnQtZGlhbG9nLWJ1dHRvbicpKS5mb3JFYWNoKChidXR0b25FbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGJ1dHRvbkVsZW1lbnQub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgZWwuZGlhbG9nLmhpZGUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICBsZXQgcmVzb2x2ZVZhbHVlID0gaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmlzUHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlID0gaW5kZXggPT09IG9wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4ID8gZWwuaW5wdXQudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsLmRpYWxvZy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGVsLmZvb3Rlci5hcHBlbmRDaGlsZChidXR0b25FbGVtZW50KTtcbiAgfSk7XG5cbiAgLy8gQ2FuY2VsIGV2ZW50c1xuICBpZiAob3B0aW9ucy5jYW5jZWxhYmxlKSB7XG4gICAgZWwuZGlhbG9nLmNhbmNlbGFibGUgPSB0cnVlO1xuICAgIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCA9ICgpID0+IHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIGVsLmRpYWxvZy5yZW1vdmUoKTtcbiAgICAgICAgX2Rlc3Ryb3lEaWFsb2coKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzb2x2ZVZhbHVlID0gb3B0aW9ucy5pc1Byb21wdCA/IG51bGwgOiAtMTtcbiAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzb2x2ZVZhbHVlKTtcbiAgICAgIHJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICB9O1xuICAgIGVsLmRpYWxvZy5hZGRFdmVudExpc3RlbmVyKCdkaWFsb2ctY2FuY2VsJywgZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsLCBmYWxzZSk7XG4gIH1cblxuICAvLyBTaG93IGRpYWxvZ1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsLmRpYWxvZyk7XG4gIG9wdGlvbnMuY29tcGlsZShlbC5kaWFsb2cpO1xuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgIGVsLmRpYWxvZy5zaG93KClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGVsLmlucHV0ICYmIG9wdGlvbnMuaXNQcm9tcHQgJiYgb3B0aW9ucy5hdXRvZm9jdXMpIHtcbiAgICAgICAgICBjb25zdCBzdHJMZW5ndGggPSBlbC5pbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgZWwuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICBlbC5pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShzdHJMZW5ndGgsIHN0ckxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIEBtZXRob2QgYWxlcnRcbiAqIEBzaWduYXR1cmUgYWxlcnQobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi+aWh+Wtl+WIl+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZUhUTUxdXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZSBpbiBIVE1MLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgavooajnpLrjgZnjgotIVE1M44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXl9IFtvcHRpb25zLmJ1dHRvbkxhYmVsc11cbiAqICAgW2VuXUxhYmVscyBmb3IgdGhlIGJ1dHRvbnMuIERlZmF1bHQgaXMgYFwiT0tcImAuWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiT0tcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgdGhlIGxhc3Qgb25lLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMCDjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuIElmIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBpdCBjYW4gYmUgY2xvc2VkIGJ5IGNsaWNraW5nIHRoZSBiYWNrZ3JvdW5kIG9yIHByZXNzaW5nIHRoZSBBbmRyb2lkIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYG5vbmVgIGFuZCBgZmFkZWAuIERlZmF1bHQgaXMgYGZhZGVgLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBJRC5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc11cbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50J3MgY2xhc3MuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fopoHntKDjga5jbGFzc+OAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdXG4gKiAgIFtlbl1EaWFsb2cgdGl0bGUuIERlZmF1bHQgaXMgYFwiQWxlcnRcImAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruS4iumDqOOBq+ihqOekuuOBmeOCi+OCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAglwiQWxlcnRcIuOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGRpYWxvZy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1hc2tDb2xvcl1cbiAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgXCJyZ2JhKDAsIDAsIDAsIDAuMilcIiAoXCJyZ2JhKDAsIDAsIDAsIDAuMylcIiBmb3IgTWF0ZXJpYWwpLlsvZW5dXG4gKiAgIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgonjgozjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGFuIGFsZXJ0IGRpYWxvZyB0byBzaG93IHRoZSB1c2VyIGEgbWVzc2FnZS5cbiAqXG4gKiAgICAgVGhlIGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UgY2FuIGJlIGVpdGhlciBzaW1wbGUgdGV4dCBvciBIVE1MLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244O844G444Oh44OD44K744O844K444KS6KaL44Gb44KL44Gf44KB44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg6KGo56S644GZ44KL44Oh44OD44K744O844K444Gv44CB44OG44Kt44K544OI44GL44KC44GX44GP44GvSFRNTOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmFsZXJ0ID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+XG4gIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIGJ1dHRvbkxhYmVsczogWydPSyddLFxuICAgIHRpdGxlOiAnQWxlcnQnXG4gIH0pO1xuXG4vKipcbiAqIEBtZXRob2QgY29uZmlybVxuICogQHNpZ25hdHVyZSBjb25maXJtKG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5kZXggb2YgdGhlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkIG9yIGAtMWAgd2hlbiBjYW5jZWxlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmJ1dHRvbkxhYmVsc11cbiAqICAgW2VuXUxhYmVscyBmb3IgdGhlIGJ1dHRvbnMuIERlZmF1bHQgaXMgYFtcIkNhbmNlbFwiLCBcIk9LXCJdYC5bL2VuXVxuICogICBbamFd44Oc44K/44Oz44Gu44Op44OZ44Or44Gu6YWN5YiX44KS5oyH5a6a44GX44G+44GZ44CCW1wiQ2FuY2VsXCIsIFwiT0tcIl3jgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIHRoZSBsYXN0IG9uZS5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDEg44Gn44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIGRpYWxvZyB0byBhc2sgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbi4gRXh0ZW5kcyBgYWxlcnQoKWAgcGFyYW1ldGVycy5cbiAqICAgICBUaGUgZGVmYXVsdCBidXR0b24gbGFiZWxzIGFyZSBgXCJDYW5jZWxcImAgYW5kIGBcIk9LXCJgIGJ1dCB0aGV5IGNhbiBiZSBjdXN0b21pemVkLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uY29uZmlybShvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuOBq+eiuuiqjeOCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOODh+OCquODq+OBqOOBruODnOOCv+ODs+ODqeODmeODq+OBr+OAgVwiQ2FuY2VsXCLjgahcIk9LXCLjgafjgZnjgYzjgIHjgZPjgozjga/jgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgafjgqvjgrnjgr/jg57jgqTjgrrjgafjgY3jgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5jb25maXJtID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+XG4gIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIGJ1dHRvbkxhYmVsczogWydDYW5jZWwnLCAnT0snXSxcbiAgICB0aXRsZTogJ0NvbmZpcm0nXG4gIH0pO1xuXG4vKipcbiAqIEBtZXRob2QgcHJvbXB0XG4gKiBAc2lnbmF0dXJlIHByb21wdChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5wdXQgdmFsdWUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZCBvciBgbnVsbGAgd2hlbiBjYW5jZWxlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJPS1wi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyB0aGUgbGFzdCBvbmUuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAwIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdXG4gKiAgIFtlbl1QbGFjZWhvbGRlciBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODl+ODrOODvOOCueODm+ODq+ODgOOBq+ihqOekuuOBmeOCi+ODhuOCreOCueODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZhbHVlXVxuICogICBbZW5dRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODh+ODleOCqeODq+ODiOOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaW5wdXRUeXBlXVxuICogICBbZW5dVHlwZSBvZiB0aGUgaW5wdXQgZWxlbWVudCAoYHBhc3N3b3JkYCwgYGRhdGVgLi4uKS4gRGVmYXVsdCBpcyBgdGV4dGAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9mb2N1c11cbiAqICAgW2VuXUF1dG9mb2N1cyB0aGUgaW5wdXQgZWxlbWVudC4gRGVmYXVsdCBpcyBgdHJ1ZWAuIEluIENvcmRvdmEsIGBLZXlib2FyZERpc3BsYXlSZXF1aXJlc1VzZXJBY3Rpb25gIGluIGBjb25maWcueG1sYCBtdXN0IGJlIGBmYWxzZWAgdG8gYWN0aXZhdGUgdGhpcyBmZWF0dXJlLlsvZW5dXG4gKiAgIFtqYV1pbnB1dOimgee0oOOBq+iHquWLleeahOOBq+ODleOCqeODvOOCq+OCueOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJDb3Jkb3Zh55Kw5aKD44Gn44Gv44CB44GT44Gu5qmf6IO944KS5pyJ5Yq544Gr44GZ44KL44Gf44KB44Gr44GvIGBjb25maWcueG1sYCDjgacgYEtleWJvYXJkRGlzcGxheVJlcXVpcmVzVXNlckFjdGlvbmAg44KSIGBmYWxzZWAg44Gr6Kit5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VibWl0T25FbnRlcl1cbiAqICAgW2VuXVN1Ym1pdCBhdXRvbWF0aWNhbGx5IHdoZW4gZW50ZXIgaXMgcHJlc3NlZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXUVudGVy44GM5oq844GV44KM44Gf6Zqb44Gr44Gd44GuZm9ybeOCknN1Ym1pdOOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHdpdGggYSBwcm9tcHQgdG8gYXNrIHRoZSB1c2VyIGEgcXVlc3Rpb24uIEV4dGVuZHMgYGFsZXJ0KClgIHBhcmFtZXRlcnMuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuODvOOBq+WFpeWKm+OCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLnByb21wdCA9IChtZXNzYWdlLCBvcHRpb25zKSA9PlxuICBub3RpZmljYXRpb24uX2NyZWF0ZUFsZXJ0RGlhbG9nKG1lc3NhZ2UsIG9wdGlvbnMsIHtcbiAgICBidXR0b25MYWJlbHM6IFsnT0snXSxcbiAgICB0aXRsZTogJ0FsZXJ0JyxcbiAgICBpc1Byb21wdDogdHJ1ZSxcbiAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgc3VibWl0T25FbnRlcjogdHJ1ZVxuICB9KTtcblxuLyoqXG4gKiBAbWV0aG9kIHRvYXN0XG4gKiBAc2lnbmF0dXJlIHRvYXN0KG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB3aGVuIHRoZSB0b2FzdCBpcyBoaWRkZW4uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dVG9hc3QgbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCB0aGVuIGBvcHRpb25zLm1lc3NhZ2VgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZV1cbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjgavooajnpLrjgZnjgovmloflrZfliJfjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJ1dHRvbkxhYmVsXVxuICogICBbZW5dTGFiZWwgZm9yIHRoZSBidXR0b24uWy9lbl1cbiAqICAgW2phXeeiuuiqjeODnOOCv+ODs+OBruODqeODmeODq+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgbm9uZWAsIGBmYWRlYCwgYGFzY2VuZGAsIGBsaWZ0YCBhbmQgYGZhbGxgLiBEZWZhdWx0IGlzIGBhc2NlbmRgIGZvciBBbmRyb2lkIGFuZCBgbGlmdGAgZm9yIGlPUy5bL2VuXVxuICogICBbamFd44OI44O844K544OI44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwiLCBcImFzY2VuZFwiLCBcImxpZnRcIiwgXCJmYWxsXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbWVvdXRdXG4gKiAgIFtlbl1OdW1iZXIgb2YgbWlsaXNlY29uZHMgd2hlcmUgdGhlIHRvYXN0IGlzIHZpc2libGUgYmVmb3JlIGhpZGluZyBhdXRvbWF0aWNhbGx5LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb3JjZV1cbiAqICAgW2VuXUlmIGB0cnVlYCwgdGhlIHRvYXN0IHNraXBzIHRoZSBub3RpZmljYXRpb24gcXVldWUgYW5kIGlzIHNob3duIGltbWVkaWF0ZWx5LiBEZWZhdWx0cyB0byBgZmFsc2VgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXVxuICogICBbZW5dVGhlIGA8b25zLXRvYXN0PmAgZWxlbWVudCdzIElELlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9hc3TopoHntKDjga5JROOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2xhc3NdXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9hc3Q+YCBlbGVtZW50J3MgY2xhc3MuWy9lbl1cbiAqICAgW2phXW9ucy10b2FzdOimgee0oOOBrmNsYXNz44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZWxlbWVudC5bL2VuXVxuICogICBbamFd44OI44O844K544OI44GubW9kaWZpZXLlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIHRvYXN0IGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICogICBbamFd44OI44O844K544OI44GM6ZaJ44GY44KJ44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhIHNpbXBsZSBub3RpZmljYXRpb24gdG9hc3Qgd2l0aCBhbiBvcHRpb25hbCBidXR0b24gdGhhdCBjYW4gYmUgdXNlZCBmb3Igc2ltcGxlIGFjdGlvbnMuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnRvYXN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24udG9hc3Qob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5ub3RpZmljYXRpb24udG9hc3QgPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgdXRpbC5jaGVja01pc3NpbmdJbXBvcnQoJ1RvYXN0Jyk7IC8vIFRocm93cyBlcnJvciwgbXVzdCBiZSBpbnNpZGUgcHJvbWlzZVxuXG4gICAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMobWVzc2FnZSwgb3B0aW9ucywge1xuICAgICAgdGltZW91dDogMCxcbiAgICAgIGZvcmNlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgbGV0IHRvYXN0ID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxvbnMtdG9hc3Q+XG4gICAgICAgICR7b3B0aW9ucy5tZXNzYWdlfVxuICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzID8gYDxidXR0b24+JHtvcHRpb25zLmJ1dHRvbkxhYmVsc1swXX08L2J1dHRvbj5gIDogJyd9XG4gICAgICA8L29ucy10b2FzdD5cbiAgICBgKTtcblxuICAgIF9zZXRBdHRyaWJ1dGVzKHRvYXN0LCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGZpbmlzaCA9IHZhbHVlID0+IHtcbiAgICAgIGlmICh0b2FzdCkge1xuICAgICAgICB0b2FzdFxuICAgICAgICAuaGlkZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodG9hc3QpIHtcbiAgICAgICAgICAgIHRvYXN0LnJlbW92ZSgpO1xuICAgICAgICAgICAgdG9hc3QgPSBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5idXR0b25MYWJlbHMpIHtcbiAgICAgIHV0aWwuZmluZENoaWxkKHRvYXN0Ll90b2FzdCwgJ2J1dHRvbicpLm9uY2xpY2sgPSAoKSA9PiBmaW5pc2goMCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b2FzdCk7XG4gICAgb3B0aW9ucy5jb21waWxlKHRvYXN0KTtcblxuICAgIGNvbnN0IHNob3cgPSAoKSA9PiB7XG4gICAgICB0b2FzdC5wYXJlbnRFbGVtZW50ICYmIHRvYXN0LnNob3cob3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGZpbmlzaCgtMSksIG9wdGlvbnMudGltZW91dClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNldEltbWVkaWF0ZSgoKSA9PiBvcHRpb25zLmZvcmNlID8gc2hvdygpIDogVG9hc3RRdWV1ZS5hZGQoc2hvdywgcHJvbWlzZSkpXG4gIH0pO1xuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbm90aWZpY2F0aW9uO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuLy8gVmFsaWRhdGUgcGFyYW1ldGVyc1xuY29uc3QgY2hlY2tPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IGVyciA9IChwcm9wLCB0eXBlID0gJ0Z1bmN0aW9uJykgPT4gdXRpbC50aHJvdyhgXCJvcHRpb25zLiR7cHJvcH1cIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mICR7dHlwZX1gKTtcbiAgY29uc3QgaGFzT3duUHJvcGVydHkgPSBwcm9wID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIHByb3ApO1xuICBjb25zdCBpbnN0YW5jZU9mID0gKHByb3AsIHR5cGUgPSBGdW5jdGlvbikgPT4gb3B0aW9uc1twcm9wXSBpbnN0YW5jZW9mIHR5cGU7XG5cbiAgY29uc3QgYiA9ICdidXR0b25zJywgY2IgPSAnY2FsbGJhY2snLCBjID0gJ2NvbXBpbGUnLCBkID0gJ2Rlc3Ryb3knO1xuICAoIWhhc093blByb3BlcnR5KGIpIHx8ICFpbnN0YW5jZU9mKGIsIEFycmF5KSkgJiYgZXJyKGIsICdBcnJheScpO1xuICAoaGFzT3duUHJvcGVydHkoY2IpICYmICFpbnN0YW5jZU9mKGNiKSkgJiYgZXJyKGNiKTtcbiAgKGhhc093blByb3BlcnR5KGMpICYmICFpbnN0YW5jZU9mKGMpKSAmJiBlcnIoYyk7XG4gIChoYXNPd25Qcm9wZXJ0eShkKSAmJiAhaW5zdGFuY2VPZihkKSkgJiYgZXJyKGQpO1xufTtcblxuLy8gQWN0aW9uIFNoZWV0XG5leHBvcnQgZGVmYXVsdCAob3B0aW9ucyA9IHt9KSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgdXRpbC5jaGVja01pc3NpbmdJbXBvcnQoJ0FjdGlvblNoZWV0Jyk7XG4gIGNoZWNrT3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBNYWluIGNvbXBvbmVudFxuICBsZXQgYWN0aW9uU2hlZXQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgIDxvbnMtYWN0aW9uLXNoZWV0XG4gICAgICAke29wdGlvbnMudGl0bGUgPyBgdGl0bGU9XCIke29wdGlvbnMudGl0bGV9XCJgIDogJyd9XG4gICAgICAke29wdGlvbnMuY2FuY2VsYWJsZSA/ICdjYW5jZWxhYmxlJyA6ICcnfVxuICAgICAgJHtvcHRpb25zLm1vZGlmaWVyID8gYG1vZGlmaWVyPVwiJHtvcHRpb25zLm1vZGlmaWVyfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLm1hc2tDb2xvciA/IGBtYXNrLWNvbG9yPVwiJHtvcHRpb25zLm1hc2tDb2xvcn1cImAgOiAnJ31cbiAgICAgICR7b3B0aW9ucy5pZCA/IGBpZD1cIiR7b3B0aW9ucy5pZH1cImAgOiAnJ31cbiAgICAgICR7b3B0aW9ucy5jbGFzcyA/IGBjbGFzcz1cIiR7b3B0aW9ucy5jbGFzc31cImAgOiAnJ31cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLXNoZWV0XCI+PC9kaXY+XG4gICAgPC9vbnMtYWN0aW9uLXNoZWV0PlxuICBgKTtcblxuICAvLyBSZXNvbHZlIGFjdGlvbiBhbmQgY2xlYW4gdXBcbiAgY29uc3QgZmluaXNoID0gKGV2ZW50LCBpbmRleCA9IC0xKSA9PiB7XG4gICAgaWYgKGFjdGlvblNoZWV0KSB7XG4gICAgICBvcHRpb25zLmRlc3Ryb3kgJiYgb3B0aW9ucy5kZXN0cm95KGFjdGlvblNoZWV0KTtcblxuICAgICAgYWN0aW9uU2hlZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGZpbmlzaCwgZmFsc2UpO1xuICAgICAgYWN0aW9uU2hlZXQucmVtb3ZlKCk7XG4gICAgICBhY3Rpb25TaGVldCA9IG51bGw7XG5cbiAgICAgIG9wdGlvbnMuY2FsbGJhY2sgJiYgb3B0aW9ucy5jYWxsYmFjayhpbmRleCk7XG4gICAgICByZXNvbHZlKGluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTGluayBjYW5jZWwgaGFuZGxlclxuICBhY3Rpb25TaGVldC5hZGRFdmVudExpc3RlbmVyKCdkaWFsb2ctY2FuY2VsJywgZmluaXNoLCBmYWxzZSk7XG5cbiAgLy8gQ3JlYXRlIGJ1dHRvbnMgYW5kIGxpbmsgYWN0aW9uIGhhbmRsZXJcbiAgY29uc3QgYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgb3B0aW9ucy5idXR0b25zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgYnV0dG9uT3B0aW9ucyA9ICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpID8geyBsYWJlbDogaXRlbSB9IDogeyAuLi5pdGVtIH07XG4gICAgaWYgKG9wdGlvbnMuZGVzdHJ1Y3RpdmUgPT09IGluZGV4KSB7XG4gICAgICBidXR0b25PcHRpb25zLm1vZGlmaWVyID0gKGJ1dHRvbk9wdGlvbnMubW9kaWZpZXIgfHwgJycpICsgJyBkZXN0cnVjdGl2ZSc7XG4gICAgfVxuXG4gICAgY29uc3QgYnV0dG9uID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvblxuICAgICAgICAke2J1dHRvbk9wdGlvbnMuaWNvbiA/IGBpY29uPVwiJHtidXR0b25PcHRpb25zLmljb259XCJgIDogJyd9XG4gICAgICAgICR7YnV0dG9uT3B0aW9ucy5tb2RpZmllciA/IGBtb2RpZmllcj1cIiR7YnV0dG9uT3B0aW9ucy5tb2RpZmllcn1cImAgOiAnJ31cbiAgICAgID5cbiAgICAgICAgJHtidXR0b25PcHRpb25zLmxhYmVsfVxuICAgICAgPC9vbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5cbiAgICBgKTtcblxuICAgIGJ1dHRvbi5vbmNsaWNrID0gZXZlbnQgPT4gYWN0aW9uU2hlZXQuaGlkZSgpLnRoZW4oKCkgPT4gZmluaXNoKGV2ZW50LCBpbmRleCkpO1xuICAgIGJ1dHRvbnMuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgfSk7XG5cbiAgLy8gRmluaXNoIGNvbXBvbmVudCBhbmQgYXR0YWNoXG4gIHV0aWwuZmluZENoaWxkKGFjdGlvblNoZWV0LCAnLmFjdGlvbi1zaGVldCcpLmFwcGVuZENoaWxkKGJ1dHRvbnMpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFjdGlvblNoZWV0KTtcbiAgb3B0aW9ucy5jb21waWxlICYmIG9wdGlvbnMuY29tcGlsZShlbC5kaWFsb2cpO1xuXG4gIC8vIFNob3dcbiAgc2V0SW1tZWRpYXRlKCgpID0+IGFjdGlvblNoZWV0LnNob3coe1xuICAgIGFuaW1hdGlvbjogb3B0aW9ucy5hbmltYXRpb24sXG4gICAgYW5pbWF0aW9uT3B0aW9uczogb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gIH0pKTtcbn0pO1xuIiwiLyoqXG4gKiBNaWNyb0V2ZW50IC0gdG8gbWFrZSBhbnkganMgb2JqZWN0IGFuIGV2ZW50IGVtaXR0ZXIgKHNlcnZlciBvciBicm93c2VyKVxuICpcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0ZWx5LCBubyBteXN0ZXJ5LCBubyBtYWdpYyBpbnZvbHZlZFxuICpcbiAqIC0gY3JlYXRlIGEgTWljcm9FdmVudERlYnVnIHdpdGggZ29vZGllcyB0byBkZWJ1Z1xuICogICAtIG1ha2UgaXQgc2FmZXIgdG8gdXNlXG4qL1xuXG4vKiogTk9URTogVGhpcyBsaWJyYXJ5IGlzIGN1c3RvbWl6ZWQgZm9yIE9uc2VuIFVJLiAqL1xuXG5jb25zdCBNaWNyb0V2ZW50ICA9IGZ1bmN0aW9uKCl7fTtcbk1pY3JvRXZlbnQucHJvdG90eXBlICA9IHtcbiAgb246IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2goZmN0KTtcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9mZihldmVudCwgd3JhcHBlcik7XG4gICAgICByZXR1cm4gZmN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB0aGlzLm9uKGV2ZW50LCB3cmFwcGVyKTtcbiAgfSxcbiAgb2ZmOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYgKGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihfZmN0KSB7XG4gICAgICAgIGlmIChmY3QpIHtcbiAgICAgICAgICAgcmV0dXJuIGZjdCAhPT0gX2ZjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9LFxuICBlbWl0OiBmdW5jdGlvbihldmVudCAvKiAsIGFyZ3MuLi4gKi8pe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2V2ZW50c1tldmVudF0ubGVuZ3RoOyBpKyspe1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XVtpXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogbWl4aW4gd2lsbCBkZWxlZ2F0ZSBhbGwgTWljcm9FdmVudC5qcyBmdW5jdGlvbiBpbiB0aGUgZGVzdGluYXRpb24gb2JqZWN0XG4gKlxuICogLSByZXF1aXJlKCdNaWNyb0V2ZW50JykubWl4aW4oRm9vYmFyKSB3aWxsIG1ha2UgRm9vYmFyIGFibGUgdG8gdXNlIE1pY3JvRXZlbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGhlIG9iamVjdCB3aGljaCB3aWxsIHN1cHBvcnQgTWljcm9FdmVudFxuKi9cbk1pY3JvRXZlbnQubWl4aW4gID0gZnVuY3Rpb24oZGVzdE9iamVjdCl7XG4gIHZhciBwcm9wcyA9IFsnb24nLCAnb25jZScsICdvZmYnLCAnZW1pdCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArKyl7XG4gICAgaWYgKHR5cGVvZiBkZXN0T2JqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkZXN0T2JqZWN0LnByb3RvdHlwZVtwcm9wc1tpXV0gID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0T2JqZWN0W3Byb3BzW2ldXSA9IE1pY3JvRXZlbnQucHJvdG90eXBlW3Byb3BzW2ldXTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk1pY3JvRXZlbnQgPSBNaWNyb0V2ZW50O1xuZXhwb3J0IGRlZmF1bHQgTWljcm9FdmVudDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBNaWNyb0V2ZW50IGZyb20gJy4vbWljcm9ldmVudCc7XG5cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IHtcblxuICAvKipcbiAgICogQG9iamVjdCBvbnMub3JpZW50YXRpb25cbiAgICogQGNhdGVnb3J5IHV0aWxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyBmb3Igb3JpZW50YXRpb24gZGV0ZWN0aW9uLlsvZW5dXG4gICAqICAgW2phXeeUu+mdouOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+aknOefpeOBruOBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBpuOBhOOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBjb25zdCBvYmogPSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2VzLlsvZW5dXG4gICAgICogICBbamFd44OH44OQ44Kk44K544Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNQb3J0cmFpdFxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICogICBbamFd54++5Zyo44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjga7loLTlkIjjgat0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAc2lnbmF0dXJlIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgZPjga7jgqTjg5njg7Pjg4jjgYznmbrngavjgZXjgozjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvbmNlXG4gICAgICogQHNpZ25hdHVyZSBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCdzIG9ubHkgdHJpZ2dlcmVkIG9uY2UuWy9lbl1cbiAgICAgKiAgW2phXeS4gOW6puOBoOOBkeWRvOOBs+WHuuOBleOCjOOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHNpZ25hdHVyZSBvZmYoZXZlbnROYW1lLCBbbGlzdGVuZXJdKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLiBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IHNwZWNpZmllZCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgdHlwZSB3aWxsIGJlIHJlbW92ZWQuWy9lbl1cbiAgICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAguOCguOBl+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBquOBi+OBo+OBn+WgtOWQiOOBq+OBr+OAgeOBneOBruOCpOODmeODs+ODiOOBq+e0kOOBpeOBj+WFqOOBpuOBruOCpOODmeODs+ODiOODquOCueODiuODvOOBjOWJiumZpOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd5YmK6Zmk44GZ44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8vIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiB0byBkZXRlY3QgaWYgd2hldGhlciBjdXJyZW50IHNjcmVlbiBpcyBwb3J0cmFpdCBvciBub3RcbiAgICBfaXNQb3J0cmFpdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzUG9ydHJhaXRcbiAgICAgKiBAc2lnbmF0dXJlIGlzUG9ydHJhaXQoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBruWgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUG9ydHJhaXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc0xhbmRzY2FwZVxuICAgICAqIEBzaWduYXR1cmUgaXNMYW5kc2NhcGUoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBtb2RlLlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cbiAgICBpc0xhbmRzY2FwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25ET01Db250ZW50TG9hZGVkLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uRE9NQ29udGVudExvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uKCk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0sXG5cbiAgICBfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIGlmICghKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cub3JpZW50YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSAwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSA5MCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHRoaXMuX2lzUG9ydHJhaXQoKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIGRpbWVuc2lvbnMgdG8gY2hhbmdlIGJlY2F1c2VcbiAgICAgIC8vIG9mIEFuZHJvaWQgaW5jb25zaXN0ZW5jeS5cbiAgICAgIGxldCBuSXRlciA9IDA7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbkl0ZXIrKztcblxuICAgICAgICBjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKChpc1BvcnRyYWl0ICYmIHcgPD0gaCkgfHxcbiAgICAgICAgICAgKCFpc1BvcnRyYWl0ICYmIHcgPj0gaCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAobkl0ZXIgPT09IDUwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCk7XG4gICAgfSxcblxuICAgIC8vIFJ1biBvbiBub3QgbW9iaWxlIGJyb3dzZXIuXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfVxuICB9O1xuXG4gIE1pY3JvRXZlbnQubWl4aW4ob2JqKTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlKCkuX2luaXQoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQG9iamVjdCBvbnMubW9kaWZpZXJcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXRpbGl0eSBtZXRob2RzIHRvIGNoYW5nZSBtb2RpZmllciBhdHRyaWJ1dGVzIG9mIE9uc2VuIFVJIGVsZW1lbnRzLi5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogb25zLm1vZGlmaWVyLmFkZChteU9uc0lucHV0RWxlbWVudCwgJ3VuZGVyYmFyJyk7XG4gKiBvbnMubW9kaWZpZXIudG9nZ2xlKG15T25zVG9hc3RFbGVtZW50LCAnY3VzdG9tLW1vZGlmaWVyJyk7XG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAc2lnbmF0dXJlIGFkZChlbGVtZW50LCBtb2RpZmllciBbLCBtb2RpZmllcl0pXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BZGQgdGhlIHNwZWNpZmllZCBtb2RpZmllcnMgdG8gdGhlIGVsZW1lbnQgaWYgdGhleSBhcmUgbm90IGFscmVhZHkgaW5jbHVkZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGFkZDogKGVsZW1lbnQsIC4uLm1vZGlmaWVycykgPT4gbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4gdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCBtb2RpZmllcikpLFxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVcbiAgICogQHNpZ25hdHVyZSByZW1vdmUoZWxlbWVudCwgbW9kaWZpZXIgWywgbW9kaWZpZXJdKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVtb3ZlIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXJzIGZyb20gdGhlIGVsZW1lbnQgaWYgdGhleSBhcmUgaW5jbHVkZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHJlbW92ZTogKGVsZW1lbnQsIC4uLm1vZGlmaWVycykgPT4gbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4gdXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCBtb2RpZmllcikpLFxuICAvKipcbiAgICogQG1ldGhvZCBjb250YWluc1xuICAgKiBAc2lnbmF0dXJlIGNvbnRhaW5zKGVsZW1lbnQsIG1vZGlmaWVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hlY2sgd2hldGhlciB0aGUgc3BlY2lmaWVkIG1vZGlmaWVyIGlzIGluY2x1ZGVkIGluIHRoZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyXG4gICAqICAgW2VuXU5hbWUgb2YgdGhlIG1vZGlmaWVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgW2VuXWB0cnVlYCB3aGVuIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXIgaXMgZm91bmQgaW4gdGhlIGVsZW1lbnQncyBgbW9kaWZpZXJgIGF0dHJpYnV0ZS4gYGZhbHNlYCBvdGhlcndpc2UuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGNvbnRhaW5zOiB1dGlsLmhhc01vZGlmaWVyLFxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoZWxlbWVudCwgbW9kaWZpZXIgWywgZm9yY2VdKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcmNlXG4gICAqICAgW2VuXUlmIGl0IGV2YWx1YXRlcyB0byB0cnVlLCBhZGQgc3BlY2lmaWVkIG1vZGlmaWVyIHZhbHVlLCBhbmQgaWYgaXQgZXZhbHVhdGVzIHRvIGZhbHNlLCByZW1vdmUgaXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZTogdXRpbC50b2dnbGVNb2RpZmllclxufTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgTWljcm9FdmVudCBmcm9tICcuL21pY3JvZXZlbnQnO1xuXG5jb25zdCBzb2Z0d2FyZUtleWJvYXJkID0gbmV3IE1pY3JvRXZlbnQoKTtcbnNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSBmYWxzZTtcblxuY29uc3Qgb25TaG93ID0gKCkgPT4ge1xuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gdHJ1ZTtcbiAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdzaG93Jyk7XG59O1xuXG5jb25zdCBvbkhpZGUgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSBmYWxzZTtcbiAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdoaWRlJyk7XG59O1xuXG5jb25zdCBiaW5kRXZlbnRzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIEtleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJ0aW5tb3NlL2NvcmRvdmEta2V5Ym9hcmQvYmxvYi85NWYzZGEzYTM4ZDhmOGUxZmE0MWZiZjQwMTQ1MzUyYzEzNTM1YTAwL1JFQURNRS5tZFxuICAgIEtleWJvYXJkLm9uc2hvdyA9IG9uU2hvdztcbiAgICBLZXlib2FyZC5vbmhpZGUgPSBvbkhpZGU7XG4gICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdpbml0Jywge3Zpc2libGU6IEtleWJvYXJkLmlzVmlzaWJsZX0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvcmRvdmEucGx1Z2lucyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZHJpZnR5Y28vaW9uaWMtcGx1Z2lucy1rZXlib2FyZC9ibG9iL2NhMjdlY2YvUkVBRE1FLm1kXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZHNob3cnLCBvblNob3cpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRoaWRlJywgb25IaWRlKTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmlzVmlzaWJsZX0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBub1BsdWdpbkVycm9yID0gKCkgPT4ge1xuICB1dGlsLndhcm4oJ29ucy1rZXlib2FyZDogQ29yZG92YSBLZXlib2FyZCBwbHVnaW4gaXMgbm90IHByZXNlbnQuJyk7XG59O1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgaWYgKCFiaW5kRXZlbnRzKCkpIHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1hY3RpdmVdJykgfHxcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtaW5hY3RpdmVdJykpIHtcbiAgICAgIG5vUGx1Z2luRXJyb3IoKTtcbiAgICB9XG5cbiAgICBzb2Z0d2FyZUtleWJvYXJkLm9uID0gbm9QbHVnaW5FcnJvcjtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNvZnR3YXJlS2V5Ym9hcmQ7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jb25zdCBnZW5lcmF0ZUlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBEb29yIGxvY2tpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ11cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9vckxvY2sge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2xvY2tMaXN0ID0gW107XG4gICAgdGhpcy5fd2FpdExpc3QgPSBbXTtcbiAgICB0aGlzLl9sb2cgPSBvcHRpb25zLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbG9jay5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrIGZvciB1bmxvY2tpbmcuXG4gICAqL1xuICBsb2NrKCkge1xuICAgIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3VubG9jayh1bmxvY2spO1xuICAgIH07XG4gICAgdW5sb2NrLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuX2xvY2tMaXN0LnB1c2godW5sb2NrKTtcbiAgICB0aGlzLl9sb2coJ2xvY2s6ICcgKyAodW5sb2NrLmlkKSk7XG5cbiAgICByZXR1cm4gdW5sb2NrO1xuICB9XG5cbiAgX3VubG9jayhmbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9ja0xpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIGluIHRoZSBsb2NrIGxpc3QuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9sb2coJ3VubG9jazogJyArIGZuLmlkKTtcblxuICAgIHRoaXMuX3RyeVRvRnJlZVdhaXRMaXN0KCk7XG4gIH1cblxuICBfdHJ5VG9GcmVlV2FpdExpc3QoKSB7XG4gICAgd2hpbGUgKCF0aGlzLmlzTG9ja2VkKCkgJiYgdGhpcy5fd2FpdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3YWl0aW5nIHVubG9ja2VkIGRvb3IuXG4gICAqXG4gICAqIEBwYXJhbXMge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBvbiB1bmxvY2tpbmcgdGhlIGRvb3IgY29tcGxldGVseS5cbiAgICovXG4gIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FsbGJhY2sgcGFyYW0gbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tMaXN0Lmxlbmd0aCA+IDA7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuXG4vLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBnbG9iYWwgUGFnZUxvYWRlci5cbmZ1bmN0aW9uIGxvYWRQYWdlKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHBhZ2VFbGVtZW50KTtcblxuICAgIGRvbmUocGFnZUVsZW1lbnQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5sb2FkUGFnZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Ll9kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBlbGVtZW50Ll9kZXN0cm95KCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGFnZUxvYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIFwiZWxlbWVudFwiIHByb3BlcnR5IGFuZCBcInVubG9hZFwiIGZ1bmN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IobG9hZGVyLCB1bmxvYWRlcikge1xuICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gbG9hZGVyIDogbG9hZFBhZ2U7XG4gICAgdGhpcy5fdW5sb2FkZXIgPSB1bmxvYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gdW5sb2FkZXIgOiB1bmxvYWRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcm5hbCBsb2FkZXIgaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICBzZXQgaW50ZXJuYWxMb2FkZXIoZm4pIHtcbiAgICBpZiAoIShmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlciA9IGZuO1xuICB9XG5cbiAgZ2V0IGludGVybmFsTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9wdGlvbnMucGFnZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9wdGlvbnMucGFyZW50IEEgbG9jYXRpb24gdG8gbG9hZCBwYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyYW1zXSBFeHRyYSBwYXJhbWV0ZXJzIGZvciBvbnMtcGFnZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBUYWtlIGFuIG9iamVjdCB0aGF0IGhhcyBcImVsZW1lbnRcIiBwcm9wZXJ0eSBhbmQgXCJ1bmxvYWRcIiBmdW5jdGlvbi5cbiAgICovXG4gIGxvYWQoe3BhZ2UsIHBhcmVudCwgcGFyYW1zID0ge319LCBkb25lKSB7XG4gICAgdGhpcy5fbG9hZGVyKHtwYWdlLCBwYXJlbnQsIHBhcmFtc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgIGlmICghKHBhZ2VFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3BhZ2VFbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgZG9uZShwYWdlRWxlbWVudCk7XG4gICAgfSk7XG4gIH1cblxuICB1bmxvYWQocGFnZUVsZW1lbnQpIHtcbiAgICBpZiAoIShwYWdlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcigncGFnZUVsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX3VubG9hZGVyKHBhZ2VFbGVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhZ2VMb2FkZXIgPSBuZXcgUGFnZUxvYWRlcigpO1xuXG5leHBvcnQgY29uc3QgaW5zdGFudFBhZ2VMb2FkZXIgPSBuZXcgUGFnZUxvYWRlcihcbiAgZnVuY3Rpb24oe3BhZ2UsIHBhcmVudCwgcGFyYW1zID0ge319LCBkb25lKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChwYWdlLnRyaW0oKSk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgZG9uZShlbGVtZW50KTtcbiAgfSxcbiAgdW5sb2FkUGFnZVxuKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cydcbmltcG9ydCBhbmltaXQgZnJvbSAnLi9hbmltaXQnXG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgbm90aWZpY2F0aW9uIGZyb20gJy4vbm90aWZpY2F0aW9uJztcbmltcG9ydCBhY3Rpb25TaGVldCBmcm9tICcuL2FjdGlvbi1zaGVldCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi9vcmllbnRhdGlvbic7XG5pbXBvcnQgbW9kaWZpZXIgZnJvbSAnLi9tb2RpZmllcic7XG5pbXBvcnQgc29mdHdhcmVLZXlib2FyZCBmcm9tICcuL3NvZnR3YXJlLWtleWJvYXJkJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24nO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuL2F1dG9zdHlsZSc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi9kb29ybG9jayc7XG5pbXBvcnQgeyBkZWZhdWx0UGFnZUxvYWRlciwgUGFnZUxvYWRlciB9IGZyb20gJy4vcGFnZS1sb2FkZXInO1xuXG4vKipcbiAqIEBvYmplY3Qgb25zXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtqYV1PbnNlbiBVSeOBp+WIqeeUqOOBp+OBjeOCi+OCsOODreODvOODkOODq+OBquOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiAgIFtlbl1BIGdsb2JhbCBvYmplY3QgdGhhdCdzIHVzZWQgaW4gT25zZW4gVUkuIFsvZW5dXG4gKi9cbmNvbnN0IG9ucyA9IHtcbiAgYW5pbWl0LFxuICBkZWZhdWx0UGFnZUxvYWRlcixcbiAgZWxlbWVudHMsXG4gIEdlc3R1cmVEZXRlY3RvcixcbiAgbW9kaWZpZXIsXG4gIG5vdGlmaWNhdGlvbixcbiAgb3JpZW50YXRpb24sXG4gIHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLFxuICBQYWdlTG9hZGVyLFxuICBwbGF0Zm9ybSxcbiAgc29mdHdhcmVLZXlib2FyZCxcbiAgX2F1dG9TdHlsZTogYXV0b1N0eWxlLFxuICBfaW50ZXJuYWw6IGludGVybmFsLFxuICBfcmVhZHlMb2NrOiBuZXcgRG9vckxvY2soKSxcbiAgX3V0aWw6IHV0aWwsXG59O1xuXG5vbnMucGxhdGZvcm0uc2VsZWN0KCh3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9wbGF0Zm9ybT0oW1xcdy1dKykvKSB8fCBbXSlbMV0pO1xuXG53YWl0RGV2aWNlUmVhZHkoKTtcblxuY29uc3QgcmVhZHlFcnJvciA9IGFmdGVyID0+IHV0aWwudGhyb3coYFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkICR7YWZ0ZXIgPyAnYWZ0ZXInIDogJ2JlZm9yZSd9IG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZWApO1xuXG4vKipcbiAqIEBtZXRob2QgaXNSZWFkeVxuICogQHNpZ25hdHVyZSBpc1JlYWR5KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXeWIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzjgZnjgafjgavliJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNSZWFkeSA9ICgpID0+IHtcbiAgcmV0dXJuICFvbnMuX3JlYWR5TG9jay5pc0xvY2tlZCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzV2ViVmlld1xuICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgcnVubmluZyBpbnNpZGUgQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1dlYlZpZXcgPSBvbnMucGxhdGZvcm0uaXNXZWJWaWV3O1xuXG4vKipcbiAqIEBtZXRob2QgcmVhZHlcbiAqIEBzaWduYXR1cmUgcmVhZHkoY2FsbGJhY2spXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXeOCouODl+ODquOBruWIneacn+WMluOBq+WIqeeUqOOBmeOCi+ODoeOCveODg+ODieOBp+OBmeOAgua4oeOBleOCjOOBn+mWouaVsOOBr+OAgU9uc2VuIFVJ44Gu5Yid5pyf5YyW44GM57WC5LqG44GX44Gm44GE44KL5pmC54K544Gn5b+F44Ga5ZG844Gw44KM44G+44GZ44CCWy9qYV1cbiAqICAgW2VuXU1ldGhvZCB1c2VkIHRvIHdhaXQgZm9yIGFwcCBpbml0aWFsaXphdGlvbi4gV2FpdHMgZm9yIGBET01Db250ZW50TG9hZGVkYCBhbmQgYGRldmljZXJlYWR5YCwgd2hlbiBuZWNlc3NhcnksIGJlZm9yZSBleGVjdXRpbmcgdGhlIGNhbGxiYWNrLlsvZW5dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciBPbnNlbiBVSSBoYXMgYmVlbiBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzliJ3mnJ/ljJbjgYzlrozkuobjgZfjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMucmVhZHkgPSBjYWxsYmFjayA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICBvbnMuX3JlYWR5TG9jay53YWl0VW5sb2NrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXJcbiAqIEBzaWduYXR1cmUgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lcihsaXN0ZW5lcilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHdoZW4gZGV2aWNlIGJhY2sgYnV0dG9uIGlzIHByZXNzZWQuIE11c3QgYmUgY2FsbGVkIG9uIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7PjgYzmirzjgZXjgozjgZ/mmYLjgavlrp/ooYzjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TZXQgZGVmYXVsdCBoYW5kbGVyIGZvciBkZXZpY2UgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOBn+OCgeOBruODh+ODleOCqeODq+ODiOOBruODj+ODs+ODieODqeOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5zZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgaWYgKCFvbnMuaXNSZWFkeSgpKSB7XG4gICAgcmVhZHlFcnJvcih0cnVlKTtcbiAgfVxuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5zZXRMaXN0ZW5lcihsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1EaXNhYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLiBNdXN0IGJlIGNhbGxlZCBvbiBgb25zLnJlYWR5YC5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOBquOBhOOCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFvbnMuaXNSZWFkeSgpKSB7XG4gICAgcmVhZHlFcnJvcih0cnVlKTtcbiAgfVxuICBpbnRlcm5hbC5kYmJEaXNwYXRjaGVyLmRpc2FibGUoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxuICogQHNpZ25hdHVyZSBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1FbmFibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuIE11c3QgYmUgY2FsbGVkIG9uIGBvbnMucmVhZHlgLlsvZW5dXG4gKiBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Kk44OZ44Oz44OI44KS5Y+X44GR5LuY44GR44KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghb25zLmlzUmVhZHkoKSkge1xuICAgIHJlYWR5RXJyb3IodHJ1ZSk7XG4gIH1cbiAgaW50ZXJuYWwuZGJiRGlzcGF0Y2hlci5lbmFibGUoKTtcbn07XG5cbm9ucy5maXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gIGludGVybmFsLmRiYkRpc3BhdGNoZXIuZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIHN0YXR1cyBiYXIgZmlsbCBmZWF0dXJlIG9uIGlPUzcgYW5kIGFib3ZlIChleGNlcHQgZm9yIGlQaG9uZSBYKS4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV1pT1M35Lul5LiK77yIaVBob25lIFjjga/pmaTjgY/vvInjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgcmVhZHlFcnJvcihmYWxzZSk7XG4gIH1cbiAgaW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZSAoZXhjZXB0IGZvciBpUGhvbmUgWCkuIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBgb25zLnJlYWR5YC5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iu+8iGlQaG9uZSBY44Gv6Zmk44GP77yJ44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS54Sh5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICByZWFkeUVycm9yKGZhbHNlKTtcbiAgfVxuICBpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBtb2NrU3RhdHVzQmFyXG4gKiBAc2lnbmF0dXJlIG1vY2tTdGF0dXNCYXIoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGVzIGEgc3RhdGljIGVsZW1lbnQgc2ltaWxhciB0byBpT1Mgc3RhdHVzIGJhci4gT25seSB1c2VmdWwgZm9yIGJyb3dzZXIgdGVzdGluZy4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMubW9ja1N0YXR1c0JhciA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICByZWFkeUVycm9yKGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IG1vY2sgPSAoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5ib2R5LmNoaWxkcmVuWzBdIHx8ICFkb2N1bWVudC5ib2R5LmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnb25zLXN0YXR1cy1iYXItbW9jaycpKSB7XG4gICAgICBjb25zdCBhbmRyb2lkID0gcGxhdGZvcm0uaXNBbmRyb2lkKCksIGkgPSBpID0+IGA8aSBjbGFzcz1cIiR7aS5zcGxpdCgnLScpWzBdfSAke2l9XCI+PC9pPmA7XG4gICAgICBjb25zdCBsZWZ0ID0gYW5kcm9pZCA/IGAke2koJ3ptZGktdHdpdHRlcicpfSAke2koJ3ptZGktZ29vZ2xlLXBsYXknKX1gIDogYE5vIFNJTSAke2koJ2ZhLXdpZmknKX1gLFxuICAgICAgICBjZW50ZXIgPSBhbmRyb2lkID8gJycgOiAnMTI6MjggUE0nLFxuICAgICAgICByaWdodCA9IGFuZHJvaWQgPyBgJHtpKCd6bWRpLW5ldHdvcmsnKX0gJHtpKCd6bWRpLXdpZmknKX0gJHtpKCd6bWRpLWJhdHRlcnknKX0gMTI6MjggUE1gIDogYDgwJSAke2koJ2ZhLWJhdHRlcnktdGhyZWUtcXVhcnRlcnMnKX1gO1xuXG4gICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZSh1dGlsLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIGA8ZGl2IGNsYXNzPVwib25zLXN0YXR1cy1iYXItbW9jayAke2FuZHJvaWQgPyAnYW5kcm9pZCcgOiAnaW9zJ31cIj5gICtcbiAgICAgICAgICBgPGRpdj4ke2xlZnR9PC9kaXY+PGRpdj4ke2NlbnRlcn08L2Rpdj48ZGl2PiR7cmlnaHR9PC9kaXY+YCArXG4gICAgICAgIGA8L2Rpdj5gXG4gICAgICApLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICBkb2N1bWVudC5ib2R5XG4gICAgPyBtb2NrKClcbiAgICA6IGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKG1vY2spO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBbmltYXRpb25zXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBbmltYXRpb25zKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBhbGwgYW5pbWF0aW9ucy4gQ291bGQgYmUgaGFuZHkgZm9yIHRlc3RpbmcgYW5kIG9sZGVyIGRldmljZXMuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuWFqOOBpueEoeWKueOBq+OBl+OBvuOBmeOAguODhuOCueODiOOBrumam+OBq+S+v+WIqeOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQW5pbWF0aW9uc1xuICogQHNpZ25hdHVyZSBlbmFibGVBbmltYXRpb25zKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGFuaW1hdGlvbnMgKGRlZmF1bHQpLlsvZW5dXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxub25zLl9kaXNhYmxlV2FybmluZ3MgPSAoKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy53YXJuaW5nc0Rpc2FibGVkID0gdHJ1ZTtcbn07XG5cbm9ucy5fZW5hYmxlV2FybmluZ3MgPSAoKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy53YXJuaW5nc0Rpc2FibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBdXRvU3R5bGluZygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgYXV0b21hdGljIHN0eWxpbmcuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQXV0b1N0eWxpbmcgPSBhdXRvU3R5bGUuZGlzYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGF1dG9tYXRpYyBzdHlsaW5nIGJhc2VkIG9uIE9TIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdHlsaW5nID0gYXV0b1N0eWxlLmVuYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVJY29uQXV0b1ByZWZpeFxuICogQHNpZ25hdHVyZSBkaXNhYmxlSWNvbkF1dG9QcmVmaXgoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFkZGluZyBgZmEtYCBwcmVmaXggYXV0b21hdGljYWxseSB0byBgb25zLWljb25gIGNsYXNzZXMuIFVzZWZ1bCB3aGVuIGluY2x1ZGluZyBjdXN0b20gaWNvbiBwYWNrcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmRpc2FibGVJY29uQXV0b1ByZWZpeCA9ICgpID0+IHtcbiAgdXRpbC5jaGVja01pc3NpbmdJbXBvcnQoJ0ljb24nKTtcbiAgZWxlbWVudHMuSWNvbi5zZXRBdXRvUHJlZml4KGZhbHNlKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBmb3JjZVVJV2ViVmlld1Njcm9sbEZpeFxuICogQHNpZ25hdHVyZSBmb3JjZVVJV2ViVmlld1Njcm9sbEZpeCgpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBmaXguXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUFwcGxpZXMgYSBmaXggZm9yIGlPUyBVSVdlYlZpZXcgd2hpY2ggcHJldmVudHMgc2Nyb2xsIGV2ZW50cyBqdW1waW5nIHRvIHBhZ2VzIHVuZGVyIHRoZSB0b3AgbGF5ZXIuIFRoaXMgbWF5IHZpc3VhbGx5IGFmZmVjdCBub3JtYWwgc2Nyb2xsaW5nIG9mIFVJV2ViVmlldyBpZiB5b3Ugb3BlbiBhIGRpYWxvZy9tZW51IGJlZm9yZSB0aGUgc2Nyb2xsIG1vbWVudHVtIGZpbmlzaGVkLiBEaXNhYmxlZCBieSBkZWZhdWx0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZm9yY2VVSVdlYlZpZXdTY3JvbGxGaXggPSAoZm9yY2UgPSB0cnVlKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy5mb3JjZVVJV2ViVmlld1Njcm9sbEZpeCA9IGZvcmNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGZvcmNlUGxhdGZvcm1TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGZvcmNlUGxhdGZvcm1TdHlsaW5nKHBsYXRmb3JtKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZWZyZXNoIHN0eWxpbmcgZm9yIHRoZSBnaXZlbiBwbGF0Zm9ybS4gT25seSB1c2VmdWwgZm9yIGRlbW9zLiBVc2UgYG9ucy5wbGF0Zm9ybS5zZWxlY3QoLi4uKWAgaW5zdGVhZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm0gTmV3IHBsYXRmb3JtIHRvIHN0eWxlIHRoZSBlbGVtZW50cy5cbiAqL1xub25zLmZvcmNlUGxhdGZvcm1TdHlsaW5nID0gbmV3UGxhdGZvcm0gPT4ge1xuICBvbnMuZW5hYmxlQXV0b1N0eWxpbmcoKTtcbiAgb25zLnBsYXRmb3JtLnNlbGVjdChuZXdQbGF0Zm9ybSB8fCAnaW9zJyk7XG5cbiAgb25zLl91dGlsLmFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWlmJykge1xuICAgICAgICBlbGVtZW50Ll9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUubWF0Y2goL15vbnMtL2kpKSB7XG4gICAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBwcmVsb2FkXG4gKiBAc2lnbmF0dXJlIHByZWxvYWQodGVtcGxhdGVQYXRocylcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0ZW1wbGF0ZVBhdGhzXG4gKiAgIFtlbl1TZXQgb2YgSFRNTCBmaWxlIHBhdGhzIGNvbnRhaW5pbmcgJ29ucy1wYWdlJyBlbGVtZW50cy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgdGhlIHRlbXBsYXRlcyBhcmUgY2FjaGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TZXBhcmF0ZWQgZmlsZXMgbmVlZCB0byBiZSByZXF1ZXN0ZWQgb24gZGVtYW5kIGFuZCB0aGlzIGNhbiBzbGlnaHRseSBkZWxheSBwdXNoaW5nIG5ldyBwYWdlcy4gVGhpcyBtZXRob2QgcmVxdWVzdHMgYW5kIGNhY2hlcyB0ZW1wbGF0ZXMgZm9yIGxhdGVyIHVzZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLnByZWxvYWQgPSBmdW5jdGlvbih0ZW1wbGF0ZXMgPSBbXSkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoKHRlbXBsYXRlcyBpbnN0YW5jZW9mIEFycmF5ID8gdGVtcGxhdGVzIDogW3RlbXBsYXRlc10pLm1hcCh0ZW1wbGF0ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHV0aWwudGhyb3coJ0V4cGVjdGVkIHN0cmluZyBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZW9mIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHRlbXBsYXRlKTtcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZUVsZW1lbnRcbiAqIEBzaWduYXR1cmUgY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICogICBbZW5dRWl0aGVyIGFuIEhUTUwgZmlsZSBwYXRoLCBhIGA8dGVtcGxhdGU+YCBpZCBvciBhbiBIVE1MIHN0cmluZyBzdWNoIGFzIGAnPGRpdiBpZD1cImZvb1wiPmhvZ2U8L2Rpdj4nYC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW58SFRNTEVsZW1lbnR9IFtvcHRpb25zLmFwcGVuZF1cbiAqICAgW2VuXVdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50IHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkIHRvIHRoZSBET00uICBEZWZhdWx0cyB0byBgZmFsc2VgLiBJZiBgdHJ1ZWAgdmFsdWUgaXMgZ2l2ZW4sIGBkb2N1bWVudC5ib2R5YCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRhcmdldC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLmluc2VydEJlZm9yZV1cbiAqICAgW2VuXVJlZmVyZW5jZSBub2RlIHRoYXQgYmVjb21lcyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBuZXcgbm9kZSAoYG9wdGlvbnMuYXBwZW5kYCBlbGVtZW50KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fFByb21pc2V9XG4gKiAgIFtlbl1JZiB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgd2FzIGFuIGlubGluZSBIVE1MIHN0cmluZywgaXQgcmV0dXJucyB0aGUgbmV3IGVsZW1lbnQuIE90aGVyd2lzZSwgaXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbmV3IGVsZW1lbnQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIG5ldyBlbGVtZW50IGZyb20gYSB0ZW1wbGF0ZS4gQm90aCBpbmxpbmUgSFRNTCBhbmQgZXh0ZXJuYWwgZmlsZXMgYXJlIHN1cHBvcnRlZCBhbHRob3VnaCB0aGUgcmV0dXJuIHZhbHVlIGRpZmZlcnMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5jcmVhdGVFbGVtZW50ID0gKHRlbXBsYXRlLCBvcHRpb25zID0ge30pID0+IHtcbiAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS50cmltKCk7XG5cbiAgY29uc3QgY3JlYXRlID0gaHRtbCA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5hcHBlbmQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMuYXBwZW5kIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBvcHRpb25zLmFwcGVuZCA6IGRvY3VtZW50LmJvZHk7XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG9wdGlvbnMuaW5zZXJ0QmVmb3JlIHx8IG51bGwpO1xuICAgICAgb3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb3B0aW9ucy5saW5rKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9O1xuXG4gIHJldHVybiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICc8JyA/IGNyZWF0ZSh0ZW1wbGF0ZSkgOiBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHRlbXBsYXRlKS50aGVuKGNyZWF0ZSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlUG9wb3ZlclxuICogQHNpZ25hdHVyZSBjcmVhdGVQb3BvdmVyKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGEgPHRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50U2NvcGVdXG4gKiAgIFtlbl1QYXJlbnQgc2NvcGUgb2YgdGhlIGRpYWxvZy4gVXNlZCB0byBiaW5kIG1vZGVscyBhbmQgYWNjZXNzIHNjb3BlIG1ldGhvZHMgZnJvbSB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIHBvcG92ZXIgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlRGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZURpYWxvZyhwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiBgPHRlbXBsYXRlPmAgY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9gPHRlbXBsYXRlPmDjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZUFsZXJ0RGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZUFsZXJ0RGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIGA8dGVtcGxhdGU+YCBjb250YWluaW5nIGEgPG9ucy1hbGVydC1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgYWxlcnQgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBhbGVydCBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuY3JlYXRlUG9wb3ZlciA9IG9ucy5jcmVhdGVEaWFsb2cgPSBvbnMuY3JlYXRlQWxlcnREaWFsb2cgPSAodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkgPT4gb25zLmNyZWF0ZUVsZW1lbnQodGVtcGxhdGUsIHsgYXBwZW5kOiB0cnVlLCAuLi5vcHRpb25zIH0pO1xuXG4vKipcbiAqIEBtZXRob2Qgb3BlbkFjdGlvblNoZWV0XG4gKiBAc2lnbmF0dXJlIG9wZW5BY3Rpb25TaGVldChvcHRpb25zKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TaG93cyBhbiBpbnN0YW50IEFjdGlvbiBTaGVldCBhbmQgbGV0cyB0aGUgdXNlciBjaG9vc2UgYW4gYWN0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmJ1dHRvbnNdXG4gKiAgIFtlbl1SZXByZXNlbnQgZWFjaCBidXR0b24gb2YgdGhlIGFjdGlvbiBzaGVldCBmb2xsb3dpbmcgdGhlIHNwZWNpZmllZCBvcmRlci4gRXZlcnkgaXRlbSBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIGxhYmVsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGBsYWJlbGAsIGBpY29uYCBhbmQgYG1vZGlmaWVyYCBwcm9wZXJ0aWVzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxuICogICBbZW5dT3B0aW9uYWwgdGl0bGUgZm9yIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVzdHJ1Y3RpdmVdXG4gKiAgIFtlbl1PcHRpb25hbCBpbmRleCBvZiB0aGUgXCJkZXN0cnVjdGl2ZVwiIGJ1dHRvbiAob25seSBmb3IgaU9TKS4gSXQgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYnV0dG9uIGFycmF5IGFzIHdlbGwuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbGFibGVdXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBhY3Rpb24gc2hlZXQgY2FuIGJlIGNhbmNlbGVkIGJ5IHRhcHBpbmcgb24gdGhlIGJhY2tncm91bmQgbWFzayBvciBub3QuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBhdHRyaWJ1dGUgb2YgdGhlIGFjdGlvbiBzaGVldC4gRS5nLiBgJ2Rlc3RydWN0aXZlJ2AuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFza0NvbG9yXVxuICogICBbZW5dT3B0aW9uYWxseSBjaGFuZ2UgdGhlIGJhY2tncm91bmQgbWFzayBjb2xvci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBlbGVtZW50J3MgaWQgYXR0cmlidXRlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsYXNzXVxuICogICBbZW5dVGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHdoZW4gdGhlIGFjdGlvbiBzaGVldCBpcyBjbG9zZWQuIFRoZSByZXNvbHZlIHZhbHVlIGlzIGVpdGhlciB0aGUgaW5kZXggb2YgdGhlIHRhcHBlZCBidXR0b24gb3IgLTEgd2hlbiBjYW5jZWxlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLm9wZW5BY3Rpb25TaGVldCA9IGFjdGlvblNoZWV0O1xuXG4vKipcbiAqIEBtZXRob2QgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlclxuICogQHNpZ25hdHVyZSByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKHBhZ2UpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhIGA8dGVtcGxhdGU+YCBpZC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSWYgbm8gcGFnZSBpcyBkZWZpbmVkIGZvciB0aGUgYG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgaXQgd2lsbCB3YWl0IGZvciB0aGlzIG1ldGhvZCBiZWluZyBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1sb2FkaW5nLXBsYWNlaG9sZGVy44Gu5bGe5oCn5YCk44Go44GX44Gm44Oa44O844K444GM5oyH5a6a44GV44KM44Gm44GE44Gq44GE5aC05ZCI44Gv44CB44Oa44O844K444Ot44O844OJ5YmN44Gr5ZG844Gw44KM44KLb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXLlh6bnkIbjgYzooYzjgo/jgozjgovjgb7jgafooajnpLrjgZXjgozjgb7jgZvjgpPjgIJbL2phXVxuICovXG5vbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IChwYWdlLCBsaW5rKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHV0aWwudGhyb3coJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cycpO1xuICB9XG5cbiAgZWxlbWVudHNcbiAgICAuZmlsdGVyKGVsZW1lbnQgPT4gIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwYWdlJykpXG4gICAgLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnb25zLWxvYWRpbmctcGxhY2Vob2xkZXInLCBwYWdlKTtcbiAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlLCBsaW5rKTtcbiAgICB9KTtcbn07XG5cblxub25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMgPSBmdW5jdGlvbigpIHtcbiAgb25zLnJlYWR5KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgcGFnZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicpO1xuICAgICAgaWYgKHR5cGVvZiBwYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxub25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24ocGFyZW50LCBwYWdlLCBsaW5rID0gKChlbCwgZG9uZSkgPT4gZG9uZSgpKSkge1xuICBwYWdlICYmIG9ucy5jcmVhdGVFbGVtZW50KHBhZ2UpXG4gICAgLnRoZW4oZWxlbWVudCA9PiB7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICBsaW5rKGVsZW1lbnQsICgpID0+IHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIH0pO1xuICAgIH0pXG4gICAgLmNhdGNoKGVycm9yID0+IFByb21pc2UucmVqZWN0KCdVbmFibGVkIHRvIHJlc29sdmUgcGxhY2Vob2xkZXI6ICcgKyBlcnJvcikpO1xufTtcblxuZnVuY3Rpb24gd2FpdERldmljZVJlYWR5KCkge1xuICBjb25zdCB1bmxvY2tEZXZpY2VSZWFkeSA9IG9ucy5fcmVhZHlMb2NrLmxvY2soKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgaWYgKG9ucy5pc1dlYlZpZXcoKSkge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgdW5sb2NrRGV2aWNlUmVhZHksIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5sb2NrRGV2aWNlUmVhZHkoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBAbWV0aG9kIGdldFNjcmlwdFBhZ2VcbiAqIEBzaWduYXR1cmUgZ2V0U2NyaXB0UGFnZSgpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUFjY2VzcyB0aGUgbGFzdCBjcmVhdGVkIHBhZ2UgZnJvbSB0aGUgY3VycmVudCBgc2NyaXB0YCBzY29wZS4gT25seSB3b3JrcyBpbnNpZGUgYDxzY3JpcHQ+PC9zY3JpcHQ+YCB0YWdzIHRoYXQgYXJlIGRpcmVjdCBjaGlsZHJlbiBvZiBgb25zLXBhZ2VgIGVsZW1lbnQuIFVzZSB0aGlzIHRvIGFkZCBsaWZlY3ljbGUgaG9va3MgdG8gYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKiAgIFtlbl1SZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhZ2UgZWxlbWVudC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuY29uc3QgZ2V0Q1MgPSAnY3VycmVudFNjcmlwdCcgaW4gZG9jdW1lbnQgPyAoKSA9PiBkb2N1bWVudC5jdXJyZW50U2NyaXB0IDogKCkgPT4gZG9jdW1lbnQuc2NyaXB0c1tkb2N1bWVudC5zY3JpcHRzLmxlbmd0aCAtIDFdO1xub25zLmdldFNjcmlwdFBhZ2UgPSAoKSA9PiBnZXRDUygpICYmIC9vbnMtcGFnZS9pLnRlc3QoZ2V0Q1MoKS5wYXJlbnRFbGVtZW50LnRhZ05hbWUpICYmIGdldENTKCkucGFyZW50RWxlbWVudCB8fCBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBvbnM7XG4iLCI7KGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8qKlxuXHQgKiBAcHJlc2VydmUgRmFzdENsaWNrOiBwb2x5ZmlsbCB0byByZW1vdmUgY2xpY2sgZGVsYXlzIG9uIGJyb3dzZXJzIHdpdGggdG91Y2ggVUlzLlxuXHQgKlxuXHQgKiBAY29kaW5nc3RhbmRhcmQgZnRsYWJzLWpzdjJcblx0ICogQGNvcHlyaWdodCBUaGUgRmluYW5jaWFsIFRpbWVzIExpbWl0ZWQgW0FsbCBSaWdodHMgUmVzZXJ2ZWRdXG5cdCAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChzZWUgTElDRU5TRS50eHQpXG5cdCAqL1xuXG5cdC8qanNsaW50IGJyb3dzZXI6dHJ1ZSwgbm9kZTp0cnVlKi9cblx0LypnbG9iYWwgZGVmaW5lLCBFdmVudCwgTm9kZSovXG5cblxuXHQvKipcblx0ICogSW5zdGFudGlhdGUgZmFzdC1jbGlja2luZyBsaXN0ZW5lcnMgb24gdGhlIHNwZWNpZmllZCBsYXllci5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0ZnVuY3Rpb24gRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0dmFyIG9sZE9uQ2xpY2s7XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgYSBjbGljayBpcyBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIGJvb2xlYW5cblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGltZXN0YW1wIGZvciB3aGVuIGNsaWNrIHRyYWNraW5nIHN0YXJ0ZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlbGVtZW50IGJlaW5nIHRyYWNrZWQgZm9yIGEgY2xpY2suXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFdmVudFRhcmdldFxuXHRcdCAqL1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFgtY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFggPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBZLWNvb3JkaW5hdGUgb2YgdG91Y2ggc3RhcnQgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogSUQgb2YgdGhlIGxhc3QgdG91Y2gsIHJldHJpZXZlZCBmcm9tIFRvdWNoLmlkZW50aWZpZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUb3VjaG1vdmUgYm91bmRhcnksIGJleW9uZCB3aGljaCBhIGNsaWNrIHdpbGwgYmUgY2FuY2VsbGVkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaEJvdW5kYXJ5ID0gb3B0aW9ucy50b3VjaEJvdW5kYXJ5IHx8IDEwO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaGUgRmFzdENsaWNrIGxheWVyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgRWxlbWVudFxuXHRcdCAqL1xuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIHRpbWUgYmV0d2VlbiB0YXAodG91Y2hzdGFydCBhbmQgdG91Y2hlbmQpIGV2ZW50c1xuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBEZWxheSA9IG9wdGlvbnMudGFwRGVsYXkgfHwgMjAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gdGltZSBmb3IgYSB0YXBcblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudGFwVGltZW91dCA9IG9wdGlvbnMudGFwVGltZW91dCB8fCA3MDA7XG5cblx0XHRpZiAoRmFzdENsaWNrLm5vdE5lZWRlZChsYXllcikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBBbmRyb2lkIGRvbid0IGhhdmUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcblx0XHRmdW5jdGlvbiBiaW5kKG1ldGhvZCwgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7IH07XG5cdFx0fVxuXG5cblx0XHR2YXIgbWV0aG9kcyA9IFsnb25Nb3VzZScsICdvbkNsaWNrJywgJ29uVG91Y2hTdGFydCcsICdvblRvdWNoTW92ZScsICdvblRvdWNoRW5kJywgJ29uVG91Y2hDYW5jZWwnXTtcblx0XHR2YXIgY29udGV4dCA9IHRoaXM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtZXRob2RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y29udGV4dFttZXRob2RzW2ldXSA9IGJpbmQoY29udGV4dFttZXRob2RzW2ldXSwgY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIGV2ZW50IGhhbmRsZXJzIGFzIHJlcXVpcmVkXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblxuXHRcdC8vIEhhY2sgaXMgcmVxdWlyZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdC8vIHdoaWNoIGlzIGhvdyBGYXN0Q2xpY2sgbm9ybWFsbHkgc3RvcHMgY2xpY2sgZXZlbnRzIGJ1YmJsaW5nIHRvIGNhbGxiYWNrcyByZWdpc3RlcmVkIG9uIHRoZSBGYXN0Q2xpY2tcblx0XHQvLyBsYXllciB3aGVuIHRoZXkgYXJlIGNhbmNlbGxlZC5cblx0XHRpZiAoIUV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgcm12ID0gTm9kZS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRybXYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgY2FwdHVyZSkge1xuXHRcdFx0XHR2YXIgYWR2ID0gTm9kZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2suaGlqYWNrZWQgfHwgKGNhbGxiYWNrLmhpamFja2VkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGlmICghZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGV2ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSwgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWR2LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBJZiBhIGhhbmRsZXIgaXMgYWxyZWFkeSBkZWNsYXJlZCBpbiB0aGUgZWxlbWVudCdzIG9uY2xpY2sgYXR0cmlidXRlLCBpdCB3aWxsIGJlIGZpcmVkIGJlZm9yZVxuXHRcdC8vIEZhc3RDbGljaydzIG9uQ2xpY2sgaGFuZGxlci4gRml4IHRoaXMgYnkgcHVsbGluZyBvdXQgdGhlIHVzZXItZGVmaW5lZCBoYW5kbGVyIGZ1bmN0aW9uIGFuZFxuXHRcdC8vIGFkZGluZyBpdCBhcyBsaXN0ZW5lci5cblx0XHRpZiAodHlwZW9mIGxheWVyLm9uY2xpY2sgPT09ICdmdW5jdGlvbicpIHtcblxuXHRcdFx0Ly8gQW5kcm9pZCBicm93c2VyIG9uIGF0IGxlYXN0IDMuMiByZXF1aXJlcyBhIG5ldyByZWZlcmVuY2UgdG8gdGhlIGZ1bmN0aW9uIGluIGxheWVyLm9uY2xpY2tcblx0XHRcdC8vIC0gdGhlIG9sZCBvbmUgd29uJ3Qgd29yayBpZiBwYXNzZWQgdG8gYWRkRXZlbnRMaXN0ZW5lciBkaXJlY3RseS5cblx0XHRcdG9sZE9uQ2xpY2sgPSBsYXllci5vbmNsaWNrO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRvbGRPbkNsaWNrKGV2ZW50KTtcblx0XHRcdH0sIGZhbHNlKTtcblx0XHRcdGxheWVyLm9uY2xpY2sgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIFdpbmRvd3MgUGhvbmUgOC4xIGZha2VzIHVzZXIgYWdlbnQgc3RyaW5nIHRvIGxvb2sgbGlrZSBBbmRyb2lkIGFuZCBpUGhvbmUuXG5cdCpcblx0KiBAdHlwZSBib29sZWFuXG5cdCovXG5cdHZhciBkZXZpY2VJc1dpbmRvd3NQaG9uZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIldpbmRvd3MgUGhvbmVcIikgPj0gMDtcblxuXHQvKipcblx0ICogQW5kcm9pZCByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgPiAwICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TID0gL2lQKGFkfGhvbmV8b2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFkZXZpY2VJc1dpbmRvd3NQaG9uZTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNCByZXF1aXJlcyBhbiBleGNlcHRpb24gZm9yIHNlbGVjdCBlbGVtZW50cy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzSU9TNCA9IGRldmljZUlzSU9TICYmICgvT1MgNF9cXGQoX1xcZCk/LykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXG5cdC8qKlxuXHQgKiBpT1MgNi4wLTcuKiByZXF1aXJlcyB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gYmUgbWFudWFsbHkgZGVyaXZlZFxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyBbNi03XV9cXGQvKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdC8qKlxuXHQgKiBCbGFja0JlcnJ5IHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0JsYWNrQmVycnkxMCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQkIxMCcpID4gMDtcblxuXHQvKipcblx0ICogVmFsaWQgdHlwZXMgZm9yIHRleHQgaW5wdXRzXG5cdCAqXG5cdCAqIEB0eXBlIGFycmF5XG5cdCAqL1xuXHR2YXIgdGV4dEZpZWxkcyA9IFsnZW1haWwnLCAnbnVtYmVyJywgJ3Bhc3N3b3JkJywgJ3NlYXJjaCcsICd0ZWwnLCAndGV4dCcsICd1cmwnXTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgbmF0aXZlIGNsaWNrLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBuZWVkcyBhIG5hdGl2ZSBjbGlja1xuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0NsaWNrID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2VuZCBhIHN5bnRoZXRpYyBjbGljayB0byBkaXNhYmxlZCBpbnB1dHMgKGlzc3VlICM2Milcblx0XHRjYXNlICdidXR0b24nOlxuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0aWYgKHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaW5wdXQnOlxuXG5cdFx0XHQvLyBGaWxlIGlucHV0cyBuZWVkIHJlYWwgY2xpY2tzIG9uIGlPUyA2IGR1ZSB0byBhIGJyb3dzZXIgYnVnIChpc3N1ZSAjNjgpXG5cdFx0XHRpZiAoKGRldmljZUlzSU9TICYmIHRhcmdldC50eXBlID09PSAnZmlsZScpIHx8IHRhcmdldC5kaXNhYmxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbGFiZWwnOlxuXHRcdGNhc2UgJ2lmcmFtZSc6IC8vIGlPUzggaG9tZXNjcmVlbiBhcHBzIGNhbiBwcmV2ZW50IGV2ZW50cyBidWJibGluZyBpbnRvIGZyYW1lc1xuXHRcdGNhc2UgJ3ZpZGVvJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiAoL1xcYm5lZWRzY2xpY2tcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgY2xpY2sgaW50byBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldCBUYXJnZXQgRE9NIGVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCByZXF1aXJlcyBhIGNhbGwgdG8gZm9jdXMgdG8gc2ltdWxhdGUgbmF0aXZlIGNsaWNrLlxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5uZWVkc0ZvY3VzID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0c3dpdGNoICh0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuXHRcdGNhc2UgJ3RleHRhcmVhJzpcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGNhc2UgJ3NlbGVjdCc6XG5cdFx0XHRyZXR1cm4gIWRldmljZUlzQW5kcm9pZDtcblx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRzd2l0Y2ggKHRhcmdldC50eXBlKSB7XG5cdFx0XHRjYXNlICdidXR0b24nOlxuXHRcdFx0Y2FzZSAnY2hlY2tib3gnOlxuXHRcdFx0Y2FzZSAnZmlsZSc6XG5cdFx0XHRjYXNlICdpbWFnZSc6XG5cdFx0XHRjYXNlICdyYWRpbyc6XG5cdFx0XHRjYXNlICdzdWJtaXQnOlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vIHBvaW50IGluIGF0dGVtcHRpbmcgdG8gZm9jdXMgZGlzYWJsZWQgaW5wdXRzXG5cdFx0XHRyZXR1cm4gIXRhcmdldC5kaXNhYmxlZCAmJiAhdGFyZ2V0LnJlYWRPbmx5O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gKC9cXGJuZWVkc2ZvY3VzXFxiLykudGVzdCh0YXJnZXQuY2xhc3NOYW1lKTtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogU2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnNlbmRDbGljayA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQsIGV2ZW50KSB7XG5cdFx0dmFyIGNsaWNrRXZlbnQsIHRvdWNoO1xuXG5cdFx0Ly8gT24gc29tZSBBbmRyb2lkIGRldmljZXMgYWN0aXZlRWxlbWVudCBuZWVkcyB0byBiZSBibHVycmVkIG90aGVyd2lzZSB0aGUgc3ludGhldGljIGNsaWNrIHdpbGwgaGF2ZSBubyBlZmZlY3QgKCMyNClcblx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0YXJnZXRFbGVtZW50KSB7XG5cdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcblx0XHR9XG5cblx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0Ly8gU3ludGhlc2lzZSBhIGNsaWNrIGV2ZW50LCB3aXRoIGFuIGV4dHJhIGF0dHJpYnV0ZSBzbyBpdCBjYW4gYmUgdHJhY2tlZFxuXHRcdGNsaWNrRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0XHRjbGlja0V2ZW50LmluaXRNb3VzZUV2ZW50KHRoaXMuZGV0ZXJtaW5lRXZlbnRUeXBlKHRhcmdldEVsZW1lbnQpLCB0cnVlLCB0cnVlLCB3aW5kb3csIDEsIHRvdWNoLnNjcmVlblgsIHRvdWNoLnNjcmVlblksIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcblx0XHRjbGlja0V2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQgPSB0cnVlO1xuXHRcdHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcblx0fTtcblxuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRldGVybWluZUV2ZW50VHlwZSA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblxuXHRcdC8vSXNzdWUgIzE1OTogQW5kcm9pZCBDaHJvbWUgU2VsZWN0IEJveCBkb2VzIG5vdCBvcGVuIHdpdGggYSBzeW50aGV0aWMgY2xpY2sgZXZlbnRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkICYmIHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xuXHRcdFx0cmV0dXJuICdtb3VzZWRvd24nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnY2xpY2snO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgbGVuZ3RoO1xuXG5cdFx0Ly8gSXNzdWUgIzE2MDogb24gaU9TIDcsIHNvbWUgaW5wdXQgZWxlbWVudHMgKGUuZy4gZGF0ZSBkYXRldGltZSBtb250aCkgdGhyb3cgYSB2YWd1ZSBUeXBlRXJyb3Igb24gc2V0U2VsZWN0aW9uUmFuZ2UuIFRoZXNlIGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gaW50ZWdlciB2YWx1ZSBmb3IgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgcHJvcGVydGllcywgYnV0IHVuZm9ydHVuYXRlbHkgdGhhdCBjYW4ndCBiZSB1c2VkIGZvciBkZXRlY3Rpb24gYmVjYXVzZSBhY2Nlc3NpbmcgdGhlIHByb3BlcnRpZXMgYWxzbyB0aHJvd3MgYSBUeXBlRXJyb3IuIEp1c3QgY2hlY2sgdGhlIHR5cGUgaW5zdGVhZC4gRmlsZWQgYXMgQXBwbGUgYnVnICMxNTEyMjcyNC5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSAmJiB0YXJnZXRFbGVtZW50LnR5cGUuaW5kZXhPZignZGF0ZScpICE9PSAwICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ3RpbWUnICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ21vbnRoJyAmJiB0YXJnZXRFbGVtZW50LnR5cGUgIT09ICdlbWFpbCcgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbnVtYmVyJykge1xuXHRcdFx0bGVuZ3RoID0gdGFyZ2V0RWxlbWVudC52YWx1ZS5sZW5ndGg7XG5cdFx0XHR0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciBhbmQgaWYgc28sIHNldCBhIGZsYWcgb24gaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS51cGRhdGVTY3JvbGxQYXJlbnQgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50KSB7XG5cdFx0dmFyIHNjcm9sbFBhcmVudCwgcGFyZW50RWxlbWVudDtcblxuXHRcdHNjcm9sbFBhcmVudCA9IHRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBkaXNjb3ZlciB3aGV0aGVyIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgc2Nyb2xsYWJsZSBsYXllci4gUmUtY2hlY2sgaWYgdGhlXG5cdFx0Ly8gdGFyZ2V0IGVsZW1lbnQgd2FzIG1vdmVkIHRvIGFub3RoZXIgcGFyZW50LlxuXHRcdGlmICghc2Nyb2xsUGFyZW50IHx8ICFzY3JvbGxQYXJlbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdHBhcmVudEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAocGFyZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBwYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodCkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSBwYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdH0gd2hpbGUgKHBhcmVudEVsZW1lbnQpO1xuXHRcdH1cblxuXHRcdC8vIEFsd2F5cyB1cGRhdGUgdGhlIHNjcm9sbCB0b3AgdHJhY2tlciBpZiBwb3NzaWJsZS5cblx0XHRpZiAoc2Nyb2xsUGFyZW50KSB7XG5cdFx0XHRzY3JvbGxQYXJlbnQuZmFzdENsaWNrTGFzdFNjcm9sbFRvcCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3A7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQgPSBmdW5jdGlvbihldmVudFRhcmdldCkge1xuXG5cdFx0Ly8gT24gc29tZSBvbGRlciBicm93c2VycyAobm90YWJseSBTYWZhcmkgb24gaU9TIDQuMSAtIHNlZSBpc3N1ZSAjNTYpIHRoZSBldmVudCB0YXJnZXQgbWF5IGJlIGEgdGV4dCBub2RlLlxuXHRcdGlmIChldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdHJldHVybiBldmVudFRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudFRhcmdldDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRFbGVtZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5pc1RleHRGaWVsZCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYSdcblx0XHRcdHx8IHRleHRGaWVsZHMuaW5kZXhPZih0YXJnZXRFbGVtZW50LnR5cGUpICE9PSAtMVxuXHRcdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHQvLyBJZ25vcmUgdG91Y2hlcyBvbiBjb250ZW50ZWRpdGFibGUgZWxlbWVudHMgdG8gcHJldmVudCBjb25mbGljdCB3aXRoIHRleHQgc2VsZWN0aW9uLlxuXHRcdC8vIChGb3IgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svcHVsbC8yMTEgKVxuXHRcdGlmICh0YXJnZXRFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblx0XHRcdC8vIElnbm9yZSB0b3VjaHN0YXJ0IGluIGZvY3VzZWQgdGV4dCBmaWVsZFxuXHRcdFx0Ly8gQWxsb3dzIG5vcm1hbCB0ZXh0IHNlbGVjdGlvbiBhbmQgY29tbWFuZHMgKHNlbGVjdC9wYXN0ZS9jdXQpIHdoZW4gYSBmaWVsZCBoYXMgZm9jdXMsIHdoaWxlIHN0aWxsIGFsbG93aW5nIGZhc3QgdGFwLXRvLWZvY3VzLlxuXHRcdFx0Ly8gV2l0aG91dCB0aGlzIGZpeCwgdXNlciBuZWVkcyB0byB0YXAtYW5kLWhvbGQgYSB0ZXh0IGZpZWxkIGZvciBjb250ZXh0IG1lbnUsIGFuZCBkb3VibGUtdGFwIHRvIHNlbGVjdCB0ZXh0IGRvZXNuJ3Qgd29yayBhdCBhbGwuXG5cdFx0XHRpZiAodGFyZ2V0RWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiB0aGlzLmlzVGV4dEZpZWxkKHRhcmdldEVsZW1lbnQpKSB7XG5cdFx0XHQgIHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRldmljZUlzSU9TNCkge1xuXG5cdFx0XHRcdC8vIFdlaXJkIHRoaW5ncyBoYXBwZW4gb24gaU9TIHdoZW4gYW4gYWxlcnQgb3IgY29uZmlybSBkaWFsb2cgaXMgb3BlbmVkIGZyb20gYSBjbGljayBldmVudCBjYWxsYmFjayAoaXNzdWUgIzIzKTpcblx0XHRcdFx0Ly8gd2hlbiB0aGUgdXNlciBuZXh0IHRhcHMgYW55d2hlcmUgZWxzZSBvbiB0aGUgcGFnZSwgbmV3IHRvdWNoc3RhcnQgYW5kIHRvdWNoZW5kIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZFxuXHRcdFx0XHQvLyB3aXRoIHRoZSBzYW1lIGlkZW50aWZpZXIgYXMgdGhlIHRvdWNoIGV2ZW50IHRoYXQgcHJldmlvdXNseSB0cmlnZ2VyZWQgdGhlIGNsaWNrIHRoYXQgdHJpZ2dlcmVkIHRoZSBhbGVydC5cblx0XHRcdFx0Ly8gU2FkbHksIHRoZXJlIGlzIGFuIGlzc3VlIG9uIGlPUyA0IHRoYXQgY2F1c2VzIHNvbWUgbm9ybWFsIHRvdWNoIGV2ZW50cyB0byBoYXZlIHRoZSBzYW1lIGlkZW50aWZpZXIgYXMgYW5cblx0XHRcdFx0Ly8gaW1tZWRpYXRlbHkgcHJlY2VlZGluZyB0b3VjaCBldmVudCAoaXNzdWUgIzUyKSwgc28gdGhpcyBmaXggaXMgdW5hdmFpbGFibGUgb24gdGhhdCBwbGF0Zm9ybS5cblx0XHRcdFx0Ly8gSXNzdWUgMTIwOiB0b3VjaC5pZGVudGlmaWVyIGlzIDAgd2hlbiBDaHJvbWUgZGV2IHRvb2xzICdFbXVsYXRlIHRvdWNoIGV2ZW50cycgaXMgc2V0IHdpdGggYW4gaU9TIGRldmljZSBVQSBzdHJpbmcsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhbGwgdG91Y2ggZXZlbnRzIHRvIGJlIGlnbm9yZWQuIEFzIHRoaXMgYmxvY2sgb25seSBhcHBsaWVzIHRvIGlPUywgYW5kIGlPUyBpZGVudGlmaWVycyBhcmUgYWx3YXlzIGxvbmcsXG5cdFx0XHRcdC8vIHJhbmRvbSBpbnRlZ2VycywgaXQncyBzYWZlIHRvIHRvIGNvbnRpbnVlIGlmIHRoZSBpZGVudGlmaWVyIGlzIDAgaGVyZS5cblx0XHRcdFx0aWYgKHRvdWNoLmlkZW50aWZpZXIgJiYgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciAodXNpbmcgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSBhbmQ6XG5cdFx0XHRcdC8vIDEpIHRoZSB1c2VyIGRvZXMgYSBmbGluZyBzY3JvbGwgb24gdGhlIHNjcm9sbGFibGUgbGF5ZXJcblx0XHRcdFx0Ly8gMikgdGhlIHVzZXIgc3RvcHMgdGhlIGZsaW5nIHNjcm9sbCB3aXRoIGFub3RoZXIgdGFwXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV2ZW50LnRhcmdldCBvZiB0aGUgbGFzdCAndG91Y2hlbmQnIGV2ZW50IHdpbGwgYmUgdGhlIGVsZW1lbnQgdGhhdCB3YXMgdW5kZXIgdGhlIHVzZXIncyBmaW5nZXJcblx0XHRcdFx0Ly8gd2hlbiB0aGUgZmxpbmcgc2Nyb2xsIHdhcyBzdGFydGVkLCBjYXVzaW5nIEZhc3RDbGljayB0byBzZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhhdCBsYXllciAtIHVubGVzcyBhIGNoZWNrXG5cdFx0XHRcdC8vIGlzIG1hZGUgdG8gZW5zdXJlIHRoYXQgYSBwYXJlbnQgbGF5ZXIgd2FzIG5vdCBzY3JvbGxlZCBiZWZvcmUgc2VuZGluZyBhIHN5bnRoZXRpYyBjbGljayAoaXNzdWUgIzQyKS5cblx0XHRcdFx0dGhpcy51cGRhdGVTY3JvbGxQYXJlbnQodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gdHJ1ZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IGV2ZW50LnRpbWVTdGFtcDtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSB0b3VjaC5wYWdlWTtcblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGEgdG91Y2htb3ZlIGV2ZW50IG9iamVjdCwgY2hlY2sgd2hldGhlciB0aGUgdG91Y2ggaGFzIG1vdmVkIHBhc3QgYSBib3VuZGFyeSBzaW5jZSBpdCBzdGFydGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUudG91Y2hIYXNNb3ZlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0sIGJvdW5kYXJ5ID0gdGhpcy50b3VjaEJvdW5kYXJ5O1xuXG5cdFx0aWYgKE1hdGguYWJzKHRvdWNoLnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgPiBib3VuZGFyeSB8fCBNYXRoLmFicyh0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydFkpID4gYm91bmRhcnkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxhc3QgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSB0b3VjaCBoYXMgbW92ZWQsIGNhbmNlbCB0aGUgY2xpY2sgdHJhY2tpbmdcblx0XHRpZiAodGhpcy50YXJnZXRFbGVtZW50ICE9PSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KSB8fCB0aGlzLnRvdWNoSGFzTW92ZWQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBmaW5kIHRoZSBsYWJlbGxlZCBjb250cm9sIGZvciB0aGUgZ2l2ZW4gbGFiZWwgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxIVE1MTGFiZWxFbGVtZW50fSBsYWJlbEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZmluZENvbnRyb2wgPSBmdW5jdGlvbihsYWJlbEVsZW1lbnQpIHtcblxuXHRcdC8vIEZhc3QgcGF0aCBmb3IgbmV3ZXIgYnJvd3NlcnMgc3VwcG9ydGluZyB0aGUgSFRNTDUgY29udHJvbCBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50LmNvbnRyb2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5jb250cm9sO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBicm93c2VycyB1bmRlciB0ZXN0IHRoYXQgc3VwcG9ydCB0b3VjaCBldmVudHMgYWxzbyBzdXBwb3J0IHRoZSBIVE1MNSBodG1sRm9yIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuaHRtbEZvcikge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxhYmVsRWxlbWVudC5odG1sRm9yKTtcblx0XHR9XG5cblx0XHQvLyBJZiBubyBmb3IgYXR0cmlidXRlIGV4aXN0cywgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZmlyc3QgbGFiZWxsYWJsZSBkZXNjZW5kYW50IGVsZW1lbnRcblx0XHQvLyB0aGUgbGlzdCBvZiB3aGljaCBpcyBkZWZpbmVkIGhlcmU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxcblx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbiwgaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCBrZXlnZW4sIG1ldGVyLCBvdXRwdXQsIHByb2dyZXNzLCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggZW5kLCBkZXRlcm1pbmUgd2hldGhlciB0byBzZW5kIGEgY2xpY2sgZXZlbnQgYXQgb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBmb3JFbGVtZW50LCB0cmFja2luZ0NsaWNrU3RhcnQsIHRhcmdldFRhZ05hbWUsIHNjcm9sbFBhcmVudCwgdG91Y2gsIHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XG5cblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1M0IHx8IHRhcmdldFRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MgJiYgIWRldmljZUlzSU9TNCkge1xuXG5cdFx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIGV2ZW50IGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIGEgcGFyZW50IGxheWVyIHRoYXQgd2FzIHNjcm9sbGVkXG5cdFx0XHQvLyBhbmQgdGhpcyB0YXAgaXMgYmVpbmcgdXNlZCB0byBzdG9wIHRoZSBzY3JvbGxpbmcgKHVzdWFsbHkgaW5pdGlhdGVkIGJ5IGEgZmxpbmcgLSBpc3N1ZSAjNDIpLlxuXHRcdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cdFx0XHRpZiAoc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wICE9PSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgdGhlIGFjdHVhbCBjbGljayBmcm9tIGdvaW5nIHRob3VnaCAtIHVubGVzcyB0aGUgdGFyZ2V0IG5vZGUgaXMgbWFya2VkIGFzIHJlcXVpcmluZ1xuXHRcdC8vIHJlYWwgY2xpY2tzIG9yIGlmIGl0IGlzIGluIHRoZSB3aGl0ZWxpc3QgaW4gd2hpY2ggY2FzZSBvbmx5IG5vbi1wcm9ncmFtbWF0aWMgY2xpY2tzIGFyZSBwZXJtaXR0ZWQuXG5cdFx0aWYgKCF0aGlzLm5lZWRzQ2xpY2sodGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIGNhbmNlbCwgc3RvcCB0cmFja2luZyB0aGUgY2xpY2suXG5cdCAqXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgbW91c2UgZXZlbnRzIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbk1vdXNlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdC8vIElmIGEgdGFyZ2V0IGVsZW1lbnQgd2FzIG5ldmVyIHNldCAoYmVjYXVzZSBhIHRvdWNoIGV2ZW50IHdhcyBuZXZlciBmaXJlZCkgYWxsb3cgdGhlIGV2ZW50XG5cdFx0aWYgKCF0aGlzLnRhcmdldEVsZW1lbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5mb3J3YXJkZWRUb3VjaEV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcm9ncmFtbWF0aWNhbGx5IGdlbmVyYXRlZCBldmVudHMgdGFyZ2V0aW5nIGEgc3BlY2lmaWMgZWxlbWVudCBzaG91bGQgYmUgcGVybWl0dGVkXG5cdFx0aWYgKCFldmVudC5jYW5jZWxhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBEZXJpdmUgYW5kIGNoZWNrIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzZWUgd2hldGhlciB0aGUgbW91c2UgZXZlbnQgbmVlZHMgdG8gYmUgcGVybWl0dGVkO1xuXHRcdC8vIHVubGVzcyBleHBsaWNpdGx5IGVuYWJsZWQsIHByZXZlbnQgbm9uLXRvdWNoIGNsaWNrIGV2ZW50cyBmcm9tIHRyaWdnZXJpbmcgYWN0aW9ucyxcblx0XHQvLyB0byBwcmV2ZW50IGdob3N0L2RvdWJsZWNsaWNrcy5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0aGlzLnRhcmdldEVsZW1lbnQpIHx8IHRoaXMuY2FuY2VsTmV4dENsaWNrKSB7XG5cblx0XHRcdC8vIFByZXZlbnQgYW55IHVzZXItYWRkZWQgbGlzdGVuZXJzIGRlY2xhcmVkIG9uIEZhc3RDbGljayBlbGVtZW50IGZyb20gYmVpbmcgZmlyZWQuXG5cdFx0XHRpZiAoZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBQYXJ0IG9mIHRoZSBoYWNrIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgRXZlbnQjc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIChlLmcuIEFuZHJvaWQgMilcblx0XHRcdFx0ZXZlbnQucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FuY2VsIHRoZSBldmVudFxuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIG1vdXNlIGV2ZW50IGlzIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiBhY3R1YWwgY2xpY2tzLCBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgdG91Y2gtZ2VuZXJhdGVkIGNsaWNrLCBhIGNsaWNrIGFjdGlvbiBvY2N1cnJpbmdcblx0ICogbmF0dXJhbGx5IGFmdGVyIGEgZGVsYXkgYWZ0ZXIgYSB0b3VjaCAod2hpY2ggbmVlZHMgdG8gYmUgY2FuY2VsbGVkIHRvIGF2b2lkIGR1cGxpY2F0aW9uKSwgb3Jcblx0ICogYW4gYWN0dWFsIGNsaWNrIHdoaWNoIHNob3VsZCBiZSBwZXJtaXR0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcGVybWl0dGVkO1xuXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSBmb3IgYW5vdGhlciBGYXN0Q2xpY2stbGlrZSBsaWJyYXJ5IGRlbGl2ZXJlZCB3aXRoIHRoaXJkLXBhcnR5IGNvZGUgdG8gZmlyZSBhIGNsaWNrIGV2ZW50IGJlZm9yZSBGYXN0Q2xpY2sgZG9lcyAoaXNzdWUgIzQ0KS4gSW4gdGhhdCBjYXNlLCBzZXQgdGhlIGNsaWNrLXRyYWNraW5nIGZsYWcgYmFjayB0byBmYWxzZSBhbmQgcmV0dXJuIGVhcmx5LiBUaGlzIHdpbGwgY2F1c2Ugb25Ub3VjaEVuZCB0byByZXR1cm4gZWFybHkuXG5cdFx0aWYgKHRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVmVyeSBvZGQgYmVoYXZpb3VyIG9uIGlPUyAoaXNzdWUgIzE4KTogaWYgYSBzdWJtaXQgZWxlbWVudCBpcyBwcmVzZW50IGluc2lkZSBhIGZvcm0gYW5kIHRoZSB1c2VyIGhpdHMgZW50ZXIgaW4gdGhlIGlPUyBzaW11bGF0b3Igb3IgY2xpY2tzIHRoZSBHbyBidXR0b24gb24gdGhlIHBvcC11cCBPUyBrZXlib2FyZCB0aGUgYSBraW5kIG9mICdmYWtlJyBjbGljayBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCB3aXRoIHRoZSBzdWJtaXQtdHlwZSBpbnB1dCBlbGVtZW50IGFzIHRoZSB0YXJnZXQuXG5cdFx0aWYgKGV2ZW50LnRhcmdldC50eXBlID09PSAnc3VibWl0JyAmJiBldmVudC5kZXRhaWwgPT09IDApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHBlcm1pdHRlZCA9IHRoaXMub25Nb3VzZShldmVudCk7XG5cblx0XHQvLyBPbmx5IHVuc2V0IHRhcmdldEVsZW1lbnQgaWYgdGhlIGNsaWNrIGlzIG5vdCBwZXJtaXR0ZWQuIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgY2hlY2sgZm9yICF0YXJnZXRFbGVtZW50IGluIG9uTW91c2UgZmFpbHMgYW5kIHRoZSBicm93c2VyJ3MgY2xpY2sgZG9lc24ndCBnbyB0aHJvdWdoLlxuXHRcdGlmICghcGVybWl0dGVkKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIElmIGNsaWNrcyBhcmUgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiBwZXJtaXR0ZWQ7XG5cdH07XG5cblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBGYXN0Q2xpY2sncyBldmVudCBsaXN0ZW5lcnMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5sYXllcjtcblxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2ssIHRydWUpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uVG91Y2hTdGFydCwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Ub3VjaE1vdmUsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5vblRvdWNoQ2FuY2VsLCBmYWxzZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogQ2hlY2sgd2hldGhlciBGYXN0Q2xpY2sgaXMgbmVlZGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cblx0ICovXG5cdEZhc3RDbGljay5ub3ROZWVkZWQgPSBmdW5jdGlvbihsYXllcikge1xuXHRcdHZhciBtZXRhVmlld3BvcnQ7XG5cdFx0dmFyIGNocm9tZVZlcnNpb247XG5cdFx0dmFyIGJsYWNrYmVycnlWZXJzaW9uO1xuXHRcdHZhciBmaXJlZm94VmVyc2lvbjtcblxuXHRcdC8vIERldmljZXMgdGhhdCBkb24ndCBzdXBwb3J0IHRvdWNoIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hyb21lIHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xuXHRcdGNocm9tZVZlcnNpb24gPSArKC9DaHJvbWVcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChjaHJvbWVWZXJzaW9uKSB7XG5cblx0XHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyBDaHJvbWUgb24gQW5kcm9pZCB3aXRoIHVzZXItc2NhbGFibGU9XCJub1wiIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICM4OSlcblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENocm9tZSAzMiBhbmQgYWJvdmUgd2l0aCB3aWR0aD1kZXZpY2Utd2lkdGggb3IgbGVzcyBkb24ndCBuZWVkIEZhc3RDbGlja1xuXHRcdFx0XHRcdGlmIChjaHJvbWVWZXJzaW9uID4gMzEgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hyb21lIGRlc2t0b3AgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzE1KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGRldmljZUlzQmxhY2tCZXJyeTEwKSB7XG5cdFx0XHRibGFja2JlcnJ5VmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oWzAtOV0qKVxcLihbMC05XSopLyk7XG5cblx0XHRcdC8vIEJsYWNrQmVycnkgMTAuMysgZG9lcyBub3QgcmVxdWlyZSBGYXN0Y2xpY2sgbGlicmFyeS5cblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mdGxhYnMvZmFzdGNsaWNrL2lzc3Vlcy8yNTFcblx0XHRcdGlmIChibGFja2JlcnJ5VmVyc2lvblsxXSA+PSAxMCAmJiBibGFja2JlcnJ5VmVyc2lvblsyXSA+PSAzKSB7XG5cdFx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Ly8gdXNlci1zY2FsYWJsZT1ubyBlbGltaW5hdGVzIGNsaWNrIGRlbGF5LlxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gd2lkdGg9ZGV2aWNlLXdpZHRoIChvciBsZXNzIHRoYW4gZGV2aWNlLXdpZHRoKSBlbGltaW5hdGVzIGNsaWNrIGRlbGF5LlxuXHRcdFx0XHRcdGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElFMTAgd2l0aCAtbXMtdG91Y2gtYWN0aW9uOiBub25lIG9yIG1hbmlwdWxhdGlvbiwgd2hpY2ggZGlzYWJsZXMgZG91YmxlLXRhcC10by16b29tIChpc3N1ZSAjOTcpXG5cdFx0aWYgKGxheWVyLnN0eWxlLm1zVG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIEZpcmVmb3ggdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0ZmlyZWZveFZlcnNpb24gPSArKC9GaXJlZm94XFwvKFswLTldKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWywwXSlbMV07XG5cblx0XHRpZiAoZmlyZWZveFZlcnNpb24gPj0gMjcpIHtcblx0XHRcdC8vIEZpcmVmb3ggMjcrIGRvZXMgbm90IGhhdmUgdGFwIGRlbGF5IGlmIHRoZSBjb250ZW50IGlzIG5vdCB6b29tYWJsZSAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyMjg5NlxuXG5cdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cdFx0XHRpZiAobWV0YVZpZXdwb3J0ICYmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMTogcHJlZml4ZWQgLW1zLXRvdWNoLWFjdGlvbiBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFuZCBpdCdzIHJlY29tZW5kZWQgdG8gdXNlIG5vbi1wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvYXBwcy9IaDc2NzMxMy5hc3B4XG5cdFx0aWYgKGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIGEgRmFzdENsaWNrIG9iamVjdFxuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGxheWVyIFRoZSBsYXllciB0byBsaXN0ZW4gb25cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHNcblx0ICovXG5cdEZhc3RDbGljay5hdHRhY2ggPSBmdW5jdGlvbihsYXllciwgb3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgRmFzdENsaWNrKGxheWVyLCBvcHRpb25zKTtcblx0fTtcblxuXG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEZhc3RDbGljaztcblx0XHR9KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gRmFzdENsaWNrLmF0dGFjaDtcblx0XHRtb2R1bGUuZXhwb3J0cy5GYXN0Q2xpY2sgPSBGYXN0Q2xpY2s7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LkZhc3RDbGljayA9IEZhc3RDbGljaztcblx0fVxufSgpKTtcbiIsIi8vIEZvciBAb25zZW51aS9jdXN0b20tZWxlbWVudHNcbmlmICh3aW5kb3cuY3VzdG9tRWxlbWVudHMpIHsgLy8gZXZlbiBpZiBuYXRpdmUgQ0UxIGltcGwgZXhpc3RzLCB1c2UgcG9seWZpbGxcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZm9yY2VQb2x5ZmlsbCA9IHRydWU7XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXTtcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcbiIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgdGFyZ2V0LCBDKSB7XG4gIHZhciBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICB2YXIgUDtcbiAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpIHsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHsgbmV3IEMoaXRlcik7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNFVCA9ICdTZXQnO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShTRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBBID0gQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBNQVAgPSAnTWFwJztcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpIH0pO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLk1hcDtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG4iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5XZWFrTWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikgeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcbiIsImNvbnN0IHJlc2VydmVkVGFnTGlzdCA9IG5ldyBTZXQoW1xuICAnYW5ub3RhdGlvbi14bWwnLFxuICAnY29sb3ItcHJvZmlsZScsXG4gICdmb250LWZhY2UnLFxuICAnZm9udC1mYWNlLXNyYycsXG4gICdmb250LWZhY2UtdXJpJyxcbiAgJ2ZvbnQtZmFjZS1mb3JtYXQnLFxuICAnZm9udC1mYWNlLW5hbWUnLFxuICAnbWlzc2luZy1nbHlwaCcsXG5dKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpIHtcbiAgY29uc3QgcmVzZXJ2ZWQgPSByZXNlcnZlZFRhZ0xpc3QuaGFzKGxvY2FsTmFtZSk7XG4gIGNvbnN0IHZhbGlkRm9ybSA9IC9eW2Etel1bLjAtOV9hLXpdKi1bXFwtLjAtOV9hLXpdKiQvLnRlc3QobG9jYWxOYW1lKTtcbiAgcmV0dXJuICFyZXNlcnZlZCAmJiB2YWxpZEZvcm07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Nvbm5lY3RlZChub2RlKSB7XG4gIC8vIFVzZSBgTm9kZSNpc0Nvbm5lY3RlZGAsIGlmIGRlZmluZWQuXG4gIGNvbnN0IG5hdGl2ZVZhbHVlID0gbm9kZS5pc0Nvbm5lY3RlZDtcbiAgaWYgKG5hdGl2ZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmF0aXZlVmFsdWU7XG4gIH1cblxuICAvKiogQHR5cGUgez9Ob2RlfHVuZGVmaW5lZH0gKi9cbiAgbGV0IGN1cnJlbnQgPSBub2RlO1xuICB3aGlsZSAoY3VycmVudCAmJiAhKGN1cnJlbnQuX19DRV9pc0ltcG9ydERvY3VtZW50IHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIHx8ICh3aW5kb3cuU2hhZG93Um9vdCAmJiBjdXJyZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IGN1cnJlbnQuaG9zdCA6IHVuZGVmaW5lZCk7XG4gIH1cbiAgcmV0dXJuICEhKGN1cnJlbnQgJiYgKGN1cnJlbnQuX19DRV9pc0ltcG9ydERvY3VtZW50IHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0XG4gKiBAcmV0dXJuIHs/Tm9kZX1cbiAqL1xuZnVuY3Rpb24gbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBzdGFydCkge1xuICBsZXQgbm9kZSA9IHN0YXJ0O1xuICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSByb290ICYmICFub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gKCFub2RlIHx8IG5vZGUgPT09IHJvb3QpID8gbnVsbCA6IG5vZGUubmV4dFNpYmxpbmc7XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICogQHBhcmFtIHshTm9kZX0gc3RhcnRcbiAqIEByZXR1cm4gez9Ob2RlfVxuICovXG5mdW5jdGlvbiBuZXh0Tm9kZShyb290LCBzdGFydCkge1xuICByZXR1cm4gc3RhcnQuZmlyc3RDaGlsZCA/IHN0YXJ0LmZpcnN0Q2hpbGQgOiBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIHN0YXJ0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSByb290XG4gKiBAcGFyYW0geyFmdW5jdGlvbighRWxlbWVudCl9IGNhbGxiYWNrXG4gKiBAcGFyYW0geyFTZXQ8Tm9kZT49fSB2aXNpdGVkSW1wb3J0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgY2FsbGJhY2ssIHZpc2l0ZWRJbXBvcnRzID0gbmV3IFNldCgpKSB7XG4gIGxldCBub2RlID0gcm9vdDtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyhub2RlKTtcblxuICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGVsZW1lbnQubG9jYWxOYW1lO1xuICAgICAgaWYgKGxvY2FsTmFtZSA9PT0gJ2xpbmsnICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpbXBvcnQgKHBvbHlmaWxsZWQgb3Igbm90KSBoYXMgaXQncyByb290IG5vZGUgYXZhaWxhYmxlLFxuICAgICAgICAvLyB3YWxrIGl0LlxuICAgICAgICBjb25zdCBpbXBvcnROb2RlID0gLyoqIEB0eXBlIHshTm9kZX0gKi8gKGVsZW1lbnQuaW1wb3J0KTtcbiAgICAgICAgaWYgKGltcG9ydE5vZGUgaW5zdGFuY2VvZiBOb2RlICYmICF2aXNpdGVkSW1wb3J0cy5oYXMoaW1wb3J0Tm9kZSkpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIHdhbGtzIG9mIHRoZSBzYW1lIGltcG9ydCByb290LlxuICAgICAgICAgIHZpc2l0ZWRJbXBvcnRzLmFkZChpbXBvcnROb2RlKTtcblxuICAgICAgICAgIGZvciAobGV0IGNoaWxkID0gaW1wb3J0Tm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMoY2hpbGQsIGNhbGxiYWNrLCB2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWdub3JlIGRlc2NlbmRhbnRzIG9mIGltcG9ydCBsaW5rcyB0byBwcmV2ZW50IGF0dGVtcHRpbmcgdG8gd2FsayB0aGVcbiAgICAgICAgLy8gZWxlbWVudHMgY3JlYXRlZCBieSB0aGUgSFRNTCBJbXBvcnRzIHBvbHlmaWxsIHRoYXQgd2UganVzdCB3YWxrZWRcbiAgICAgICAgLy8gYWJvdmUuXG4gICAgICAgIG5vZGUgPSBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIGVsZW1lbnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxOYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIC8vIElnbm9yZSBkZXNjZW5kYW50cyBvZiB0ZW1wbGF0ZXMuIFRoZXJlIHNob3VsZG4ndCBiZSBhbnkgZGVzY2VuZGFudHNcbiAgICAgICAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgbW92ZWQgaW50byBgLmNvbnRlbnRgIGR1cmluZyBjb25zdHJ1Y3Rpb24gaW5cbiAgICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IHRlbXBsYXRlIGJ1dCwgaW4gY2FzZSB0aGV5IGV4aXN0IGFuZCBhcmUgc3RpbGxcbiAgICAgICAgLy8gd2FpdGluZyB0byBiZSBtb3ZlZCBieSBhIHBvbHlmaWxsLCB0aGV5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgZWxlbWVudCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBXYWxrIHNoYWRvdyByb290cy5cbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50Ll9fQ0Vfc2hhZG93Um9vdDtcbiAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gc2hhZG93Um9vdC5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICAgIHdhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKGNoaWxkLCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5leHROb2RlKHJvb3QsIG5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogVXNlZCB0byBzdXBwcmVzcyBDbG9zdXJlJ3MgXCJNb2RpZnlpbmcgdGhlIHByb3RvdHlwZSBpcyBvbmx5IGFsbG93ZWQgaWYgdGhlXG4gKiBjb25zdHJ1Y3RvciBpcyBpbiB0aGUgc2FtZSBzY29wZVwiIHdhcm5pbmcgd2l0aG91dCB1c2luZ1xuICogYEBzdXBwcmVzcyB7bmV3Q2hlY2tUeXBlcywgZHVwbGljYXRlfWAgYmVjYXVzZSBgbmV3Q2hlY2tUeXBlc2AgaXMgdG9vIGJyb2FkLlxuICpcbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eVVuY2hlY2tlZChkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUpIHtcbiAgZGVzdGluYXRpb25bbmFtZV0gPSB2YWx1ZTtcbn1cbiIsIi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ3VzdG9tRWxlbWVudFN0YXRlID0ge1xuICBjdXN0b206IDEsXG4gIGZhaWxlZDogMixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUVsZW1lbnRTdGF0ZTtcbiIsImltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuL1V0aWxpdGllcy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuL0N1c3RvbUVsZW1lbnRTdGF0ZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgeyFNYXA8c3RyaW5nLCAhQ3VzdG9tRWxlbWVudERlZmluaXRpb24+fSAqL1xuICAgIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbiA9IG5ldyBNYXAoKTtcblxuICAgIC8qKiBAdHlwZSB7IU1hcDwhRnVuY3Rpb24sICFDdXN0b21FbGVtZW50RGVmaW5pdGlvbj59ICovXG4gICAgdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24gPSBuZXcgTWFwKCk7XG5cbiAgICAvKiogQHR5cGUgeyFBcnJheTwhZnVuY3Rpb24oIU5vZGUpPn0gKi9cbiAgICB0aGlzLl9wYXRjaGVzID0gW107XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5faGFzUGF0Y2hlcyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudERlZmluaXRpb259IGRlZmluaXRpb25cbiAgICovXG4gIHNldERlZmluaXRpb24obG9jYWxOYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uLnNldChsb2NhbE5hbWUsIGRlZmluaXRpb24pO1xuICAgIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uLnNldChkZWZpbml0aW9uLmNvbnN0cnVjdG9yLCBkZWZpbml0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEByZXR1cm4geyFDdXN0b21FbGVtZW50RGVmaW5pdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuICBsb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsTmFtZVRvRGVmaW5pdGlvbi5nZXQobG9jYWxOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAgICogQHJldHVybiB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufHVuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yVG9EZWZpbml0aW9uKGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uLmdldChjb25zdHJ1Y3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIU5vZGUpfSBsaXN0ZW5lclxuICAgKi9cbiAgYWRkUGF0Y2gobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9oYXNQYXRjaGVzID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXRjaGVzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICovXG4gIHBhdGNoVHJlZShub2RlKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNQYXRjaGVzKSByZXR1cm47XG5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMobm9kZSwgZWxlbWVudCA9PiB0aGlzLnBhdGNoKGVsZW1lbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqL1xuICBwYXRjaChub2RlKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNQYXRjaGVzKSByZXR1cm47XG5cbiAgICBpZiAobm9kZS5fX0NFX3BhdGNoZWQpIHJldHVybjtcbiAgICBub2RlLl9fQ0VfcGF0Y2hlZCA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3BhdGNoZXNbaV0obm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAgICovXG4gIGNvbm5lY3RUcmVlKHJvb3QpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGVsZW1lbnQgPT4gZWxlbWVudHMucHVzaChlbGVtZW50KSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5fX0NFX3N0YXRlID09PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGdyYWRlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICAgKi9cbiAgZGlzY29ubmVjdFRyZWUocm9vdCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgZWxlbWVudCA9PiBlbGVtZW50cy5wdXNoKGVsZW1lbnQpKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGVzIGFsbCB1bmN1c3RvbWl6ZWQgY3VzdG9tIGVsZW1lbnRzIGF0IGFuZCBiZWxvdyBhIHJvb3Qgbm9kZSBmb3JcbiAgICogd2hpY2ggdGhlcmUgaXMgYSBkZWZpbml0aW9uLiBXaGVuIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9uIGNhbGxiYWNrcyBhcmVcbiAgICogYXNzdW1lZCB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSAod2hpY2gsIGJ5IHRoZSBjdXJyZW50IERPTSAvIEhUTUwgc3BlY1xuICAgKiBkZWZpbml0aW9ucywgdGhleSBhcmUgKm5vdCopLCBjYWxsYmFja3MgZm9yIGJvdGggZWxlbWVudHMgY3VzdG9taXplZFxuICAgKiBzeW5jaHJvbm91c2x5IGJ5IHRoZSBwYXJzZXIgYW5kIGVsZW1lbnRzIGJlaW5nIHVwZ3JhZGVkIG9jY3VyIGluIHRoZSBzYW1lXG4gICAqIHJlbGF0aXZlIG9yZGVyLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIGZ1bmN0aW9uLCB3aGVuIHVzZWQgdG8gc2ltdWxhdGUgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHRyZWUgdGhhdFxuICAgKiBpcyBhbHJlYWR5IGNyZWF0ZWQgYnV0IG5vdCBjdXN0b21pemVkIChpLmUuIGJ5IHRoZSBwYXJzZXIpLCBkb2VzICpub3QqXG4gICAqIHByZXZlbnQgdGhlIGVsZW1lbnQgZnJvbSByZWFkaW5nIHRoZSAnZmluYWwnICh0cnVlKSBzdGF0ZSBvZiB0aGUgdHJlZS4gRm9yXG4gICAqIGV4YW1wbGUsIHRoZSBlbGVtZW50LCBkdXJpbmcgdHJ1bHkgc3luY2hyb25vdXMgcGFyc2luZyAvIGNvbnN0cnVjdGlvbiB3b3VsZFxuICAgKiBzZWUgdGhhdCBpdCBjb250YWlucyBubyBjaGlsZHJlbiBhcyB0aGV5IGhhdmUgbm90IHlldCBiZWVuIGluc2VydGVkLlxuICAgKiBIb3dldmVyLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1vZGlmeSB0aGUgdHJlZSwgdGhlIGVsZW1lbnQgd2lsbFxuICAgKiAoaW5jb3JyZWN0bHkpIGhhdmUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSwgc2VsZi1tb2RpZmljYXRpb24gcmVzdHJpY3Rpb25zXG4gICAqIGZvciBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcnMgaW1wb3NlZCBieSB0aGUgRE9NIHNwZWMgYXJlICpub3QqIGVuZm9yY2VkLlxuICAgKlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIG5lc3RlZCBsaXN0IHNob3dzIHRoZSBzdGVwcyBleHRlbmRpbmcgZG93biBmcm9tIHRoZSBIVE1MXG4gICAqIHNwZWMncyBwYXJzaW5nIHNlY3Rpb24gdGhhdCBjYXVzZSBlbGVtZW50cyB0byBiZSBzeW5jaHJvbm91c2x5IGNyZWF0ZWQgYW5kXG4gICAqIHVwZ3JhZGVkOlxuICAgKlxuICAgKiBUaGUgXCJpbiBib2R5XCIgaW5zZXJ0aW9uIG1vZGU6XG4gICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICogLSBTd2l0Y2ggb24gdG9rZW46XG4gICAqICAgLi4gb3RoZXIgY2FzZXMgLi5cbiAgICogICAtPiBBbnkgb3RoZXIgc3RhcnQgdGFnXG4gICAqICAgICAgLSBbSW5zZXJ0IGFuIEhUTUwgZWxlbWVudF0oYmVsb3cpIGZvciB0aGUgdG9rZW4uXG4gICAqXG4gICAqIEluc2VydCBhbiBIVE1MIGVsZW1lbnQ6XG4gICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2luc2VydC1hbi1odG1sLWVsZW1lbnRcbiAgICogLSBJbnNlcnQgYSBmb3JlaWduIGVsZW1lbnQgZm9yIHRoZSB0b2tlbiBpbiB0aGUgSFRNTCBuYW1lc3BhY2U6XG4gICAqICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaW5zZXJ0LWEtZm9yZWlnbi1lbGVtZW50XG4gICAqICAgLSBDcmVhdGUgYW4gZWxlbWVudCBmb3IgYSB0b2tlbjpcbiAgICogICAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2NyZWF0ZS1hbi1lbGVtZW50LWZvci10aGUtdG9rZW5cbiAgICogICAgIC0gV2lsbCBleGVjdXRlIHNjcmlwdCBmbGFnIGlzIHRydWU/XG4gICAqICAgICAgIC0gKEVsZW1lbnQgcXVldWUgcHVzaGVkIHRvIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suKVxuICAgKiAgICAgLSBDcmVhdGUgYW4gZWxlbWVudDpcbiAgICogICAgICAgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWNyZWF0ZS1lbGVtZW50XG4gICAqICAgICAgIC0gU3luYyBDRSBmbGFnIGlzIHRydWU/XG4gICAqICAgICAgICAgLSBDb25zdHJ1Y3RvciBjYWxsZWQuXG4gICAqICAgICAgICAgLSBTZWxmLW1vZGlmaWNhdGlvbiByZXN0cmljdGlvbnMgZW5mb3JjZWQuXG4gICAqICAgICAgIC0gU3luYyBDRSBmbGFnIGlzIGZhbHNlP1xuICAgKiAgICAgICAgIC0gKFVwZ3JhZGUgcmVhY3Rpb24gZW5xdWV1ZWQuKVxuICAgKiAgICAgLSBBdHRyaWJ1dGVzIGFwcGVuZGVkIHRvIGVsZW1lbnQuXG4gICAqICAgICAgIChgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCByZWFjdGlvbnMgZW5xdWV1ZWQuKVxuICAgKiAgICAgLSBXaWxsIGV4ZWN1dGUgc2NyaXB0IGZsYWcgaXMgdHJ1ZT9cbiAgICogICAgICAgLSAoRWxlbWVudCBxdWV1ZSBwb3BwZWQgZnJvbSB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLlxuICAgKiAgICAgICAgIFJlYWN0aW9ucyBpbiB0aGUgcG9wcGVkIHN0YWNrIGFyZSBpbnZva2VkLilcbiAgICogICAtIChFbGVtZW50IHF1ZXVlIHB1c2hlZCB0byB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLilcbiAgICogICAtIEluc2VydCB0aGUgZWxlbWVudDpcbiAgICogICAgIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ub2RlLWluc2VydFxuICAgKiAgICAgLSBTaGFkb3ctaW5jbHVkaW5nIGRlc2NlbmRhbnRzIGFyZSBjb25uZWN0ZWQuIER1cmluZyBwYXJzaW5nXG4gICAqICAgICAgIGNvbnN0cnVjdGlvbiwgdGhlcmUgYXJlIG5vIHNoYWRvdy0qZXhjbHVkaW5nKiBkZXNjZW5kYW50cy5cbiAgICogICAgICAgSG93ZXZlciwgdGhlIGNvbnN0cnVjdG9yIG1heSBoYXZlIHZhbGlkbHkgYXR0YWNoZWQgYSBzaGFkb3dcbiAgICogICAgICAgdHJlZSB0byBpdHNlbGYgYW5kIGFkZGVkIGRlc2NlbmRhbnRzIHRvIHRoYXQgc2hhZG93IHRyZWUuXG4gICAqICAgICAgIChgY29ubmVjdGVkQ2FsbGJhY2tgIHJlYWN0aW9ucyBlbnF1ZXVlZC4pXG4gICAqICAgLSAoRWxlbWVudCBxdWV1ZSBwb3BwZWQgZnJvbSB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLlxuICAgKiAgICAgUmVhY3Rpb25zIGluIHRoZSBwb3BwZWQgc3RhY2sgYXJlIGludm9rZWQuKVxuICAgKlxuICAgKiBAcGFyYW0geyFOb2RlfSByb290XG4gICAqIEBwYXJhbSB7IVNldDxOb2RlPj19IHZpc2l0ZWRJbXBvcnRzXG4gICAqL1xuICBwYXRjaEFuZFVwZ3JhZGVUcmVlKHJvb3QsIHZpc2l0ZWRJbXBvcnRzID0gbmV3IFNldCgpKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgIGNvbnN0IGdhdGhlckVsZW1lbnRzID0gZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdsaW5rJyAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdpbXBvcnQnKSB7XG4gICAgICAgIC8vIFRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgc2V0cyBhIGRlc2NlbmRhbnQgZWxlbWVudCBvZiB0aGUgbGluayB0b1xuICAgICAgICAvLyB0aGUgYGltcG9ydGAgcHJvcGVydHksIHNwZWNpZmljYWxseSB0aGlzIGlzICpub3QqIGEgRG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IGltcG9ydE5vZGUgPSAvKiogQHR5cGUgez9Ob2RlfSAqLyAoZWxlbWVudC5pbXBvcnQpO1xuXG4gICAgICAgIGlmIChpbXBvcnROb2RlIGluc3RhbmNlb2YgTm9kZSAmJiBpbXBvcnROb2RlLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaXNJbXBvcnREb2N1bWVudCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBDb25uZWN0ZWQgbGlua3MgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGxpbmsncyBpbXBvcnQgcm9vdCBpcyBub3QgYXZhaWxhYmxlLCBpdHMgY29udGVudHMgY2FuJ3QgYmVcbiAgICAgICAgICAvLyB3YWxrZWQuIFdhaXQgZm9yICdsb2FkJyBhbmQgd2FsayBpdCB3aGVuIGl0J3MgcmVhZHkuXG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0Tm9kZSA9IC8qKiBAdHlwZSB7IU5vZGV9ICovIChlbGVtZW50LmltcG9ydCk7XG5cbiAgICAgICAgICAgIGlmIChpbXBvcnROb2RlLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaXNJbXBvcnREb2N1bWVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENvbm5lY3RlZCBsaW5rcyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9oYXNSZWdpc3RyeSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBgdmlzaXRlZEltcG9ydHNgIHNldCB0aGF0IHdhcyBwb3B1bGF0ZWQgc3luYyBkdXJpbmdcbiAgICAgICAgICAgIC8vIHRoZSBgcGF0Y2hBbmRVcGdyYWRlVHJlZWAgY2FsbCB0aGF0IGNhdXNlZCB0aGlzICdsb2FkJyBoYW5kbGVyIHRvXG4gICAgICAgICAgICAvLyBiZSBhZGRlZC4gVGhlbiwgcmVtb3ZlICp0aGlzKiBsaW5rJ3MgaW1wb3J0IG5vZGUgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHdhbGsgdGhhdCBpbXBvcnQgYWdhaW4sIGV2ZW4gaWYgaXQgd2FzIHBhcnRpYWxseSB3YWxrZWQgbGF0ZXJcbiAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgc2FtZSBgcGF0Y2hBbmRVcGdyYWRlVHJlZWAgY2FsbC5cbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZpc2l0ZWRJbXBvcnRzID0gbmV3IFNldCh2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgICAgICB2aXNpdGVkSW1wb3J0cy5kZWxldGUoaW1wb3J0Tm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMucGF0Y2hBbmRVcGdyYWRlVHJlZShpbXBvcnROb2RlLCB2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50c2AgcG9wdWxhdGVzIChhbmQgaW50ZXJuYWxseSBjaGVja3MgYWdhaW5zdClcbiAgICAvLyBgdmlzaXRlZEltcG9ydHNgIHdoZW4gdHJhdmVyc2luZyBhIGxvYWRlZCBpbXBvcnQuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGdhdGhlckVsZW1lbnRzLCB2aXNpdGVkSW1wb3J0cyk7XG5cbiAgICBpZiAodGhpcy5faGFzUGF0Y2hlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhdGNoKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVwZ3JhZGVFbGVtZW50KGVsZW1lbnRzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgdXBncmFkZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGVsZW1lbnQuX19DRV9zdGF0ZTtcbiAgICBpZiAoY3VycmVudFN0YXRlICE9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgaWYgKCFkZWZpbml0aW9uKSByZXR1cm47XG5cbiAgICBkZWZpbml0aW9uLmNvbnN0cnVjdGlvblN0YWNrLnB1c2goZWxlbWVudCk7XG5cbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGRlZmluaXRpb24uY29uc3RydWN0b3I7XG4gICAgdHJ5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgKGNvbnN0cnVjdG9yKSgpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3IgZGlkIG5vdCBwcm9kdWNlIHRoZSBlbGVtZW50IGJlaW5nIHVwZ3JhZGVkLicpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkZWZpbml0aW9uLmNvbnN0cnVjdGlvblN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVsZW1lbnQuX19DRV9zdGF0ZSA9IENFU3RhdGUuZmFpbGVkO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9fQ0Vfc3RhdGUgPSBDRVN0YXRlLmN1c3RvbTtcbiAgICBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG5cbiAgICBpZiAoZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkQXR0cmlidXRlcyA9IGRlZmluaXRpb24ub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYnNlcnZlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9ic2VydmVkQXR0cmlidXRlc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZWxlbWVudCwgbmFtZSwgbnVsbCwgdmFsdWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZChlbGVtZW50KSkge1xuICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmaW5pdGlvbi5jb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgZGVmaW5pdGlvbi5jb25uZWN0ZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBkaXNjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50Ll9fQ0VfaXNDb25uZWN0ZWRDYWxsYmFja0NhbGxlZCkge1xuICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG4gICAgaWYgKGRlZmluaXRpb24uZGlzY29ubmVjdGVkQ2FsbGJhY2spIHtcbiAgICAgIGRlZmluaXRpb24uZGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9fQ0VfaXNDb25uZWN0ZWRDYWxsYmFja0NhbGxlZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkVmFsdWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBuZXdWYWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgKi9cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGVsZW1lbnQsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGVsZW1lbnQuX19DRV9kZWZpbml0aW9uO1xuICAgIGlmIChcbiAgICAgIGRlZmluaXRpb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrICYmXG4gICAgICBkZWZpbml0aW9uLm9ic2VydmVkQXR0cmlidXRlcy5pbmRleE9mKG5hbWUpID4gLTFcbiAgICApIHtcbiAgICAgIGRlZmluaXRpb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwoZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGludGVybmFscywgZG9jKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfVxuICAgICAqL1xuICAgIHRoaXMuX2ludGVybmFscyA9IGludGVybmFscztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshRG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5fZG9jdW1lbnQgPSBkb2M7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG5cblxuICAgIC8vIFNpbXVsYXRlIHRyZWUgY29uc3RydWN0aW9uIGZvciBhbGwgY3VycmVudGx5IGFjY2Vzc2libGUgbm9kZXMgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUodGhpcy5fZG9jdW1lbnQpO1xuXG4gICAgaWYgKHRoaXMuX2RvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9oYW5kbGVNdXRhdGlvbnMuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIE5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciBhcmUgZ2l2ZW4gdG8gdGhlIG9ic2VydmVyICpiZWZvcmUqIHRoZSBuZXh0XG4gICAgICAvLyB0YXNrIHJ1bnMuIElubGluZSBzY3JpcHRzIGFyZSBydW4gaW4gYSBuZXcgdGFzay4gVGhpcyBtZWFucyB0aGF0IHRoZVxuICAgICAgLy8gb2JzZXJ2ZXIgd2lsbCBiZSBhYmxlIHRvIGhhbmRsZSB0aGUgbmV3bHkgcGFyc2VkIG5vZGVzIGJlZm9yZSB0aGUgaW5saW5lXG4gICAgICAvLyBzY3JpcHQgaXMgcnVuLlxuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSBtdXRhdGlvbnNcbiAgICovXG4gIF9oYW5kbGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgLy8gT25jZSB0aGUgZG9jdW1lbnQncyBgcmVhZHlTdGF0ZWAgaXMgJ2ludGVyYWN0aXZlJyBvciAnY29tcGxldGUnLCBhbGwgbmV3XG4gICAgLy8gbm9kZXMgY3JlYXRlZCB3aXRoaW4gdGhhdCBkb2N1bWVudCB3aWxsIGJlIHRoZSByZXN1bHQgb2Ygc2NyaXB0IGFuZFxuICAgIC8vIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHBhdGNoaW5nLlxuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLl9kb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IHJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhZGRlZE5vZGVzID0gbXV0YXRpb25zW2ldLmFkZGVkTm9kZXM7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFkZGVkTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGFkZGVkTm9kZXNbal07XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZlcnJlZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshUHJvbWlzZTxUPn1cbiAgICAgKi9cbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5fdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gdmFsdWVcbiAgICovXG4gIHJlc29sdmUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWxyZWFkeSByZXNvbHZlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKHRoaXMuX3Jlc29sdmUpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTxUPn1cbiAgICovXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgfVxufVxuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIGZyb20gJy4vRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlci5qcyc7XG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi9EZWZlcnJlZC5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi9VdGlsaXRpZXMuanMnO1xuXG4vKipcbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IHtcblxuICAvKipcbiAgICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbHMpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQ3VzdG9tRWxlbWVudEludGVybmFsc31cbiAgICAgKi9cbiAgICB0aGlzLl9pbnRlcm5hbHMgPSBpbnRlcm5hbHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshTWFwPHN0cmluZywgIURlZmVycmVkPHVuZGVmaW5lZD4+fVxuICAgICAqL1xuICAgIHRoaXMuX3doZW5EZWZpbmVkRGVmZXJyZWQgPSBuZXcgTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmbHVzaCBjYWxsYmFjayB0cmlnZ2VycyB0aGUgZG9jdW1lbnQgd2FsayBzeW5jaHJvbm91c2x5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gZm4gPT4gZm4oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fZmx1c2hQZW5kaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9kb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyID0gbmV3IERvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIoaW50ZXJuYWxzLCBkb2N1bWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAgICovXG4gIGRlZmluZShsb2NhbE5hbWUsIGNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0N1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9ycyBtdXN0IGJlIGZ1bmN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAoIVV0aWxpdGllcy5pc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUobG9jYWxOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgZWxlbWVudCBuYW1lICcke2xvY2FsTmFtZX0nIGlzIG5vdCB2YWxpZC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgY3VzdG9tIGVsZW1lbnQgd2l0aCBuYW1lICcke2xvY2FsTmFtZX0nIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBjdXN0b20gZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIGRlZmluZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGxldCBjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBsZXQgZGlzY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgbGV0IGFkb3B0ZWRDYWxsYmFjaztcbiAgICBsZXQgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrO1xuICAgIGxldCBvYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgdHJ5IHtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIGNvbnN0IHByb3RvdHlwZSA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgIGlmICghKHByb3RvdHlwZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9yXFwncyBwcm90b3R5cGUgaXMgbm90IGFuIG9iamVjdC4nKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2sobmFtZSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja1ZhbHVlID0gcHJvdG90eXBlW25hbWVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICEoY2FsbGJhY2tWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke25hbWV9JyBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2Nvbm5lY3RlZENhbGxiYWNrJyk7XG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdkaXNjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgYWRvcHRlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2Fkb3B0ZWRDYWxsYmFjaycpO1xuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycpO1xuICAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gY29uc3RydWN0b3JbJ29ic2VydmVkQXR0cmlidXRlcyddIHx8IFtdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0ge1xuICAgICAgbG9jYWxOYW1lLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjayxcbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrLFxuICAgICAgYWRvcHRlZENhbGxiYWNrLFxuICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLFxuICAgICAgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgICAgY29uc3RydWN0aW9uU3RhY2s6IFtdLFxuICAgIH07XG5cbiAgICB0aGlzLl9pbnRlcm5hbHMuc2V0RGVmaW5pdGlvbihsb2NhbE5hbWUsIGRlZmluaXRpb24pO1xuXG4gICAgdGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5wdXNoKGxvY2FsTmFtZSk7XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGNhbGxlZCB0aGUgZmx1c2ggY2FsbGJhY2sgYW5kIGl0IGhhc24ndCBjYWxsZWQgYmFjayB5ZXQsXG4gICAgLy8gZG9uJ3QgY2FsbCBpdCBhZ2Fpbi5cbiAgICBpZiAoIXRoaXMuX2ZsdXNoUGVuZGluZykge1xuICAgICAgdGhpcy5fZmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2soKCkgPT4gdGhpcy5fZmx1c2goKSk7XG4gICAgfVxuICB9XG5cbiAgX2ZsdXNoKCkge1xuICAgIC8vIElmIG5vIG5ldyBkZWZpbml0aW9ucyB3ZXJlIGRlZmluZWQsIGRvbid0IGF0dGVtcHQgdG8gZmx1c2guIFRoaXMgY291bGRcbiAgICAvLyBoYXBwZW4gaWYgYSBmbHVzaCBjYWxsYmFjayBrZWVwcyB0aGUgZnVuY3Rpb24gaXQgaXMgZ2l2ZW4gYW5kIGNhbGxzIGl0XG4gICAgLy8gbXVsdGlwbGUgdGltZXMuXG4gICAgaWYgKHRoaXMuX2ZsdXNoUGVuZGluZyA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgIHRoaXMuX2ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKGRvY3VtZW50KTtcblxuICAgIHdoaWxlICh0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5nZXQobG9jYWxOYW1lKTtcbiAgICAgIGlmIChkZWZlcnJlZCkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0KGxvY2FsTmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9pbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiBkZWZpbml0aW9uLmNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcmV0dXJuIHshUHJvbWlzZTx1bmRlZmluZWQ+fVxuICAgKi9cbiAgd2hlbkRlZmluZWQobG9jYWxOYW1lKSB7XG4gICAgaWYgKCFVdGlsaXRpZXMuaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lKGxvY2FsTmFtZSkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgU3ludGF4RXJyb3IoYCcke2xvY2FsTmFtZX0nIGlzIG5vdCBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUuYCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW9yID0gdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5nZXQobG9jYWxOYW1lKTtcbiAgICBpZiAocHJpb3IpIHtcbiAgICAgIHJldHVybiBwcmlvci50b1Byb21pc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHRoaXMuX3doZW5EZWZpbmVkRGVmZXJyZWQuc2V0KGxvY2FsTmFtZSwgZGVmZXJyZWQpO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcbiAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IG9ubHkgaWYgdGhlIGdpdmVuIGxvY2FsIG5hbWUgaGFzIGEgZGVmaW5pdGlvbiAqYW5kKlxuICAgIC8vIHRoZSBmdWxsIGRvY3VtZW50IHdhbGsgdG8gdXBncmFkZSBlbGVtZW50cyB3aXRoIHRoYXQgbG9jYWwgbmFtZSBoYXNcbiAgICAvLyBhbHJlYWR5IGhhcHBlbmVkLlxuICAgIGlmIChkZWZpbml0aW9uICYmIHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMuaW5kZXhPZihsb2NhbE5hbWUpID09PSAtMSkge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZlcnJlZC50b1Byb21pc2UoKTtcbiAgfVxuXG4gIHBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2sob3V0ZXIpIHtcbiAgICB0aGlzLl9kb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBjb25zdCBpbm5lciA9IHRoaXMuX2ZsdXNoQ2FsbGJhY2s7XG4gICAgdGhpcy5fZmx1c2hDYWxsYmFjayA9IGZsdXNoID0+IG91dGVyKCgpID0+IGlubmVyKGZsdXNoKSk7XG4gIH1cbn1cblxuLy8gQ2xvc3VyZSBjb21waWxlciBleHBvcnRzLlxud2luZG93WydDdXN0b21FbGVtZW50UmVnaXN0cnknXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeTtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ2RlZmluZSddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5kZWZpbmU7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydnZXQnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZ2V0O1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsnd2hlbkRlZmluZWQnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUud2hlbkRlZmluZWQ7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrJ10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2s7XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIERvY3VtZW50X2NyZWF0ZUVsZW1lbnQ6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCxcbiAgRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnROUyxcbiAgRG9jdW1lbnRfaW1wb3J0Tm9kZTogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLFxuICBEb2N1bWVudF9wcmVwZW5kOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlWydwcmVwZW5kJ10sXG4gIERvY3VtZW50X2FwcGVuZDogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZVsnYXBwZW5kJ10sXG4gIE5vZGVfY2xvbmVOb2RlOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlLFxuICBOb2RlX2FwcGVuZENoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQsXG4gIE5vZGVfaW5zZXJ0QmVmb3JlOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLFxuICBOb2RlX3JlbW92ZUNoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsXG4gIE5vZGVfcmVwbGFjZUNoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkLFxuICBOb2RlX3RleHRDb250ZW50OiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5Ob2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50JyksXG4gIEVsZW1lbnRfYXR0YWNoU2hhZG93OiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2F0dGFjaFNoYWRvdyddLFxuICBFbGVtZW50X2lubmVySFRNTDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsICdpbm5lckhUTUwnKSxcbiAgRWxlbWVudF9nZXRBdHRyaWJ1dGU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUsXG4gIEVsZW1lbnRfc2V0QXR0cmlidXRlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLFxuICBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxcbiAgRWxlbWVudF9nZXRBdHRyaWJ1dGVOUzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5TLFxuICBFbGVtZW50X3NldEF0dHJpYnV0ZU5TOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsXG4gIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlM6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyxcbiAgRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnaW5zZXJ0QWRqYWNlbnRFbGVtZW50J10sXG4gIEVsZW1lbnRfcHJlcGVuZDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydwcmVwZW5kJ10sXG4gIEVsZW1lbnRfYXBwZW5kOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2FwcGVuZCddLFxuICBFbGVtZW50X2JlZm9yZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydiZWZvcmUnXSxcbiAgRWxlbWVudF9hZnRlcjogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydhZnRlciddLFxuICBFbGVtZW50X3JlcGxhY2VXaXRoOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ3JlcGxhY2VXaXRoJ10sXG4gIEVsZW1lbnRfcmVtb3ZlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ3JlbW92ZSddLFxuICBIVE1MRWxlbWVudDogd2luZG93LkhUTUxFbGVtZW50LFxuICBIVE1MRWxlbWVudF9pbm5lckhUTUw6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2lubmVySFRNTCcpLFxuICBIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQ6IHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGVbJ2luc2VydEFkamFjZW50RWxlbWVudCddLFxufTtcbiIsIi8qKlxuICogVGhpcyBjbGFzcyBleGlzdHMgb25seSB0byB3b3JrIGFyb3VuZCBDbG9zdXJlJ3MgbGFjayBvZiBhIHdheSB0byBkZXNjcmliZVxuICogc2luZ2xldG9ucy4gSXQgcmVwcmVzZW50cyB0aGUgJ2FscmVhZHkgY29uc3RydWN0ZWQgbWFya2VyJyB1c2VkIGluIGN1c3RvbVxuICogZWxlbWVudCBjb25zdHJ1Y3Rpb24gc3RhY2tzLlxuICpcbiAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYWxyZWFkeS1jb25zdHJ1Y3RlZC1tYXJrZXJcbiAqL1xuY2xhc3MgQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyIHt9XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIoKTtcbiIsImltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuaW1wb3J0IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlciBmcm9tICcuLi9BbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgd2luZG93WydIVE1MRWxlbWVudCddID0gKGZ1bmN0aW9uKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihuZXc6IEhUTUxFbGVtZW50KTogIUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhUTUxFbGVtZW50KCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgcmVhbGx5IGJlIGBuZXcudGFyZ2V0YCBidXQgYG5ldy50YXJnZXRgIGNhbid0IGJlIGVtdWxhdGVkXG4gICAgICAvLyBpbiBFUzUuIEFzc3VtaW5nIHRoZSB1c2VyIGtlZXBzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBjb25zdHJ1Y3RvcidzXG4gICAgICAvLyBwcm90b3R5cGUncyBgY29uc3RydWN0b3JgIHByb3BlcnR5LCB0aGlzIGlzIGVxdWl2YWxlbnQuXG4gICAgICAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi9cbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGludGVybmFscy5jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbihjb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VzdG9tIGVsZW1lbnQgYmVpbmcgY29uc3RydWN0ZWQgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggYGN1c3RvbUVsZW1lbnRzYC4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29uc3RydWN0aW9uU3RhY2sgPSBkZWZpbml0aW9uLmNvbnN0cnVjdGlvblN0YWNrO1xuXG4gICAgICBpZiAoY29uc3RydWN0aW9uU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCBkZWZpbml0aW9uLmxvY2FsTmFtZSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihlbGVtZW50LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBlbGVtZW50Ll9fQ0Vfc3RhdGUgPSBDRVN0YXRlLmN1c3RvbTtcbiAgICAgICAgZWxlbWVudC5fX0NFX2RlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2goZWxlbWVudCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBjb25zdHJ1Y3Rpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGNvbnN0cnVjdGlvblN0YWNrW2xhc3RJbmRleF07XG4gICAgICBpZiAoZWxlbWVudCA9PT0gQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIEhUTUxFbGVtZW50IGNvbnN0cnVjdG9yIHdhcyBlaXRoZXIgY2FsbGVkIHJlZW50cmFudGx5IGZvciB0aGlzIGNvbnN0cnVjdG9yIG9yIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdGlvblN0YWNrW2xhc3RJbmRleF0gPSBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXI7XG5cbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihlbGVtZW50LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgaW50ZXJuYWxzLnBhdGNoKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyAoZWxlbWVudCkpO1xuXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUgPSBOYXRpdmUuSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9KSgpO1xufTtcbiIsImltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uLy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uLy4uL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgcHJlcGVuZDogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAgKiAgYXBwZW5kOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogfX1cbiAqL1xubGV0IFBhcmVudE5vZGVOYXRpdmVNZXRob2RzO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICogQHBhcmFtIHshT2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHshUGFyZW50Tm9kZU5hdGl2ZU1ldGhvZHN9IGJ1aWx0SW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzLCBkZXN0aW5hdGlvbiwgYnVpbHRJbikge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydwcmVwZW5kJ10gPSBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcbiAgICBjb25zdCBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovIChub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgIH0pKTtcblxuICAgIGJ1aWx0SW4ucHJlcGVuZC5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydhcHBlbmQnXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5hcHBlbmQuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi9VdGlsaXRpZXMuanMnO1xuXG5pbXBvcnQgUGF0Y2hQYXJlbnROb2RlIGZyb20gJy4vSW50ZXJmYWNlL1BhcmVudE5vZGUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2NyZWF0ZUVsZW1lbnQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAgICogQHJldHVybiB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24obG9jYWxOYW1lKSB7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKHRoaXMuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgKGRlZmluaXRpb24uY29uc3RydWN0b3IpKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cbiAgICAgICAgKE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbG9jYWxOYW1lKSk7XG4gICAgICBpbnRlcm5hbHMucGF0Y2gocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2ltcG9ydE5vZGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZGVlcFxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUsIGRlZXApIHtcbiAgICAgIGNvbnN0IGNsb25lID0gTmF0aXZlLkRvY3VtZW50X2ltcG9ydE5vZGUuY2FsbCh0aGlzLCBub2RlLCBkZWVwKTtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGRvY3VtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAoIXRoaXMuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2hUcmVlKGNsb25lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKGNsb25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9KTtcblxuICBjb25zdCBOU19IVE1MID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2NyZWF0ZUVsZW1lbnROUycsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0RvY3VtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgICAqIEByZXR1cm4geyFFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5hbWVzcGFjZSwgbG9jYWxOYW1lKSB7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKHRoaXMuX19DRV9oYXNSZWdpc3RyeSAmJiAobmFtZXNwYWNlID09PSBudWxsIHx8IG5hbWVzcGFjZSA9PT0gTlNfSFRNTCkpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IChkZWZpbml0aW9uLmNvbnN0cnVjdG9yKSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG4gICAgICAgIChOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBsb2NhbE5hbWUpKTtcbiAgICAgIGludGVybmFscy5wYXRjaChyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICBQYXRjaFBhcmVudE5vZGUoaW50ZXJuYWxzLCBEb2N1bWVudC5wcm90b3R5cGUsIHtcbiAgICBwcmVwZW5kOiBOYXRpdmUuRG9jdW1lbnRfcHJlcGVuZCxcbiAgICBhcHBlbmQ6IE5hdGl2ZS5Eb2N1bWVudF9hcHBlbmQsXG4gIH0pO1xufTtcbiIsImltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vVXRpbGl0aWVzLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzKSB7XG4gIC8vIGBOb2RlI25vZGVWYWx1ZWAgaXMgaW1wbGVtZW50ZWQgb24gYEF0dHJgLlxuICAvLyBgTm9kZSN0ZXh0Q29udGVudGAgaXMgaW1wbGVtZW50ZWQgb24gYEF0dHJgLCBgRWxlbWVudGAuXG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAnaW5zZXJ0QmVmb3JlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gcmVmTm9kZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUsIHJlZk5vZGUpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBjb25zdCBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2luc2VydEJlZm9yZS5jYWxsKHRoaXMsIG5vZGUsIHJlZk5vZGUpO1xuXG4gICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2luc2VydEJlZm9yZS5jYWxsKHRoaXMsIG5vZGUsIHJlZk5vZGUpO1xuXG4gICAgICBpZiAobm9kZVdhc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2FwcGVuZENoaWxkJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBjYW4ndCBiZSBjb25uZWN0ZWQsIHNvIGBkaXNjb25uZWN0VHJlZWAgd2lsbCBuZXZlclxuICAgICAgICAvLyBuZWVkIHRvIGJlIGNhbGxlZCBvbiBhIERvY3VtZW50RnJhZ21lbnQncyBjaGlsZHJlbiBhZnRlciBpbnNlcnRpbmcgaXQuXG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zZXJ0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGluc2VydGVkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgICBpZiAobm9kZVdhc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2Nsb25lTm9kZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZGVlcFxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgIGNvbnN0IGNsb25lID0gTmF0aXZlLk5vZGVfY2xvbmVOb2RlLmNhbGwodGhpcywgZGVlcCk7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQgaXNcbiAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAoIXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaFRyZWUoY2xvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoY2xvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ3JlbW92ZUNoaWxkJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgY29uc3Qgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdyZXBsYWNlQ2hpbGQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVUb0luc2VydFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVUb1JlbW92ZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKSB7XG4gICAgICBpZiAobm9kZVRvSW5zZXJ0IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBjb25zdCBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGVUb0luc2VydC5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfcmVwbGFjZUNoaWxkLmNhbGwodGhpcywgbm9kZVRvSW5zZXJ0LCBub2RlVG9SZW1vdmUpO1xuXG4gICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb1JlbW92ZSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGVUb0luc2VydCk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9yZXBsYWNlQ2hpbGQuY2FsbCh0aGlzLCBub2RlVG9JbnNlcnQsIG5vZGVUb1JlbW92ZSk7XG4gICAgICBjb25zdCB0aGlzSXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzSXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb1JlbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlVG9JbnNlcnRXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb0luc2VydCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzSXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGVUb0luc2VydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cblxuICBmdW5jdGlvbiBwYXRjaF90ZXh0Q29udGVudChkZXN0aW5hdGlvbiwgYmFzZURlc2NyaXB0b3IpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdGluYXRpb24sICd0ZXh0Q29udGVudCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGJhc2VEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGJhc2VEZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldDogLyoqIEB0aGlzIHtOb2RlfSAqLyBmdW5jdGlvbihhc3NpZ25lZFZhbHVlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSB0ZXh0IG5vZGUgdGhlbiB0aGVyZSBhcmUgbm8gbm9kZXMgdG8gZGlzY29ubmVjdC5cbiAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgYXNzaWduZWRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlbW92ZWROb2RlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2hlY2tpbmcgZm9yIGBmaXJzdENoaWxkYCBpcyBmYXN0ZXIgdGhhbiByZWFkaW5nIGBjaGlsZE5vZGVzLmxlbmd0aGBcbiAgICAgICAgLy8gdG8gY29tcGFyZSB3aXRoIDAuXG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAvLyBVc2luZyBgY2hpbGROb2Rlc2AgaXMgZmFzdGVyIHRoYW4gYGNoaWxkcmVuYCwgZXZlbiB0aG91Z2ggd2Ugb25seVxuICAgICAgICAgIC8vIGNhcmUgYWJvdXQgZWxlbWVudHMuXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNMZW5ndGggPiAwICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgICAgLy8gQ29weWluZyBhbiBhcnJheSBieSBpdGVyYXRpbmcgaXMgZmFzdGVyIHRoYW4gdXNpbmcgc2xpY2UuXG4gICAgICAgICAgICByZW1vdmVkTm9kZXMgPSBuZXcgQXJyYXkoY2hpbGROb2Rlc0xlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICByZW1vdmVkTm9kZXNbaV0gPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VEZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIGFzc2lnbmVkVmFsdWUpO1xuXG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKHJlbW92ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50ICYmIE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50LmdldCkge1xuICAgIHBhdGNoX3RleHRDb250ZW50KE5vZGUucHJvdG90eXBlLCBOYXRpdmUuTm9kZV90ZXh0Q29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxzLmFkZFBhdGNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHBhdGNoX3RleHRDb250ZW50KGVsZW1lbnQsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAvLyBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgdGV4dENvbnRlbnRgIGdldHRlciBhc3N1bWVzIHRoYXRcbiAgICAgICAgLy8gdGV4dCBub2RlcycgYHRleHRDb250ZW50YCBnZXR0ZXIgd2lsbCBub3QgYmUgcGF0Y2hlZC5cbiAgICAgICAgZ2V0OiAvKiogQHRoaXMge05vZGV9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59ICovXG4gICAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuY2hpbGROb2Rlc1tpXS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IC8qKiBAdGhpcyB7Tm9kZX0gKi8gZnVuY3Rpb24oYXNzaWduZWRWYWx1ZSkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwodGhpcywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbCh0aGlzLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhc3NpZ25lZFZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsImltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uLy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uLy4uL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYmVmb3JlOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogICBhZnRlcjogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqICAgcmVwbGFjZVdpdGg6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiAgIHJlbW92ZTogIWZ1bmN0aW9uKCksXG4gKiB9fVxuICovXG5sZXQgQ2hpbGROb2RlTmF0aXZlTWV0aG9kcztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7IUNoaWxkTm9kZU5hdGl2ZU1ldGhvZHN9IGJ1aWx0SW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzLCBkZXN0aW5hdGlvbiwgYnVpbHRJbikge1xuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydiZWZvcmUnXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5iZWZvcmUuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uKCFOb2RlfHN0cmluZyl9IG5vZGVzXG4gICAqL1xuICBkZXN0aW5hdGlvblsnYWZ0ZXInXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5hZnRlci5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydyZXBsYWNlV2l0aCddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBjb25zdCB3YXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICBidWlsdEluLnJlcGxhY2VXaXRoLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUodGhpcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGRlc3RpbmF0aW9uWydyZW1vdmUnXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgIGJ1aWx0SW4ucmVtb3ZlLmNhbGwodGhpcyk7XG5cbiAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUodGhpcyk7XG4gICAgfVxuICB9O1xufTtcbiIsImltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uL1V0aWxpdGllcy5qcyc7XG5cbmltcG9ydCBQYXRjaFBhcmVudE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvUGFyZW50Tm9kZS5qcyc7XG5pbXBvcnQgUGF0Y2hDaGlsZE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvQ2hpbGROb2RlLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzKSB7XG4gIGlmIChOYXRpdmUuRWxlbWVudF9hdHRhY2hTaGFkb3cpIHtcbiAgICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdhdHRhY2hTaGFkb3cnLFxuICAgICAgLyoqXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEBwYXJhbSB7IXttb2RlOiBzdHJpbmd9fSBpbml0XG4gICAgICAgKiBAcmV0dXJuIHtTaGFkb3dSb290fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihpbml0KSB7XG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBOYXRpdmUuRWxlbWVudF9hdHRhY2hTaGFkb3cuY2FsbCh0aGlzLCBpbml0KTtcbiAgICAgICAgdGhpcy5fX0NFX3NoYWRvd1Jvb3QgPSBzaGFkb3dSb290O1xuICAgICAgICByZXR1cm4gc2hhZG93Um9vdDtcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIEVsZW1lbnRzOiBgRWxlbWVudCNhdHRhY2hTaGFkb3dgIHdhcyBub3QgcGF0Y2hlZC4nKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcGF0Y2hfaW5uZXJIVE1MKGRlc3RpbmF0aW9uLCBiYXNlRGVzY3JpcHRvcikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0aW5hdGlvbiwgJ2lubmVySFRNTCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGJhc2VEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGJhc2VEZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldDogLyoqIEB0aGlzIHtFbGVtZW50fSAqLyBmdW5jdGlvbihodG1sU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpO1xuXG4gICAgICAgIC8vIE5PVEU6IEluIElFMTEsIHdoZW4gdXNpbmcgdGhlIG5hdGl2ZSBgaW5uZXJIVE1MYCBzZXR0ZXIsIGFsbCBub2Rlc1xuICAgICAgICAvLyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZXNjZW5kYW50cyBvZiB0aGUgY29udGV4dCBlbGVtZW50IGhhdmUgYWxsIG9mXG4gICAgICAgIC8vIHRoZWlyIGNoaWxkcmVuIHJlbW92ZWQgYXMgcGFydCBvZiB0aGUgc2V0IC0gdGhlIGVudGlyZSBzdWJ0cmVlIGlzXG4gICAgICAgIC8vICdkaXNhc3NlbWJsZWQnLiBUaGlzIHdvcmsgYXJvdW5kIHdhbGtzIHRoZSBzdWJ0cmVlICpiZWZvcmUqIHVzaW5nIHRoZVxuICAgICAgICAvLyBuYXRpdmUgc2V0dGVyLlxuICAgICAgICAvKiogQHR5cGUgeyFBcnJheTwhRWxlbWVudD58dW5kZWZpbmVkfSAqL1xuICAgICAgICBsZXQgcmVtb3ZlZEVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICByZW1vdmVkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHModGhpcywgZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICByZW1vdmVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VEZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIGh0bWxTdHJpbmcpO1xuXG4gICAgICAgIGlmIChyZW1vdmVkRWxlbWVudHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlbW92ZWRFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgICAgICAgIGludGVybmFscy5kaXNjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgICAgaWYgKCF0aGlzLm93bmVyRG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICAgIGludGVybmFscy5wYXRjaFRyZWUodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWxTdHJpbmc7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTCAmJiBOYXRpdmUuRWxlbWVudF9pbm5lckhUTUwuZ2V0KSB7XG4gICAgcGF0Y2hfaW5uZXJIVE1MKEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuRWxlbWVudF9pbm5lckhUTUwpO1xuICB9IGVsc2UgaWYgKE5hdGl2ZS5IVE1MRWxlbWVudF9pbm5lckhUTUwgJiYgTmF0aXZlLkhUTUxFbGVtZW50X2lubmVySFRNTC5nZXQpIHtcbiAgICBwYXRjaF9pbm5lckhUTUwoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuSFRNTEVsZW1lbnRfaW5uZXJIVE1MKTtcbiAgfSBlbHNlIHtcblxuICAgIC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovXG4gICAgY29uc3QgcmF3RGl2ID0gTmF0aXZlLkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCwgJ2RpdicpO1xuXG4gICAgaW50ZXJuYWxzLmFkZFBhdGNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHBhdGNoX2lubmVySFRNTChlbGVtZW50LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gSW1wbGVtZW50cyBnZXR0aW5nIGBpbm5lckhUTUxgIGJ5IHBlcmZvcm1pbmcgYW4gdW5wYXRjaGVkIGBjbG9uZU5vZGVgXG4gICAgICAgIC8vIG9mIHRoZSBlbGVtZW50IGFuZCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBlbGVtZW50J3MgYGlubmVySFRNTGAuXG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgdG9vIGV4cGVuc2l2ZT9cbiAgICAgICAgZ2V0OiAvKiogQHRoaXMge0VsZW1lbnR9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBOYXRpdmUuTm9kZV9jbG9uZU5vZGUuY2FsbCh0aGlzLCB0cnVlKS5pbm5lckhUTUw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEltcGxlbWVudHMgc2V0dGluZyBgaW5uZXJIVE1MYCBieSBjcmVhdGluZyBhbiB1bnBhdGNoZWQgZWxlbWVudCxcbiAgICAgICAgLy8gc2V0dGluZyBgaW5uZXJIVE1MYCBvZiB0aGF0IGVsZW1lbnQgYW5kIHJlcGxhY2luZyB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIGVsZW1lbnQncyBjaGlsZHJlbiB3aXRoIHRob3NlIG9mIHRoZSB1bnBhdGNoZWQgZWxlbWVudC5cbiAgICAgICAgc2V0OiAvKiogQHRoaXMge0VsZW1lbnR9ICovIGZ1bmN0aW9uKGFzc2lnbmVkVmFsdWUpIHtcbiAgICAgICAgICAvLyBOT1RFOiByZS1yb3V0ZSB0byBgY29udGVudGAgZm9yIGB0ZW1wbGF0ZWAgZWxlbWVudHMuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGJlY2F1c2UgYHRlbXBsYXRlLmFwcGVuZENoaWxkYCBkb2VzIG5vdFxuICAgICAgICAgIC8vIHJvdXRlIGludG8gYHRlbXBsYXRlLmNvbnRlbnRgLlxuICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMubG9jYWxOYW1lID09PSAndGVtcGxhdGUnID8gKC8qKiBAdHlwZSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9ICovICh0aGlzKSkuY29udGVudCA6IHRoaXM7XG4gICAgICAgICAgcmF3RGl2LmlubmVySFRNTCA9IGFzc2lnbmVkVmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwoY29udGVudCwgY29udGVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJhd0Rpdi5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwoY29udGVudCwgcmF3RGl2LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdzZXRBdHRyaWJ1dGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICBuZXdWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG51bGwpO1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3NldEF0dHJpYnV0ZU5TJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZXNwYWNlLCBuYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGludGVybmFscy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcywgbmFtZSwgb2xkVmFsdWUsIG51bGwsIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3JlbW92ZUF0dHJpYnV0ZU5TJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZXNwYWNlLCBuYW1lKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICByZXR1cm4gTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIC8vIEluIG9sZGVyIGJyb3dzZXJzLCBgRWxlbWVudCNnZXRBdHRyaWJ1dGVOU2AgbWF5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICAvLyBpbnN0ZWFkIG9mIG51bGwgaWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdC4gRm9yIGRldGFpbHMsIHNlZTtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEF0dHJpYnV0ZU5TI05vdGVzXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfSk7XG5cblxuICBmdW5jdGlvbiBwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQoZGVzdGluYXRpb24sIGJhc2VNZXRob2QpIHtcbiAgICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoZGVzdGluYXRpb24sICdpbnNlcnRBZGphY2VudEVsZW1lbnQnLFxuICAgICAgLyoqXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aGVyZVxuICAgICAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7P0VsZW1lbnR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHdoZXJlLCBlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChlbGVtZW50KTtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWRFbGVtZW50ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cbiAgICAgICAgICAoYmFzZU1ldGhvZC5jYWxsKHRoaXMsIHdoZXJlLCBlbGVtZW50KSk7XG5cbiAgICAgICAgaWYgKHdhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQoaW5zZXJ0ZWRFbGVtZW50KSkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zZXJ0ZWRFbGVtZW50O1xuICAgICAgfSk7XG4gIH1cblxuICBpZiAoTmF0aXZlLkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCkge1xuICAgIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChIVE1MRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5IVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpO1xuICB9IGVsc2UgaWYgKE5hdGl2ZS5FbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCkge1xuICAgIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChFbGVtZW50LnByb3RvdHlwZSwgTmF0aXZlLkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBFbGVtZW50czogYEVsZW1lbnQjaW5zZXJ0QWRqYWNlbnRFbGVtZW50YCB3YXMgbm90IHBhdGNoZWQuJyk7XG4gIH1cblxuXG4gIFBhdGNoUGFyZW50Tm9kZShpbnRlcm5hbHMsIEVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgcHJlcGVuZDogTmF0aXZlLkVsZW1lbnRfcHJlcGVuZCxcbiAgICBhcHBlbmQ6IE5hdGl2ZS5FbGVtZW50X2FwcGVuZCxcbiAgfSk7XG5cbiAgUGF0Y2hDaGlsZE5vZGUoaW50ZXJuYWxzLCBFbGVtZW50LnByb3RvdHlwZSwge1xuICAgIGJlZm9yZTogTmF0aXZlLkVsZW1lbnRfYmVmb3JlLFxuICAgIGFmdGVyOiBOYXRpdmUuRWxlbWVudF9hZnRlcixcbiAgICByZXBsYWNlV2l0aDogTmF0aXZlLkVsZW1lbnRfcmVwbGFjZVdpdGgsXG4gICAgcmVtb3ZlOiBOYXRpdmUuRWxlbWVudF9yZW1vdmUsXG4gIH0pO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRSZWdpc3RyeSBmcm9tICcuL0N1c3RvbUVsZW1lbnRSZWdpc3RyeS5qcyc7XG5cbmltcG9ydCBQYXRjaEhUTUxFbGVtZW50IGZyb20gJy4vUGF0Y2gvSFRNTEVsZW1lbnQuanMnO1xuaW1wb3J0IFBhdGNoRG9jdW1lbnQgZnJvbSAnLi9QYXRjaC9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgUGF0Y2hOb2RlIGZyb20gJy4vUGF0Y2gvTm9kZS5qcyc7XG5pbXBvcnQgUGF0Y2hFbGVtZW50IGZyb20gJy4vUGF0Y2gvRWxlbWVudC5qcyc7XG5cbmNvbnN0IHByaW9yQ3VzdG9tRWxlbWVudHMgPSB3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ107XG5cbmlmICghcHJpb3JDdXN0b21FbGVtZW50cyB8fFxuICAgICBwcmlvckN1c3RvbUVsZW1lbnRzWydmb3JjZVBvbHlmaWxsJ10gfHxcbiAgICAgKHR5cGVvZiBwcmlvckN1c3RvbUVsZW1lbnRzWydkZWZpbmUnXSAhPSAnZnVuY3Rpb24nKSB8fFxuICAgICAodHlwZW9mIHByaW9yQ3VzdG9tRWxlbWVudHNbJ2dldCddICE9ICdmdW5jdGlvbicpKSB7XG4gIC8qKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9ICovXG4gIGNvbnN0IGludGVybmFscyA9IG5ldyBDdXN0b21FbGVtZW50SW50ZXJuYWxzKCk7XG5cbiAgUGF0Y2hIVE1MRWxlbWVudChpbnRlcm5hbHMpO1xuICBQYXRjaERvY3VtZW50KGludGVybmFscyk7XG4gIFBhdGNoTm9kZShpbnRlcm5hbHMpO1xuICBQYXRjaEVsZW1lbnQoaW50ZXJuYWxzKTtcblxuICAvLyBUaGUgbWFpbiBkb2N1bWVudCBpcyBhbHdheXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgZG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeSA9IHRydWU7XG5cbiAgLyoqIEB0eXBlIHshQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5fSAqL1xuICBjb25zdCBjdXN0b21FbGVtZW50cyA9IG5ldyBDdXN0b21FbGVtZW50UmVnaXN0cnkoaW50ZXJuYWxzKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnY3VzdG9tRWxlbWVudHMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGN1c3RvbUVsZW1lbnRzLFxuICB9KTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLy8gQHZlcnNpb24gMC43LjIyXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgaWYgKGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZ2lzdHJhdGlvbnNUYWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzZXRJbW1lZGlhdGU7XG4gIGlmICgvVHJpZGVudHxFZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dDtcbiAgfSBlbHNlIGlmICh3aW5kb3cuc2V0SW1tZWRpYXRlKSB7XG4gICAgc2V0SW1tZWRpYXRlID0gd2luZG93LnNldEltbWVkaWF0ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2V0SW1tZWRpYXRlUXVldWUgPSBbXTtcbiAgICB2YXIgc2VudGluZWwgPSBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmRhdGEgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNldEltbWVkaWF0ZVF1ZXVlO1xuICAgICAgICBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZVF1ZXVlLnB1c2goZnVuYyk7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2Uoc2VudGluZWwsIFwiKlwiKTtcbiAgICB9O1xuICB9XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2sob2JzZXJ2ZXIpIHtcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0SW1tZWRpYXRlKGRpc3BhdGNoQ2FsbGJhY2tzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHwgbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrcygpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBvYnNlcnZlcnMgPSBzY2hlZHVsZWRPYnNlcnZlcnM7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzID0gW107XG4gICAgb2JzZXJ2ZXJzLnNvcnQoZnVuY3Rpb24obzEsIG8yKSB7XG4gICAgICByZXR1cm4gbzEudWlkXyAtIG8yLnVpZF87XG4gICAgfSk7XG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBvYnNlcnZlci5jYWxsYmFja18ocXVldWUsIG9ic2VydmVyKTtcbiAgICAgICAgYW55Tm9uRW1wdHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChhbnlOb25FbXB0eSkgZGlzcGF0Y2hDYWxsYmFja3MoKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpIHJldHVybjtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpIHJlZ2lzdHJhdGlvbi5yZW1vdmVUcmFuc2llbnRPYnNlcnZlcnMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgbm9kZSA9IHRhcmdldDsgbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSByZWdpc3RyYXRpb24ub3B0aW9ucztcbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciByZWNvcmQgPSBjYWxsYmFjayhvcHRpb25zKTtcbiAgICAgICAgICBpZiAocmVjb3JkKSByZWdpc3RyYXRpb24uZW5xdWV1ZShyZWNvcmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciB1aWRDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gSnNNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB0aGlzLm5vZGVzXyA9IFtdO1xuICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB0aGlzLnVpZF8gPSArK3VpZENvdW50ZXI7XG4gIH1cbiAgSnNNdXRhdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHtcbiAgICBvYnNlcnZlOiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHRhcmdldCA9IHdyYXBJZk5lZWRlZCh0YXJnZXQpO1xuICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEgfHwgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlICYmICFvcHRpb25zLmNoYXJhY3RlckRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdpc3RyYXRpb25zW2ldLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xuICAgICAgICB0aGlzLm5vZGVzXy5wdXNoKHRhcmdldCk7XG4gICAgICB9XG4gICAgICByZWdpc3RyYXRpb24uYWRkTGlzdGVuZXJzKCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubm9kZXNfLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIGlmIChyZWdpc3RyYXRpb24ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICB9LFxuICAgIHRha2VSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5T2ZSZWNvcmRzID0gdGhpcy5yZWNvcmRzXztcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICAgIHJldHVybiBjb3B5T2ZSZWNvcmRzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gbnVsbDtcbiAgICB0aGlzLm9sZFZhbHVlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBjb3B5TXV0YXRpb25SZWNvcmQob3JpZ2luYWwpIHtcbiAgICB2YXIgcmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKG9yaWdpbmFsLnR5cGUsIG9yaWdpbmFsLnRhcmdldCk7XG4gICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBvcmlnaW5hbC5hZGRlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnJlbW92ZWROb2RlcyA9IG9yaWdpbmFsLnJlbW92ZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBvcmlnaW5hbC5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmVjb3JkLm5leHRTaWJsaW5nID0gb3JpZ2luYWwubmV4dFNpYmxpbmc7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBvcmlnaW5hbC5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgcmVjb3JkLm9sZFZhbHVlID0gb3JpZ2luYWwub2xkVmFsdWU7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuICB2YXIgY3VycmVudFJlY29yZCwgcmVjb3JkV2l0aE9sZFZhbHVlO1xuICBmdW5jdGlvbiBnZXRSZWNvcmQodHlwZSwgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQodHlwZSwgdGFyZ2V0KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpIHtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZSA9IGNvcHlNdXRhdGlvblJlY29yZChjdXJyZW50UmVjb3JkKTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUmVjb3JkcygpIHtcbiAgICBjdXJyZW50UmVjb3JkID0gcmVjb3JkV2l0aE9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24ocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZCA9PT0gcmVjb3JkV2l0aE9sZFZhbHVlIHx8IHJlY29yZCA9PT0gY3VycmVudFJlY29yZDtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IG5ld1JlY29yZCkgcmV0dXJuIGxhc3RSZWNvcmQ7XG4gICAgaWYgKHJlY29yZFdpdGhPbGRWYWx1ZSAmJiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKGxhc3RSZWNvcmQpKSByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIFJlZ2lzdHJhdGlvbihvYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gIH1cbiAgUmVnaXN0cmF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlbnF1ZXVlOiBmdW5jdGlvbihyZWNvcmQpIHtcbiAgICAgIHZhciByZWNvcmRzID0gdGhpcy5vYnNlcnZlci5yZWNvcmRzXztcbiAgICAgIHZhciBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDtcbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RSZWNvcmQgPSByZWNvcmRzW2xlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xuICAgICAgICAgIHJlY29yZHNbbGVuZ3RoIC0gMV0gPSByZWNvcmRUb1JlcGxhY2VMYXN0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIHJlY29yZHNbbGVuZ3RoXSA9IHJlY29yZDtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18odGhpcy50YXJnZXQpO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01BdHRyTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVSZW1vdmVkXCIsIHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGRUcmFuc2llbnRPYnNlcnZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KSByZXR1cm47XG4gICAgICB0aGlzLmFkZExpc3RlbmVyc18obm9kZSk7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmVnaXN0cmF0aW9uc1RhYmxlLnNldChub2RlLCByZWdpc3RyYXRpb25zID0gW10pO1xuICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHRoaXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzO1xuICAgICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gICAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18obm9kZSk7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICBjYXNlIFwiRE9NQXR0ck1vZGlmaWVkXCI6XG4gICAgICAgIHZhciBuYW1lID0gZS5hdHRyTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGUucmVsYXRlZE5vZGUubmFtZXNwYWNlVVJJO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciByZWNvcmQgPSBuZXcgZ2V0UmVjb3JkKFwiYXR0cmlidXRlc1wiLCB0YXJnZXQpO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IGUuYXR0ckNoYW5nZSA9PT0gTXV0YXRpb25FdmVudC5BRERJVElPTiA/IG51bGwgOiBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmxlbmd0aCAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWUpID09PSAtMSAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWVzcGFjZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCI6XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoYXJhY3RlckRhdGFcIiwgdGFyZ2V0KTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5wcmV2VmFsdWU7XG4gICAgICAgIGZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCh0YXJnZXQsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGFPbGRWYWx1ZSkgcmV0dXJuIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVSZW1vdmVkXCI6XG4gICAgICAgIHRoaXMuYWRkVHJhbnNpZW50T2JzZXJ2ZXIoZS50YXJnZXQpO1xuXG4gICAgICAgY2FzZSBcIkRPTU5vZGVJbnNlcnRlZFwiOlxuICAgICAgICB2YXIgY2hhbmdlZE5vZGUgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcztcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJET01Ob2RlSW5zZXJ0ZWRcIikge1xuICAgICAgICAgIGFkZGVkTm9kZXMgPSBbIGNoYW5nZWROb2RlIF07XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFtdO1xuICAgICAgICAgIHJlbW92ZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjaGFuZ2VkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZChcImNoaWxkTGlzdFwiLCBlLnRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgcmVjb3JkLmFkZGVkTm9kZXMgPSBhZGRlZE5vZGVzO1xuICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nO1xuICAgICAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBuZXh0U2libGluZztcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKGUucmVsYXRlZE5vZGUsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0KSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjbGVhclJlY29yZHMoKTtcbiAgICB9XG4gIH07XG4gIGdsb2JhbC5Kc011dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG4gIGlmICghZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgICBKc011dGF0aW9uT2JzZXJ2ZXIuX2lzUG9seWZpbGxlZCA9IHRydWU7XG4gIH1cbn0pKHNlbGYpO1xuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxMiBCYXJuZXNhbmRub2JsZS5jb20sIGxsYywgRG9uYXZvbiBXZXN0LCBhbmQgRG9tZW5pYyBEZW5pY29sYVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSBwYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBwYXJ0aWFsbHlBcHBsaWVkKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwiXCIgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHNlbGYpKTtcbiIsIi8vIENhdXRpb246XG4vLyBEbyBub3QgcmVwbGFjZSB0aGlzIGltcG9ydCBzdGF0ZW1lbnQgd2l0aCBjb2Rlcy5cbi8vXG4vLyBJZiB5b3UgcmVwbGFjZSB0aGlzIGltcG9ydCBzdGF0ZW1lbnQgd2l0aCBjb2Rlcyxcbi8vIHRoZSBjb2RlcyB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBmb2xsb3dpbmcgcG9seWZpbGxzIGFyZSBpbXBvcnRlZFxuLy8gYmVjYXVzZSBpbXBvcnQgc3RhdGVtZW50cyBhcmUgaG9pc3RlZCBkdXJpbmcgY29tcGlsYXRpb24uXG5pbXBvcnQgJy4vcG9seWZpbGwtc3dpdGNoZXMnO1xuXG4vLyBQb2x5ZmlsbCBFQ01BU2NyaXB0IHN0YW5kYXJkIGZlYXR1cmVzIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnY29yZS1qcy9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZic7XG5pbXBvcnQgJ2NvcmUtanMvZm4vc2V0JztcbmltcG9ydCAnY29yZS1qcy9mbi9tYXAnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL3dlYWstbWFwJztcbmltcG9ydCAnY29yZS1qcy9mbi9hcnJheS9mcm9tJztcblxuLy8gUG9seWZpbGwgQ3VzdG9tIEVsZW1lbnRzIHYxIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9jdXN0b20tZWxlbWVudHMnO1xuXG4vLyBQb2x5ZmlsbCBNdXRhdGlvbk9ic2VydmVyIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnLi9NdXRhdGlvbk9ic2VydmVyQDAuNy4yMi9NdXRhdGlvbk9ic2VydmVyLmpzJztcblxuLy8gUG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnLi9zZXRJbW1lZGlhdGVAMS4wLjIrbW9kL3NldEltbWVkaWF0ZS5qcyc7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBERUZBVUxUX1ZJRVdQT1JUID0gJ3dpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEsbWF4aW11bS1zY2FsZT0xLG1pbmltdW0tc2NhbGU9MSx1c2VyLXNjYWxhYmxlPW5vJztcblxuICB2YXIgVmlld3BvcnQgPSB7IFxuICAgIGVuc3VyZVZpZXdwb3J0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG4gICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICB2aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5uYW1lID0gJ3ZpZXdwb3J0JztcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh2aWV3cG9ydEVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlld3BvcnRFbGVtZW50O1xuICAgIH0sXG5cbiAgICBzZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmlld3BvcnRFbGVtZW50ID0gVmlld3BvcnQuZW5zdXJlVmlld3BvcnRFbGVtZW50KCk7XG5cbiAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2aWV3cG9ydEVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50JykpIHtcbiAgICAgICAgdmlld3BvcnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsIERFRkFVTFRfVklFV1BPUlQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3aW5kb3cuVmlld3BvcnQgPSBWaWV3cG9ydDtcbn0pKCk7XG4iLCJpbXBvcnQgeyBGYXN0Q2xpY2sgfSBmcm9tICdAb25zZW51aS9mYXN0Y2xpY2snO1xuaW1wb3J0ICcuL29ucy9wbGF0Zm9ybSc7IC8vIFRoaXMgZmlsZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgQ3VzdG9tIEVsZW1lbnRzIHBvbHlmaWxscy5cbmltcG9ydCAnLi9wb2x5ZmlsbHMvaW5kZXguanMnO1xuaW1wb3J0ICcuL3ZlbmRvci9pbmRleC5qcyc7XG5pbXBvcnQgJy4vb25zL21pY3JvZXZlbnQuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cChvbnMpIHtcbiAgaWYgKHdpbmRvdy5fb25zTG9hZGVkKSB7XG4gICAgb25zLl91dGlsLndhcm4oJ09uc2VuIFVJIGlzIGxvYWRlZCBtb3JlIHRoYW4gb25jZS4nKTtcbiAgfVxuICB3aW5kb3cuX29uc0xvYWRlZCA9IHRydWU7XG5cbiAgLy8gZmFzdGNsaWNrXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgIG9ucy5mYXN0Q2xpY2sgPSBGYXN0Q2xpY2suYXR0YWNoKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgY29uc3Qgc3VwcG9ydFRvdWNoQWN0aW9uID0gJ3RvdWNoLWFjdGlvbicgaW4gZG9jdW1lbnQuYm9keS5zdHlsZTtcblxuICAgIG9ucy5wbGF0Zm9ybS5fcnVuT25BY3R1YWxQbGF0Zm9ybSgoKSA9PiB7XG4gICAgICBpZiAob25zLnBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgIC8vIEluIEFuZHJvaWQ0LjQrLCBjb3JyZWN0IHZpZXdwb3J0IHNldHRpbmdzIGNhbiByZW1vdmUgY2xpY2sgZGVsYXkuXG4gICAgICAgIC8vIFNvIGRpc2FibGUgRmFzdENsaWNrIG9uIEFuZHJvaWQuXG4gICAgICAgIG9ucy5mYXN0Q2xpY2suZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIGlmIChvbnMucGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgICBpZiAoc3VwcG9ydFRvdWNoQWN0aW9uICYmIChvbnMucGxhdGZvcm0uaXNJT1NTYWZhcmkoKSB8fCBvbnMucGxhdGZvcm0uaXNXS1dlYlZpZXcoKSkpIHtcbiAgICAgICAgICAvLyBJZiAndG91Y2gtYWN0aW9uJyBzdXBwb3J0ZWQgaW4gaU9TIFNhZmFyaSBvciBXS1dlYlZpZXcsIGRpc2FibGUgRmFzdENsaWNrLlxuICAgICAgICAgIG9ucy5mYXN0Q2xpY2suZGVzdHJveSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvIG5vdGhpbmcuICd0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbicgaGFzIG5vIGVmZmVjdCBvbiBVSVdlYlZpZXcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuXG4gIG9ucy5yZWFkeShmdW5jdGlvbigpIHtcbiAgICBvbnMuZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKTtcbiAgICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG9ucy5faW50ZXJuYWwuZGJiRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHdpbmRvdy5kb2N1bWVudC5ib2R5LCAoKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobmF2aWdhdG9yLCAnYXBwJykpIHtcbiAgICAgICAgbmF2aWdhdG9yLmFwcC5leGl0QXBwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBjbG9zZSB0aGUgYXBwLiBJcyBcXCdjb3Jkb3ZhLmpzXFwnIGluY2x1ZGVkP1xcbkVycm9yOiBcXCd3aW5kb3cubmF2aWdhdG9yLmFwcFxcJyBpcyB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5fZ2VzdHVyZURldGVjdG9yID0gbmV3IG9ucy5HZXN0dXJlRGV0ZWN0b3IoZG9jdW1lbnQuYm9keSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gICAgLy8gU2ltdWxhdGUgRGV2aWNlIEJhY2sgQnV0dG9uIG9uIEVTQyBwcmVzc1xuICAgIGlmICghb25zLnBsYXRmb3JtLmlzV2ViVmlldygpKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICBvbnMuZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHNldHVwIGxvYWRpbmcgcGxhY2Vob2xkZXJcbiAgICBvbnMuX3NldHVwTG9hZGluZ1BsYWNlSG9sZGVycygpO1xuICB9KTtcblxuICAvLyB2aWV3cG9ydC5qc1xuICBWaWV3cG9ydC5zZXR1cCgpO1xufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuZnVuY3Rpb24gZ2V0RWxlbWVudENsYXNzKCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAnZnVuY3Rpb24nKSB7IC8vIGNhc2Ugb2YgU2FmYXJpXG4gICAgY29uc3QgQmFzZUVsZW1lbnQgPSAoKSA9PiB7fTtcbiAgICBCYXNlRWxlbWVudC5wcm90b3R5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXR1cm4gQmFzZUVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VFbGVtZW50IGV4dGVuZHMgZ2V0RWxlbWVudENsYXNzKCkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGVtcGxhdGVcbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERlZmluZSBhIHNlcGFyYXRlIEhUTUwgZnJhZ21lbnQgYW5kIHVzZSBhcyBhIHRlbXBsYXRlLiBUaGVzZSB0ZW1wbGF0ZXMgY2FuIGJlIGxvYWRlZCBhcyBwYWdlcyBpbiBgPG9ucy1uYXZpZ2F0b3I+YCwgYDxvbnMtdGFiYmFyPmAgYW5kIGA8b25zLXNwbGl0dGVyPmAuIFRoZXkgY2FuIGFsc28gYmUgdXNlZCB0byBnZW5lcmF0ZSBkaWFsb2dzLiBTaW5jZSBPbnNlbiBVSSAyLjQuMCwgdGhlIG5hdGl2ZSBgPHRlbXBsYXRlPmAgZWxlbWVudCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGA8b25zLXRlbXBsYXRlPmAgZm9yIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgZmVhdHVyZXMuIGA8b25zLXRlbXBsYXRlPmAgaXMgc3RpbGwgc3VwcG9ydGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICogICBbL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44Go44GX44Gm5L2/55So44GZ44KL44Gf44KB44GuSFRNTOODleODqeOCsOODoeODs+ODiOOCkuWumue+qeOBl+OBvuOBmeOAguOBk+OBruimgee0oOOBp0hUTUzjgpLlrqPoqIDjgZnjgovjgajjgIFpZOWxnuaAp+OBq+aMh+WumuOBl+OBn+WQjeWJjeOCknBhZ2Xjga5VUkzjgajjgZfjgaZvbnMtbmF2aWdhdG9y44Gq44Gp44Gu44Kz44Oz44Od44O844ON44Oz44OI44GL44KJ5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXVRoZSBgPG9ucy1uYXZpZ2F0b3I+YCBjb21wb25lbnQgZW5hYmxlcyBzdGFjayBiYXNlZCBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXRhYmJhclxuICogICBbZW5dVGhlIGA8b25zLXRhYmJhcj5gIGNvbXBvbmVudCBpcyB1c2VkIHRvIGFkZCB0YWIgbmF2aWdhdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRyYWdnYWJsZSBtZW51IG9yIGNvbHVtbiBiYXNlZCBsYXlvdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImZvb2Jhci5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICBQYWdlIGNvbnRlbnRcbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtbmF2aWdhdG9yIHBhZ2U9XCJmb29iYXIuaHRtbFwiPjwvb25zLW5hdmlnYXRvcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVtcGxhdGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdGVtcGxhdGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGVtcGxhdGUgY29udGVudC4gVGhpcyBwcm9wZXJ0eSBjYW4gbm90IGJlIHVzZWQgd2l0aCBBbmd1bGFySlMgYmluZGluZ3MuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuaW5uZXJIVE1MO1xuXG4gICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHsgLy8gTm90ZTogdGhpcy5wYXJlbnROb2RlIGlzIG5vdCBzZXQgaW4gc29tZSBDRTAvQ0UxIHBvbHlmaWxscy5cbiAgICAgIC8vIFNob3cgd2FybmluZyB3aGVuIHRoZSBvbnMtdGVtcGxhdGUgaXMgbm90IGxvY2F0ZWQganVzdCB1bmRlciBkb2N1bWVudC5ib2R5XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7IC8vIGlmIHRoZSBwYXJlbnQgaXMgbm90IGRvY3VtZW50LmJvZHlcbiAgICAgICAgdXRpbC53YXJuKGBvbnMtdGVtcGxhdGUgKGlkID0gJHt0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKX0pIG11c3QgYmUgbG9jYXRlZCBqdXN0IHVuZGVyIGRvY3VtZW50LmJvZHkkeyB0aGlzLnBhcmVudE5vZGUub3V0ZXJIVE1MID8gYDpcXG5cXG4ke3RoaXMucGFyZW50Tm9kZS5vdXRlckhUTUx9YCA6ICcuJyB9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdfdGVtcGxhdGVsb2FkZWQnLCB7YnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZX0pO1xuICAgIGV2ZW50LnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICBldmVudC50ZW1wbGF0ZUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlRlbXBsYXRlID0gVGVtcGxhdGVFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGVtcGxhdGUnLCBUZW1wbGF0ZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi4vb25zL29yaWVudGF0aW9uJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlmXG4gKiBAY2F0ZWdvcnkgY29uZGl0aW9uYWxcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pZlxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb25kaXRpb25hbGx5IGRpc3BsYXkgY29udGVudCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLCBkZXZpY2Ugb3JpZW50YXRpb24gb3IgYm90aC5cbiAqXG4gKiAgICAgU29tZXRpbWVzIGl0IGlzIHVzZWZ1bCB0byBjb25kaXRpb25hbGx5IGhpZGUgb3Igc2hvdyBjZXJ0YWluIGNvbXBvbmVudHMgYmFzZWQgb24gcGxhdGZvcm0uIFdoZW4gcnVubmluZyBvbiBpT1MgdGhlIGA8b25zLWlmPmAgZWxlbWVudCBjYW4gYmUgdXNlZCB0byBoaWRlIHRoZSBgPG9ucy1mYWI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1pZiBvcmllbnRhdGlvbj1cImxhbmRzY2FwZVwiPlxuICogICAgIExhbmRzY2FwZSB2aWV3IVxuICogICA8L29ucy1pZj5cbiAqICAgPG9ucy1pZiBwbGF0Zm9ybT1cImFuZHJvaWRcIj5cbiAqICAgICBUaGlzIGlzIEFuZHJvaWQuXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiaW9zIG90aGVyXCI+XG4gKiAgICAgVGhpcyBpcyBub3QgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhdGZvcm1cbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwYWNlLXNlcGFyYXRlZCBwbGF0Zm9ybSBuYW1lcy4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJpb3NcImAsIGBcImFuZHJvaWRcImAsIGBcIndpbmRvd3NcImAgYW5kIGBcIm90aGVyXCJgLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3JpZW50YXRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWl0aGVyIGBcInBvcnRyYWl0XCJgIG9yIGBcImxhbmRzY2FwZVwiYC5bL2VuXVxuICAgKiAgW2phXXBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GX44G+44GZWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAocGxhdGZvcm0uX2dldFNlbGVjdGVkUGxhdGZvcm0oKSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNBbGxvd2VkUGxhdGZvcm0oKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZE5vZGVzWzBdLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vbignY2hhbmdlJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ29yaWVudGF0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnb3JpZW50YXRpb24nKSB7XG4gICAgICB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcbiAgfVxuXG4gIF9wbGF0Zm9ybVVwZGF0ZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpID8gJycgOiAnbm9uZSc7XG4gIH1cblxuICBfaXNBbGxvd2VkUGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGxhdGZvcm0nKS5zcGxpdCgvXFxzKy8pLmluZGV4T2YocGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPj0gMDtcbiAgfVxuXG4gIF9vbk9yaWVudGF0aW9uQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb3JpZW50YXRpb24nKSAmJiB0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICBjb25zdCBjb25kaXRpb25hbE9yaWVudGF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudGF0aW9uJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uLmlzUG9ydHJhaXQoKSA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJztcblxuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gKGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPT09IGN1cnJlbnRPcmllbnRhdGlvbikgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuSWYgPSBJZkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1pZicsIElmRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwO1xuXG4gICAgdGhpcy5kZWYgPSB7XG4gICAgICB0aW1pbmc6IHRoaXMudGltaW5nLFxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICBkZWxheTogdGhpcy5kZWxheVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZXh0ZW5kKHByb3BlcnRpZXMgPSB7fSkge1xuICAgIGNvbnN0IGV4dGVuZGVkQW5pbWF0b3IgPSB0aGlzO1xuICAgIGNvbnN0IG5ld0FuaW1hdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBleHRlbmRlZEFuaW1hdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB1dGlsLmV4dGVuZCh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9O1xuXG4gICAgbmV3QW5pbWF0b3IucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgcmV0dXJuIG5ld0FuaW1hdG9yO1xuICB9XG59XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8vIFRoaXMgb2JqZWN0IHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byB1c2Vycy4gUGxlYXNlIGtlZXAgdGhpcyBwcml2YXRlLlxuY29uc3QgaVBob25lWFBhdGNoID0ge307XG5cbmlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlID0gKCkgPT4ge1xuICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnb25zZmxhZy1pcGhvbmV4LXBvcnRyYWl0JykgIT0gbnVsbCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8IHdpbmRvdy5pbm5lckhlaWdodDtcbn1cblxuaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlID0gKCkgPT4ge1xuICAvLyBJZiB3aWR0aCA9PT0gaGVpZ2h0LCB0cmVhdCBpdCBhcyBsYW5kc2NhcGVcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29uc2ZsYWctaXBob25leC1sYW5kc2NhcGUnKSAhPSBudWxsICYmIHdpbmRvdy5pbm5lcldpZHRoID49IHdpbmRvdy5pbm5lckhlaWdodDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzYWZlIGFyZWEgbGVuZ3RocyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2FmZSBhcmVhcy5cbiAqL1xuaVBob25lWFBhdGNoLmdldFNhZmVBcmVhTGVuZ3RocyA9ICgpID0+IHtcbiAgbGV0IHNhZmVBcmVhTGVuZ3RocztcbiAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICBzYWZlQXJlYUxlbmd0aHMgPSB7XG4gICAgICB0b3A6IDQ0LFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDM0LFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICBzYWZlQXJlYUxlbmd0aHMgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogNDQsXG4gICAgICBib3R0b206IDIxLFxuICAgICAgbGVmdDogNDRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNhZmVBcmVhTGVuZ3RocyA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gc2FmZUFyZWFMZW5ndGhzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNhZmUgYXJlYSByZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzYWZlIGFyZWFzLlxuICovXG5pUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFET01SZWN0ID0gKCkgPT4ge1xuICBsZXQgc2FmZUFyZWFSZWN0O1xuICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgIHNhZmVBcmVhUmVjdCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiA0NCwgLyogMCArIDQ0ICh0b3Agc2FmZSBhcmVhKSAqL1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSA3OCAvKiBoZWlnaHQgLSA0NCAodG9wIHNhZmUgYXJlYSkgLSAzNCAoYm90dG9tIHNhZmUgYXJlYSkgKi9cbiAgICB9O1xuICB9IGVsc2UgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSgpKSB7XG4gICAgc2FmZUFyZWFSZWN0ID0ge1xuICAgICAgeDogNDQsIC8qIDAgKyA0NCAobGVmdCBzYWZlIGFyZWEpICovXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC0gODgsIC8qIHdpZHRoIC0gNDQgKGxlZnQgc2FmZSBhcmVhKSAtIDM0IChyaWdodCBzYWZlIGFyZWEpICovXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAtIDIxIC8qIGhlaWdodCAtIDIxIChib3R0b20gc2FmZSBhcmVhKSAqL1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2FmZUFyZWFSZWN0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnNhZmVBcmVhUmVjdCxcbiAgICBsZWZ0OiBzYWZlQXJlYVJlY3QueCxcbiAgICB0b3A6IHNhZmVBcmVhUmVjdC55LFxuICAgIHJpZ2h0OiBzYWZlQXJlYVJlY3QueCArIHNhZmVBcmVhUmVjdC53aWR0aCxcbiAgICBib3R0b206IHNhZmVBcmVhUmVjdC55ICsgc2FmZUFyZWFSZWN0LmhlaWdodFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpUGhvbmVYUGF0Y2g7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcbmltcG9ydCBpUGhvbmVYUGF0Y2ggZnJvbSAnLi4vLi4vb25zL2lwaG9uZXgtcGF0Y2gnO1xuXG5leHBvcnQgY2xhc3MgQWN0aW9uU2hlZXRBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBBY3Rpb24gU2hlZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNREFjdGlvblNoZWV0QW5pbWF0b3IgZXh0ZW5kcyBBY3Rpb25TaGVldEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuNCB9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMubWFza1RpbWluZyA9ICdsaW5lYXInO1xuICAgIHRoaXMubWFza0R1cmF0aW9uID0gMC4yO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMS4wIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5tYXNrRHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCA4MCUsIDApYCwgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoeyBvcGFjaXR5OiAxIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fc2hlZXQsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgODAlLCAwKWAsIG9wYWNpdHk6IDAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBJT1NBY3Rpb25TaGVldEFuaW1hdG9yIGV4dGVuZHMgQWN0aW9uU2hlZXRBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoeyB0aW1pbmcgPSAnZWFzZScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjMgfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLm1hc2tUaW1pbmcgPSAnbGluZWFyJztcbiAgICB0aGlzLm1hc2tEdXJhdGlvbiA9IDAuMjtcbiAgICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gJ2NhbGMoMTAwJSArIDQ4cHgpJztcbiAgICB9IGVsc2UgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmxpZnRBbW91bnQgPSAnY2FsYygxMDAlICsgMzNweCknO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpZnRBbW91bnQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCAvIDIuMCAtIDEgKyAncHgnOyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAucXVldWUoeyBvcGFjaXR5OiAwIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMSB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLm1hc2tUaW1pbmdcbiAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9zaGVldCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmxpZnRBbW91bnR9LCAwKWAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDEgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoeyBvcGFjaXR5OiAwIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMubWFza0R1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5saWZ0QW1vdW50fSwgMClgIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS1lbGVtZW50JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi4vLi4vb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VEaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgX3RvZ2dsZVN0eWxlKHNob3VsZFNob3cpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBzaG91bGRTaG93ID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZURpYWxvZ0VsZW1lbnQpIHtcbiAgICAgIHV0aWwudGhyb3dBYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLl9kb29yTG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX2NhbmNlbCA9IHRoaXMuX2NhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NlbGZDYW1lbE5hbWUgPSB1dGlsLmNhbWVsaXplKHRoaXMudGFnTmFtZS5zbGljZSg0KSk7XG4gICAgdGhpcy5fZGVmYXVsdERCQiA9IGUgPT4gdGhpcy5jYW5jZWxhYmxlID8gdGhpcy5fY2FuY2VsKCkgOiBlLmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gIH1cblxuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgX2NhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxhYmxlICYmICF0aGlzLl9ydW5uaW5nKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGlhbG9nLWNhbmNlbCcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4gdGhpcy5fcnVubmluZyA9IGZhbHNlXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2hvdyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldFZpc2libGUodHJ1ZSwgLi4uYXJncyk7XG4gIH1cblxuICBoaWRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0VmlzaWJsZShmYWxzZSwgLi4uYXJncyk7XG4gIH1cblxuICB0b2dnbGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9zZXRWaXNpYmxlKCF0aGlzLnZpc2libGUsIC4uLmFyZ3MpO1xuICB9XG5cbiAgX3NldFZpc2libGUoc2hvdWxkU2hvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYWN0aW9uID0gc2hvdWxkU2hvdyA/ICdzaG93JyA6ICdoaWRlJztcblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcHJlJHthY3Rpb259YCwgeyAvLyBwcmVzaG93IHByZWhpZGVcbiAgICAgIFt0aGlzLl9zZWxmQ2FtZWxOYW1lXTogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHthY3Rpb259IGV2ZW50LmApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHNob3VsZFNob3cgJiYgdGhpcy5fdG9nZ2xlU3R5bGUodHJ1ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBzaG91bGRTaG93O1xuICAgICAgICB1dGlsLmlvc1BhZ2VTY3JvbGxGaXgoc2hvdWxkU2hvdyk7XG5cbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBhbmltYXRvclthY3Rpb25dKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICFzaG91bGRTaG93ICYmIHRoaXMuX3RvZ2dsZVN0eWxlKGZhbHNlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgdW5sb2NrKCk7XG5cbiAgICAgICAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfJyArIGFjdGlvbik7XG4gICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3QnICsgYWN0aW9uLCB7W3RoaXMuX3NlbGZDYW1lbE5hbWVdOiB0aGlzfSk7IC8vIHBvc3RzaG93IHBvc3RoaWRlXG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHNldCBjYW5jZWxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdjYW5jZWxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdjYW5jZWxhYmxlJyk7XG4gIH1cblxuICBfdXBkYXRlTWFzaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21hc2sgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKSkge1xuICAgICAgICB0aGlzLl9tYXNrLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX2RlZmF1bHREQkIuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2FuY2VsLCBmYWxzZSk7XG4gICAgICAgIHV0aWwuaW9zTWFza1Njcm9sbEZpeCh0aGlzLl9tYXNrLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgdGhpcy5fbWFzay5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NhbmNlbCwgZmFsc2UpO1xuICAgICAgdXRpbC5pb3NNYXNrU2Nyb2xsRml4KHRoaXMuX21hc2ssIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdhbmltYXRpb24nLCAnbWFzay1jb2xvciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWFzay1jb2xvcic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hc2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJywgJ2RpYWxvZy1jYW5jZWwnXTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7IEFjdGlvblNoZWV0QW5pbWF0b3IsIElPU0FjdGlvblNoZWV0QW5pbWF0b3IsIE1EQWN0aW9uU2hlZXRBbmltYXRvciB9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmFjdGlvbi1zaGVldCc6ICdhY3Rpb24tc2hlZXQtLSonLFxuICAnLmFjdGlvbi1zaGVldC1tYXNrJzogJ2FjdGlvbi1zaGVldC1tYXNrLS0qJyxcbiAgJy5hY3Rpb24tc2hlZXQtdGl0bGUnOiAnYWN0aW9uLXNoZWV0LXRpdGxlLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1EQWN0aW9uU2hlZXRBbmltYXRvciA6IElPU0FjdGlvblNoZWV0QW5pbWF0b3IsXG4gICdub25lJzogQWN0aW9uU2hlZXRBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYWN0aW9uLXNoZWV0XG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFjdGlvbi9ib3R0b20gc2hlZXQgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLlxuICpcbiAqICAgICBUaGlzIGVsZW1lbnQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgeyBhcHBlbmQ6IHRydWUgfSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPHRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgICBUaGUgYWN0aW9uIHNoZWV0IGlzIHVzZWZ1bCBmb3IgZGlzcGxheWluZyBhIGxpc3Qgb2Ygb3B0aW9ucyBhbmQgYXNraW5nIHRoZSB1c2VyIHRvIG1ha2UgYSBkZWNpc2lvbi4gQSBgb25zLWFjdGlvbi1zaGVldC1idXR0b25gIGlzIHByb3ZpZGVkIGZvciB0aGlzIHB1cnBvc2UsIGFsdGhvdWdoIGl0IGNhbiBjb250YWluIGFueSB0eXBlIG9mIGNvbnRlbnQuXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIChib3R0b20gc2hlZXQpIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOAgeOCguOBl+OBj+OBr+ODnOODiOODoOOCt+ODvOODiOOCkuePvuWcqOOBruOCueOCr+ODquODvOODs+S4iuOBq+ihqOekuuOBl+OBvuOBmeOAglxuICpcbiAqICAgICDjgZPjga7opoHntKDjga/jgIFgPGJvZHk+YOimgee0oOOBq+ebtOaOpeOCouOCv+ODg+ODgeOBleOCjOOCi+OBi+OAgeOCguOBl+OBj+OBr2BvbnMuY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgeyBhcHBlbmQ6IHRydWUgfSlg44GoYDx0ZW1wbGF0ZT5g44K/44Kw44KS5L2/44Gj44Gm44OG44Oz44OX44Os44O844OI44GL44KJ5YuV55qE44Gr55Sf5oiQ44GV44KM44G+44GZ44CCXG4gKlxuICogICAgIOOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBr+OAgemBuOaKnuiCouOBruODquOCueODiOOCkuihqOekuuOBl+OBpuODpuODvOOCtuODvOOBq+Wwi+OBreOCi+OBruOBq+S+v+WIqeOBp+OBmeOAgmBvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbmDjga/jgIHjgZPjga7opoHntKDjga7kuK3jgavnva7jgY/jgZ/jgoHjgavmj5DkvpvjgZXjgozjgabjgYTjgb7jgZnjgYzjgIHjgZ3jgozku6XlpJbjgavjgoLku5bjga7jganjga7jgojjgYbjgaropoHntKDjgpLlkKvjgoDjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJcbiAqXG4gKiAgICAgQW5kcm9pZOODh+ODkOOCpOOCueOBp+Wun+ihjOOBleOCjOOCi+OBqOOBjeOBq+OBr+OAgeiHquWLleeahOOBq+ODnuODhuODquOCouODq+ODh+OCtuOCpOODsyjjg5zjg4jjg6Djgrfjg7zjg4gp44Go44GX44Gm6KGo56S644GV44KM44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gYm90dG9tIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjg4jjg6Djgrfjg7zjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvcmVmZXJlbmNlL2FjdGlvbi1zaGVldFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5dYDxvbnMtcG9wb3Zlcj5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbW9kYWxcbiAqICAgW2VuXWA8b25zLW1vZGFsPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1tb2RhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hY3Rpb24tc2hlZXQgaWQ9XCJzaGVldFwiPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogPC9vbnMtYWN0aW9uLXNoZWV0PlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaGVldCcpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25TaGVldEVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgYWN0aW9uIHNoZWV0IGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhY3Rpb24gc2hlZXQgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWN0aW9uU2hlZXRcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGFjdGlvbiBzaGVldCBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFjdGlvblNoZWV0XG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGl0bGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dT3B0aW9uYWwgdGl0bGUgb2YgdGhlIGFjdGlvbiBzaGVldC4gQSBuZXcgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgY29udGFpbmluZyB0aGlzIHN0cmluZy5bL2VuXVxuICAgKiAgW2phXeOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBruOCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBk+OBp+aMh+WumuOBl+OBn+aWh+Wtl+WIl+OCkuWQq+OCgOaWsOOBl+OBhOimgee0oOOBjOS9nOaIkOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44KL44Go44CB44Ki44Kv44K344On44Oz44K344O844OI44Gu6IOM5pmv44KEQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+OCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBjOmWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGFjdGlvbiBzaGVldC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZGVmYXVsdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQtbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9zaGVldCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQnKTtcbiAgfVxuXG4gIGdldCBfdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmFjdGlvbi1zaGVldC10aXRsZScpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFjdGlvblNoZWV0QW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWN0aW9uU2hlZXRBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWFjdGlvbi1zaGVldD5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImFjdGlvbi1zaGVldC1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXRcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLXNoZWV0LXRpdGxlPjwvZGl2PlxuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWFjdGlvbi1zaGVldD5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fc2hlZXQpIHtcbiAgICAgIGNvbnN0IHNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzaGVldC5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBzaGVldC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpdGxlICYmIHRoaXMuaGFzQXR0cmlidXRlKCd0aXRsZScpKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGl0bGUuaW5uZXJIVE1MID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICB0aXRsZS5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQtdGl0bGUnKTtcbiAgICAgIHRoaXMuX3NoZWV0Lmluc2VydEJlZm9yZSh0aXRsZSwgdGhpcy5fc2hlZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2FjdGlvbi1zaGVldC1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NoZWV0LnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlVGl0bGUoKSB7XG4gICAgaWYgKHRoaXMuX3RpdGxlKSB7XG4gICAgICB0aGlzLl90aXRsZS5pbm5lckhUTUwgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFd6Zqg44KM44Gf6KaB57Sg44KS6Kej5rG644GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGFjdGlvbiBzaGVldCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBhY3Rpb24gc2hlZXQgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBhY3Rpb24gc2hlZXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS6Kit5a6a44GX44G+44GZ44CC44Kt44Oj44Oz44K744Or5Y+v6IO944Gq44Ki44Kv44K344On44Oz44K344O844OI44Gv44CB6IOM5pmv44KS44K/44OD44OX44GX44Gf44KKQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+mWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAndGl0bGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtBY3Rpb25TaGVldEFuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBY3Rpb25TaGVldEFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdBY3Rpb25TaGVldCcpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWN0aW9uU2hlZXRBbmltYXRvcigpIHtcbiAgICByZXR1cm4gQWN0aW9uU2hlZXRBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5BY3Rpb25TaGVldCA9IEFjdGlvblNoZWV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFjdGlvbi1zaGVldCcsIEFjdGlvblNoZWV0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS1lbGVtZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VCdXR0b25FbGVtZW50KSB7XG4gICAgICB1dGlsLnRocm93QWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgZ2V0IF9pY29uKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWljb24nKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKHRoaXMuX2RlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKCF0aGlzLl9pY29uICYmIHRoaXMuaGFzQXR0cmlidXRlKCdpY29uJykpIHtcbiAgICAgIHV0aWwuY2hlY2tNaXNzaW5nSW1wb3J0KCdJY29uJyk7XG4gICAgICBjb25zdCBpY29uID0gdXRpbC5jcmVhdGVFbGVtZW50KGA8b25zLWljb24gaWNvbj1cIiR7dGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKX1cIj48L29ucy1pY29uPmApO1xuICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKHRoaXMuX2RlZmF1bHRDbGFzc05hbWUucmVwbGFjZSgnYnV0dG9uJywgJ2ljb24nKSk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShpY29uLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgX3VwZGF0ZUljb24oKSB7XG4gICAgaWYgKHRoaXMuX2ljb24pIHtcbiAgICAgIHRoaXMuX2ljb24uc2V0QXR0cmlidXRlKCdpY29uJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB0aGlzLl9yaXBwbGVPcHQgJiYgdXRpbC51cGRhdGVSaXBwbGUoLi4udGhpcy5fcmlwcGxlT3B0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJywgJ2ljb24nLCAncmlwcGxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lLCB0aGlzLl9zY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lKSAmJiB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlQnV0dG9uRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1idXR0b24nO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hY3Rpb24tc2hlZXQtYnV0dG9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAbW9kaWZpZXIgZGVzdHJ1Y3RpdmVcbiAqICAgW2VuXVNob3dzIGEgXCJkZXN0cnVjdGl2ZVwiIGJ1dHRvbiAob25seSBmb3IgaU9TKS5bL2VuXVxuICogICBbamFdXCJkZXN0cnVjdGl2ZVwi44Gq44Oc44K/44Oz44KS6KGo56S644GX44G+44GZKGlPU+OBp+OBruOBv+acieWKuSnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Db21wb25lbnQgdGhhdCByZXByZXNlbnQgZWFjaCBidXR0b24gb2YgdGhlIGFjdGlvbiBzaGVldC5bL2VuXVxuICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44Gr6KGo56S644GV44KM44KL5ZCE44Oc44K/44Oz44KS6KGo54++44GZ44KL44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hY3Rpb24tc2hlZXRcbiAqICAgW2VuXVRoZSBgPG9ucy1hY3Rpb24tc2hlZXQ+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWFjdGlvbi1zaGVldOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtbGlzdC1pdGVtPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWljb25cbiAqICAgW2VuXVRoZSBgPG9ucy1pY29uPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1pY29u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9hY3Rpb24tc2hlZXRcbiAqIEBndWlkZSBhcHBzaXplLmh0bWwjcmVtb3ZpbmctaWNvbi1wYWNrcyBbZW5dUmVtb3ZpbmcgaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQGd1aWRlIGZhcS5odG1sI2hvdy1jYW4taS11c2UtY3VzdG9tLWljb24tcGFja3MgW2VuXUFkZGluZyBjdXN0b20gaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGFjdGlvbiBzaGVldCBidXR0b24uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOeUqOOBruODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hY3Rpb24tc2hlZXQgaWQ9XCJzaGVldFwiPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogPC9vbnMtYWN0aW9uLXNoZWV0PlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaGVldCcpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlQnV0dG9uRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1DcmVhdGVzIGFuIGBvbnMtaWNvbmAgY29tcG9uZW50IHdpdGggdGhpcyBzdHJpbmcuIE9ubHkgdmlzaWJsZSBvbiBBbmRyb2lkLiBDaGVjayBbU2VlIGFsc29dKCNzZWVhbHNvKSBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlsvZW5dXG4gICAqICBbamFdYG9ucy1pY29uYOOCs+ODs+ODneODvOODjeODs+ODiOOCkuaCquaAp+OBl+OBvuOBmeOAgkFuZHJvaWTjgafjga7jgb/ooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGFjdGlvbiBzaGVldCBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44Oc44K/44Oz44Gu6KaL44Gf55uu44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICcnOiAnYWN0aW9uLXNoZWV0LWJ1dHRvbi0tKicsXG4gICAgICAnLmFjdGlvbi1zaGVldC1pY29uJzogJ2FjdGlvbi1zaGVldC1pY29uLS0qJ1xuICAgIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdhY3Rpb24tc2hlZXQtYnV0dG9uJztcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxub25zRWxlbWVudHMuQWN0aW9uU2hlZXRCdXR0b24gPSBBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uJywgQWN0aW9uU2hlZXRCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGNsYXNzIEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoLjksIC45LCAxKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMSwgMSwgMSknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLCAxLCAxKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoLjksIC45LCAxKScsIG9wYWNpdHk6IDAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBhbGVydCBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBJT1NBbGVydERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQWxlcnREaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkdXJhdGlvbiA9IDAuMiwgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoe2R1cmF0aW9uLCB0aW1pbmcsIGRlbGF5fSk7XG4gIH1cblxuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLjMsIDEuMywgMSknLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEsIDEsIDEpJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgQWxlcnREaWFsb2dBbmltYXRvciwgSU9TQWxlcnREaWFsb2dBbmltYXRvciwgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hbGVydC1kaWFsb2cnOiAnYWxlcnQtZGlhbG9nLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJzogJ2FsZXJ0LWRpYWxvZy1jb250YWluZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy10aXRsZSc6ICdhbGVydC1kaWFsb2ctdGl0bGUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250ZW50JzogJ2FsZXJ0LWRpYWxvZy1jb250ZW50LS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXItLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCc6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24nOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKicsXG4gICdvbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctbWFzayc6ICdhbGVydC1kaWFsb2ctbWFzay0tKicsXG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ25vbmUnOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWxlcnQgZGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzY3JlZW4uIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBxdWVzdGlvbnMsIHdhcm5pbmdzIG9yIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiBUaGUgdGl0bGUsIGNvbnRlbnQgYW5kIGJ1dHRvbnMgY2FuIGJlIGVhc2lseSBjdXN0b21pemVkIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHN0eWxlIGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlQWxlcnREaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDx0ZW1wbGF0ZT5gIHRhZy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOePvuWcqOOBruOCueOCr+ODquODvOODs+OBruS4iuOBq+ihqOekuuOBmeOCi+OCouODqeODvOODiOODgOOCpOOCouODreOCsOOBp+OBmeOAguODpuODvOOCtuOBq+WvvuOBmeOCi+WVj+OBhOOBi+OBkeOAgeitpuWRiuOAgeOCqOODqeODvOODoeODg+OCu+ODvOOCuOOCkuihqOekuuOBmeOCi+OBruOBq+WIqeeUqOOBp+OBjeOBvuOBmeOAguOCv+OCpOODiOODq+OChOOCs+ODs+ODhuODs+ODhOOChOODnOOCv+ODs+OBr+ewoeWNmOOBq+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOAgeWun+ihjOOBl+OBpuOBhOOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOOBq+S9teOBm+OBpuOCueOCv+OCpOODq+OBjOiHquWLleeahOOBq+WIh+OCiuabv+OCj+OCiuOBvuOBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gUXd3eHlwXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYWxlcnQtZGlhbG9nXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jgrnjgr/jgqTjg6tbL2phXVxuICogQG1vZGlmaWVyIHJvd2Zvb3RlclxuICogICBbZW5dSG9yaXpvbnRhbGx5IGFsaWducyB0aGUgZm9vdGVyIGJ1dHRvbnMuWy9lbl1cbiAqICAgW2phXeODleODg+OCv+ODvOOBruikh+aVsOOBruODnOOCv+ODs+OCkuawtOW5s+OBq+mFjee9rlsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1vbnMtZGlhbG9nIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1vbnMtcG9wb3ZlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMubm90aWZpY2F0aW9uXG4gKiAgIFtlbl1Vc2luZyBvbnMubm90aWZpY2F0aW9uIHV0aWxpdHkgZnVuY3Rpb25zLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovjgavjga/jgIFvbnMubm90aWZpY2F0aW9u44Kq44OW44K444Kn44Kv44OI44Gu44Oh44K944OD44OJ44KS5L2/44GG44GT44Go44KC44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFsZXJ0LWRpYWxvZyBpZD1cImFsZXJ0LWRpYWxvZ1wiPlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgQW4gZXJyb3IgaGFzIG9jY3VycmVkIVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICA8YnV0dG9uIGlkPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiIGNsYXNzPVwiYWxlcnQtZGlhbG9nLWJ1dHRvblwiPk9LPC9idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FsZXJ0LWRpYWxvZycpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGVydERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBzaG93aW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruihqOekuuOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0byBzdG9wIHRoZSBkaWFsb2cgZnJvbSBoaWRpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KI44GG44Go44GZ44KL44Gu44KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7opovjgZ/nm67jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44KS6Kit5a6a44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6IOM5pmv44KS44K/44OD44OX44GX44Gf44KKQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaKvOOBmeOBqOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGRpYWxvZy4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjgafjga9cIm5vbmVcIuOBi1wiZGVmYXVsdFwi44GM5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CC5L6L77yae2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIFwicmdiYSgwLCAwLCAwLCAwLjIpXCIuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFsZXJ0LWRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfZGlhbG9nKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFsZXJ0LWRpYWxvZycpO1xuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfdGl0bGVFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLXRpdGxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfY29udGVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXSwgJy5hbGVydC1kaWFsb2ctY29udGVudCcpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWxlcnREaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCByZXN1bHQgYWZ0ZXIgY29tcGlsZTpcbiAgICAgKlxuICAgICAqIDxvbnMtYWxlcnQtZGlhbG9nIHN0eWxlPVwibm9uZVwiPlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGFpbmVyXCI+Li4uPC9kaXY+XG4gICAgICogICA8L2Rpdj5cbiAgICAgKiA8L29ucy1hbGVydC1kaWFsb2c+XG4gICAgICovXG5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgaWYgKCF0aGlzLl9tYXNrICYmICF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWFzaykge1xuICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctbWFzaycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kaWFsb2cpIHtcbiAgICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGlhbG9nLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZycpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoZGlhbG9nLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZywgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJykpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1jb250YWluZXInKTtcbiAgICAgIHRoaXMuX2RpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXS5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV3jgZ3jga7jg4DjgqTjgqLjg63jgrDjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLooajjgZfjgb7jgZnjgILjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgarjg4DjgqTjgqLjg63jgrDjga/jgIHog4zmma/jgpLjgr/jg4Pjg5fjgZnjgovjgYtBbmRyb2lk44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44KS5oq844GZ44GT44Go44Gn6ZaJ44GY44KL44GT44Go44GM5Ye65p2l44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+OBruOBr+OAgVwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dQSBgUHJvbWlzZWAgb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBleOCjOOCi+imgee0oOOCkuino+axuuOBmeOCi2BQcm9taXNlYOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+IFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODgOOCpOOCouODreOCsOOBjOmWieOBmOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+OCs+ODvOODq+ODkOODg+OCr+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBhbGVydCBkaWFsb2cuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFd6Zqg44KM44Gf6KaB57Sg44KS6Kej5rG644GZ44KLYFByb21pc2Vg44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgQWxlcnREaWFsb2dBbmltYXRvcikpIHtcbiAgICAgIHV0aWwudGhyb3dBbmltYXRvcignQWxlcnREaWFsb2cnKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEFsZXJ0RGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIEFsZXJ0RGlhbG9nQW5pbWF0b3I7XG4gIH1cbn1cblxub25zRWxlbWVudHMuQWxlcnREaWFsb2cgPSBBbGVydERpYWxvZ0VsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1hbGVydC1kaWFsb2cnLCBBbGVydERpYWxvZ0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgQmFzZUJ1dHRvbkVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtYnV0dG9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYWxlcnQtZGlhbG9nLWJ1dHRvblxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gYWxlcnQtZGlhbG9nIGJ1dHRvbi5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYWxlcnQtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYWxlcnQgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiAgPG9ucy1hbGVydC1kaWFsb2c+XG4gKiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+V2FybmluZyE8L2Rpdj5cbiAqICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICogICAgICBBbiBlcnJvciBoYXMgb2NjdXJyZWQhXG4gKiAgICA8L2Rpdj5cbiAqICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+XG4gKiAgICAgIDxhbGVydC1kaWFsb2ctYnV0dG9uIG9uY2xpY2s9XCJhcHAuY2xvc2UoKVwiPkNhbmNlbDwvYWxlcnQtZGlhbG9nLWJ1dHRvbj5cbiAqICAgICAgPGFsZXJ0LWRpYWxvZy1idXR0b24gY2xhc3M9XCJhbGVydC1kaWFsb2ctYnV0dG9uXCIgb25jbGljaz1cImFwcC5jbG9zZSgpXCI+T0s8L2FsZXJ0LWRpYWxvZy1idXR0b24+XG4gKiAgICA8L2Rpdj5cbiAqICA8L29ucy1hbGVydC1kaWFsb2c+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VCdXR0b25FbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBr+aMh+WumuOBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4geyAnJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLSonIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdhbGVydC1kaWFsb2ctYnV0dG9uJztcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiBbdGhpcywgdW5kZWZpbmVkLCB7ICdtb2RpZmllcic6ICdsaWdodC1ncmF5JyB9XTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5BbGVydERpYWxvZ0J1dHRvbiA9IEFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nLCBBbGVydERpYWxvZ0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBpb3NCYWNrQnV0dG9uSWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvaW9zLWJhY2stYnV0dG9uLWljb24uc3ZnJztcbmltcG9ydCBtZEJhY2tCdXR0b25JY29uIGZyb20gJy4uLy4uL2ltYWdlcy9tZC1iYWNrLWJ1dHRvbi1pY29uLnN2Zyc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYmFjay1idXR0b24nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnYmFjay1idXR0b24tLSonLFxuICAnLmJhY2stYnV0dG9uX19pY29uJzogJ2JhY2stYnV0dG9uLS0qX19pY29uJyxcbiAgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnOiAnYmFjay1idXR0b24tLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYmFjay1idXR0b25cbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJhY2sgYnV0dG9uIGNvbXBvbmVudCBmb3IgYDxvbnMtdG9vbGJhcj5gLiBQdXQgaXQgaW4gdGhlIGxlZnQgcGFydCBvZiB0aGUgYDxvbnMtdG9vbGJhcj5gLlxuICpcbiAqICAgICBJdCB3aWxsIGZpbmQgdGhlIHBhcmVudCBgPG9ucy1uYXZpZ2F0b3I+YCBlbGVtZW50IGFuZCBwb3AgYSBwYWdlIHdoZW4gY2xpY2tlZC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNwZWNpZnlpbmcgdGhlIGBvbkNsaWNrYCBwcm9wZXJ0eS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2JhY2stYnV0dG9uXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbmF2aWdhdG9yXG4gKiAgIFtlbl1vbnMtbmF2aWdhdG9yIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbmF2aWdhdG9y44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRvb2xiYXI+XG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgVGl0bGVcbiAqICAgPGRpdj5cbiAqIDwvb25zLXRvb2xiYXI+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFja0J1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODkOODg+OCr+ODnOOCv+ODs+OBruimi+OBn+ebruOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVJY29uKGljb24gPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19pY29uJykpIHtcbiAgICBpY29uLmlubmVySFRNTCA9IGF1dG9TdHlsZS5nZXRQbGF0Zm9ybSh0aGlzKSA9PT0gJ2FuZHJvaWQnIHx8IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJykgPyBtZEJhY2tCdXR0b25JY29uIDogaW9zQmFja0J1dHRvbkljb247XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrLWJ1dHRvbl9fbGFiZWwnKSkge1xuICAgICAgY29uc3QgbGFiZWwgPSB1dGlsLmNyZWF0ZSgnc3Bhbi5iYWNrLWJ1dHRvbl9fbGFiZWwnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19pY29uJykpIHtcbiAgICAgIGNvbnN0IGljb24gPSB1dGlsLmNyZWF0ZSgnc3Bhbi5iYWNrLWJ1dHRvbl9faWNvbicpO1xuICAgICAgdGhpcy5fdXBkYXRlSWNvbihpY29uKTtcblxuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcywgdW5kZWZpbmVkLCB7Y2VudGVyOiAnJywgJ3NpemUnOiAnY29udGFpbicsICdiYWNrZ3JvdW5kJzogJ3RyYW5zcGFyZW50J30pO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIFwic2xpZGVcIiwgXCJsaWZ0XCIsIFwiZmFkZVwiIGFuZCBcIm5vbmVcIi5cbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIFwiLWlvc1wiIG9yIFwiLW1kXCJcbiAgICogICAgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gXCJsaWZ0LWlvc1wiLCBcImxpZnQtbWRcIi4gRGVmYXVsdHMgdmFsdWVzIGFyZSBcInNsaWRlLWlvc1wiIGFuZCBcImZhZGUtbWRcIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9iamVjdCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uQ2xpY2tcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiYWNrIGJ1dHRvbiBiZWhhdmlvci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgX29uQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG5hdmlnYXRvciA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLW5hdmlnYXRvcicpO1xuICAgICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICBuYXZpZ2F0b3IucG9wUGFnZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbW9kaWZpZXInOiB7XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpICYmIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkJhY2tCdXR0b24gPSBCYWNrQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJhY2stYnV0dG9uJywgQmFja0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYm90dG9tLWJhcic7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdib3R0b20tYmFyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJvdHRvbS10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Ub29sYmFyIGNvbXBvbmVudCB0aGF0IGlzIHBvc2l0aW9uZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gU2luY2UgYm90dG9tIHRvb2xiYXJzIGFyZSB2ZXJ5IHZlcnNhdGlsZSBlbGVtZW50cywgYG9ucy1ib3R0b20tdG9vbGJhcmAgZG9lcyBub3QgcHJvdmlkZSBhbnkgc3BlY2lmaWMgbGF5b3V0IHN5bnRheCBmb3IgaXRzIGNoaWxkcmVuLiBNb2RpZmllcnMgb3IgY3VzdG9tIENTUyBtdXN0IGJlIHVzZWQuWy9lbl1cbiAqICAgW2phXeODmuODvOOCuOS4i+mDqOOBq+mFjee9ruOBleOCjOOCi+ODhOODvOODq+ODkOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgdHJhbnNwYXJlbnRcbiAqICAgW2VuXU1ha2UgdGhlIHRvb2xiYXIgdHJhbnNwYXJlbnQuWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBruiDjOaZr+OCkumAj+aYjuOBq+OBl+OBpuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgYWxpZ25lZFxuICogICBbZW5dVmVydGljYWxseSBhbGlnbnMgaXRzIGNoaWxkcmVuIGFuZCBhcHBsaWVzIGZsZXhib3ggZm9yIGJsb2NrIGVsZW1lbnRzLiBganVzdGlmeS1jb250ZW50YCBDU1MgcnVsZSBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgaG9yaXpvbnRhbCBhbGlnbi5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyIFtlbl1vbnMtdG9vbGJhciBjb21wb25lbnRbL2VuXVtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1ib3R0b20tdG9vbGJhcj5cbiAqICAgQ29udGVudFxuICogPC9vbnMtYm90dG9tLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvdHRvbVRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KaL44Gf55uu44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxufVxuXG5vbnNFbGVtZW50cy5Cb3R0b21Ub29sYmFyID0gQm90dG9tVG9vbGJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1ib3R0b20tdG9vbGJhcicsIEJvdHRvbVRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VCdXR0b25FbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWJ1dHRvbic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJ1dHRvblxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1CdXR0b24gd2l0aCBvdXRsaW5lIGFuZCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuaMgeOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGlnaHRcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IGRvZXNuJ3Qgc3RhbmQgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgZ/jgarjgYTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIHF1aWV0XG4gKiAgIFtlbl1CdXR0b24gd2l0aCBubyBvdXRsaW5lIGFuZCBvciBiYWNrZ3JvdW5kLi5bL2VuXVxuICogICBbamFd5p6g57ea44KE6IOM5pmv44GM54Sh44GE5paH5a2X44Gg44GR44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjdGFcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IHJlYWxseSBzdGFuZHMgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgaTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlXG4gKiAgIFtlbl1MYXJnZSBidXR0b24gdGhhdCBjb3ZlcnMgdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi+Wkp+OBjeOBquODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2UtLXF1aWV0XG4gKiAgIFtlbl1MYXJnZSBxdWlldCBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi3F1aWV044Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tY3RhXG4gKiAgIFtlbl1MYXJnZSBjYWxsIHRvIGFjdGlvbiBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi2N0YeODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oc44K/44OzWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbC0tZmxhdFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGZsYXQgYnV0dG9uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODleODqeODg+ODiOODnOOCv+ODs1svamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJ1dHRvbiBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgYnV0dG9uIGluIGEgdG9vbGJhciwgdXNlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgb3IgYDxvbnMtYmFjay1idXR0b24+YCBpbnN0ZWFkLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhcyBhIE1hdGVyaWFsIERlc2lnbiBidXR0b24gd2l0aCBhIHJpcHBsZSBlZmZlY3Qgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnOOCv+ODs+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOAguODhOODvOODq+ODkOODvOOBq+ODnOOCv+ODs+OCkuioree9ruOBmeOCi+WgtOWQiOOBr+OAgW9ucy10b29sYmFyLWJ1dHRvbuOCguOBl+OBj+OBr29ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2J1dHRvblxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiBtb2RpZmllcj1cImxhcmdlLS1jdGFcIj5cbiAqICAgVGFwIE1lXG4gKiA8L29ucy1idXR0b24+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VCdXR0b25FbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHsgJyc6ICdidXR0b24tLSonIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdidXR0b24nO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkJ1dHRvbiA9IEJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1idXR0b24nLCBCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnY2FyZCc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnY2FyZC0tKicsXG4gICcuY2FyZF9fdGl0bGUnOiAnY2FyZC0tKl9fdGl0bGUnLFxuICAnLmNhcmRfX2NvbnRlbnQnOiAnY2FyZC0tKl9fY29udGVudCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcmRcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dQSBjYXJkIHdpdGggbWF0ZXJpYWwgZGVzaWduLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgIENvbXBvbmVudCB0byBjcmVhdGUgYSBjYXJkIHRoYXQgZGlzcGxheXMgc29tZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAgICBUaGUgY2FyZCBtYXkgYmUgY29tcG9zZWQgYnkgZGl2cyB3aXRoIHNwZWNpYWxseSBwcmVwYXJlZCBjbGFzc2VzIGB0aXRsZWAgYW5kL29yIGBjb250ZW50YC4gWW91IGNhbiBhbHNvIGFkZCB5b3VyIG93biBjb250ZW50IGFzIHlvdSBwbGVhc2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2FyZFxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2FyZD5cbiAqICAgPHA+U29tZSBjb250ZW50PC9wPlxuICogPC9vbnMtY2FyZD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FyZEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjYXJkLlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgbGV0IHRpdGxlLCBjb250ZW50O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3RpdGxlJykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnY2FyZF9fdGl0bGUnKTtcbiAgICAgICAgdGl0bGUgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY29udGVudCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NhcmRfX2NvbnRlbnQnKTtcbiAgICAgICAgY29udGVudCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuQ2FyZCA9IENhcmRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2FyZCcsIENhcmRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdjYXJvdXNlbC1pdGVtLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBpdGVtIGNvbXBvbmVudC4gVXNlZCBhcyBhIGNoaWxkIG9mIHRoZSBgPG9ucy1jYXJvdXNlbD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcbiAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbFxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWw+YCBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXTxvbnMtY2Fyb3VzZWw+44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogPC9vbnMtY2Fyb3VzZWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcm91c2VsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5DYXJvdXNlbEl0ZW0gPSBDYXJvdXNlbEl0ZW1FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwtaXRlbScsIENhcm91c2VsSXRlbUVsZW1lbnQpO1xuIiwiaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi9hbmltaXQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3QgZGlyZWN0aW9uTWFwID0ge1xuICB2ZXJ0aWNhbDoge1xuICAgIGF4aXM6ICdZJyxcbiAgICBzaXplOiAnSGVpZ2h0JyxcbiAgICBkaXI6IFsndXAnLCAnZG93biddLFxuICAgIHQzZDogWycwcHgsICcsICdweCwgMHB4J11cbiAgfSxcbiAgaG9yaXpvbnRhbDoge1xuICAgIGF4aXM6ICdYJyxcbiAgICBzaXplOiAnV2lkdGgnLFxuICAgIGRpcjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgdDNkOiBbJycsICdweCwgMHB4LCAwcHgnXVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2lwZXIge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAvLyBQYXJhbWV0ZXJzXG4gICAgY29uc3QgRkFMU0UgPSAoKCkgPT4gZmFsc2UpO1xuICAgIGBnZXRJbml0aWFsSW5kZXggZ2V0QnViYmxlV2lkdGggaXNWZXJ0aWNhbCBpc092ZXJTY3JvbGxhYmxlIGlzQ2VudGVyZWRcbiAgICBpc0F1dG9TY3JvbGxhYmxlIHJlZnJlc2hIb29rIHByZUNoYW5nZUhvb2sgcG9zdENoYW5nZUhvb2sgb3ZlclNjcm9sbEhvb2tgXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmZvckVhY2goa2V5ID0+IHRoaXNba2V5XSA9IHBhcmFtc1trZXldIHx8IEZBTFNFKTtcblxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IHBhcmFtcy5nZXRFbGVtZW50OyAvLyBSZXF1aXJlZFxuICAgIHRoaXMuc2Nyb2xsSG9vayA9IHBhcmFtcy5zY3JvbGxIb29rOyAvLyBPcHRpb25hbFxuICAgIHRoaXMuaXRlbVNpemUgPSBwYXJhbXMuaXRlbVNpemUgfHwgJzEwMCUnO1xuXG4gICAgdGhpcy5nZXRBdXRvU2Nyb2xsUmF0aW8gPSAoLi4uYXJncykgPT4ge1xuICAgICAgbGV0IHJhdGlvID0gcGFyYW1zLmdldEF1dG9TY3JvbGxSYXRpbyAmJiBwYXJhbXMuZ2V0QXV0b1Njcm9sbFJhdGlvKC4uLmFyZ3MpO1xuICAgICAgcmF0aW8gPSB0eXBlb2YgcmF0aW8gPT09ICdudW1iZXInICYmIHJhdGlvID09PSByYXRpbyA/IHJhdGlvIDogLjU7XG4gICAgICBpZiAocmF0aW8gPCAwLjAgfHwgcmF0aW8gPiAxLjApIHtcbiAgICAgICAgdXRpbC50aHJvdygnSW52YWxpZCBhdXRvLXNjcm9sbC1yYXRpbyAnICsgcmF0aW8gKyAnLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhdGlvO1xuICAgIH07XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBvbmx5IG9uIGRlc2t0b3BcbiAgICB0aGlzLnNob3VsZEJsb2NrID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnb3RoZXInO1xuXG4gICAgLy8gQmluZCBoYW5kbGVyc1xuICAgIHRoaXMub25EcmFnU3RhcnQgPSB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkRyYWcgPSB0aGlzLm9uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25EcmFnRW5kID0gdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2hvdWxkRml4U2Nyb2xsID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnaW9zJztcbiAgfVxuXG4gIGluaXQoeyBzd2lwZWFibGUsIGF1dG9SZWZyZXNoIH0gPSB7fSkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5nZXRFbGVtZW50KCkuY2hpbGRyZW5bMF07XG4gICAgdGhpcy5ibG9ja2VyID0gdGhpcy5nZXRFbGVtZW50KCkuY2hpbGRyZW5bMV07XG4gICAgaWYgKCF0aGlzLnRhcmdldCB8fCAhdGhpcy5ibG9ja2VyKSB7XG4gICAgICB1dGlsLnRocm93KCdFeHBlY3RlZCBcInRhcmdldFwiIGFuZCBcImJsb2NrZXJcIiBlbGVtZW50cyB0byBleGlzdCBiZWZvcmUgaW5pdGlhbGl6aW5nIFN3aXBlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRCbG9jaykge1xuICAgICAgdGhpcy5ibG9ja2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNsYXNzZXNcbiAgICB0aGlzLmdldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdvbnMtc3dpcGVyJyk7XG4gICAgdGhpcy50YXJnZXQuY2xhc3NMaXN0LmFkZCgnb25zLXN3aXBlci10YXJnZXQnKTtcbiAgICB0aGlzLmJsb2NrZXIuY2xhc3NMaXN0LmFkZCgnb25zLXN3aXBlci1ibG9ja2VyJyk7XG5cbiAgICAvLyBTZXR1cCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuZ2V0RWxlbWVudCgpLFxuICAgICAgeyBkcmFnTWluRGlzdGFuY2U6IDEsIGRyYWdMb2NrVG9BeGlzOiB0cnVlLCBwYXNzaXZlOiAhdGhpcy5fc2hvdWxkRml4U2Nyb2xsIH1cbiAgICApO1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoc3dpcGVhYmxlKTtcbiAgICB0aGlzLnVwZGF0ZUF1dG9SZWZyZXNoKGF1dG9SZWZyZXNoKTtcblxuICAgIC8vIFNldHVwIGluaXRpYWwgbGF5b3V0XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCkpO1xuXG4gICAgLy8gRml4IHJlbmRlcmluZyBnbGl0Y2ggb24gQW5kcm9pZCA0LjFcbiAgICAvLyBGaXggZm9yIGlmcmFtZXMgd2hlcmUgdGhlIHdpZHRoIGlzIGluY29uc2lzdGVudCBhdCB0aGUgYmVnaW5uaW5nXG4gICAgaWYgKHdpbmRvdyAhPT0gd2luZG93LnBhcmVudCB8fCB0aGlzLm9mZnNldEhlaWdodCA9PT0gMCkge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkICYmIHRoaXMub25SZXNpemUoKSk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoZmFsc2UpO1xuICAgIHRoaXMudXBkYXRlQXV0b1JlZnJlc2goZmFsc2UpO1xuXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yICYmIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLmJsb2NrZXIgPSB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcblxuICAgIHRoaXMuc2V0dXBSZXNpemUoZmFsc2UpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3Njcm9sbCAvIHRoaXMudGFyZ2V0U2l6ZTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldC5jaGlsZHJlbi5sZW5ndGg7XG4gIH1cblxuICBnZXQgaXRlbU51bVNpemUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pdGVtTnVtU2l6ZSAhPT0gJ251bWJlcicgfHwgdGhpcy5faXRlbU51bVNpemUgIT09IHRoaXMuX2l0ZW1OdW1TaXplKSB7XG4gICAgICB0aGlzLl9pdGVtTnVtU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUl0ZW1TaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pdGVtTnVtU2l6ZTtcbiAgfVxuXG4gIGdldCBtYXhTY3JvbGwoKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5pdGVtQ291bnQgKiB0aGlzLml0ZW1OdW1TaXplIC0gdGhpcy50YXJnZXRTaXplO1xuICAgIHJldHVybiBNYXRoLmNlaWwobWF4IDwgMCA/IDAgOiBtYXgpOyAvLyBOZWVkIHRvIHJldHVybiBhbiBpbnRlZ2VyIHZhbHVlLlxuICB9XG5cbiAgX2NhbGN1bGF0ZUl0ZW1TaXplKCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLml0ZW1TaXplLm1hdGNoKC9eKFxcZCspKHB4fCUpLyk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHV0aWwudGhyb3coYEludmFsaWQgc3RhdGU6IHN3aXBlcidzIHNpemUgdW5pdCBtdXN0IGJlICclJyBvciAncHgnYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgcmV0dXJuIG1hdGNoZXNbMl0gPT09ICclJyA/IE1hdGgucm91bmQodmFsdWUgLyAxMDAgKiB0aGlzLnRhcmdldFNpemUpIDogdmFsdWU7XG4gIH1cblxuICBfc2V0dXBJbml0aWFsSW5kZXgoKSB7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBNYXRoLm1heChNYXRoLm1pbihOdW1iZXIodGhpcy5nZXRJbml0aWFsSW5kZXgoKSksIHRoaXMuaXRlbUNvdW50KSwgMCk7XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5pdGVtTnVtU2l6ZSAqIHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwpO1xuICB9XG5cbiAgX3NldFN3aXBpbmcodG9nZ2xlKSB7XG4gICAgdGhpcy50YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnc3dpcGluZycsIHRvZ2dsZSk7IC8vIEhpZGVzIGV2ZXJ5dGhpbmcgZXhjZXB0IHNob3duIHBhZ2VzXG4gIH1cblxuICBzZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fc2V0U3dpcGluZyh0cnVlKTtcbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1Db3VudCAtIDEpKTtcbiAgICBjb25zdCBzY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLm1heFNjcm9sbCwgdGhpcy5fb2Zmc2V0ICsgdGhpcy5pdGVtTnVtU2l6ZSAqIGluZGV4KSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNVSVdlYlZpZXcoKSkge1xuICAgICAgLyogRGlydHkgZml4IGZvciAjMjIzMShodHRwczovL2dpdGh1Yi5jb20vT25zZW5VSS9PbnNlblVJL2lzc3Vlcy8yMjMxKS4gYmVnaW4gKi9cbiAgICAgIGNvbnN0IGNvbmNhdCA9IGFycmF5T2ZBcnJheSA9PiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheU9mQXJyYXkpO1xuICAgICAgY29uc3QgY29udGVudHMgPSBjb25jYXQoXG4gICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMudGFyZ2V0LmNoaWxkcmVuKS5tYXAocGFnZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHBhZ2UuY2hpbGRyZW4pXG4gICAgICAgICAgICAuZmlsdGVyKGNoaWxkID0+IGNoaWxkLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fY29udGVudCcpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRzLmZvckVhY2goY29udGVudCA9PiB7XG4gICAgICAgICAgICBtYXAuc2V0KGNvbnRlbnQsIGNvbnRlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtcbiAgICAgICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncGFnZV9fY29udGVudC0tc3VwcHJlc3MtbGF5ZXItY3JlYXRpb24nKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudHMuZm9yRWFjaChjb250ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIG1hcC5nZXQoY29udGVudCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKTtcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgICAgLyogZW5kICovXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGdldEFjdGl2ZUluZGV4KHNjcm9sbCA9IHRoaXMuX3Njcm9sbCkge1xuICAgIHNjcm9sbCAtPSB0aGlzLl9vZmZzZXQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZW1Db3VudCxcbiAgICAgIHNpemUgPSB0aGlzLml0ZW1OdW1TaXplO1xuXG4gICAgaWYgKHRoaXMuaXRlbU51bVNpemUgPT09IDAgfHwgIXV0aWwuaXNJbnRlZ2VyKHNjcm9sbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXN0QWN0aXZlSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbCA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGlmIChzaXplICogaSA8PSBzY3JvbGwgJiYgc2l6ZSAqIChpICsgMSkgPiBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50IC0gMTtcbiAgfVxuXG4gIHNldHVwUmVzaXplKGFkZCkge1xuICAgIHdpbmRvd1soYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lciddKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZSh0cnVlKTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRhcmdldCAmJiB0aGlzLnRhcmdldC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKSwgMTAwMC82MCk7IC8vIEhpZGUgZWxlbWVudHMgYWZ0ZXIgYW5pbWF0aW9uc1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnNldHVwUmVzaXplKGZhbHNlKTtcbiAgICB0aGlzLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgLy8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW9uc1xuICB9XG5cbiAgdXBkYXRlU3dpcGVhYmxlKHNob3VsZFVwZGF0ZSkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IHNob3VsZFVwZGF0ZSA/ICdvbicgOiAnb2ZmJztcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdlbmQnLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXV0b1JlZnJlc2goc2hvdWxkV2F0Y2gpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgc2hvdWxkV2F0Y2hcbiAgICAgICAgPyB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy50YXJnZXQsIHsgY2hpbGRMaXN0OiB0cnVlIH0pXG4gICAgICAgIDogdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSXRlbVNpemUobmV3U2l6ZSkge1xuICAgIHRoaXMuaXRlbVNpemUgPSBuZXdTaXplIHx8ICcxMDAlJztcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIHRvZ2dsZUJsb2NrZXIoYmxvY2spIHtcbiAgICB0aGlzLmJsb2NrZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IGJsb2NrID8gJ2F1dG8nIDogJ25vbmUnO1xuICB9XG5cbiAgX2NhbkNvbnN1bWVHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICBjb25zdCBkID0gZ2VzdHVyZS5kaXJlY3Rpb247XG4gICAgY29uc3QgaXNGaXJzdCA9IHRoaXMuX3Njcm9sbCA9PT0gMCAmJiAhdGhpcy5pc092ZXJTY3JvbGxhYmxlKCk7XG4gICAgY29uc3QgaXNMYXN0ID0gdGhpcy5fc2Nyb2xsID09PSB0aGlzLm1heFNjcm9sbCAmJiAhdGhpcy5pc092ZXJTY3JvbGxhYmxlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5pc1ZlcnRpY2FsKClcbiAgICAgID8gKChkID09PSAnZG93bicgJiYgIWlzRmlyc3QpIHx8IChkID09PSAndXAnICYmICFpc0xhc3QpKVxuICAgICAgOiAoKGQgPT09ICdyaWdodCcgJiYgIWlzRmlyc3QpIHx8IChkID09PSAnbGVmdCcgJiYgIWlzTGFzdCkpO1xuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gZXZlbnQuY29uc3VtZWQgfHwgIXV0aWwuaXNWYWxpZEdlc3R1cmUoZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBjb25zdCBjb25zdW1lID0gZXZlbnQuY29uc3VtZTtcbiAgICAgIGV2ZW50LmNvbnN1bWUgPSAoKSA9PiB7IGNvbnN1bWUgJiYgY29uc3VtZSgpOyB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTsgfTtcblxuICAgICAgaWYgKHRoaXMuX2NhbkNvbnN1bWVHZXN0dXJlKGV2ZW50Lmdlc3R1cmUpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IGV2ZW50Lmdlc3R1cmUuY2VudGVyICYmIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggfHwgMCxcbiAgICAgICAgICBkaXN0RnJvbUVkZ2UgPSB0aGlzLmdldEJ1YmJsZVdpZHRoKCkgfHwgMCxcbiAgICAgICAgICBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN1bWUgJiYgY29uc3VtZSgpO1xuICAgICAgICAgICAgZXZlbnQuY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7IC8vIEF2b2lkIHN0YXJ0aW5nIGRyYWcgZnJvbSBvdXRzaWRlXG4gICAgICAgICAgICB0aGlzLnNob3VsZEJsb2NrICYmIHRoaXMudG9nZ2xlQmxvY2tlcih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN3aXBpbmcodHJ1ZSk7XG4gICAgICAgICAgICB1dGlsLmlvc1ByZXZlbnRTY3JvbGwodGhpcy5fZ2VzdHVyZURldGVjdG9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIExldCBwYXJlbnQgZWxlbWVudHMgY29uc3VtZSB0aGUgZ2VzdHVyZSBvciBjb25zdW1lIGl0IHJpZ2h0IGF3YXlcbiAgICAgICAgc3RhcnRYIDwgZGlzdEZyb21FZGdlIHx8IHN0YXJ0WCA+ICh0aGlzLnRhcmdldFNpemUgLSBkaXN0RnJvbUVkZ2UpXG4gICAgICAgICAgPyBzZXRJbW1lZGlhdGUoKCkgPT4gIXRoaXMuX2lnbm9yZURyYWcgJiYgc3RhcnQoKSlcbiAgICAgICAgICA6IHN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuX2lnbm9yZURyYWcgfHwgIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250aW51ZWQgPSB0cnVlOyAvLyBGaXggZm9yIHJhbmRvbSAnZHJhZ2VuZCcgd2l0aG91dCAnZHJhZydcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldERlbHRhKGV2ZW50KSwgeyB0aHJvdHRsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIG9uRHJhZ0VuZChldmVudCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWV2ZW50Lmdlc3R1cmUgfHwgdGhpcy5faWdub3JlRHJhZyB8fCAhdGhpcy5fY29udGludWVkKSB7XG4gICAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTsgLy8gb25EcmFnRW5kIG1pZ2h0IGZpcmUgYmVmb3JlIG9uRHJhZ1N0YXJ0J3Mgc2V0SW1tZWRpYXRlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGludWVkID0gZmFsc2U7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXREZWx0YShldmVudCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbChzY3JvbGwpO1xuICAgIHNjcm9sbCA9PT0gbm9ybWFsaXplZFNjcm9sbCA/IHRoaXMuX3N0YXJ0TW9tZW50dW1TY3JvbGwoc2Nyb2xsLCBldmVudCkgOiB0aGlzLl9raWxsT3ZlclNjcm9sbChub3JtYWxpemVkU2Nyb2xsKTtcbiAgICB0aGlzLnNob3VsZEJsb2NrICYmIHRoaXMudG9nZ2xlQmxvY2tlcihmYWxzZSk7XG4gIH1cblxuICBfc3RhcnRNb21lbnR1bVNjcm9sbChzY3JvbGwsIGV2ZW50KSB7XG4gICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRWZWxvY2l0eShldmVudCksXG4gICAgICBtYXRjaGVzRGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uID09PSB0aGlzLmRNLmRpclt0aGlzLl9nZXREZWx0YShldmVudCkgPCAwID8gMCA6IDFdO1xuXG4gICAgY29uc3QgbmV4dFNjcm9sbCA9IHRoaXMuX2dldEF1dG9TY3JvbGwoc2Nyb2xsLCB2ZWxvY2l0eSwgbWF0Y2hlc0RpcmVjdGlvbik7XG4gICAgbGV0IGR1cmF0aW9uID0gTWF0aC5hYnMobmV4dFNjcm9sbCAtIHNjcm9sbCkgLyAodmVsb2NpdHkgKyAwLjAxKSAvIDEwMDA7XG4gICAgZHVyYXRpb24gPSBNYXRoLm1pbiguMjUsIE1hdGgubWF4KC4xLCBkdXJhdGlvbikpO1xuXG4gICAgdGhpcy5fY2hhbmdlVG8obmV4dFNjcm9sbCwgeyBzd2lwZTogdHJ1ZSwgYW5pbWF0aW9uT3B0aW9uczogeyBkdXJhdGlvbiwgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC40LCAuNywgLjUsIDEpJyB9IH0pO1xuICB9XG5cbiAgX2tpbGxPdmVyU2Nyb2xsKHNjcm9sbCkge1xuICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRNLmRpcltOdW1iZXIoc2Nyb2xsID4gMCldO1xuICAgIGNvbnN0IGtpbGxPdmVyU2Nyb2xsID0gKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCB7IGFuaW1hdGlvbk9wdGlvbnM6IHsgZHVyYXRpb246IC40LCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknIH0gfSk7XG4gICAgdGhpcy5vdmVyU2Nyb2xsSG9vayh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkgfHwga2lsbE92ZXJTY3JvbGwoKTtcbiAgfVxuXG4gIF9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGUgPSB7IGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KHNjcm9sbCksIGxhc3RBY3RpdmVJbmRleDogdGhpcy5fbGFzdEFjdGl2ZUluZGV4LCBzd2lwZTogb3B0aW9ucy5zd2lwZSB8fCBmYWxzZSB9O1xuICAgIGNvbnN0IGNoYW5nZSA9IGUuYWN0aXZlSW5kZXggIT09IGUubGFzdEFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IGNhbmNlbGVkID0gY2hhbmdlID8gdGhpcy5wcmVDaGFuZ2VIb29rKGUpIDogZmFsc2U7XG5cbiAgICB0aGlzLl9zY3JvbGwgPSBjYW5jZWxlZCA/IHRoaXMuX29mZnNldCArIGUubGFzdEFjdGl2ZUluZGV4ICogdGhpcy5pdGVtTnVtU2l6ZSA6IHNjcm9sbDtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjYW5jZWxlZCA/IGUubGFzdEFjdGl2ZUluZGV4IDogZS5hY3RpdmVJbmRleDtcblxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbCA9PT0gdGhpcy5fc2Nyb2xsICYmICFjYW5jZWxlZCkge1xuICAgICAgICB0aGlzLl9zZXRTd2lwaW5nKGZhbHNlKTtcbiAgICAgICAgY2hhbmdlICYmIHRoaXMucG9zdENoYW5nZUhvb2soZSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVqZWN0KSB7XG4gICAgICAgIHRoaXMuX3NldFN3aXBpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfc2Nyb2xsVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy50aHJvdHRsZSkge1xuICAgICAgY29uc3QgcmF0aW8gPSAwLjM1O1xuICAgICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgICAgc2Nyb2xsID0gdGhpcy5pc092ZXJTY3JvbGxhYmxlKCkgPyBNYXRoLnJvdW5kKHNjcm9sbCAqIHJhdGlvKSA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLm1heFNjcm9sbDtcbiAgICAgICAgaWYgKG1heFNjcm9sbCA8IHNjcm9sbCkge1xuICAgICAgICAgIHNjcm9sbCA9IHRoaXMuaXNPdmVyU2Nyb2xsYWJsZSgpID8gbWF4U2Nyb2xsICsgTWF0aC5yb3VuZCgoc2Nyb2xsIC0gbWF4U2Nyb2xsKSAqIHJhdGlvKSA6IG1heFNjcm9sbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMuYW5pbWF0aW9uICA9PT0gJ25vbmUnID8ge30gOiBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnM7XG4gICAgdGhpcy5zY3JvbGxIb29rICYmIHRoaXMuaXRlbU51bVNpemUgPiAwICYmIHRoaXMuc2Nyb2xsSG9vaygoc2Nyb2xsIC8gdGhpcy5pdGVtTnVtU2l6ZSkudG9GaXhlZCgyKSwgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+XG4gICAgICBhbmltaXQodGhpcy50YXJnZXQpXG4gICAgICAgIC5xdWV1ZSh7IHRyYW5zZm9ybTogdGhpcy5fZ2V0VHJhbnNmb3JtKHNjcm9sbCkgfSwgb3B0KVxuICAgICAgICAucGxheShyZXNvbHZlKVxuICAgICk7XG4gIH1cblxuICBfZ2V0QXV0b1Njcm9sbChzY3JvbGwsIHZlbG9jaXR5LCBtYXRjaGVzRGlyZWN0aW9uKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXhTY3JvbGwsXG4gICAgICBvZmZzZXQgPSB0aGlzLl9vZmZzZXQsXG4gICAgICBzaXplID0gdGhpcy5pdGVtTnVtU2l6ZTtcblxuICAgIGlmICghdGhpcy5pc0F1dG9TY3JvbGxhYmxlKCkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIH1cblxuICAgIGxldCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBzID0gb2Zmc2V0OyBzIDwgbWF4OyBzICs9IHNpemUpIHtcbiAgICAgIGFyci5wdXNoKHMpO1xuICAgIH1cbiAgICBhcnIucHVzaChtYXgpO1xuXG4gICAgYXJyID0gYXJyXG4gICAgICAuc29ydCgobGVmdCwgcmlnaHQpID0+IE1hdGguYWJzKGxlZnQgLSBzY3JvbGwpIC0gTWF0aC5hYnMocmlnaHQgLSBzY3JvbGwpKVxuICAgICAgLmZpbHRlcigoaXRlbSwgcG9zKSA9PiAhcG9zIHx8IGl0ZW0gIT09IGFycltwb3MgLSAxXSk7XG5cbiAgICBsZXQgcmVzdWx0ID0gYXJyWzBdO1xuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXggKiBzaXplICsgb2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xuXG4gICAgaWYgKHNjcm9sbFJhdGlvIDw9IHRoaXMuZ2V0QXV0b1Njcm9sbFJhdGlvKG1hdGNoZXNEaXJlY3Rpb24sIHZlbG9jaXR5LCBzaXplKSkge1xuICAgICAgcmVzdWx0ID0gbGFzdFNjcm9sbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNjcm9sbFJhdGlvIDwgMS4wICYmIGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBhcnJbMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHJlc3VsdCkpO1xuICB9XG5cbiAgX3Jlc2V0KCkge1xuICAgIHRoaXMuX3RhcmdldFNpemUgPSB0aGlzLl9pdGVtTnVtU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIF9ub3JtYWxpemVTY3JvbGwoc2Nyb2xsKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KCBNYXRoLm1pbihzY3JvbGwsIHRoaXMubWF4U2Nyb2xsKSwgMClcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcih0aGlzLl9zY3JvbGwpKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGwodGhpcy5fc2Nyb2xsKTtcbiAgICAgIHNjcm9sbCAhPT0gdGhpcy5fc2Nyb2xsID8gdGhpcy5fa2lsbE92ZXJTY3JvbGwoc2Nyb2xsKSA6IHRoaXMuX2NoYW5nZVRvKHNjcm9sbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoSG9vaygpO1xuICB9XG5cbiAgZ2V0IHRhcmdldFNpemUoKSB7XG4gICAgaWYgKCF0aGlzLl90YXJnZXRTaXplKSB7XG4gICAgICB0aGlzLl90YXJnZXRTaXplID0gdGhpcy50YXJnZXRbYG9mZnNldCR7dGhpcy5kTS5zaXplfWBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U2l6ZTtcbiAgfVxuXG4gIF9nZXREZWx0YShldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlW2BkZWx0YSR7dGhpcy5kTS5heGlzfWBdO1xuICB9XG5cbiAgX2dldFZlbG9jaXR5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmVbYHZlbG9jaXR5JHt0aGlzLmRNLmF4aXN9YF07XG4gIH1cblxuICBfZ2V0VHJhbnNmb3JtKHNjcm9sbCkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRNLnQzZFswXX0key1zY3JvbGx9JHt0aGlzLmRNLnQzZFsxXX0pYDtcbiAgfVxuXG4gIF91cGRhdGVMYXlvdXQoKSB7XG4gICAgdGhpcy5kTSA9IGRpcmVjdGlvbk1hcFt0aGlzLmlzVmVydGljYWwoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCddO1xuICAgIHRoaXMudGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1zd2lwZXItdGFyZ2V0LS12ZXJ0aWNhbCcsIHRoaXMuaXNWZXJ0aWNhbCgpKTtcblxuICAgIGZvciAobGV0IGMgPSB0aGlzLnRhcmdldC5jaGlsZHJlblswXTsgYzsgYyA9IGMubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBjLnN0eWxlW3RoaXMuZE0uc2l6ZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDZW50ZXJlZCgpKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAodGhpcy50YXJnZXRTaXplIC0gdGhpcy5pdGVtTnVtU2l6ZSkgLyAtMiB8fCAwO1xuICAgIH1cbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IFN3aXBlciBmcm9tICcuLi9vbnMvaW50ZXJuYWwvc3dpcGVyJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBjb21wb25lbnQuIEEgY2Fyb3VzZWwgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBzZXZlcmFsIGl0ZW1zIGluIHRoZSBzYW1lIHNwYWNlLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHN1cHBvcnRzIGRpc3BsYXlpbmcgY29udGVudCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS4gVGhlIHVzZXIgY2FuIHNjcm9sbCB0aHJvdWdoIHRoZSBpdGVtcyBieSBkcmFnZ2luZyBhbmQgaXQgY2FuIGFsc28gYmUgY29udHJvbGxlciBwcm9ncmFtbWF0aWNhbGx5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2Nhcm91c2VsXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWwtaXRlbVxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5sYXN0QWN0aXZlSW5kZXhcbiAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3ZlcnNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFd44Kq44O844OQ44O844K544Kv44Ot44O844Or44GV44KM44Gf5pa55ZCR44GM5b6X44KJ44KM44G+44GZ44CCXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBruOBhOOBmuOCjOOBi+OBruaWueWQkeOBjOa4oeOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxuICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOBr1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLlvJXmlbDjgajjgZfjgablj5fjgZHlj5bjgorjgb7jgZnjgILmuKHjgZfjgZ9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44GMcmVzb2x2ZeOBleOCjOOCi+OBi3JlamVjdOOBleOCjOOCi+OBvuOBp+OAgeOCq+ODq+ODvOOCu+ODq+OBr+OCueOCr+ODreODvOODq+ODkOODg+OCr+OBl+OBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBruaWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GLXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmdWxsc2NyZWVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgY292ZXIgdGhlIHdob2xlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIFhYnNvbHV0ZeODneOCuOOCt+ODp+ODs+OCkuS9v+OBo+OBpuOCq+ODq+ODvOOCu+ODq+OBjOiHquWLleeahOOBq+eUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgc2Nyb2xsYWJsZSBvdmVyIHRoZSBlZGdlLiBJdCB3aWxsIGJvdW5jZSBiYWNrIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgemBuOOCk+OBp+OBhOOCi29ucy1jYXJvdXNlbC1pdGVt44Gv44Kr44Or44O844K744Or44Gu55yf44KT5Lit44G46KGM44GN44G+44GZ44CC6aCF55uu44GM44Kr44Or44O844K744Or44KI44KK44KC5bCP44GV44GE5aC05ZCI44Gr44Gu44G/44CB44GT44KM44Gv5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3Mgd2lkdGguIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1widmVydGljYWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbC1yYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXUEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAgdGhhdCBzcGVjaWZpZXMgaG93IG11Y2ggdGhlIHVzZXIgbXVzdCBkcmFnIHRoZSBjYXJvdXNlbCBpbiBvcmRlciBmb3IgaXQgdG8gYXV0byBzY3JvbGwgdG8gdGhlIG5leHQgaXRlbS5bL2VuXVxuICAgKiAgICBbamFdMC4w44GL44KJMS4w44G+44Gn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CC44Kr44Or44O844K744Or44Gu6KaB57Sg44KS44Gp44KM44GQ44KJ44GE44Gu5Ymy5ZCI44G+44Gn44OJ44Op44OD44Kw44GZ44KL44Go5qyh44Gu6KaB57Sg44Gr6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRyYWfjgoR0b3VjaOOChHN3aXBl44KS5Y+X44GR5LuY44GR44Gq44GP44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5pdGlhbC1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlZmF1bHQgMFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIG9ucy1jYXJvdXNlbC1pdGVtIHRvIHNob3cgaW5pdGlhbGx5LiBEZWZhdWx0IGlzIDAuWy9lbl1cbiAgICogICBbamFd5pyA5Yid44Gr6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpIw5aeL44G+44KK44Gu44Kk44Oz44OH44OD44Kv44K544Gn5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI5YCk44GvIDAg44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1yZWZyZXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGVuIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggd2hlbiB0aGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGNoYW5nZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHlrZDopoHntKDjga7mlbDjgYzlpInjgo/jgovjgajjgqvjg6vjg7zjgrvjg6vjga/oh6rli5XnmoTjgavmm7TmlrDjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5jaGlsZHJlblswXSAmJiB0aGlzLmNoaWxkcmVuWzBdLnRhZ05hbWUgIT09ICdPTlMtQ0FST1VTRUwtSVRFTScgJiYgdGhpcy5jaGlsZHJlblswXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAoIXRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0YXJnZXQpO1xuICAgIH1cblxuICAgICF0aGlzLmNoaWxkcmVuWzFdICYmIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCA9IHRoaXMuYXBwZW5kQ2hpbGQuYmluZCh0YXJnZXQpO1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlID0gdGhpcy5pbnNlcnRCZWZvcmUuYmluZCh0YXJnZXQpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLl9zd2lwZXIpIHtcbiAgICAgIHRoaXMuX3N3aXBlciA9IG5ldyBTd2lwZXIoe1xuICAgICAgICBnZXRFbGVtZW50OiAoKSA9PiB0aGlzLFxuICAgICAgICBnZXRJbml0aWFsSW5kZXg6ICgpID0+IHRoaXMuZ2V0QXR0cmlidXRlKCdpbml0aWFsLWluZGV4JyksXG4gICAgICAgIGdldEF1dG9TY3JvbGxSYXRpbzogKCkgPT4gdGhpcy5hdXRvU2Nyb2xsUmF0aW8sXG4gICAgICAgIGlzVmVydGljYWw6ICgpID0+IHRoaXMudmVydGljYWwsXG4gICAgICAgIGlzT3ZlclNjcm9sbGFibGU6ICgpID0+IHRoaXMub3ZlcnNjcm9sbGFibGUsXG4gICAgICAgIGlzQ2VudGVyZWQ6ICgpID0+IHRoaXMuY2VudGVyZWQsXG4gICAgICAgIGlzQXV0b1Njcm9sbGFibGU6ICgpID0+IHRoaXMuYXV0b1Njcm9sbCxcbiAgICAgICAgaXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG4gICAgICAgIG92ZXJTY3JvbGxIb29rOiB0aGlzLl9vbk92ZXJTY3JvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgcHJlQ2hhbmdlSG9vazogdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzLCAncHJlY2hhbmdlJyksXG4gICAgICAgIHBvc3RDaGFuZ2VIb29rOiB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMsICdwb3N0Y2hhbmdlJyksXG4gICAgICAgIHJlZnJlc2hIb29rOiB0aGlzLl9vblJlZnJlc2guYmluZCh0aGlzKSxcbiAgICAgICAgc2Nyb2xsSG9vazogKC4uLmFyZ3MpID0+IHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSguLi5hcmdzKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9zd2lwZXIuaW5pdCh7XG4gICAgICAgIHN3aXBlYWJsZTogdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpLFxuICAgICAgICBhdXRvUmVmcmVzaDogdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N3aXBlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N3aXBlYWJsZScsICdhdXRvLXJlZnJlc2gnLCAnZGlyZWN0aW9uJywgJ2l0ZW0taGVpZ2h0JywgJ2l0ZW0td2lkdGgnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKCF0aGlzLl9zd2lwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgIHRoaXMuX3N3aXBlci51cGRhdGVTd2lwZWFibGUodGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdXRvLXJlZnJlc2gnOlxuICAgICAgICB0aGlzLl9zd2lwZXIudXBkYXRlQXV0b1JlZnJlc2godGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpdGVtLWhlaWdodCc6XG4gICAgICAgIHRoaXMudmVydGljYWwgJiYgdGhpcy5fc3dpcGVyLnVwZGF0ZUl0ZW1TaXplKHRoaXMuaXRlbVNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2l0ZW0td2lkdGgnOlxuICAgICAgICB0aGlzLnZlcnRpY2FsIHx8IHRoaXMuX3N3aXBlci51cGRhdGVJdGVtU2l6ZSh0aGlzLml0ZW1TaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICB0aGlzLl9zd2lwZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuX3N3aXBlci5zaG93KCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLl9zd2lwZXIuaGlkZSgpO1xuICB9XG5cbiAgX29uT3ZlclNjcm9sbCh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkge1xuICAgIGxldCB3YWl0Rm9yQWN0aW9uID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvdmVyc2Nyb2xsJywge1xuICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICBhY3RpdmVJbmRleDogdGhpcy5nZXRBY3RpdmVJbmRleCgpLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgd2FpdFRvUmV0dXJuOiBwcm9taXNlID0+IHtcbiAgICAgICAgd2FpdEZvckFjdGlvbiA9IHRydWU7XG4gICAgICAgIHByb21pc2UudGhlbihraWxsT3ZlclNjcm9sbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gd2FpdEZvckFjdGlvbjtcbiAgfVxuXG4gIF9vbkNoYW5nZShldmVudE5hbWUsIHsgYWN0aXZlSW5kZXgsIGxhc3RBY3RpdmVJbmRleCB9KSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGV2ZW50TmFtZSwgeyBjYXJvdXNlbDogdGhpcywgYWN0aXZlSW5kZXgsIGxhc3RBY3RpdmVJbmRleCB9KTtcbiAgfVxuXG4gIF9vblJlZnJlc2goKSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywgeyBjYXJvdXNlbDogdGhpcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB0aGF0IHRoZSBjYXJvdXNlbCBzaG91bGQgYmUgc2V0IHRvLlsvZW5dXG4gICAqICAgW2phXWNhcm91c2Vs6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIGA8b25zLWNhcm91c2VsLWl0ZW0+YCB0byBzaG93LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSaW5kZXjjgafmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSxcbiAgICAgIGFuaW1hdGlvbk9wdGlvbnM6IHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpXG4gICAgICAgID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgICAgIDogeyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguNCwgLjcsIC41LCAxKScgfSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544GM6L+U44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GV44KM44Gm44GE44KLb25zLWNhcm91c2VsLWl0ZW3opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5nZXRBY3RpdmVJbmRleCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpcnN0XG4gICAqIEBzaWduYXR1cmUgZmlyc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgaXMgc2V0IHRvIGBcIm5vbmVcImAsIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBmaXJzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgoMCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsYXN0XG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBsYXN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxhc3Qob3B0aW9ucykge1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgYDxvbnMtY2Fyb3VzZWwtaXRlbXM+YCBkeW5hbWljYWxseSBvciB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZS5bL2VuXVxuICAgKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4jjgoTlhoXpg6jjga7nirbmhYvjgpLmnIDmlrDjga7jgoLjga7jgavmm7TmlrDjgZfjgb7jgZnjgIJvbnMtY2Fyb3VzZWwtaXRlbeOCkuWLleeahOOBq+Wil+OChOOBl+OBn+OCiuOAgW9ucy1jYXJvdXNlbOOBruWkp+OBjeOBleOCkuWLleeahOOBq+WkieOBiOOCi+mam+OBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3N3aXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGl0ZW1Db3VudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBpdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5pdGVtQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIGNhcm91c2VsLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHV0aWwudGhyb3coYFwib25Td2lwZVwiIG11c3QgYmUgYSBmdW5jdGlvbmApXG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgYXV0byBzY3JvbGwgaXMgZW5hYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnYXV0by1zY3JvbGwnKTtcbiAgfVxuXG4gIHNldCBhdXRvU2Nyb2xsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdhdXRvLXNjcm9sbCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCB2ZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgZ2V0IGl0ZW1TaXplKCkge1xuICAgIGNvbnN0IGl0ZW1TaXplQXR0ciA9ICh0aGlzLmdldEF0dHJpYnV0ZShgaXRlbS0ke3RoaXMudmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCd9YCkgfHwgJycpLnRyaW0oKTtcbiAgICByZXR1cm4gaXRlbVNpemVBdHRyLm1hdGNoKC9eXFxkKyhweHwlKSQvKSA/IGl0ZW1TaXplQXR0ciA6ICcxMDAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFJhdGlvXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBhdXRvIHNjcm9sbCByYXRpby4gWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Kq44O844OI44K544Kv44Ot44O844Or44GucmF0aW/lgKTjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGF1dG9TY3JvbGxSYXRpbygpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnYXV0by1zY3JvbGwtcmF0aW8nKSk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbFJhdGlvKHJhdGlvKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJywgcmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG92ZXJzY3JvbGxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgb3ZlcnNjcm9sbGFibGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXW92ZXJzY3JvbGzjgafjgY3jgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvdmVyc2Nyb2xsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ292ZXJzY3JvbGxhYmxlJyk7XG4gIH1cblxuICBzZXQgb3ZlcnNjcm9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ292ZXJzY3JvbGxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjZW50ZXJlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGNlbnRlcmVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1jZW50ZXJlZOeKtuaFi+OBq+OBquOBo+OBpuOBhOOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGNlbnRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2VudGVyZWQnKTtcbiAgfVxuXG4gIHNldCBjZW50ZXJlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2VudGVyZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwb3N0Y2hhbmdlJywgJ3JlZnJlc2gnLCAnb3ZlcnNjcm9sbCddO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkNhcm91c2VsID0gQ2Fyb3VzZWxFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwnLCBDYXJvdXNlbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jb2xcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1yb3c+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ25tZW50LlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwgW2VuXUxheW91dGluZyBndWlkZVsvZW5dW2phXeODrOOCpOOCouOCpuODiOapn+iDvVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcm93XG4gKiAgIFtlbl1UaGUgYDxvbnMtcm93PmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgb2YgYDxvbnMtY29sPmAuWy9lbl1cbiAqICAgW2phXW9ucy1yb3fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiY2VudGVyXCIsIGFuZCBcImJvdHRvbVwiLlsvZW5dXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIGNzcyB3aWR0aCB2YWx1ZXMgKFwiMTAlXCIsIFwiNTBweFwiKS5bL2VuXVxuICogICBbamFd44Kr44Op44Og44Gu5qiq5bmF44KS5oyH5a6a44GZ44KL44CC44OR44O844K744Oz44OI44KC44GX44GP44Gv44OU44Kv44K744Or44Gn5oyH5a6a44GX44G+44GZ77yIMTAl44KENTBweO+8ieOAglsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyd3aWR0aCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgc3R5bGVyLmNsZWFyKHRoaXMsICdmbGV4IG1heFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gd2lkdGgudHJpbSgpLm1hdGNoKC9eXFxkKyQvKSA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG5cbiAgICAgIHN0eWxlcih0aGlzLCB7XG4gICAgICAgIGZsZXg6ICcwIDAgJyArIHdpZHRoLFxuICAgICAgICBtYXhXaWR0aDogd2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Db2wgPSBDb2xFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY29sJywgQ29sRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGNsYXNzIERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWREaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2UtaW4tb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNjAlLCAwKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKC01MCUsICR7dGhpcy5ib2R5SGVpZ2h0IC8gMi4wIC0gMX1weCwgMClgIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKC01MCUsICR7dGhpcy5ib2R5SGVpZ2h0IC8gMi4wIC0gMX1weCwgMClgIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGlkZURpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuXG4gICAgdGhpcy5ib2R5SGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7IC8vIGF2b2lkIEZvcmNlZCBTeW5jaHJvbm91cyBMYXlvdXRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyB9LFxuICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgRGlhbG9nQW5pbWF0b3IsIElPU0RpYWxvZ0FuaW1hdG9yLCBBbmRyb2lkRGlhbG9nQW5pbWF0b3IsIFNsaWRlRGlhbG9nQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5kaWFsb2cnOiAnZGlhbG9nLS0qJyxcbiAgJy5kaWFsb2ctY29udGFpbmVyJzogJ2RpYWxvZy1jb250YWluZXItLSonLFxuICAnLmRpYWxvZy1tYXNrJzogJ2RpYWxvZy1tYXNrLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yLFxuICAnc2xpZGUnOiBTbGlkZURpYWxvZ0FuaW1hdG9yLFxuICAnbm9uZSc6IERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiBjdXJyZW50IHNjcmVlbi4gQXMgb3Bwb3NlZCB0byB0aGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCwgdGhpcyBjb21wb25lbnQgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgY29udGVudC5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlRGlhbG9nKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8dGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBkaWFsb2cgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIG1lbnVzLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIHRvIGFzayB0aGUgdXNlciB0byBtYWtlIGEgZGVjaXNpb24uXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4genh4YUdhXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXWA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1tb2RhbFxuICogICBbZW5dYDxvbnMtbW9kYWw+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW1vZGFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWRpYWxvZyBpZD1cImRpYWxvZ1wiPlxuICogICA8cD5UaGlzIGlzIGEgZGlhbG9nITwvcD5cbiAqIDwvb25zLWRpYWxvZz5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWRpYWxvZz5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJkaWFsb2dcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2cnKTtcblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93QW5pbWF0b3IoJ0RpYWxvZycpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIERpYWxvZ0FuaW1hdG9yO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkRpYWxvZyA9IERpYWxvZ0VsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1kaWFsb2cnLCBEaWFsb2dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdmYWInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnZmFiLS0qJyxcbiAgJy5mYWJfX2ljb24nOiAnZmFiLS0qX19pY29uJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZmFiXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiBpcyBhIGNpcmN1bGFyIGJ1dHRvbiBkZWZpbmVkIGluIHRoZSBbTWF0ZXJpYWwgRGVzaWduIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9idXR0b25zLWZsb2F0aW5nLWFjdGlvbi1idXR0b24uaHRtbCkuIFRoZXkgYXJlIG9mdGVuIHVzZWQgdG8gcHJvbW90ZSB0aGUgcHJpbWFyeSBhY3Rpb24gb2YgdGhlIGFwcC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGRpc3BsYXllZCBlaXRoZXIgYXMgYW4gaW5saW5lIGVsZW1lbnQgb3IgaW4gb25lIG9mIHRoZSBjb3JuZXJzLiBOb3JtYWxseSBpdCB3aWxsIGJlIHBvc2l0aW9uZWQgaW4gdGhlIGxvd2VyIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9mYWJcbiAqIEBtb2RpZmllciBtaW5pXG4gKiAgIFtlbl1NYWtlcyB0aGUgYG9ucy1mYWJgIHNtYWxsZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudCBpcyBhIEZsb2F0aW5nIGFjdGlvbiBidXR0b24gdGhhdCBkaXNwbGF5cyBhIG1lbnUgd2hlbiB0YXBwZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgcG9zaXRpb24gb2YgdGhlIGJ1dHRvbi4gU2hvdWxkIGJlIGEgc3RyaW5nIGxpa2UgYFwiYm90dG9tIHJpZ2h0XCJgIG9yIGBcInRvcCBsZWZ0XCJgLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgZGVmaW5lZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgc3RhdGVtZW50cyBjYW4gYmUgZXhlY3V0ZWQgYmVmb3JlIGNvbnRlbnRSZWFkeVxuICAgIC8vIHNpbmNlIHRoZXNlIGRvIG5vdCBhY2Nlc3MgdGhlIGNoaWxkcmVuXG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmZhYl9faWNvbicpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmYWJfX2ljb24nKTtcblxuICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1yaXBwbGUnKSB7XG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnNob3coKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnLCAncG9zaXRpb24nLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuaGlkZSgpKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZmFiLS10b3BfX2xlZnQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxuICAgICAgJ2ZhYi0tdG9wX19yaWdodCcsXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgZmxvYXRpbmcgYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMudG9nZ2xlKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1IaWRlIHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy50b2dnbGUoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUoYWN0aW9uID0gIXRoaXMudmlzaWJsZSkge1xuICAgIGNvbnN0IGlzQm90dG9tID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpIHx8ICcnKS5pbmRleE9mKCdib3R0b20nKSA+PSAwO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGlzQm90dG9tID8gYHRyYW5zbGF0ZTNkKDBweCwgLSR7dXRpbC5nbG9iYWxzLmZhYk9mZnNldCB8fCAwfXB4LCAwcHgpYCA6ICcnO1xuXG4gICAgc3R5bGVyKHRoaXMsIHsgdHJhbnNmb3JtOiBgJHt0cmFuc2xhdGV9IHNjYWxlKCR7TnVtYmVyKGFjdGlvbil9KWAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlLnRyYW5zZm9ybS5pbmRleE9mKCdzY2FsZSgwKScpID09PSAtMSAmJiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5GYWIgPSBGYWJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZmFiJywgRmFiRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1nZXN0dXJlLWRldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdG8gZGV0ZWN0IGZpbmdlciBnZXN0dXJlcyB3aXRoaW4gdGhlIHdyYXBwZWQgZWxlbWVudC4gRm9sbG93aW5nIGdlc3R1cmVzIGFyZSBzdXBwb3J0ZWQ6XG4gKiAgICAgLSBEcmFnIGdlc3R1cmVzOiBgZHJhZ2AsIGBkcmFnbGVmdGAsIGBkcmFncmlnaHRgLCBgZHJhZ3VwYCwgYGRyYWdkb3duYFxuICogICAgIC0gSG9sZCBnZXN0dXJlczogYGhvbGRgLCBgcmVsZWFzZWBcbiAqICAgICAtIFN3aXBlIGdlc3R1cmVzOiBgc3dpcGVgLCBgc3dpcGVsZWZ0YCwgYHN3aXBlcmlnaHRgLCBgc3dpcGV1cGAsIGBzd2lwZWRvd25gXG4gKiAgICAgLSBUYXAgZ2VzdHVyZXM6IGB0YXBgLCBgZG91YmxldGFwYFxuICogICAgIC0gUGluY2ggZ2VzdHVyZXM6IGBwaW5jaGAsIGBwaW5jaGluYCwgYHBpbmNob3V0YFxuICogICAgIC0gT3RoZXIgZ2VzdHVyZXM6IGB0b3VjaGAsIGB0cmFuc2Zvcm1gLCBgcm90YXRlYFxuICogICBbL2VuXVxuICogICBbamFd6KaB57Sg5YaF44Gu44K444Kn44K544OB44Oj44O85pON5L2c44KS5qSc55+l44GX44G+44GZ44CC6Kmz44GX44GP44Gv44Ks44Kk44OJ44KS5Y+C54Wn44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAqIEBndWlkZSBmZWF0dXJlcy5odG1sI2dlc3R1cmUtZGV0ZWN0aW9uXG4gKiAgIFtlbl1EZXRlY3RpbmcgZmluZ2VyIGdlc3R1cmVzWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOBruaknOefpVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1nZXN0dXJlLWRldGVjdG9yPlxuICogICA8ZGl2IGlkPVwiZGV0ZWN0LWFyZWFcIiBzdHlsZT1cIndpZHRoOiAxMDBweDsgaGVpZ2h0OiAxMDBweDtcIj5cbiAqICAgICBTd2lwZSBIZXJlXG4gKiAgIDwvZGl2PlxuICogPC9vbnMtZ2VzdHVyZS1kZXRlY3Rvcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzd2lwZWxlZnQnLCBmdW5jdGlvbihldmVudCkge1xuICogICAgIGlmIChldmVudC50YXJnZXQubWF0Y2hlcygnI2RldGVjdC1hcmVhJykpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdTd2lwZSBsZWZ0IGlzIGRldGVjdGVkLicpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VzdHVyZURldGVjdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkdlc3R1cmVEZXRlY3RvciA9IEdlc3R1cmVEZXRlY3RvckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1nZXN0dXJlLWRldGVjdG9yJywgR2VzdHVyZURldGVjdG9yRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmxldCBhdXRvUHJlZml4ID0gJ2ZhJzsgLy8gRklYTUU6IFRvIGJlIHJlbW92ZWQgaW4gdjNcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWNvblxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5cyBhbiBpY29uLiBUaGUgZm9sbG93aW5nIGljb24gc3VpdGVzIGFyZSBhdmFpbGFibGU6XG4gKlxuICogICAgICogW0ZvbnQgQXdlc29tZV0oaHR0cHM6Ly9mb3J0YXdlc29tZS5naXRodWIuaW8vRm9udC1Bd2Vzb21lLylcbiAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbS8pXG4gKiAgICAgKiBbTWF0ZXJpYWwgRGVzaWduIEljb25pYyBGb250XShodHRwOi8vemF2b2xva2xvbS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25pYy1mb250LylcbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4QWh2Z1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ljb25cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgYXBwc2l6ZS5odG1sI3JlbW92aW5nLWljb24tcGFja3MgW2VuXVJlbW92aW5nIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBndWlkZSBmYXEuaHRtbCNob3ctY2FuLWktdXNlLWN1c3RvbS1pY29uLXBhY2tzIFtlbl1BZGRpbmcgY3VzdG9tIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWljb25cbiAqICAgaWNvbj1cIm1kLWNhclwiXG4gKiAgIHNpemU9XCIyMHB4XCJcbiAqICAgc3R5bGU9XCJjb2xvcjogcmVkXCI+XG4gKiA8L29ucy1pY29uPlxuICpcbiAqIDxvbnMtYnV0dG9uPlxuICogICA8b25zLWljb24gaWNvbj1cIm1kLWNhclwiPjwvb25zLWljb24+XG4gKiAgIENhclxuICogPC9vbnMtYnV0dG9uPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBpY29uIG5hbWUuIGBcIm1kLVwiYCBwcmVmaXggZm9yIE1hdGVyaWFsIEljb25zLCBgXCJmYS1cImAgZm9yIEZvbnQgQXdlc29tZSBhbmQgYFwiaW9uLVwiYCBwcmVmaXggZm9yIElvbmljb25zLlxuICAgKlxuICAgKiAgICAgU2VlIGFsbCBhdmFpbGFibGUgaWNvbnMgb24gdGhlIGVsZW1lbnQgZGVzY3JpcHRpb24gKGF0IHRoZSB0b3ApLlxuICAgKlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZSBgPG9ucy1pY29uIGljb249XCJpb24tZWRpdCwgbWF0ZXJpYWw6bWQtZWRpdFwiPjwvb25zLWljb24+YCB3aWxsIGRpc3BsYXkgYFwibWQtZWRpdFwiYCBmb3IgTWF0ZXJpYWwgRGVzaWduIGFuZCBgXCJpb24tZWRpdFwiYCBhcyB0aGUgZGVmYXVsdCBpY29uLlxuICAgKlxuICAgKiAgICAgYGZhLWAgcHJlZml4IGlzIGFkZGVkIGF1dG9tYXRpY2FsbHkgaWYgbm9uZSBpcyBwcm92aWRlZC4gQ2hlY2sgW1NlZSBhbHNvXSgjc2VlYWxzbykgc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBzaXplcyBvZiB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSBsZywgMngsIDN4LCA0eCwgNXgsIG9yIGluIHRoZSBzaXplIGluIHBpeGVscy5cbiAgICogICAgIEljb25zIGNhbiBhbHNvIGJlIHN0eWxlZCBiYXNlZCBvbiBtb2RpZmllciBwcmVzZW5jZS4gQWRkIGNvbW1hLXNlcGFyYXRlZCBpY29ucyB3aXRoIGBcIm1vZGlmaWVyTmFtZTpcImAgcHJlZml4LlxuICAgKlxuICAgKiAgICAgVGhlIGNvZGU6XG4gICAqXG4gICAqICAgICBgYGBcbiAgICogICAgIDxvbnMtaWNvblxuICAgKiAgICAgICBpY29uPVwiaW9uLWVkaXRcIlxuICAgKiAgICAgICBzaXplPVwiMzJweCwgbWF0ZXJpYWw6MjRweFwiPlxuICAgKiAgICAgPC9vbnMtaWNvbj5cbiAgICogICAgIGBgYFxuICAgKlxuICAgKiAgICAgd2lsbCByZW5kZXIgYXMgYSBgMjRweGAgaWNvbiBpZiB0aGUgYFwibWF0ZXJpYWxcImAgbW9kaWZpZXIgaXMgcHJlc2VudCBhbmQgYDMycHhgIG90aGVyd2lzZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByb3RhdGVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU51bWJlciBvZiBkZWdyZWVzIHRvIHJvdGF0ZSB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSA5MCwgMTgwIGFuZCAyNzAuWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz44KS5Zue6Lui44GX44Gm6KGo56S644GX44G+44GZ44CCOTAsIDE4MCwgMjcw44GL44KJ5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtd2lkdGhcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVdoZW4gdXNlZCBpbiBhIGxpc3QsIHlvdSB3YW50IHRoZSBpY29ucyB0byBoYXZlIHRoZSBzYW1lIHdpZHRoIHNvIHRoYXQgdGhleSBhbGlnbiB2ZXJ0aWNhbGx5IGJ5IGRlZmluaW5nIHRoaXMgYXR0cmlidXRlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3BpblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB3aGV0aGVyIHRoZSBpY29uIHNob3VsZCBiZSBzcGlubmluZy5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaWNvbicsICdzaXplJywgJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUobmFtZSA9PT0gJ2ljb24nID8gbGFzdCA6IHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJyksIG5hbWUgPT09ICdtb2RpZmllcicgPyBsYXN0IDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLl9idWlsZENsYXNzQW5kU3R5bGUodGhpcy5fcGFyc2VBdHRyKCdpY29uJyksIHRoaXMuX3BhcnNlQXR0cignc2l6ZScpKTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLnN0eWxlLCBzdHlsZSk7XG5cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX3BhcnNlQXR0cihhdHRyTmFtZSwgbW9kaWZpZXIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJykge1xuICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgfHwgYXR0ck5hbWUgfHwgJydcbiAgICBjb25zdCBwYXJ0cyA9IGF0dHIuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIGNvbnN0IGRlZiA9IHBhcnRzWzBdO1xuICAgIGxldCBtZCA9IHBhcnRzWzFdO1xuICAgIG1kID0gKG1kIHx8ICcnKS5zcGxpdCgvXFxzKjpcXHMqLyk7XG5cbiAgICByZXR1cm4gKG1vZGlmaWVyICYmIChSZWdFeHAoYChefFxcXFxzKykke21kWzBdfSgkfFxcXFxzKylgLCAnaScpLnRlc3QobW9kaWZpZXIpKSA/IG1kWzFdIDogZGVmKSB8fCAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdW5uZWVkZWQgY2xhc3MgdmFsdWUuXG4gICAqL1xuICBfY2xlYW5DbGFzc0F0dHJpYnV0ZShsYXN0SWNvbiwgbGFzdE1vZGlmaWVyKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIHByZWZpeCB9ID0gdGhpcy5fcHJlZml4SWNvbih0aGlzLl9wYXJzZUF0dHIobGFzdEljb24sIGxhc3RNb2RpZmllcikpO1xuICAgIGNvbnN0IGN1c3RvbVByZWZpeFJFID0gY2xhc3NOYW1lICE9PSBwcmVmaXggPyBgfCR7cHJlZml4fSR8JHtwcmVmaXh9LWAgOiBgfCR7Y2xhc3NOYW1lfSRgIHx8ICcnO1xuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgXihmYSR8ZmEtfGlvbi18em1kaSR8em1kaS18b25zLWljb24tLSR7Y3VzdG9tUHJlZml4UkV9KWApO1xuXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiByZS50ZXN0KGNsYXNzTmFtZSkpXG4gICAgICAuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX3ByZWZpeEljb24oaWNvbk5hbWUpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBhdXRvUHJlZml4ICsgKGF1dG9QcmVmaXggPyAnLScgOiAnJykgKyBpY29uTmFtZTtcbiAgICByZXR1cm4geyBjbGFzc05hbWUsIHByZWZpeDogY2xhc3NOYW1lLnNwbGl0KCctJylbMF0gfTtcbiAgfVxuXG4gIF9idWlsZENsYXNzQW5kU3R5bGUoaWNvbk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBjbGFzc0xpc3QgPSBbJ29ucy1pY29uJ107XG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcblxuICAgIC8vIEljb25cbiAgICBpZiAoaWNvbk5hbWUuaW5kZXhPZignaW9uLScpID09PSAwKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnb25zLWljb24tLWlvbicpO1xuICAgIH0gZWxzZSBpZiAoaWNvbk5hbWUuaW5kZXhPZignZmEtJykgPT09IDApIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKGljb25OYW1lKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYScpO1xuICAgIH0gZWxzZSBpZiAoaWNvbk5hbWUuaW5kZXhPZignbWQtJykgPT09IDApICB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaScpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGktJyArIGljb25OYW1lLnNwbGl0KC8tKC4rKT8vKVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBwcmVmaXggfSA9IHRoaXMuX3ByZWZpeEljb24oaWNvbk5hbWUpO1xuICAgICAgcHJlZml4ICYmIGNsYXNzTGlzdC5wdXNoKHByZWZpeCk7XG4gICAgICBjbGFzc05hbWUgJiYgY2xhc3NMaXN0LnB1c2goY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBTaXplXG4gICAgaWYgKHNpemUubWF0Y2goL15bMS01XXh8bGckLykpIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdvbnMtaWNvbi0tJyArIHNpemUpO1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZm9udC1zaXplJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmZvbnRTaXplID0gc2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NMaXN0OiBjbGFzc0xpc3QsXG4gICAgICBzdHlsZTogc3R5bGVcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHNldEF1dG9QcmVmaXgocHJlZml4KSB7XG4gICAgYXV0b1ByZWZpeCA9IHByZWZpeCA/ICh0eXBlb2YgcHJlZml4ID09PSAnc3RyaW5nJyAmJiBwcmVmaXggfHwgJ2ZhJykgOiAnJztcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5JY29uID0gSWNvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1pY29uJywgSWNvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdERlbGVnYXRlIHtcblxuICBjb25zdHJ1Y3Rvcih1c2VyRGVsZWdhdGUsIHRlbXBsYXRlRWxlbWVudCA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWxlZ2F0ZSAhPT0gJ29iamVjdCcgfHwgdXNlckRlbGVnYXRlID09PSBudWxsKSB7XG4gICAgICB1dGlsLnRocm93KCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHVzZXJEZWxlZ2F0ZTtcblxuICAgIGlmICghKHRlbXBsYXRlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpICYmIHRlbXBsYXRlRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgdXRpbC50aHJvdygnXCJ0ZW1wbGF0ZUVsZW1lbnRcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50IG9yIG51bGwnKTtcbiAgICB9XG4gICAgdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gdGVtcGxhdGVFbGVtZW50O1xuICB9XG5cbiAgZ2V0IGl0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5pdGVtSGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNSZW5kZXJGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX3JlbmRlcigpIHtcbiAgICB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlci5hcHBseSh0aGlzLl91c2VyRGVsZWdhdGUsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQSBmdW5jdGlvbiB0aGF0IHRha2UgaXRlbSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgKi9cbiAgbG9hZEl0ZW1FbGVtZW50KGluZGV4LCBkb25lKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnQoaW5kZXgsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCk7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdXRpbC50aHJvdygnXCJjcmVhdGVJdGVtQ29udGVudFwiIG11c3QgcmV0dXJuIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZG9uZSh7ZWxlbWVudH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb3VudEl0ZW1zKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgICBpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgdXRpbC50aHJvdygnXCJjb3VudEl0ZW1zXCIgbXVzdCByZXR1cm4gYSBudW1iZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW0uZWxlbWVudFxuICAgKi9cbiAgdXBkYXRlSXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB1dGlsLnRocm93KCdcImNhbGN1bGF0ZUl0ZW1IZWlnaHRcIiBtdXN0IHJldHVybiBhIG51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKi9cbiAgZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGUgY29yZSBmdW5jdGlvbnMgZm9yIG9ucy1sYXp5LXJlcGVhdC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhenlSZXBlYXRQcm92aWRlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gd3JhcHBlckVsZW1lbnRcbiAgICogQHBhcmFtIHtMYXp5UmVwZWF0RGVsZWdhdGV9IGRlbGVnYXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3cmFwcGVyRWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICBpZiAoIShkZWxlZ2F0ZSBpbnN0YW5jZW9mIExhenlSZXBlYXREZWxlZ2F0ZSkpIHtcbiAgICAgIHV0aWwudGhyb3coJ1wiZGVsZWdhdGVcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBMYXp5UmVwZWF0RGVsZWdhdGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IHdyYXBwZXJFbGVtZW50O1xuICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5faW5zZXJ0SW5kZXggPSAodGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bMF0gJiYgdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bMF0udGFnTmFtZSA9PT0gJ09OUy1MQVpZLVJFUEVBVCcpID8gMSA6IDA7XG5cbiAgICBpZiAod3JhcHBlckVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWxpc3QnKSB7XG4gICAgICB3cmFwcGVyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYXp5LWxpc3QnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudCA9IHRoaXMuX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQod3JhcHBlckVsZW1lbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9wYWdlQ29udGVudCkge1xuICAgICAgdXRpbC50aHJvdygnTGF6eVJlcGVhdCBtdXN0IGJlIGRlc2NlbmRhbnQgb2YgYSBQYWdlIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB0aGlzLl9wYWdlQ29udGVudC5zY3JvbGxUb3A7XG4gICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICB0aGlzLl90b3BQb3NpdGlvbnMgPSBbMF07XG4gICAgdGhpcy5fcmVuZGVyZWRJdGVtcyA9IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0ICYmICF0aGlzLl9kZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KDApKSB7XG4gICAgICB0aGlzLl91bmtub3duSXRlbUhlaWdodCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICB9XG5cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnBhZGRpbmdUb3AsIDEwKTtcbiAgfVxuXG4gIHNldCBwYWRkaW5nKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IG5ld1ZhbHVlICsgJ3B4JztcbiAgfVxuXG4gIF9maW5kUGFnZUNvbnRlbnRFbGVtZW50KHdyYXBwZXJFbGVtZW50KSB7XG4gICAgY29uc3QgcGFnZUNvbnRlbnQgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICcucGFnZV9fY29udGVudCcpO1xuXG4gICAgaWYgKHBhZ2VDb250ZW50KSB7XG4gICAgICByZXR1cm4gcGFnZUNvbnRlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh3cmFwcGVyRWxlbWVudCwgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLmZpbmRDaGlsZChwYWdlLCAnLmNvbnRlbnQnKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2NoZWNrSXRlbUhlaWdodChjYWxsYmFjaykge1xuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudCgwLCBpdGVtID0+IHtcbiAgICAgIGlmICghdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQpIHtcbiAgICAgICAgdXRpbC50aHJvdygnSW52YWxpZCBzdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZChpdGVtLmVsZW1lbnQpO1xuXG4gICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95SXRlbSgwLCBpdGVtKTtcbiAgICAgICAgaXRlbS5lbGVtZW50ICYmIGl0ZW0uZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0O1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID4gMCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0cnkgdG8gbWVhc3VyZSBvZmZzZXQgaGVpZ2h0XG4gICAgICAvLyBkaXJ0eSBmaXggZm9yIGFuZ3VsYXIyIGRpcmVjdGl2ZVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgaXRlbS5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5faXRlbUhlaWdodCA9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtSGVpZ2h0ID09IDApIHtcbiAgICAgICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHN0YXRlOiBcIml0ZW1IZWlnaHRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBzdGF0aWNJdGVtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0IHx8IHRoaXMuX2l0ZW1IZWlnaHQ7XG4gIH1cbiAgX2NvdW50SXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgfVxuXG4gIF9nZXRJdGVtSGVpZ2h0KGkpIHtcbiAgICAvLyBJdGVtIGlzIHJlbmRlcmVkXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkSXRlbXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmICghdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oZWlnaHQgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2ldLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkSXRlbXNbaV0uaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIEl0ZW0gaXMgbm90IHJlbmRlcmVkLCBzY3JvbGwgdXBcbiAgICBpZiAodGhpcy5fdG9wUG9zaXRpb25zW2kgKyAxXSAmJiB0aGlzLl90b3BQb3NpdGlvbnNbaV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3BQb3NpdGlvbnNbaSArIDFdIC0gdGhpcy5fdG9wUG9zaXRpb25zW2ldO1xuICAgIH1cbiAgICAvLyBJdGVtIGlzIG5vdCByZW5kZXJlZCwgc2Nyb2xsIGRvd25cbiAgICByZXR1cm4gdGhpcy5zdGF0aWNJdGVtSGVpZ2h0IHx8IHRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoaSk7XG4gIH1cblxuICBfY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLnJlZHVjZSgoYSwgYikgPT4gYSArIHRoaXMuX2dldEl0ZW1IZWlnaHQoKyhiKSksIDApXG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cblxuICBfbGFzdEl0ZW1SZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykpO1xuICB9XG5cbiAgX2ZpcnN0SXRlbVJlbmRlcmVkKCkge1xuICAgIHJldHVybiBNYXRoLm1pbiguLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0geyBmb3JjZVNjcm9sbERvd246IHRydWUgfTtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMuX2ZpcnN0SXRlbVJlbmRlcmVkKCk7XG5cbiAgICBpZiAodXRpbC5pc0ludGVnZXIoZmlyc3RJdGVtSW5kZXgpKSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLl90b3BQb3NpdGlvbnNbZmlyc3RJdGVtSW5kZXhdICsgdGhpcy5fY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQoKSArICdweCc7XG4gICAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLl90b3BQb3NpdGlvbnNbZmlyc3RJdGVtSW5kZXhdO1xuICAgICAgZm9yY2VSZW5kZXIuZm9yY2VGaXJzdEluZGV4ID0gZmlyc3RJdGVtSW5kZXg7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9yZW5kZXIoZm9yY2VSZW5kZXIpO1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9ICdpbmhlcml0JztcbiAgfVxuXG4gIF9yZW5kZXIoe2ZvcmNlU2Nyb2xsRG93biA9IGZhbHNlLCBmb3JjZUZpcnN0SW5kZXgsIGZvcmNlTGFzdEluZGV4fSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hlY2tJdGVtSGVpZ2h0KHRoaXMuX3JlbmRlci5iaW5kKHRoaXMsIGFyZ3VtZW50c1swXSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzU2Nyb2xsVXAgPSAhZm9yY2VTY3JvbGxEb3duICYmIHRoaXMubGFzdFNjcm9sbFRvcCA+IHRoaXMuX3BhZ2VDb250ZW50LnNjcm9sbFRvcDtcbiAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSB0aGlzLl9wYWdlQ29udGVudC5zY3JvbGxUb3A7XG4gICAgY29uc3Qga2VlcCA9IHt9O1xuXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIGNvbnN0IGxpbWl0ID0gNCAqIHdpbmRvdy5pbm5lckhlaWdodCAtIG9mZnNldDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2NvdW50SXRlbXMoKTtcblxuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSBmb3JjZUZpcnN0SW5kZXggfHwgTWF0aC5tYXgoMCwgdGhpcy5fY2FsY3VsYXRlU3RhcnRJbmRleChvZmZzZXQpIC0gMzApOyAvLyBSZWNhbGN1bGF0ZSBmb3IgMCBvciB1bmRlZmluZWRcbiAgICBsZXQgaSA9IHN0YXJ0O1xuXG4gICAgZm9yIChsZXQgdG9wID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldOyBpIDwgY291bnQgJiYgdG9wIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGkgPj0gdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCkgeyAvLyBwZXJmIG9wdGltaXphdGlvblxuICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoICs9IDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdG9wO1xuICAgICAgdG9wICs9IHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uICYmIHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5fcmVuZGVyKHN0YXJ0LCBpLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tzdGFydF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSAxOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAga2VlcFtqXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaiwgaXNTY3JvbGxVcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcmNlTGFzdEluZGV4IHx8IE1hdGgubWF4KGkgLSAxLCAuLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7IC8vIFJlY2FsY3VsYXRlIGZvciAwIG9yIHVuZGVmaW5lZFxuICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0OyBqIDw9IGxhc3RJbmRleDsgaisrKSB7XG4gICAgICAgIGtlZXBbal0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJFbGVtZW50KGosIGlzU2Nyb2xsVXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IGtlZXBba2V5XSB8fCB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSwgaXNTY3JvbGxVcCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2Nyb2xsVXBcbiAgICovXG4gIF9yZW5kZXJFbGVtZW50KGluZGV4LCBpc1Njcm9sbFVwKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS51cGRhdGVJdGVtKGluZGV4LCBpdGVtKTsgLy8gdXBkYXRlIGlmIGl0IGV4aXN0c1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgaXRlbSA9PiB7XG4gICAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5pbnNlcnRCZWZvcmUoaXRlbS5lbGVtZW50LCB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblt0aGlzLl9pbnNlcnRJbmRleF0pXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgIGl0ZW0uaGVpZ2h0ID0gdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4ICsgMV0gLSB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2Nyb2xsVXBcbiAgICovXG4gIF9yZW1vdmVFbGVtZW50KGluZGV4LCBpc1Njcm9sbFVwID0gdHJ1ZSkge1xuICAgIGluZGV4ID0gKyhpbmRleCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcblxuICAgIGlmIChpc1Njcm9sbFVwKSB7XG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXggKyAxXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWRkaW5nID0gdGhpcy5wYWRkaW5nICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpdGVtLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgfVxuXG4gIF9yZW1vdmVBbGxFbGVtZW50cygpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuICB9XG5cbiAgX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpICsgMV0gPSB0aGlzLl90b3BQb3NpdGlvbnNbaV0gKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVTdGFydEluZGV4KGN1cnJlbnQpIHtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMuX2ZpcnN0SXRlbVJlbmRlcmVkKCk7XG4gICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2xhc3RJdGVtUmVuZGVyZWQoKTtcblxuICAgIC8vIEZpeCBmb3IgU2FmYXJpIHNjcm9sbCBhbmQgQW5ndWxhciAyXG4gICAgdGhpcy5fcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpO1xuXG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gdGhpcy5fY291bnRJdGVtcygpIC0gMTtcblxuICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIGluZGV4IGF0IHRvcCBvZiBzY3JlZW4gc28gd2UgY2FuIHNwZWVkIHVwIHJlbmRlcmluZy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudCArIHRoaXMuX3RvcFBvc2l0aW9uc1ttaWRkbGVdO1xuXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IDAgJiYgdmFsdWUgKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KG1pZGRsZSkgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX2RvdWJsZUZpcmVPblRvdWNoZW5kKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIHRoaXMuX2RlYm91bmNlKHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpLCAxMDApO1xuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHV0aWwuYmluZExpc3RlbmVycyh0aGlzLCBbJ19vbkNoYW5nZScsICdfZG91YmxlRmlyZU9uVG91Y2hlbmQnXSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX2RlYm91bmNlKHRoaXMuX2JvdW5kT25DaGFuZ2UsIDMwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fcGFnZUNvbnRlbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fcGFnZUNvbnRlbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcGFyZW50RWxlbWVudCA9IHRoaXMuX2RlbGVnYXRlID0gdGhpcy5fcmVuZGVyZWRJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7IExhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyIH0gZnJvbSAnLi4vb25zL2ludGVybmFsL2xhenktcmVwZWF0JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGF6eS1yZXBlYXRcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFVzaW5nIHRoaXMgY29tcG9uZW50IGEgbGlzdCB3aXRoIG1pbGxpb25zIG9mIGl0ZW1zIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IGEgZHJvcCBpbiBwZXJmb3JtYW5jZS5cbiAqICAgICBJdCBkb2VzIHRoYXQgYnkgXCJsYXppbHlcIiBsb2FkaW5nIGVsZW1lbnRzIGludG8gdGhlIERPTSB3aGVuIHRoZXkgY29tZSBpbnRvIHZpZXcgYW5kXG4gKiAgICAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgRE9NIHdoZW4gdGhleSBhcmUgbm90IHZpc2libGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXjgafmj4/nlLvjgZXjgozjgovjgqLjgqTjg4bjg6Djga5ET03opoHntKDjga7oqq3jgb/ovrzjgb/jga/jgIHnlLvpnaLjgavopovjgYjjgZ3jgYbjgavjgarjgaPjgZ/mmYLjgb7jgafoh6rli5XnmoTjgavpgYXlu7bjgZXjgozjgIFcbiAqICAgICDnlLvpnaLjgYvjgonopovjgYjjgarjgY/jgarjgaPjgZ/loLTlkIjjgavjga/jgZ3jga7opoHntKDjga/li5XnmoTjgavjgqLjg7Pjg63jg7zjg4njgZXjgozjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/jgYbjgZPjgajjgafjgIHjg5Hjg5Xjgqnjg7zjg57jg7PjgrnjgpLliqPljJbjgZXjgZvjgovjgZPjgajnhKHjgZfjgavlt6jlpKfjgarmlbDjga7opoHntKDjgpLmj4/nlLvjgafjgY3jgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIFF3ckdCbVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xhenktcmVwZWF0XG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgbGlzdC5bL2VuXVxuICogICBbamFdYDxvbnMtbGlzdD5g6KaB57Sg44Gv44Oq44K544OI44KS5o+P55S744GZ44KL44Gu44Gr5L2/44KP44KM44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYSBhbmQgYWxzbyBub3QgZG9jdW1lbnRlZFxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGVsZWdhdGUnKSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGEgZGVsZWdhdGUgb2JqZWN0IHRvIGxvYWQgYW5kIHVubG9hZCBpdGVtIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqICAgICBUbyBoZWxwIHJlbmRlcmluZyB0aGUgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXggYW5kIGEgdGVtcGxhdGUgaXMgc3VwcGxpZWQgYXMgYXJndW1lbnRzLiBUaGUgdGVtcGxhdGUgaXMgdGhlIGluaXRpYWwgY29udGVudCBvZiB0aGUgYDxvbnMtbGF6eS1yZXBlYXQ+YCBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44GvYEhUTUxFbGVtZW50YOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglxuICAgKiAgICAg6KaB57Sg44KS55Sf5oiQ44GX44KE44GZ44GP44GZ44KL44Gf44KB44Gr44CB54++5Zyo44Gu44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K544Go44OG44Oz44OX44Os44O844OI44GM5byV5pWw44Gr5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jb3VudEl0ZW1zXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTaG91bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgYW4gaXRlbS4gVGhlIGluZGV4IGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiByZW5kZXJpbmcgbGlzdHMgd2hlcmUgdGhlIGl0ZW1zIGhhdmUgZGlmZmVyZW50IGhlaWdodC5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44Gd44KM44Ge44KM44Gu44Ki44Kk44Og44GM6YGV44Gj44Gf6auY44GV44KS5oyB44Gk44Oq44K544OI44KS44Os44Oz44OA44Oq44Oz44Kw44GZ44KL6Zqb44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgILjgoLjgZfjgZPjga7plqLmlbDjgYznhKHjgYTloLTlkIjjgavjga/jgIFcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuZGVzdHJveUl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYnV0IG1heSBiZSBpbXBvcnRhbnQgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44GC44KL44Ki44Kk44OG44Og44GMRE9N44OE44Oq44O844GL44KJ6Zmk44GL44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44G+44GZ44CCXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOBjOOAgeWQhOOCouOCpOODhuODoOOBruW+jOWHpueQhuOBjOW/heimgeOBquWgtOWQiOOBq+OBr+ODoeODouODquODvOODquODvOOCr+OCkumBv+OBkeOCi+OBn+OCgeOBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIHNldCBkZWxlZ2F0ZSh1c2VyRGVsZWdhdGUpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVFbGVtZW50ICYmIHRoaXMuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG5ldyBMYXp5UmVwZWF0UHJvdmlkZXIodGhpcy5wYXJlbnRFbGVtZW50LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgdXRpbC50aHJvdygnTm8gZGVsZWdhdGUgZ2V0dGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjgpLmm7TmlrDjgZfjgb7jgZnjgILjgoLjgZfjg4fjg7zjgr/jgYzlpInjgo/jgaPjgZ/loLTlkIjjgavjga/jgZPjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgaPjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcblxub25zRWxlbWVudHMuTGF6eVJlcGVhdCA9IExhenlSZXBlYXRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGF6eS1yZXBlYXQnLCBMYXp5UmVwZWF0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LWhlYWRlcic7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LWhlYWRlci0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWhlYWRlclxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSGVhZGVyIGVsZW1lbnQgZm9yIGxpc3QgaXRlbXMuIE11c3QgYmUgcHV0IGluc2lkZSB0aGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFd44Oq44K544OI6KaB57Sg44Gr5L2/55So44GZ44KL44OY44OD44OA44O855So44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3TjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0LWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGhlYWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RIZWFkZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBoZWFkZXIuWy9lbl1cbiAgICogICBbamFd44OY44OD44OA44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdEhlYWRlciA9IExpc3RIZWFkZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC1oZWFkZXInLCBMaXN0SGVhZGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LXRpdGxlJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtdGl0bGUtLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC10aXRsZVxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIGxpc3QgdGl0bGUuWy9lbl1cbiAqICAgW2phXeODquOCueODiOOBruOCv+OCpOODiOODq+OCkuihqOePvuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0LXRpdGxlPkxpc3QgVGl0bGU8L29ucy1saXN0LXRpdGxlPlxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IHRpdGxlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RUaXRsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdFRpdGxlID0gTGlzdFRpdGxlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtdGl0bGUnLCBMaXN0VGl0bGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE4IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGNsYXNzIExpc3RJdGVtQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgc2hvd0V4cGFuc2lvbihsaXN0SXRlbSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaGlkZUV4cGFuc2lvbihsaXN0SXRlbSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTbGlkZUxpc3RJdGVtQW5pbWF0b3IgZXh0ZW5kcyBMaXN0SXRlbUFuaW1hdG9yIHtcblxuICBzaG93RXhwYW5zaW9uKGxpc3RJdGVtLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVFeHBhbnNpb24obGlzdEl0ZW0sIHRydWUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGhpZGVFeHBhbnNpb24obGlzdEl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUV4cGFuc2lvbihsaXN0SXRlbSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9hbmltYXRlRXhwYW5zaW9uKGxpc3RJdGVtLCBzaG91bGRPcGVuLCBjYWxsYmFjaykge1xuICAgIC8vIFRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgdGhlIGV4cGFuc2lvbiBwYW5lbCBjb3JyZWN0bHksIHdlIG5lZWQgdG8ga25vdyBpdHNcbiAgICAvLyBoZWlnaHQuIFRvIGNhbGN1bGF0ZSB0aGlzLCB3ZSBzZXQgaXRzIGhlaWdodCB0byBhdXRvLCBhbmQgdGhlbiBnZXQgdGhlIGNvbXB1dGVkXG4gICAgLy8gaGVpZ2h0IGFuZCBwYWRkaW5nLiBPbmNlIHRoaXMgaXMgZG9uZSwgd2Ugc2V0IHRoZSBoZWlnaHQgYmFjayB0byBpdHMgb3JpZ2luYWwgdmFsdWUuXG4gICAgY29uc3Qgb2xkSGVpZ2h0ID0gbGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQuc3R5bGUuaGVpZ2h0O1xuICAgIGNvbnN0IG9sZERpc3BsYXkgPSBsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudC5zdHlsZS5kaXNwbGF5O1xuICAgIGxpc3RJdGVtLmV4cGFuZGFibGVDb250ZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICBsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQpO1xuXG4gICAgY29uc3QgZXhwYW5zaW9uT3BlblRyYW5zaXRpb24gPSBbXG4gICAgICB7IGhlaWdodDogMCwgcGFkZGluZ1RvcDogMCwgcGFkZGluZ0JvdHRvbTogMCB9LFxuICAgICAge1xuICAgICAgICBoZWlnaHQ6IGNvbXB1dGVkU3R5bGUuaGVpZ2h0LFxuICAgICAgICBwYWRkaW5nVG9wOiBjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSxcbiAgICAgIH1cbiAgICBdO1xuICAgIGNvbnN0IGljb25PcGVuVHJhbnNpdGlvbiA9IFt7dHJhbnNmb3JtOiAncm90YXRlKDQ1ZGVnKSd9LCB7dHJhbnNmb3JtOiAncm90YXRlKDIyNWRlZyknfV07XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSB2YWx1ZXMgd2UgbmVlZCwgcmVzZXQgdGhlIGhlaWdodCBiYWNrIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgIGxpc3RJdGVtLmV4cGFuZGFibGVDb250ZW50LnN0eWxlLmhlaWdodCA9IG9sZEhlaWdodDtcblxuICAgIGFuaW1pdChsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudCwgeyBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgcHJvcGVydHk6ICdoZWlnaHQgcGFkZGluZy10b3AgcGFkZGluZy1ib3R0b20nIH0pXG4gICAgICAuZGVmYXVsdCguLi4oc2hvdWxkT3BlbiA/IGV4cGFuc2lvbk9wZW5UcmFuc2l0aW9uIDogZXhwYW5zaW9uT3BlblRyYW5zaXRpb24ucmV2ZXJzZSgpKSlcbiAgICAgIC5wbGF5KCgpID0+IHtcbiAgICAgICAgbGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IG9sZERpc3BsYXk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcblxuICAgIGlmIChsaXN0SXRlbS5leHBhbmRDaGV2cm9uKSB7XG4gICAgICBhbmltaXQobGlzdEl0ZW0uZXhwYW5kQ2hldnJvbiwgeyBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgcHJvcGVydHk6ICd0cmFuc2Zvcm0nIH0pXG4gICAgICAgIC5kZWZhdWx0KC4uLihzaG91bGRPcGVuID8gaWNvbk9wZW5UcmFuc2l0aW9uIDogaWNvbk9wZW5UcmFuc2l0aW9uLnJldmVyc2UoKSkpXG4gICAgICAgIC5wbGF5KCk7XG4gICAgfVxuICB9XG5cbn0iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uLy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBMaXN0SXRlbUFuaW1hdG9yLCBTbGlkZUxpc3RJdGVtQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LWl0ZW0nO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnLmxpc3QtaXRlbSc6ICdsaXN0LWl0ZW0tLSonLFxuICAnLmxpc3QtaXRlbV9fbGVmdCc6ICdsaXN0LWl0ZW0tLSpfX2xlZnQnLFxuICAnLmxpc3QtaXRlbV9fY2VudGVyJzogJ2xpc3QtaXRlbS0tKl9fY2VudGVyJyxcbiAgJy5saXN0LWl0ZW1fX3JpZ2h0JzogJ2xpc3QtaXRlbS0tKl9fcmlnaHQnLFxuICAnLmxpc3QtaXRlbV9fbGFiZWwnOiAnbGlzdC1pdGVtLS0qX19sYWJlbCcsXG4gICcubGlzdC1pdGVtX190aXRsZSc6ICdsaXN0LWl0ZW0tLSpfX3RpdGxlJyxcbiAgJy5saXN0LWl0ZW1fX3N1YnRpdGxlJzogJ2xpc3QtaXRlbS0tKl9fc3VidGl0bGUnLFxuICAnLmxpc3QtaXRlbV9fdGh1bWJuYWlsJzogJ2xpc3QtaXRlbS0tKl9fdGh1bWJuYWlsJyxcbiAgJy5saXN0LWl0ZW1fX2ljb24nOiAnbGlzdC1pdGVtLS0qX19pY29uJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBTbGlkZUxpc3RJdGVtQW5pbWF0b3IsXG4gICdub25lJzogTGlzdEl0ZW1BbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC1pdGVtXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQG1vZGlmaWVyIHRhcHBhYmxlXG4gKiAgIFtlbl1NYWtlIHRoZSBsaXN0IGl0ZW0gY2hhbmdlIGFwcGVhcmFuY2Ugd2hlbiBpdCdzIHRhcHBlZC4gT24gaU9TIGl0IGlzIGJldHRlciB0byB1c2UgdGhlIFwidGFwcGFibGVcIiBhbmQgXCJ0YXAtYmFja2dyb3VuZC1jb2xvclwiIGF0dHJpYnV0ZSBmb3IgYmV0dGVyIGJlaGF2aW9yIHdoZW4gc2Nyb2xsaW5nLlsvZW5dXG4gKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgZfjgZ/mmYLjgavlirnmnpzjgYzooajnpLrjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGNoZXZyb25cbiAqICAgW2VuXURpc3BsYXkgYSBjaGV2cm9uIGF0IHRoZSByaWdodCBlbmQgb2YgdGhlIGxpc3QgaXRlbSBhbmQgbWFrZSBpdCBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIHRhcHBlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBsb25nZGl2aWRlclxuICogICBbZW5dRGlzcGxheXMgYSBsb25nIGhvcml6b250YWwgZGl2aWRlciBiZXR3ZWVuIGl0ZW1zLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vZGl2aWRlclxuICogICBbZW5dUmVtb3ZlcyB0aGUgZGl2aWRlciBiZXR3ZWVuIGxpc3QgaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCBpdGVtLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdGhhdCByZXByZXNlbnRzIGVhY2ggaXRlbSBpbiBhIGxpc3QuIFRoZSBsaXN0IGl0ZW0gaXMgY29tcG9zZWQgb2YgZm91ciBwYXJ0cyB0aGF0IGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBgbGVmdGAsIGBjZW50ZXJgLCBgcmlnaHRgIGFuZCBgZXhwYW5kYWJsZS1jb250ZW50YCBjbGFzc2VzLiBUaGVzZSBjbGFzc2VzIGNhbiBiZSB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBjb250ZW50IG9mIHRoZSBsaXN0IGl0ZW1zIGlzIHByb3Blcmx5IGFsaWduZWQuXG4gKlxuICogICAgIGBgYFxuICogICAgIDxvbnMtbGlzdC1pdGVtPlxuICogICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5MZWZ0PC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+Q2VudGVyPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5SaWdodDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImV4cGFuZGFibGUtY29udGVudFwiPkV4cGFuZGFibGUgY29udGVudDwvZGl2PlxuICogICAgIDwvb25zLWxpc3QtaXRlbT5cbiAqICAgICBgYGBcbiAqXG4gKiAgICAgVGhlcmUgYXJlIGFsc28gYSBudW1iZXIgb2YgY2xhc3NlcyAocHJlZml4ZWQgd2l0aCBgbGlzdC1pdGVtX18qYCkgdGhhdCBoZWxwIHdoZW4gcHV0dGluZyB0aGluZ3MgbGlrZSBpY29ucyBhbmQgdGh1bWJuYWlscyBpbnRvIHRoZSBsaXN0IGl0ZW1zLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0XG4gKiAgIFtlbl1vbnMtbGlzdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3QtaXRlbT5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cIm1kLWZhY2VcIiBjbGFzcz1cImxpc3QtaXRlbV9faWNvblwiPjwvb25zLWljb24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3QtaXRlbV9fdGl0bGVcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0LWl0ZW1fX3N1YnRpdGxlXCI+U3VidGl0bGU8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtc3dpdGNoPjwvb25zLXN3aXRjaD5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy1saXN0LWl0ZW0+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QgaXRlbS5bL2VuXVxuICAgKiAgIFtqYV3lkITopoHntKDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBsb2NrLW9uLWRyYWdcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVByZXZlbnQgdmVydGljYWwgc2Nyb2xsaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgaG9yaXpvbnRhbGx5LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODpuODvOOCtuODvOOBjOOBk+OBruimgee0oOOCkuaoquaWueWQkeOBq+ODieODqeODg+OCsOOBl+OBpuOBhOOCi+aZguOBq+OAgee4puaWueWQkeOBruOCueOCr+ODreODvOODq+OBjOi1t+OBjeOBquOBhOOCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcHBhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZXMgdGhlIGVsZW1lbnQgcmVhY3QgdG8gdGFwcy4gYHByZXZlbnQtdGFwYCBhdHRyaWJ1dGUgY2FuIGJlIGFkZGVkIHRvIGNoaWxkIGVsZW1lbnRzIGxpa2UgYnV0dG9ucyBvciBpbnB1dHMgdG8gcHJldmVudCB0aGlzIGVmZmVjdC4gYG9ucy0qYCBlbGVtZW50cyBhcmUgaWdub3JlZCBieSBkZWZhdWx0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhcC1iYWNrZ3JvdW5kLWNvbG9yXG4gICAqIEB0eXBlIHtDb2xvcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXSBDaGFuZ2VzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gdGFwcGVkLiBGb3IgdGhpcyB0byB3b3JrLCB0aGUgYXR0cmlidXRlIFwidGFwcGFibGVcIiBuZWVkcyB0byBiZSBzZXQuIFRoZSBkZWZhdWx0IGNvbG9yIGlzIFwiI2Q5ZDlkOVwiLiBJdCB3aWxsIGRpc3BsYXkgYXMgYSByaXBwbGUgZWZmZWN0IG9uIEFuZHJvaWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZXhwYW5kYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU1ha2VzIHRoZSBlbGVtZW50IGFibGUgdG8gYmUgZXhwYW5kZWQgdG8gcmV2ZWFsIGV4dHJhIGNvbnRlbnQuIEZvciB0aGlzIHRvIHdvcmssIHRoZSBleHBhbmRhYmxlIGNvbnRlbnQgbXVzdCBiZSBkZWZpbmVkIGluIGBkaXYuZXhwYW5kYWJsZS1jb250ZW50YC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGV4cGFuZGFibGUgY29udGVudC4gQ2FuIGJlIGVpdGhlciBgXCJkZWZhdWx0XCJgIG9yIGBcIm5vbmVcImAuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgdGhpcy50b2dnbGVFeHBhbnNpb24gPSB0aGlzLnRvZ2dsZUV4cGFuc2lvbi5iaW5kKHRoaXMpO1xuXG4gICAgLy8gRWxlbWVudHMgaWdub3JlZCB3aGVuIHRhcHBpbmdcbiAgICBjb25zdCByZSA9IC9eb25zLSg/IWNvbCR8cm93JHxpZiQpL2k7XG4gICAgdGhpcy5fc2hvdWxkSWdub3JlVGFwID0gZSA9PiBlLmhhc0F0dHJpYnV0ZSgncHJldmVudC10YXAnKSB8fCByZS50ZXN0KGUudGFnTmFtZSk7XG5cbiAgICAvLyBzaG93IGFuZCBoaWRlIGZ1bmN0aW9ucyBmb3IgVnVlIGhpZGFibGUgbWl4aW5cbiAgICB0aGlzLnNob3cgPSB0aGlzLnNob3dFeHBhbnNpb247XG4gICAgdGhpcy5oaWRlID0gdGhpcy5oaWRlRXhwYW5zaW9uO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdleHBhbmRhYmxlJykpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtLS1leHBhbmRhYmxlJyk7XG4gICAgfVxuXG4gICAgbGV0IGxlZnQsIGNlbnRlciwgcmlnaHQsIHRvcCwgZXhwYW5kYWJsZUNvbnRlbnQ7XG5cbiAgICBjb25zdCBjaGlsZEVscyA9IHV0aWwuZ2V0QWxsQ2hpbGROb2Rlcyh0aGlzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRFbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsID0gY2hpbGRFbHNbaV07XG5cbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2xlZnQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX2xlZnQnKTtcbiAgICAgICAgbGVmdCA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgICBjZW50ZXIgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncmlnaHQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX3JpZ2h0Jyk7XG4gICAgICAgIHJpZ2h0ID0gZWw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3RvcCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fdG9wJyk7XG4gICAgICAgIHRvcCA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdleHBhbmRhYmxlLWNvbnRlbnQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX2V4cGFuZGFibGUtY29udGVudCcpO1xuICAgICAgICBleHBhbmRhYmxlQ29udGVudCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmlnaHQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2V4cGFuZGFibGUnKSkge1xuICAgICAgcmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHJpZ2h0LmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fcmlnaHQnLCAncmlnaHQnKTtcblxuICAgICAgLy8gV2UgY2Fubm90IHVzZSBhIHBzZXVkby1lbGVtZW50IGZvciB0aGlzIGNoZXZyb24sIGFzIHdlIGNhbm5vdCBhbmltYXRlIGl0IHVzaW5nXG4gICAgICAvLyBKUy4gU28sIHdlIG1ha2UgYSBjaGV2cm9uIHNwYW4gaW5zdGVhZC5cbiAgICAgIGNvbnN0IGNoZXZyb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBjaGV2cm9uLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fZXhwYW5kLWNoZXZyb24nKTtcbiAgICAgIHJpZ2h0LmFwcGVuZENoaWxkKGNoZXZyb24pO1xuICAgIH1cblxuICAgIGlmICghY2VudGVyKSB7XG4gICAgICBjZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKCFsZWZ0ICYmICFyaWdodCAmJiAhZXhwYW5kYWJsZUNvbnRlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgIGNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgaWYgKGVsICE9PSBsZWZ0ICYmIGVsICE9PSByaWdodCAmJiBlbCAhPT0gZXhwYW5kYWJsZUNvbnRlbnQgJiYgZWwudGFnTmFtZSAhPT0gJ09OUy1SSVBQTEUnKSB7XG4gICAgICAgICAgICBjZW50ZXIuaW5zZXJ0QmVmb3JlKGVsLCBjZW50ZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhwYW5kYWJsZUNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY2VudGVyLCByaWdodCB8fCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnY2VudGVyJywgJ2xpc3QtaXRlbV9fY2VudGVyJyk7XG5cbiAgICBpZiAoZXhwYW5kYWJsZUNvbnRlbnQpIHtcbiAgICAgIC8vIGNyZWF0ZSAndG9wJyBkaXZcbiAgICAgIC8vIHRoaXMgaG9sZHMgZXZlcnl0aGluZyBleGNlcHQgdGhlIGV4cGFuZGFibGUgY29udGVudFxuICAgICAgdGhpcy5fdG9wID0gdG9wIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5fdG9wLmNsYXNzTGlzdC5hZGQoJ3RvcCcsICdsaXN0LWl0ZW1fX3RvcCcpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90b3ApO1xuXG4gICAgICB0aGlzLl90b3AuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX3RvcC5hcHBlbmRDaGlsZChsZWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodCkge1xuICAgICAgICB0aGlzLl90b3AuYXBwZW5kQ2hpbGQocmlnaHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd0V4cGFuc2lvblxuICAgKiBAc2lnbmF0dXJlIHNob3dFeHBhbnNpb24oKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgZXhwYW5kYWJsZSBjb250ZW50IGlmIHRoZSBlbGVtZW50IGlzIGV4cGFuZGFibGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3dFeHBhbnNpb24oKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdleHBhbmRhYmxlJykgJiYgIXRoaXMuX2V4cGFuZGluZykge1xuICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9leHBhbmRpbmcgPSB0cnVlO1xuXG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcigpO1xuICAgICAgYW5pbWF0b3Iuc2hvd0V4cGFuc2lvbih0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZXhwYW5kZWQnKTtcbiAgICAgICAgdGhpcy5fZXhwYW5kaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlRXhwYW5zaW9uXG4gICAqIEBzaWduYXR1cmUgaGlkZUV4cGFuc2lvbigpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBleHBhbmRhYmxlIGNvbnRlbnQgaWYgdGhlIGVsZW1lbnQgZXhwYW5kYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZUV4cGFuc2lvbigpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2V4cGFuZGFibGUnKSAmJiAhdGhpcy5fZXhwYW5kaW5nKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9leHBhbmRpbmcgPSB0cnVlO1xuXG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcigpO1xuICAgICAgYW5pbWF0b3IuaGlkZUV4cGFuc2lvbih0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnZXhwYW5kZWQnKTtcbiAgICAgICAgdGhpcy5fZXhwYW5kaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVFeHBhbnNpb24oKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cGFuZGVkJykgPyB0aGlzLmhpZGVFeHBhbnNpb24oKSA6IHRoaXMuc2hvd0V4cGFuc2lvbigpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IExpc3RJdGVtQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTGlzdEl0ZW1BbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsICdyaXBwbGUnLCAnYW5pbWF0aW9uJ107XG4gIH1cblxuICBnZXQgZXhwYW5kYWJsZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmxpc3QtaXRlbV9fZXhwYW5kYWJsZS1jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgZXhwYW5kQ2hldnJvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGlzdC1pdGVtX19leHBhbmQtY2hldnJvbicpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnModHJ1ZSk7XG4gICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKGZhbHNlKTtcbiAgfVxuXG4gIF9zZXR1cExpc3RlbmVycyhhZGQpIHtcbiAgICBjb25zdCBhY3Rpb24gPSAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgdXRpbFthY3Rpb25dKHRoaXMsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHV0aWxbYWN0aW9uXSh0aGlzLCAndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpc1thY3Rpb25dKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcblxuICAgIGlmICh0aGlzLl90b3ApIHtcbiAgICAgIHRoaXMuX3RvcFthY3Rpb25dKCdjbGljaycsIHRoaXMudG9nZ2xlRXhwYW5zaW9uKTtcbiAgICB9XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgY29uc3QgZ2VzdHVyZSA9IGV2ZW50Lmdlc3R1cmU7XG4gICAgLy8gUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgaWYgdGhlIHVzZXJzIHBhbnMgbGVmdCBvciByaWdodC5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZ2VzdHVyZS5kaXJlY3Rpb24pID4gLTEpIHtcbiAgICAgIGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBfb25Ub3VjaChlKSB7XG4gICAgaWYgKHRoaXMudGFwcGVkIHx8XG4gICAgICAodGhpcyAhPT0gZS50YXJnZXQgJiYgKHRoaXMuX3Nob3VsZElnbm9yZVRhcChlLnRhcmdldCkgfHwgdXRpbC5maW5kUGFyZW50KGUudGFyZ2V0LCB0aGlzLl9zaG91bGRJZ25vcmVUYXAsIHAgPT4gcCA9PT0gdGhpcykpKVxuICAgICkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgdGFwXG4gICAgfVxuXG4gICAgdGhpcy50YXBwZWQgPSB0cnVlO1xuICAgIGNvbnN0IHRvdWNoU3R5bGUgPSB7IHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDAuMHMgbGluZWFyIDAuMDJzLCBib3gtc2hhZG93IDAuMHMgbGluZWFyIDAuMDJzJyB9O1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd0YXBwYWJsZScpKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIH1cblxuICAgICAgdG91Y2hTdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGFwLWJhY2tncm91bmQtY29sb3InKSB8fCAnI2Q5ZDlkOSc7XG4gICAgICB0b3VjaFN0eWxlLmJveFNoYWRvdyA9IGAwcHggLTFweCAwcHggMHB4ICR7dG91Y2hTdHlsZS5iYWNrZ3JvdW5kQ29sb3J9YDtcbiAgICB9XG5cbiAgICBzdHlsZXIodGhpcywgdG91Y2hTdHlsZSk7XG4gIH1cblxuICBfb25SZWxlYXNlKCkge1xuICAgIHRoaXMudGFwcGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciB8fCAnJztcbiAgICBzdHlsZXIuY2xlYXIodGhpcywgJ3RyYW5zaXRpb24gYm94U2hhZG93Jyk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdEl0ZW0gPSBMaXN0SXRlbUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0LWl0ZW0nLCBMaXN0SXRlbUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbGlzdCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3RcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgaW5zZXRcbiAqICAgW2VuXUluc2V0IGxpc3QgdGhhdCBkb2Vzbid0IGNvdmVyIHRoZSB3aG9sZSB3aWR0aCBvZiB0aGUgcGFyZW50LlsvZW5dXG4gKiAgIFtqYV3opqropoHntKDjga7nlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgonjgarjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgIFtlbl1BIGxpc3Qgd2l0aCBubyBib3JkZXJzIGF0IHRoZSB0b3AgYW5kIGJvdHRvbS5bL2VuXVxuICogICBbamFd44Oq44K544OI44Gu5LiK5LiL44Gu44Oc44O844OA44O844GM54Sh44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ29tcG9uZW50IHRvIGRlZmluZSBhIGxpc3QsIGFuZCB0aGUgY29udGFpbmVyIGZvciBvbnMtbGlzdC1pdGVtKHMpLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjgpLooajnj77jgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdC1pdGVt44Gu44Kz44Oz44OG44OK44Go44GX44Gm5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXW9ucy1saXN0LWl0ZW0gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaGVhZGVyXG4gKiAgIFtlbl1vbnMtbGlzdC1oZWFkZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN0LWhlYWRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGF6eS1yZXBlYXRcbiAqICAgW2VuXW9ucy1sYXp5LXJlcGVhdCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxhenktcmVwZWF044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0LlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9uc0VsZW1lbnRzLkxpc3QgPSBMaXN0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QnLCBMaXN0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS1lbGVtZW50JztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBJTlBVVF9BVFRSSUJVVEVTID0gW1xuICAnYXV0b2NhcGl0YWxpemUnLFxuICAnYXV0b2NvbXBsZXRlJyxcbiAgJ2F1dG9jb3JyZWN0JyxcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdpbnB1dG1vZGUnLFxuICAnbWF4JyxcbiAgJ21heGxlbmd0aCcsXG4gICdtaW4nLFxuICAnbWlubGVuZ3RoJyxcbiAgJ25hbWUnLFxuICAncGF0dGVybicsXG4gICdwbGFjZWhvbGRlcicsXG4gICdyZWFkb25seScsXG4gICdyZXF1aXJlZCcsXG4gICdzaXplJyxcbiAgJ3N0ZXAnLFxuICAndmFsaWRhdG9yJyxcbiAgJ3ZhbHVlJ1xuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUlucHV0RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBfdXBkYXRlKCkge30gLy8gT3B0aW9uYWxseSBpbXBsZW1lbnRlZFxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlSW5wdXRFbGVtZW50KSB7XG4gICAgICB1dGlsLnRocm93QWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQgPSB0aGlzLl9kZWxlZ2F0ZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lICYmIHRoaXMuY2xhc3NMaXN0LmFkZCh0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodXRpbC5jcmVhdGVGcmFnbWVudCh0aGlzLl90ZW1wbGF0ZSkpO1xuXG4gICAgdGhpcy5fc2V0SW5wdXRJZCgpO1xuXG4gICAgdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfZGVsZWdhdGVFdmVudChldmVudCkge1xuICAgIGNvbnN0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQudHlwZSwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgX3NldElucHV0SWQoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpbnB1dC1pZCcpKSB7XG4gICAgICB0aGlzLl9pbnB1dC5pZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpbnB1dC1pZCcpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0ID09PSBudWxsXG4gICAgICA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpXG4gICAgICA6IHRoaXMuX2lucHV0LnZhbHVlO1xuICB9XG5cbiAgc2V0IHZhbHVlKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICB2YWwgPSB2YWwudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB2YWw7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnaW5wdXQtaWQnLCAnY2xhc3MnLCAuLi5JTlBVVF9BVFRSSUJVVEVTXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgdGhpcy5fc2NoZW1lKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQtaWQnOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fc2V0SW5wdXRJZCgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChJTlBVVF9BVFRSSUJVVEVTLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlSW5wdXRFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWlucHV0JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJyxcbiAgJy50ZXh0LWlucHV0X19sYWJlbCc6ICd0ZXh0LWlucHV0LS0qX19sYWJlbCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWlucHV0XG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdW5kZXJiYXJcbiAqICBbZW5dRGlzcGxheXMgYSBob3Jpem9udGFsIGxpbmUgdW5kZXJuZWF0aCBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogIFtlbl1EaXNwbGF5cyBhIHRyYW5zcGFyZW50IGlucHV0LiBXb3JrcyBmb3IgTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBbiBpbnB1dCBlbGVtZW50LiBUaGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIGlucHV0IHR5cGUuIEFsbCB0ZXh0IGlucHV0IHR5cGVzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogICAgVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVuZGVyIGFzIGEgTWF0ZXJpYWwgRGVzaWduIGlucHV0IG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dD5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50LlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaW5wdXRcbiAqIEBzZWVhbHNvIG9ucy1jaGVja2JveFxuICogICBbZW5dVGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBjaGVja2JveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYWRpb1xuICogICBbZW5dVGhlIGA8b25zLXJhZGlvPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYWRpbyBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1pbnB1dCBwbGFjZWhvbGRlcj1cIlVzZXJuYW1lXCIgZmxvYXQ+PC9vbnMtaW5wdXQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0RWxlbWVudCBleHRlbmRzIEJhc2VJbnB1dEVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uSW5wdXQgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uRm9jdXNpbiA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyogSW5oZXJpdGVkIHByb3BzICovXG5cbiAgX3VwZGF0ZSgpIHtcbiAgICB0aGlzLl91cGRhdGVMYWJlbCgpO1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsQ2xhc3MoKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8aW5wdXQgdHlwZT1cIiR7dGhpcy50eXBlfVwiIGNsYXNzPVwidGV4dC1pbnB1dFwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LWlucHV0X19sYWJlbFwiPjwvc3Bhbj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgcmV0dXJuIChbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5kZXhPZih0eXBlKSA8IDApICYmIHR5cGUgfHwgJ3RleHQnO1xuICB9XG5cbiAgLyogT3duIHByb3BzICovXG5cbiAgX3VwZGF0ZUxhYmVsKCkge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykgfHwgJyc7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2hlbHBlci50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUxhYmVsQ2xhc3MoKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGVscGVyLmNsYXNzTGlzdC5hZGQoJ3RleHQtaW5wdXQtLW1hdGVyaWFsX19sYWJlbC0tYWN0aXZlJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9oZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgaWYgKFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHR5cGUpID49IDApIHtcbiAgICAgIHV0aWwud2FybihgV2FybjogPG9ucy1pbnB1dCB0eXBlPVwiJHt0eXBlfVwiPiBpcyBkZXByZWNhdGVkIHNpbmNlIHYyLjQuMC4gVXNlIDxvbnMtJHt0eXBlfT4gaW5zdGVhZC5gKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2JvdW5kT25Gb2N1c2luKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAndHlwZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgdGhpcy50eXBlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QbGFjZWhvbGRlciB0ZXh0LiBJbiBNYXRlcmlhbCBEZXNpZ24sIHRoaXMgcGxhY2Vob2xkZXIgd2lsbCBiZSBhIGZsb2F0aW5nIGxhYmVsLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZsb2F0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHByZXNlbnQsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIGFuaW1hdGVkIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+aZguOAgeODqeODmeODq+OBr+OCouODi+ODoeODvOOCt+ODp+ODs+OBmeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHR5cGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIFNwZWNpZnkgdGhlIGlucHV0IHR5cGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIFwidHlwZVwiIGF0dHJpYnV0ZSBmb3Igbm9ybWFsIGlucHV0cy4gSXQgZXhwZWN0cyBzdHJpY3QgdGV4dCB0eXBlcyBzdWNoIGFzIGB0ZXh0YCwgYHBhc3N3b3JkYCwgZXRjLiBGb3IgY2hlY2tib3gsIHJhZGlvIGJ1dHRvbiwgc2VsZWN0IG9yIHJhbmdlLCBwbGVhc2UgaGF2ZSBhIGxvb2sgYXQgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMuXG4gICAqXG4gICAqICAgIFBsZWFzZSB0YWtlIGEgbG9vayBhdCBbTUROXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQjYXR0ci10eXBlKSBmb3IgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIHBvc3NpYmxlIHZhbHVlcy4gRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSBhbmQgYnJvd3NlciB2ZXJzaW9uIHNvbWUgb2YgdGhlc2UgbWlnaHQgbm90IHdvcmsuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgaW5wdXQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5JbnB1dCA9IElucHV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlucHV0JywgSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UtaW5wdXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VDaGVja2JveEVsZW1lbnQpIHtcbiAgICAgIHV0aWwudGhyb3dBYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnY2hlY2tlZCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdjaGVja2VkJykpO1xuICAgIH0pO1xuICB9XG5cbiAgLyogSW5oZXJpdGVkIHByb3BzICovXG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2NoZWNrbWFya1wiPjwvc3Bhbj5cbiAgICBgO1xuICB9XG5cbiAgLyogT3duIHByb3BzICovXG5cbiAgZ2V0IF9oZWxwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICB9XG5cbiAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LmNoZWNrZWQ7XG4gIH1cblxuICBzZXQgY2hlY2tlZCh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAnY2hlY2tlZCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICB0aGlzLmNoZWNrZWQgPSBjdXJyZW50ICE9PSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmNoZWNrYm94JzogJ2NoZWNrYm94LS0qJyxcbiAgJy5jaGVja2JveF9faW5wdXQnOiAnY2hlY2tib3gtLSpfX2lucHV0JyxcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jaGVja2JveFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgW2VuXWlPUyBib3JkZXJsZXNzIGNoZWNrYm94LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNoZWNrYm94IGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2NoZWNrYm94XG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYWRpb1xuICogICBbZW5dVGhlIGA8b25zLXJhZGlvPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYWRpbyBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWFyY2gtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWFyY2gtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlYXJjaCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jaGVja2JveCBjaGVja2VkPjwvb25zLWNoZWNrYm94PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAnY2hlY2tib3gnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdjaGVja2JveCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY2hlY2tib3guWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zRWxlbWVudHMuQ2hlY2tib3ggPSBDaGVja2JveEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jaGVja2JveCcsIENoZWNrYm94RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgQmFzZUNoZWNrYm94RWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1jaGVja2JveCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5yYWRpby1idXR0b24nOiAncmFkaW8tYnV0dG9uLS0qJyxcbiAgJy5yYWRpby1idXR0b25fX2lucHV0JzogJ3JhZGlvLWJ1dHRvbi0tKl9faW5wdXQnLFxuICAnLnJhZGlvLWJ1dHRvbl9fY2hlY2ttYXJrJzogJ3JhZGlvLWJ1dHRvbi0tKl9fY2hlY2ttYXJrJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmFkaW9cbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gcmFkaW8gYnV0dG9uLlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIHJhZGlvIGJ1dHRvbiBlbGVtZW50LiBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gcmFkaW8gYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dCB0eXBlPVwicmFkaW9cIj5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50LlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmFkaW9cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtY2hlY2tib3hcbiAqICAgW2VuXVRoZSBgPG9ucy1jaGVja2JveD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgY2hlY2tib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLWlucHV0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNlYXJjaC1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLXNlYXJjaC1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgc2VhcmNoIGlucHV0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhbmdlXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFuZ2U+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhbmdlIHNsaWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcmFkaW8gY2hlY2tlZD48L29ucy1yYWRpbz5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaW9FbGVtZW50IGV4dGVuZHMgQmFzZUNoZWNrYm94RWxlbWVudCB7XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ3JhZGlvLWJ1dHRvbic7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3JhZGlvJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSByYWRpbyBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgcmFkaW8gYnV0dG9uIGlzIGNoZWNrZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5SYWRpbyA9IFJhZGlvRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhZGlvJywgUmFkaW9FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlSW5wdXRFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWlucHV0JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnNlYXJjaC1pbnB1dCc6ICdzZWFyY2gtaW5wdXQtLSonXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zZWFyY2gtaW5wdXRcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc2VhcmNoIGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIHNlYXJjaCBpbnB1dCBlbGVtZW50LiBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gc2VhcmNoIGlucHV0IG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dD5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtc2VhcmNoLWlucHV0PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlYXJjaC1pbnB1dFxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWNoZWNrYm94XG4gKiAgIFtlbl1UaGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGNoZWNrYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc2VhcmNoLWlucHV0IHBsYWNlaG9sZGVyPVwiU2VhcmNoXCI+PC9vbnMtc2VhcmNoLWlucHV0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hJbnB1dEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cInNlYXJjaC1pbnB1dFwiPlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zRWxlbWVudHMuU2VhcmNoSW5wdXQgPSBTZWFyY2hJbnB1dEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zZWFyY2gtaW5wdXQnLCBTZWFyY2hJbnB1dEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZU1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBNb2RhbEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsLCB0aGlzLmRlZilcbiAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSlcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIG1vZGFsLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZnRNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvclxue1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciggLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsLCB0aGlzLmRlZilcbiAgICAgIC5kZWZhdWx0KFxuICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDEwMCUsIDApJyB9LFxuICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9XG4gICAgICApXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0sXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMTAwJSwgMCknIH1cbiAgICAgIClcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEZhZGVNb2RhbEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTGlmdE1vZGFsQW5pbWF0b3IgZnJvbSAnLi9saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdtb2RhbC0tKicsXG4gICdtb2RhbF9fY29udGVudCc6ICdtb2RhbC0tKl9fY29udGVudCdcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbW9kYWwnO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6IE1vZGFsQW5pbWF0b3IsXG4gICdmYWRlJzogRmFkZU1vZGFsQW5pbWF0b3IsXG4gICdsaWZ0JzogTGlmdE1vZGFsQW5pbWF0b3IsXG4gICdub25lJzogTW9kYWxBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbW9kYWxcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgTW9kYWwgY29tcG9uZW50IHRoYXQgbWFza3MgY3VycmVudCBzY3JlZW4uIFVuZGVybHlpbmcgY29tcG9uZW50cyBhcmUgbm90IHN1YmplY3QgdG8gYW55IGV2ZW50cyB3aGlsZSB0aGUgbW9kYWwgY29tcG9uZW50IGlzIHNob3duLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBibG9jayB1c2VyIGlucHV0IHdoaWxlIHNvbWUgb3BlcmF0aW9uIGlzIHJ1bm5pbmcgb3IgdG8gc2hvdyBzb21lIGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg55S76Z2i5YWo5L2T44KS44Oe44K544Kv44GZ44KL44Oi44O844OA44Or55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC5LiL5YG044Gr44GC44KL44Kz44Oz44Od44O844ON44Oz44OI44Gv44CBXG4gKiAgICAg44Oi44O844OA44Or44GM6KGo56S644GV44KM44Gm44GE44KL6ZaT44Gv44Kk44OZ44Oz44OI6YCa55+l44GM6KGM44KP44KM44G+44Gb44KT44CCXG4gKiAgIFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZGlhbG9nXG4gKiAgIFtlbl1UaGUgYDxvbnMtZGlhbG9nPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIG1vZGFsIGRpYWxvZy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRldklnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9yZWZlcmVuY2UvbW9kYWxcbiAqIEBleGFtcGxlXG4gKiA8b25zLW1vZGFsIGlkPVwibW9kYWxcIj5cbiAqICAgTW9kYWwgY29udGVudFxuICogPC9vbnMtbW9kYWw+XG4gKiA8c2NyaXB0PlxuICogICB2YXIgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kYWwnKTtcbiAqICAgbW9kYWwuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGFsRWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgbW9kYWwgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubW9kYWxcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIG1vZGFsIGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIG1vZGFsIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBtb2RhbCBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgbW9kYWwgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg6Ljg7zjg4Djg6vjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubW9kYWxcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIG1vZGFsLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImZhZGVcImAgb3IgYFwibGlmdFwiYC5bL2VuXVxuICAgKiAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJmYWRlXCIsXCJsaWZ0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9kZWZhdWx0REJCID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBNb2RhbEFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ01vZGFsQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS56SW5kZXggPSAxMDAwMTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcubW9kYWxfX2NvbnRlbnQnKSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdtb2RhbF9fY29udGVudCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIGNvbnRlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIF90b2dnbGVTdHlsZShzaG91bGRTaG93KSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gc2hvdWxkU2hvdyA/ICd0YWJsZScgOiAnbm9uZSc7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBtb2RhbCBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1vZGFsIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgbW9kYWwgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjga7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgbW9kYWwgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgbW9kYWwuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RhbEFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdNb2RhbCcpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTW9kYWxBbmltYXRvcigpIHtcbiAgICByZXR1cm4gTW9kYWxBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Nb2RhbCA9IE1vZGFsRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW1vZGFsJywgTW9kYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgpID0+IHtcbiAgY29uc3QgW3ZhbHVlLCBweF0gPSBbcGFyc2VJbnQod2lkdGgsIDEwKSwgL3B4Ly50ZXN0KHdpZHRoKV07XG4gIHJldHVybiBweCA/IHZhbHVlIDogTWF0aC5yb3VuZChkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoICogdmFsdWUgLyAxMDApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpcGVSZXZlYWwge1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICdlbGVtZW50IGlnbm9yZVN3aXBlIGlzSW5pdGlhbFN0YXRlIG9uRHJhZ0NhbGxiYWNrIHN3aXBlTWF4IHN3aXBlTWluIHN3aXBlTWlkJ1xuICAgICAgLnNwbGl0KC9cXHMrLykuZm9yRWFjaChrZXkgPT4gdGhpc1trZXldID0gcGFyYW1zW2tleV0pO1xuXG4gICAgdGhpcy5lbGVtZW50SGFuZGxlciA9IHBhcmFtcy5lbGVtZW50SGFuZGxlciB8fCBwYXJhbXMuZWxlbWVudDtcbiAgICB0aGlzLmdldFRocmVzaG9sZCA9IHBhcmFtcy5nZXRUaHJlc2hvbGQgfHwgKCgpID0+IC41KTtcbiAgICB0aGlzLmdldFNpZGUgPSBwYXJhbXMuZ2V0U2lkZSB8fCAoKCkgPT4gJ2xlZnQnKTtcblxuICAgIHRoaXMuaGFuZGxlR2VzdHVyZSA9IHRoaXMuaGFuZGxlR2VzdHVyZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2hvdWxkRml4U2Nyb2xsID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnaW9zJztcbiAgfVxuXG4gIHVwZGF0ZShzd2lwZWFibGUgPSB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSkge1xuICAgIGlmICghdGhpcy5nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLmVsZW1lbnRIYW5kbGVyLCB7IGRyYWdNaW5EaXN0YW5jZTogMSwgcGFzc2l2ZTogIXRoaXMuX3Nob3VsZEZpeFNjcm9sbCB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb24gPSBzd2lwZWFibGUgPyAnb24nIDogJ29mZic7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZyBkcmFnc3RhcnQgZHJhZ2VuZCcsIHRoaXMuaGFuZGxlR2VzdHVyZSk7XG4gIH1cblxuICBoYW5kbGVHZXN0dXJlKGUpIHtcbiAgICBpZiAoZS5nZXN0dXJlKSB7XG4gICAgICBpZiAoZS50eXBlID09PSAnZHJhZ3N0YXJ0Jykge1xuICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGUpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgICBlLnR5cGUgPT09ICdkcmFnZW5kJyA/IHRoaXMub25EcmFnRW5kKGUpIDogdGhpcy5vbkRyYWcoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBnZXREaXN0YW5jZSA9ICgpID0+IHRoaXMuZ2V0U2lkZSgpID09PSAnbGVmdCcgPyBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYIDogd2luZG93LmlubmVyV2lkdGggLSBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYO1xuICAgIHRoaXMuX2lnbm9yZURyYWcgPSBldmVudC5jb25zdW1lZCB8fCAhdXRpbC5pc1ZhbGlkR2VzdHVyZShldmVudCkgfHwgdGhpcy5pZ25vcmVTd2lwZShldmVudCwgZ2V0RGlzdGFuY2UoKSk7XG5cbiAgICBpZiAoIXRoaXMuX2lnbm9yZURyYWcpIHtcbiAgICAgIGV2ZW50LmNvbnN1bWUgJiYgZXZlbnQuY29uc3VtZSgpO1xuICAgICAgZXZlbnQuY29uc3VtZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoVG9QeCh0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggfHwgJzEwMCUnKTtcbiAgICAgIHRoaXMuX3N0YXJ0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZSA9ICghKHRoaXMuaXNJbml0aWFsU3RhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdGhpcy5pc0luaXRpYWxTdGF0ZSgpKSA/IDAgOiB0aGlzLl93aWR0aDtcblxuICAgICAgdXRpbC5pb3NQcmV2ZW50U2Nyb2xsKHRoaXMuZ2VzdHVyZURldGVjdG9yKTtcbiAgICB9XG4gIH1cblxuICBvbkRyYWcoZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5nZXRTaWRlKCkgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fd2lkdGgsIHRoaXMuX3N0YXJ0RGlzdGFuY2UgKyBkZWx0YSkpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdGhpcy5fZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB0aGlzLnN3aXBlTWlkKHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl93aWR0aCk7XG4gICAgfVxuICB9XG5cbiAgb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgY29uc3QgaXNTd2lwZU1heCA9IHRoaXMuZ2V0U2lkZSgpICE9PSBkaXJlY3Rpb24gJiYgdGhpcy5fZGlzdGFuY2UgPiB0aGlzLl93aWR0aCAqIHRoaXMuZ2V0VGhyZXNob2xkKCk7XG4gICAgaXNTd2lwZU1heCA/IHRoaXMuc3dpcGVNYXgoKSA6IHRoaXMuc3dpcGVNaW4oKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgJiYgdGhpcy5nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gdGhpcy5lbGVtZW50ID0gdGhpcy5lbGVtZW50SGFuZGxlciA9IG51bGw7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgYmxvY2socGFnZSkge1xuICAgIGNvbnN0IGJsb2NrZXIgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDEwMDAwMFwiPjwvZGl2PlxuICAgIGApO1xuICAgIHBhZ2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChibG9ja2VyKTtcbiAgICByZXR1cm4gKCkgPT4gYmxvY2tlci5yZW1vdmUoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIEFic3RyYWN0IHN3aXBlIGFuaW1hdG9yIGZvciBpT1MgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgc3RhdGljIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih7IGR1cmF0aW9uUmVzdG9yZSA9IDAuMSwgZHVyYXRpb25Td2lwZSA9IDAuMTUsIHRpbWluZ1N3aXBlID0gJ2xpbmVhcicsIC4uLnJlc3QgfSA9IHt9KSB7XG4gICAgc3VwZXIoey4uLnJlc3R9KTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBJT1NTd2lwZU5hdmlnYXRvckFuaW1hdG9yKSB7XG4gICAgICB1dGlsLnRocm93QWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLmR1cmF0aW9uUmVzdG9yZSA9IGR1cmF0aW9uUmVzdG9yZTtcbiAgICB0aGlzLmR1cmF0aW9uU3dpcGUgPSBkdXJhdGlvblN3aXBlO1xuICAgIHRoaXMudGltaW5nU3dpcGUgPSB0aW1pbmdTd2lwZTtcblxuICAgIHRoaXMub3B0U3dpcGUgPSB7IHRpbWluZzogdGltaW5nU3dpcGUsIGR1cmF0aW9uOiBkdXJhdGlvblN3aXBlIH07XG4gICAgdGhpcy5vcHRSZXN0b3JlID0geyB0aW1pbmc6IHRpbWluZ1N3aXBlLCBkdXJhdGlvbjogZHVyYXRpb25SZXN0b3JlIH07XG5cbiAgICB0aGlzLnN3aXBlU2hhZG93ID0gdXRpbC5jcmVhdGVFbGVtZW50KFxuICAgICAgYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogMTAwJTsgd2lkdGg6IDEycHg7IHJpZ2h0OiAxMDAlOyB0b3A6IDA7IGJvdHRvbTogMDsgei1pbmRleDogLTE7YCArXG4gICAgICAgIGBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHRyYW5zcGFyZW50IDAsIHJnYmEoMCwwLDAsLjA0KSA0MCUsIHJnYmEoMCwwLDAsLjEyKSA4MCUsIHJnYmEoMCwwLDAsLjE2KSAxMDAlKTtcIj48L2Rpdj5gXG4gICAgKTtcblxuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSB0cnVlO1xuICB9XG5cbiAgX2RlY29tcG9zZSgpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgX2NhbGN1bGF0ZURlbHRhKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIF9kcmFnU3RhcnRTZXR1cChlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSBmYWxzZTtcblxuICAgIC8vIEF2b2lkIGNvbnRlbnQgY2xpY2tzXG4gICAgdGhpcy51bmJsb2NrID0gc3VwZXIuYmxvY2sobGVhdmVQYWdlKTtcblxuICAgIC8vIE1hc2tcbiAgICBlbnRlclBhZ2UucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIC8vIERlY29tcG9zaXRpb25cbiAgICB0aGlzLnRhcmdldCA9IHtcbiAgICAgIGVudGVyOiB1dGlsLmZpbmRUb29sYmFyUGFnZShlbnRlclBhZ2UpIHx8IGVudGVyUGFnZSxcbiAgICAgIGxlYXZlOiB1dGlsLmZpbmRUb29sYmFyUGFnZShsZWF2ZVBhZ2UpIHx8IGxlYXZlUGFnZSxcbiAgICB9O1xuICAgIHRoaXMuZGVjb21wID0ge1xuICAgICAgZW50ZXI6IHRoaXMuX2RlY29tcG9zZSh0aGlzLnRhcmdldC5lbnRlciksXG4gICAgICBsZWF2ZTogdGhpcy5fZGVjb21wb3NlKHRoaXMudGFyZ2V0LmxlYXZlKVxuICAgIH07XG5cbiAgICAvLyBBbmltYXRpb24gdmFsdWVzXG4gICAgdGhpcy5kZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgdGhpcy5kZWNvbXAubGVhdmUpO1xuICAgIHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcih0aGlzLnRhcmdldC5lbnRlciwgdGhpcy50YXJnZXQubGVhdmUpO1xuXG4gICAgLy8gU2hhZG93ICYmIHN0eWxlc1xuICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG4gICAgICB0aGlzLnN3aXBlU2hhZG93LnN0eWxlLnRvcCA9IHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXIub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgIHRoaXMudGFyZ2V0LmxlYXZlLmFwcGVuZENoaWxkKHRoaXMuc3dpcGVTaGFkb3cpO1xuICAgICAgdGhpcy5fc2F2ZVN0eWxlKHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYXZlUGFnZS5hcHBlbmRDaGlsZCh0aGlzLnN3aXBlU2hhZG93KTtcbiAgICAgIHRoaXMuX3NhdmVTdHlsZShlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG4gICAgfVxuICAgIGxlYXZlUGFnZS5jbGFzc0xpc3QuYWRkKCdvdmVyZmxvdy12aXNpYmxlJyk7XG4gICAgdGhpcy5vdmVyZmxvd0VsZW1lbnQgPSBsZWF2ZVBhZ2U7XG4gICAgdGhpcy5kZWNvbXAubGVhdmUuY29udGVudC5jbGFzc0xpc3QuYWRkKCdjb250ZW50LXN3aXBpbmcnKTtcblxuICB9XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlLCBtYXhXaWR0aCwgZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICB0aGlzLmlzU3dpcGluZyA9IHRydWU7XG5cbiAgICBpZiAoZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0RyYWdTdGFydCkge1xuICAgICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgdGhpcy5fZHJhZ1N0YXJ0U2V0dXAoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHN3aXBlUmF0aW8gPSAoZGlzdGFuY2UgLSBtYXhXaWR0aCkgLyBtYXhXaWR0aDtcblxuICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG5cbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgLyogRW50ZXIgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAuZW50ZXIuY29udGVudCwgdGhpcy5kZWNvbXAuZW50ZXIuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAuZW50ZXIuYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7c3dpcGVSYXRpbyAqIDI1fSUsIDAsIDApYCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEgKyBzd2lwZVJhdGlvICogMTAgLyAxMDAgLy8gMC45IC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlICogc3dpcGVSYXRpb31weCwgMCwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gLy8gMCAtPiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gKiAxMCAvIDEwMCwgLy8gMC45IC0+IDFcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5kZWx0YS5sYWJlbCAqIHN3aXBlUmF0aW99cHgsIDAsIDApYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gLy8gMCAtPiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgLyogTGVhdmUgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAubGVhdmUuY29udGVudCwgdGhpcy5kZWNvbXAubGVhdmUuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAubGVhdmUuYmFja2dyb3VuZCwgdGhpcy5zd2lwZVNoYWRvd10pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7ZGlzdGFuY2V9cHgsIDAsIDApYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7KDEgKyBzd2lwZVJhdGlvKSAqIDEyNX0lLCAwLCAwKWBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8sIC8vIDEgLT4gMFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlICogKDEgKyBzd2lwZVJhdGlvKX1weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2Rpc3RhbmNlfXB4LCAwLCAwKWBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3N3aXBlUmF0aW8gKiAyNX0lLCAwLCAwKWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAqIDEwIC8gMTAwIC8vIDAuOSAtPiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuc3dpcGVTaGFkb3cpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IC0xICogc3dpcGVSYXRpbyAvLyAxIC0+IDBcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXN0b3JlKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAvKiBFbnRlciBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5lbnRlci5jb250ZW50LCB0aGlzLmRlY29tcC5lbnRlci5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5lbnRlci5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTI1JSwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSwgdGhpcy5vcHRSZXN0b3JlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7dGhpcy5kZWx0YS50aXRsZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvblJlc3RvcmV9cyAke3RoaXMudGltaW5nU3dpcGV9YCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtJHt0aGlzLmRlbHRhLmxhYmVsfXB4LCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgLyogTGVhdmUgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAubGVhdmUuY29udGVudCwgdGhpcy5kZWNvbXAubGVhdmUuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAubGVhdmUuYmFja2dyb3VuZCwgdGhpcy5zd2lwZVNoYWRvd10pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApYFxuICAgICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb25SZXN0b3JlfXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zICR7dGhpcy50aW1pbmdTd2lwZX1gXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSwgdGhpcy5vcHRSZXN0b3JlKVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0KGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICAgICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcG9wU3dpcGUoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXNEcmFnU3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaG91bGRBbmltYXRlVG9vbGJhcikge1xuXG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIC8qIEVudGVyIHBhZ2UgKi9cblxuICAgICAgICBhbmltaXQoW3RoaXMuZGVjb21wLmVudGVyLmNvbnRlbnQsIHRoaXMuZGVjb21wLmVudGVyLmJvdHRvbVRvb2xiYXIsIHRoaXMuZGVjb21wLmVudGVyLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApYCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvblN3aXBlfXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9uU3dpcGV9cyAke3RoaXMudGltaW5nU3dpcGV9YCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIub3RoZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMTAwJSwgMCwgMClgXG4gICAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMTI1JSwgMCwgMClgXG4gICAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5kZWx0YS50aXRsZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9uU3dpcGV9cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb25Td2lwZX1zICR7dGhpcy50aW1pbmdTd2lwZX1gXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1heFdpZHRofXB4LCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHRoaXMub3B0U3dpcGUpLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMCwgMCknXG4gICAgICAgIH0sIHRoaXMub3B0U3dpcGUpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLl9yZXNldChlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIF9zYXZlU3R5bGUoLi4uYXJncykge1xuICAgIHRoaXMuX3NhdmVkU3R5bGUgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IHNhdmUgPSBlbCA9PiB0aGlzLl9zYXZlZFN0eWxlLnNldChlbCwgZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICBhcmdzLmZvckVhY2goc2F2ZSk7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmRlY29tcCkuZm9yRWFjaChwID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGVjb21wW3BdKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAodGhpcy5kZWNvbXBbcF1ba10gaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuZGVjb21wW3BdW2tdIDogW3RoaXMuZGVjb21wW3BdW2tdXSkuZm9yRWFjaChzYXZlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Jlc3RvcmVTdHlsZSguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdG9yZSA9IGVsID0+IHtcbiAgICAgIHRoaXMuX3NhdmVkU3R5bGUuZ2V0KGVsKSA9PT0gbnVsbCA/IGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKSA6IGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB0aGlzLl9zYXZlZFN0eWxlLmdldChlbCkpXG4gICAgICB0aGlzLl9zYXZlZFN0eWxlLmRlbGV0ZShlbClcbiAgICB9O1xuICAgIGFyZ3MuZm9yRWFjaChyZXN0b3JlKTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuZGVjb21wKS5mb3JFYWNoKHAgPT4ge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5kZWNvbXBbcF0pLmZvckVhY2goayA9PiB7XG4gICAgICAgICh0aGlzLmRlY29tcFtwXVtrXSBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5kZWNvbXBbcF1ba10gOiBbdGhpcy5kZWNvbXBbcF1ba11dKS5mb3JFYWNoKHJlc3RvcmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfcmVzZXQoLi4uYXJncykge1xuICAgIHRoaXMuaXNTd2lwaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2F2ZWRTdHlsZSAmJiB0aGlzLl9yZXN0b3JlU3R5bGUoLi4uYXJncyk7XG4gICAgdGhpcy51bmJsb2NrICYmIHRoaXMudW5ibG9jaygpO1xuICAgIHRoaXMuc3dpcGVTaGFkb3cucmVtb3ZlKCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICB0aGlzLm92ZXJmbG93RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdvdmVyZmxvdy12aXNpYmxlJyk7XG4gICAgdGhpcy5kZWNvbXAubGVhdmUuY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdjb250ZW50LXN3aXBpbmcnKTtcbiAgICB0aGlzLmRlY29tcCA9IHRoaXMudGFyZ2V0ID0gdGhpcy5vdmVyZmxvd0VsZW1lbnQgPSB0aGlzLl9zYXZlZFN0eWxlID0gbnVsbDtcbiAgICB0aGlzLmlzRHJhZ1N0YXJ0ID0gdHJ1ZTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc3dpcGUtYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCB0cmFuc2xhdGUzZCA9ICh4ID0gMCwgeSA9IDAsIHogPSAwKSA9PiBgdHJhbnNsYXRlM2QoJHt4fSwgJHt5fSwgJHt6fSlgO1xuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBuYXZpZ2F0b3IgdHJhbnNpdGlvbiBsaWtlIGlPUydzIHNjcmVlbiBzbGlkZSB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgSU9TU3dpcGVOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoeyB0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKDAuMywgLjQsIDAsIC45KScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjQsIC4uLnJlc3QgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiwgLi4ucmVzdCB9KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtgICtcbiAgICAgICAgYGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyB6LWluZGV4OiAyXCI+PC9kaXY+YFxuICAgICk7XG4gIH1cblxuICBfZGVjb21wb3NlKHBhZ2UpIHtcbiAgICBjb25zdCB0b29sYmFyID0gcGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gdG9vbGJhci5fZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKTtcbiAgICBjb25zdCByaWdodCA9IHRvb2xiYXIuX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpO1xuXG4gICAgY29uc3QgZXhjbHVkZUJhY2tCdXR0b24gPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbnMtYmFjay1idXR0b24nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG90aGVyID0gW11cbiAgICAgIC5jb25jYXQobGVmdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBsZWZ0IDogZXhjbHVkZUJhY2tCdXR0b24obGVmdC5jaGlsZHJlbikpXG4gICAgICAuY29uY2F0KHJpZ2h0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IHJpZ2h0IDogZXhjbHVkZUJhY2tCdXR0b24ocmlnaHQuY2hpbGRyZW4pKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b29sYmFyQ2VudGVyOiB0b29sYmFyLl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uSWNvbjogdG9vbGJhci5fZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCgpLFxuICAgICAgYmFja0J1dHRvbkxhYmVsOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpLFxuICAgICAgb3RoZXI6IG90aGVyLFxuICAgICAgY29udGVudDogcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKSxcbiAgICAgIGJhY2tncm91bmQ6IHBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCksXG4gICAgICB0b29sYmFyOiB0b29sYmFyLFxuICAgICAgYm90dG9tVG9vbGJhcjogcGFnZS5fZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQoKVxuICAgIH07XG4gIH1cblxuICBfc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpIHtcbiAgICBjb25zdCB0b29sYmFycyA9IGVudGVyUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKSAmJiBsZWF2ZVBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCk7XG5cbiAgICBjb25zdCBlbnRlclRvb2xiYXIgPSBlbnRlclBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCk7XG4gICAgY29uc3QgbGVhdmVUb29sYmFyID0gbGVhdmVQYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuXG4gICAgY29uc3QgaXNTdGF0aWMgPSBlbnRlclRvb2xiYXIuaGFzQXR0cmlidXRlKCdzdGF0aWMnKSB8fCBsZWF2ZVRvb2xiYXIuaGFzQXR0cmlidXRlKCdzdGF0aWMnKTtcbiAgICBjb25zdCBpc01hdGVyaWFsID0gdXRpbC5oYXNNb2RpZmllcihlbnRlclRvb2xiYXIsICdtYXRlcmlhbCcpIHx8IHV0aWwuaGFzTW9kaWZpZXIobGVhdmVUb29sYmFyLCAnbWF0ZXJpYWwnKTtcbiAgICBjb25zdCBpc1RyYW5zcGFyZW50ID0gdXRpbC5oYXNNb2RpZmllcihlbnRlclRvb2xiYXIsICd0cmFuc3BhcmVudCcpIHx8IHV0aWwuaGFzTW9kaWZpZXIobGVhdmVUb29sYmFyLCAndHJhbnNwYXJlbnQnKTtcblxuICAgIHJldHVybiB0b29sYmFycyAmJiAhaXNTdGF0aWMgJiYgIWlzTWF0ZXJpYWwgJiYgIWlzVHJhbnNwYXJlbnQ7XG4gIH1cblxuICBfY2FsY3VsYXRlRGVsdGEoZWxlbWVudCwgZGVjb21wb3NpdGlvbikge1xuICAgIGxldCB0aXRsZSwgbGFiZWw7XG5cbiAgICBjb25zdCBwYWdlUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2xhYmVsJykpIHtcbiAgICAgIGNvbnN0IGxhYmVsUmVjdCA9IGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGl0bGUgPSBNYXRoLnJvdW5kKHBhZ2VSZWN0LndpZHRoIC8gMiAtIGxhYmVsUmVjdC53aWR0aCAvIDIgLSBsYWJlbFJlY3QubGVmdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gTWF0aC5yb3VuZCgocGFnZVJlY3Qud2lkdGggLyAyKSAqIDAuNik7XG4gICAgfVxuXG4gICAgaWYgKGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkljb24uY2xhc3NMaXN0LmNvbnRhaW5zKCdiYWNrLWJ1dHRvbl9faWNvbicpKSB7XG4gICAgICBsYWJlbCA9IGRlY29tcG9zaXRpb24uYmFja0J1dHRvbkljb24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgLSAyO1xuICAgIH1cblxuICAgIHJldHVybiB7dGl0bGUsIGxhYmVsfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBjb250ZW50UmVhZHkoZW50ZXJQYWdlLCAoKSA9PiB7XG4gICAgICBjb25zdCBlbnRlclBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShlbnRlclBhZ2UpIHx8IGVudGVyUGFnZTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlO1xuICAgICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2VUYXJnZXQpO1xuICAgICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2VUYXJnZXQpO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbik7XG5cbiAgICAgIGNvbnN0IHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlVGFyZ2V0LCBsZWF2ZVBhZ2VUYXJnZXQpO1xuXG4gICAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgICAgYW5pbWl0KFtlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCcxMDAlJykgfSxcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTI1JScpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZChgJHtkZWx0YS50aXRsZX1weGApLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgICAgeyBjc3M6IHsgb3BhY2l0eTogMSB9LCB0aW1pbmc6ICdsaW5lYXInIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSwgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJy0yNSUnKSwgb3BhY2l0eTogMC45IH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKGAtJHtkZWx0YS50aXRsZX1weGApLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9ufXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9ufXMgJHt0aGlzLnRpbWluZ31gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZChgLSR7ZGVsdGEubGFiZWx9cHhgKSwgb3BhY2l0eTogMCB9XG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24ub3RoZXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoIHsgb3BhY2l0eTogMSB9LCB7IGNzczogeyBvcGFjaXR5OiAwIH0sIHRpbWluZzogJ2xpbmVhcicgfSlcblxuICAgICAgICApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KCB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJzEwMCUnKSwgfSwgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KCB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSwgb3BhY2l0eTogMSB9LCB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJy0yNSUnKSwgb3BhY2l0eTogLjkgfSlcbiAgICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXNTd2lwaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3BTd2lwZShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IGVudGVyUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlO1xuICAgIGNvbnN0IGxlYXZlUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlO1xuICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlVGFyZ2V0KTtcbiAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICBjb25zdCBkZWx0YSA9IHRoaXMuX2NhbGN1bGF0ZURlbHRhKGxlYXZlUGFnZSwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbik7XG5cbiAgICBjb25zdCBzaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZVRhcmdldCwgbGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgIGlmIChzaG91bGRBbmltYXRlVG9vbGJhcikge1xuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBhbmltaXQoW2VudGVyUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnLTI1JScpLCBvcGFjaXR5OiAuOSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksIG9wYWNpdHk6IDEgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlciwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoYC0ke2RlbHRhLnRpdGxlfXB4YCksIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbCwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoYC0ke2RlbHRhLmxhYmVsfXB4YCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgeyBjc3M6IHsgb3BhY2l0eTogMSB9LCB0aW1pbmc6ICdsaW5lYXInIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChbbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0sIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTAwJScpIH1cbiAgICAgICAgICApXG4gICAgICAgICAgLndhaXQoMClcbiAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAgeyBvcGFjaXR5OiAwIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIsIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTI1JScpIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbCwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSwgb3BhY2l0eTogMSB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKGAke2RlbHRhLnRpdGxlfXB4YCksXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJy0yNSUnKSwgb3BhY2l0eTogLjkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgICApLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTAwJScpIH1cbiAgICAgICAgICApXG4gICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0xpZnROYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOycgK1xuICAgICAgICAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KGJsYWNrLCB3aGl0ZSk7XCI+PC9kaXY+J1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknIH1cbiAgICAgICAgKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsIG9wYWNpdHk6IC45IH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtNDNweCwgMCknLCBvcGFjaXR5OiAuOSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyB9XG4gICAgICAgIClcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwgMCwgMCknO1xuXG4vKipcbiAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybSwgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybSwgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIG5hdmlnYXRvciB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLmJsYWNrTWFza09wYWNpdHkgPSAwLjQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyB6LWluZGV4OiAyOycgK1xuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7XCI+PC9kaXY+J1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IG9wYWNpdHk6IHRoaXMuYmxhY2tNYXNrT3BhY2l0eSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfVxuICAgICAgICApLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC00NSUsIDAsIDApJyB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IHRoaXMuYmxhY2tNYXNrT3BhY2l0eSB9LFxuICAgICAgICAgIHsgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTQ1JSwgMCwgMCknLCBvcGFjaXR5OiAuOSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRExpZnROYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMC4wNSwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgICc8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOycgK1xuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+J1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAxMDAlLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9XG4gICAgICAgICksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAuNCB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkgKyB0aGlzLmR1cmF0aW9uKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAuNCB9LCB7IG9wYWNpdHk6IDEgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMTAwJSwgMCknIH1cbiAgICAgICAgKVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogRmFkZS1pbiArIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKScsIHRpbWluZ1BvcCA9ICdjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgICB0aGlzLnRpbWluZ1BvcCA9IHRpbWluZ1BvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCA0MnB4LCAwKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgY3NzOiB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDM4cHgsIDApJywgb3BhY2l0eTogMCB9LCB0aW1pbmc6IHRoaXMudGltaW5nUG9wIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uZU5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgU3dpcGVSZXZlYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL3N3aXBlLXJldmVhbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vaW9zLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBJT1NMaWZ0TmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3MtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgSU9TRmFkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vaW9zLWZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL21kLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCBNRExpZnROYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL21kLWxpZnQtYW5pbWF0b3InO1xuaW1wb3J0IE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTm9uZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbm9uZS1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlciwgaW5zdGFudFBhZ2VMb2FkZXJ9IGZyb20gJy4uLy4uL29ucy9wYWdlLWxvYWRlcic7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JBbmltYXRvciA6IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdzbGlkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURTbGlkZU5hdmlnYXRvckFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2xpZnQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yIDogSU9TTGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdzbGlkZS1pb3MnOiBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnc2xpZGUtbWQnOiBNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdsaWZ0LWlvcyc6IElPU0xpZnROYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2xpZnQtbWQnOiBNRExpZnROYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2ZhZGUtaW9zJzogSU9TRmFkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnZmFkZS1tZCc6IE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnbm9uZSc6IE5vbmVOYXZpZ2F0b3JBbmltYXRvclxufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5hdmlnYXRvclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShuYXZpZ2F0b3JFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmNvbnN0IHZlcmlmeVBhZ2VFbGVtZW50ID0gZWwgPT4gKGVsLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSAmJiB1dGlsLnRocm93KCAnT25seSBwYWdlIGVsZW1lbnRzIGNhbiBiZSBjaGlsZHJlbiBvZiBuYXZpZ2F0b3InKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbmF2aWdhdG9yXG4gKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBIGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIHBhZ2Ugc3RhY2sgbWFuYWdlbWVudCBhbmQgbmF2aWdhdGlvbi4gU3RhY2sgbmF2aWdhdGlvbiBpcyB0aGUgbW9zdCBjb21tb24gbmF2aWdhdGlvbiBwYXR0ZXJuIGZvciBtb2JpbGUgYXBwcy5cbiAqXG4gKiAgICAgV2hlbiBhIHBhZ2UgaXMgcHVzaGVkIG9uIHRvcCBvZiB0aGUgc3RhY2sgaXQgaXMgZGlzcGxheWVkIHdpdGggYSB0cmFuc2l0aW9uIGFuaW1hdGlvbi4gV2hlbiB0aGUgdXNlciByZXR1cm5zIHRvIHRoZSBwcmV2aW91cyBwYWdlIHRoZSB0b3AgcGFnZSB3aWxsIGJlIHBvcHBlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIGFuZCBoaWRkZW4gd2l0aCBhbiBvcHBvc2l0ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbi5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB5cmh0dlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25hdmlnYXRvclxuICogQGd1aWRlIGxpZmVjeWNsZS5odG1sI2V2ZW50c1xuICogICBbZW5dT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2VuXVxuICogICBbamFdT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRvb2xiYXIgb24gdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBsZXRzIHRoZSB1c2VyIHJldHVybiB0byB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLW5hdmlnYXRvciBpZD1cIm5hdmlnYXRvclwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBUaXRsZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgICA8cD5cbiAqICAgICAgIDxvbnMtYnV0dG9uXG4gKiAgICAgICAgIG9uY2xpY2s9XCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2aWdhdG9yJykucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpXCI+XG4gKiAgICAgICAgIFB1c2ggcGFnZVxuICogICAgICAgPC9vbnMtYnV0dG9uPlxuICogICAgIDwvcD5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJwYWdlLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIEFub3RoZXIgcGFnZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvdGVtcGxhdGU+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcnN0IHBhZ2UgdG8gc2hvdyB3aGVuIG5hdmlnYXRvciBpcyBpbml0aWFsaXplZC5bL2VuXVxuICAgKiAgIFtqYV3jg4rjg5PjgrLjg7zjgr/jg7zjgYzliJ3mnJ/ljJbjgZXjgozjgZ/mmYLjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1FbmFibGUgaU9TIFwic3dpcGUgdG8gcG9wXCIgZmVhdHVyZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZS10YXJnZXQtd2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgMjBweFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHdpZHRoIG9mIHN3aXBlYWJsZSBhcmVhIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZWRnZSAoaW4gcGl4ZWxzKS4gVXNlIHRoaXMgdG8gZW5hYmxlIHN3aXBlIG9ubHkgd2hlbiB0aGUgZmluZ2VyIHRvdWNoIG9uIHRoZSBzY3JlZW4gZWRnZS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6/jgqTjg5fjga7liKTlrprpoJjln5/jgpLjg5Tjgq/jgrvjg6vljZjkvY3jgafmjIflrprjgZfjgb7jgZnjgILnlLvpnaLjga7nq6/jgYvjgonmjIflrprjgZfjgZ/ot53pm6LjgavpgZTjgZnjgovjgajjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZS10aHJlc2hvbGRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMC4yXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgaG93IG11Y2ggdGhlIHBhZ2UgbmVlZHMgdG8gYmUgc3dpcGVkIGJlZm9yZSBwb3BwaW5nLiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAgZGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlcHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgYSBwYWdlIGlzIHB1c2hlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcHVzaOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHB1c2guWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CBcHVzaOWHpueQhuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlcG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcG9wcGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwb3DjgZXjgozjgovnm7TliY3jgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmN1cnJlbnRQYWdlXG4gICAqICAgW2VuXUN1cnJlbnQgcGFnZSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd54++5Zyo44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBwb3AuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CBcGFnZeOBrnBvcOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHB1c2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgYSBwYWdlIGlzIHB1c2hlZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GMcHVzaOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guS6huOBl+OBpuOBi+OCieeZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXB1c2jjgZXjgozjgZ9wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmxlYXZlUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIHByZXZpb3VzIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5Lul5YmN44GucGFnZeOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHBvcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcG9wcGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwb3DjgZXjgozjgabjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLjgo/jgaPjgZ/lvozjgavnmbrngavjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubmF2aWdhdG9yXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmVudGVyUGFnZVxuICAgKiAgIFtlbl1PYmplY3Qgb2YgdGhlIG5leHQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1wb3DjgZXjgozjgabooajnpLrjgZXjgozjgovjg5rjg7zjgrjjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1wb3DjgZXjgozjgabmtojjgYjjgovjg5rjg7zjgrjjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICBnZXQgYW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRvckZhY3Rvcnk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fcGFnZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAdHlwZSB7UGFnZUxvYWRlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2VMb2FkZXIgaW5zdGFuY2UuIEl0IGNhbiBiZSBvdmVycmlkZW4gdG8gY2hhbmdlIHRoZSB3YXkgcGFnZXMgYXJlIGxvYWRlZCBieSB0aGlzIGVsZW1lbnQuIFVzZWZ1bCBmb3IgbGliIGRldmVsb3BlcnMuWy9lbl1cbiAgICogICBbamFdUGFnZUxvYWRlcuOCpOODs+OCueOCv+ODs+OCueOCkuagvOe0jeOBl+OBpuOBhOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKHBhZ2VMb2FkZXIpIHtcbiAgICBpZiAoIShwYWdlTG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHV0aWwudGhyb3dQYWdlTG9hZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIHBhZ2UgdG8gYmUgbG9hZGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gVGhpcyB2YWx1ZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGBwYWdlYCBhdHRyaWJ1dGUuIFVzZWZ1bCBmb3IgbGliIGRldmVsb3BlcnMuWy9lbl1cbiAgICogICBbamFd5Yid5pyf5YyW5pmC44Gr6Kqt44G/6L6844KA44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCYHBhZ2Vg5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCk44KI44KK44KCYHBhZ2Vg44OX44Ot44OR44OG44Kj44Gr5oyH5a6a44GX44Gf5YCk44KS5YSq5YWI44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcblxuICAgIGlmICghcGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpID09PSAnZm9yY2UnKSB7XG4gICAgICBsZXQgc3dpcGVBbmltYXRvcjtcblxuICAgICAgdGhpcy5fc3dpcGUgPSBuZXcgU3dpcGVSZXZlYWwoe1xuICAgICAgICBlbGVtZW50OiB0aGlzLFxuICAgICAgICBnZXRUaHJlc2hvbGQ6ICgpID0+IE1hdGgubWF4KDAuMiwgcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGUtdGhyZXNob2xkJykpIHx8IDApLFxuXG4gICAgICAgIHN3aXBlTWF4OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKDEsIHsgZHVyYXRpb246IHN3aXBlQW5pbWF0b3IuZHVyYXRpb25Td2lwZSwgdGltaW5nOiBzd2lwZUFuaW1hdG9yLnRpbWluZ1N3aXBlIH0pO1xuICAgICAgICAgIHRoaXNbdGhpcy5zd2lwZU1heCA/ICdzd2lwZU1heCcgOiAncG9wUGFnZSddKHsgYW5pbWF0b3I6IHN3aXBlQW5pbWF0b3IgfSk7XG4gICAgICAgICAgc3dpcGVBbmltYXRvciA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHN3aXBlTWlkOiAoZGlzdGFuY2UsIHdpZHRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKGRpc3RhbmNlL3dpZHRoKTtcbiAgICAgICAgICBzd2lwZUFuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSwgd2lkdGgsIHRoaXMudG9wUGFnZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCB0aGlzLnRvcFBhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBzd2lwZU1pbjogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSgwLCB7IGR1cmF0aW9uOiBzd2lwZUFuaW1hdG9yLmR1cmF0aW9uUmVzdG9yZSwgdGltaW5nOiBzd2lwZUFuaW1hdG9yLnRpbWluZ1N3aXBlIH0pO1xuICAgICAgICAgIHN3aXBlQW5pbWF0b3IucmVzdG9yZSh0aGlzLnRvcFBhZ2UucHJldmlvdXNFbGVtZW50U2libGluZywgdGhpcy50b3BQYWdlKTtcbiAgICAgICAgICBzd2lwZUFuaW1hdG9yID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBpZ25vcmVTd2lwZTogKGV2ZW50LCBkaXN0YW5jZSkgPT4ge1xuICAgICAgICAgIC8vIEJhc2ljIGNvbmRpdGlvbnNcbiAgICAgICAgICBpZiAoIXRoaXMuX2lzUnVubmluZyAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICAgICAgLy8gQXJlYSBvciBkaXJlY3Rpb25hbCBpc3N1ZXNcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGUtdGFyZ2V0LXdpZHRoJykgfHwgMjUsIDEwKTtcbiAgICAgICAgICAgIGlmIChldmVudC5nZXN0dXJlLmRpcmVjdGlvbiA9PT0gICdyaWdodCcgJiYgYXJlYSA+IGRpc3RhbmNlKSB7XG5cbiAgICAgICAgICAgICAgLy8gU3dpcGVzIG9uIG9ucy1iYWNrLWJ1dHRvbiBhbmQgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICAgIGNvbnN0IGlzQkIgPSBlbCA9PiAvb25zLWJhY2stYnV0dG9uL2kudGVzdChlbC50YWdOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0JCKGV2ZW50LnRhcmdldCkgJiYgIXV0aWwuZmluZFBhcmVudChldmVudC50YXJnZXQsIGlzQkIsIHAgPT4gL29ucy1wYWdlL2kudGVzdChwLnRhZ05hbWUpKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQW5pbWF0b3IgaXMgc3dpcGVhYmxlXG4gICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gKHRoaXMudG9wUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9KS5hbmltYXRpb24gfHwgdGhpcy5hbmltYXRvckZhY3RvcnkuX2FuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBBbmltYXRvciA9IF9hbmltYXRvckRpY3RbYW5pbWF0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICA/IF9hbmltYXRvckRpY3RbYW5pbWF0aW9uXS5jYWxsKClcbiAgICAgICAgICAgICAgICAgIDogX2FuaW1hdG9yRGljdFthbmltYXRpb25dO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBBbmltYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgQW5pbWF0b3Iuc3dpcGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgICBzd2lwZUFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7IC8vIFByZXBhcmUgZm9yIHRoZSBzd2lwZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBJZ25vcmUgc3dpcGVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdzd2lwZWFibGUnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGRlZmVycmVkLnByb21pc2U7XG5cbiAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBzaG93ID0gIXV0aWwuaGFzQW55Q29tcG9uZW50QXNQYXJlbnQodGhpcyk7XG4gICAgICBjb25zdCBvcHRpb25zID0geyBhbmltYXRpb246ICdub25lJywgc2hvdyB9O1xuXG4gICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5fZ2V0UGFnZVRhcmdldCgpLCBvcHRpb25zKS50aGVuKCgpID0+IGRlZmVycmVkLnJlc29sdmUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2ZXJpZnlQYWdlRWxlbWVudCh0aGlzLnBhZ2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRvcFBhZ2UpIHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcy50b3BQYWdlLCAoKSA9PlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgc2hvdyAmJiB0aGlzLnRvcFBhZ2UuX3Nob3coKTtcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG4gICAgICAgICAgICB9LCAwKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAwICYmIHRoaXMuX2dldFBhZ2VUYXJnZXQoKSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoUGFnZSh0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIG9wdGlvbnMpLnRoZW4oKCkgPT4gZGVmZXJyZWQucmVzb2x2ZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBOYXZpZ2F0b3JBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdOYXZpZ2F0b3JBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IG51bGw7XG5cbiAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fc3dpcGUgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnYW5pbWF0aW9uJywgJ3N3aXBlYWJsZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgIHRoaXMuX3N3aXBlICYmIHRoaXMuX3N3aXBlLnVwZGF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwb3BQYWdlXG4gICAqIEBzaWduYXR1cmUgcG9wUGFnZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5kYXRhXVxuICAgKiAgIFtlbl1DdXN0b20gZGF0YSB0aGF0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lc11cbiAgICogICBbZW5dTnVtYmVyIG9mIHBhZ2VzIHRvIGJlIHBvcHBlZC4gT25seSBvbmUgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mmI7jgonjgYvjgavjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBvcHMgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBwYWdlIHN0YWNrLiBUaGUgcHJldmlvdXMgcGFnZSB3aWxsIGJlIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgYvjgonlj5bjgorpmaTjgY3jgb7jgZnjgILkuIDjgaTliY3jga7jg5rjg7zjgrjjgavmiLvjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcG9wUGFnZShvcHRpb25zID0ge30pIHtcbiAgICAoe29wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKG51bGwsIG9wdGlvbnMpKTtcblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcihvcHRpb25zLnRpbWVzKSAmJiBvcHRpb25zLnRpbWVzID4gMSkge1xuICAgICAgdGhpcy5fcmVtb3ZlUGFnZXMob3B0aW9ucy50aW1lcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9wVXBkYXRlID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpO1xuICB9XG5cbiAgX3BvcFBhZ2Uob3B0aW9ucywgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ucy1uYXZpZ2F0b3JcXCdzIHBhZ2Ugc3RhY2sgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQb3BFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXBvcCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aDtcblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLnVwZGF0ZUJhY2tCdXR0b24oKGxlbmd0aCAtIDIpID4gMCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZW50ZXJQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAyXTtcblxuICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMgfHwge30sIGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9LCBvcHRpb25zKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICBlbnRlclBhZ2UuZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UuZGF0YSB8fCB7fSwgb3B0aW9ucy5kYXRhIHx8IHt9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBlbnRlclBhZ2UuX3Nob3coKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3Rwb3AnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayAmJiBvcHRpb25zLmNhbGxiYWNrKGVudGVyUGFnZSk7XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGVhdmVQYWdlLl9oaWRlKCk7XG4gICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICBjb25zdCBhbmltYXRvciA9IG9wdGlvbnMuYW5pbWF0b3IgfHwgdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuICAgICAgYW5pbWF0b3IucG9wKHRoaXMucGFnZXNbbGVuZ3RoIC0gMl0sIHRoaXMucGFnZXNbbGVuZ3RoIC0gMV0sIGRvbmUpO1xuICAgIH0pLmNhdGNoKCgpID0+IHRoaXMuX2lzUnVubmluZyA9IGZhbHNlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHVzaFBhZ2VcbiAgICogQHNpZ25hdHVyZSBwdXNoUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGEgSFRNTCBkb2N1bWVudCBvciBhIHRlbXBsYXRlIGRlZmluZWQgd2l0aCB0aGUgYDx0ZW1wbGF0ZT5gIHRhZy5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44GvYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhZ2VdXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBPbmx5IG5lY2Vzc2FyeSBpZiBgcGFnZWAgcGFyYW1ldGVyIGlzIG51bGwgb3IgdW5kZWZpbmVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlSFRNTF1cbiAgICogICBbZW5dSFRNTCBjb2RlIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBhcyBhIG5ldyBwYWdlLiBPdmVyd3JpdGVzIGBwYWdlYCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXXB1c2hQYWdlKCnjgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBwdXNoZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ov73liqDjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVB1c2hlcyB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2suWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuaWsOOBl+OBhOODmuODvOOCuOOCueOCv+ODg+OCr+OBq+i/veWKoOOBl+OBvuOBmeOAguaWsOOBl+OBhOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBwdXNoUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHByZXBhcmUgPSBwYWdlRWxlbWVudCA9PiB7XG4gICAgICB2ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICB0aGlzLl9wYWdlTWFwLnNldChwYWdlRWxlbWVudCwgcGFnZSk7XG4gICAgICBwYWdlRWxlbWVudCA9IHV0aWwuZXh0ZW5kKHBhZ2VFbGVtZW50LCB7XG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YVxuICAgICAgfSk7XG4gICAgICBwYWdlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnBhZ2VIVE1MKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGluc3RhbnRQYWdlTG9hZGVyLmxvYWQoe3BhZ2U6IG9wdGlvbnMucGFnZUhUTUwsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgICAgcHJlcGFyZShwYWdlRWxlbWVudCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHByZXBhcmUocGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cblxuICBfcHVzaFBhZ2Uob3B0aW9ucyA9IHt9LCB1cGRhdGUgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpO1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCB7YW5pbWF0aW9uT3B0aW9uc30sIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBwYWdlTGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IGVudGVyUGFnZSAgPSB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZSA9IG9wdGlvbnMubGVhdmVQYWdlIHx8IHRoaXMucGFnZXNbcGFnZUxlbmd0aCAtIDJdO1xuXG4gICAgICB2ZXJpZnlQYWdlRWxlbWVudChlbnRlclBhZ2UpO1xuXG4gICAgICBlbnRlclBhZ2UudXBkYXRlQmFja0J1dHRvbihwYWdlTGVuZ3RoID4gKG9wdGlvbnMuX3JlcGxhY2VQYWdlID8gMiA6IDEpKTtcblxuICAgICAgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLnB1c2hlZE9wdGlvbnMgfHwge30sIG9wdGlvbnMgfHwge30pO1xuICAgICAgZW50ZXJQYWdlLmRhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLmRhdGEgfHwge30sIG9wdGlvbnMuZGF0YSB8fCB7fSk7XG4gICAgICBlbnRlclBhZ2UudW5sb2FkID0gZW50ZXJQYWdlLnVubG9hZCB8fCBvcHRpb25zLnVubG9hZDtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgb3B0aW9ucy5zaG93ICE9PSBmYWxzZSAmJiBzZXRJbW1lZGlhdGUoKCkgPT4gZW50ZXJQYWdlLl9zaG93KCkpO1xuICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdHB1c2gnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgICAgbGVhdmVQYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayAmJiBvcHRpb25zLmNhbGxiYWNrKGVudGVyUGFnZSk7XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgICAgIGFuaW1hdG9yLnB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVwbGFjZVBhZ2VcbiAgICogQHNpZ25hdHVyZSByZXBsYWNlUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVwbGFjZXMgdGhlIGN1cnJlbnQgdG9wIHBhZ2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG9uZS4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjgpLmjIflrprjgZfjgZ/jg5rjg7zjgrjjgavnva7jgY3mj5vjgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVwbGFjZVBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucylcbiAgICAgIC50aGVuKHJlc29sdmVkVmFsdWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc29sdmVkVmFsdWUpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpbnNlcnRQYWdlXG4gICAqIEBzaWduYXR1cmUgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGhlIGluZGV4IHdoZXJlIGl0IHNob3VsZCBiZSBpbnNlcnRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgavmjL/lhaXjgZnjgovkvY3nva7jga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBpbnNlcnRlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5zZXJ0IHRoZSBzcGVjaWZpZWQgcGFnZSBpbnRvIHRoZSBzdGFjayB3aXRoIGF0IGEgcG9zaXRpb24gZGVmaW5lZCBieSB0aGUgYGluZGV4YCBhcmd1bWVudC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9wYWdl44KS44Oa44O844K444K544K/44OD44Kv44GuaW5kZXjjgafmjIflrprjgZfjgZ/kvY3nva7jgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG4gICAgaW5kZXggPSB0aGlzLl9ub3JtYWxpemVJbmRleChpbmRleCk7XG5cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHBhZ2UgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLnBhZ2VIVE1MIDogcGFnZTtcbiAgICBjb25zdCBsb2FkZXIgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBpbnN0YW50UGFnZUxvYWRlciA6IHRoaXMuX3BhZ2VMb2FkZXI7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICB2ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3BhZ2VNYXAuc2V0KHBhZ2VFbGVtZW50LCBwYWdlKTtcbiAgICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgICBwdXNoZWRPcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuXG4gICAgICAgIHBhZ2VFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhZ2VFbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBhZ2VFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHRoaXMucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlbW92ZVBhZ2UoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgcmVtb3ZlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgYvjgonliYrpmaTjgZnjgovjg5rjg7zjgrjjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXZlYWxlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeWJiumZpOOBq+OCiOOBo+OBpuihqOekuuOBleOCjOOBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVtb3ZlIHRoZSBzcGVjaWZpZWQgcGFnZSBhdCBhIHBvc2l0aW9uIGluIHRoZSBzdGFjayBkZWZpbmVkIGJ5IHRoZSBgaW5kZXhgIGFyZ3VtZW50LiBFeHRlbmRzIGBwb3BQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gr44GC44KL44Oa44O844K444KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlbW92ZVBhZ2UoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4IDwgdGhpcy5wYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IGxlYXZlUGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuICAgICAgICBjb25zdCBlbnRlclBhZ2UgPSB0aGlzLnRvcFBhZ2U7XG5cbiAgICAgICAgdGhpcy5fcGFnZU1hcC5kZWxldGUobGVhdmVQYWdlKTtcbiAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQobGVhdmVQYWdlKTtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAxKSB7IC8vIGVkZ2UgY2FzZVxuICAgICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoZW50ZXJQYWdlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3BQYWdlKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlc2V0VG9QYWdlXG4gICAqIEBzaWduYXR1cmUgcmVzZXRUb1BhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucG9wXVxuICAgKiAgIFtlbl1QZXJmb3JtcyAncG9wJyBlZmZlY3QgaWYgYHRydWVgIGluc3RlYWQgb2YgJ3B1c2gnIG9yIG5vbmUuIFRoaXMgYWxzbyBzZXRzIGBvcHRpb25zLmFuaW1hdGlvbmAgdmFsdWUgdG8gYGRlZmF1bHRgIGluc3RlYWQgb2YgYG5vbmVgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbGVhcnMgcGFnZSBzdGFjayBhbmQgYWRkcyB0aGUgc3BlY2lmaWVkIHBhZ2UgdG8gdGhlIHN0YWNrLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOCueOCv+ODg+OCr+OCkuODquOCu+ODg+ODiOOBl+OAgeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXNldFRvUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24gJiYgIW9wdGlvbnMucG9wKSB7XG4gICAgICBvcHRpb25zLmFuaW1hdGlvbiA9ICdub25lJztcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMucGFnZSAmJiAhb3B0aW9ucy5wYWdlSFRNTCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgIHBhZ2UgPSBvcHRpb25zLnBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9wKSB7XG4gICAgICB0aGlzLl9yZW1vdmVQYWdlcygpXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRQYWdlKDAsIHBhZ2UsIHsgZGF0YTogb3B0aW9ucy5kYXRhIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHRoaXMucG9wUGFnZShvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgLy8gVGlwOiBjYWxsYmFjayBydW5zIGJlZm9yZSByZXNvbHZlZCBwcm9taXNlXG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBuZXdQYWdlID0+IHtcbiAgICAgIHRoaXMuX3JlbW92ZVBhZ2VzKClcbiAgICAgIG5ld1BhZ2UudXBkYXRlQmFja0J1dHRvbihmYWxzZSk7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXdQYWdlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBicmluZ1BhZ2VUb3BcbiAgICogQHNpZ25hdHVyZSBicmluZ1BhZ2VUb3AoaXRlbSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGl0ZW1cbiAgICogICBbZW5dUGFnZSBVUkwgb3IgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZSBpbiBuYXZpZ2F0b3IncyBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjga5VUkzjgYvjgoLjgZfjgY/jga9vbnMtbmF2aWdhdG9y44Gu44Oa44O844K444K544K/44OD44Kv44Gu44Kk44Oz44OH44OD44Kv44K55YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHRvcCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQnJpbmdzIHRoZSBnaXZlbiBwYWdlIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc3RhY2sgaWYgaXQgYWxyZWFkeSBleGlzdHMgb3IgcHVzaGVzIGl0IGludG8gdGhlIHN0YWNrIGlmIGRvZXNuJ3QuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44Gu5LiA55Wq5LiK44Gr56e75YuV44GX44G+44GZ44CC44KC44GX5oyH5a6a44GX44Gf44Oa44O844K444GM54Sh44GL44Gj44Gf5aC05ZCI5paw44GX44GPcHVzaOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBicmluZ1BhZ2VUb3AoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKFsnbnVtYmVyJywgJ3N0cmluZyddLmluZGV4T2YodHlwZW9mIGl0ZW0pID09PSAtMSkge1xuICAgICAgdXRpbC50aHJvdygnRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBhZ2UgbmFtZSBvciB0aGUgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZS4gWW91IHN1cHBsaWVkICcgKyBpdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgPyB0aGlzLl9ub3JtYWxpemVJbmRleChpdGVtKSA6IHRoaXMuX2xhc3RJbmRleE9mUGFnZShpdGVtKTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1tpbmRleF07XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgKHtvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlKTtcbiAgICB9XG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICB1dGlsLnRocm93KCdGYWlsZWQgdG8gZmluZCBpdGVtICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwdXNoUGFnZSBpcyBhbHJlYWR5IHJ1bm5pbmcuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBwYWdlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICBwYWdlLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBwYWdlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocGFnZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMpO1xuICB9XG5cbiAgX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT0gJ29iamVjdCcpIHtcbiAgICAgIHV0aWwudGhyb3coJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QuIFlvdSBzdXBwbGllZCAnICsgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKChwYWdlID09PSBudWxsIHx8IHBhZ2UgPT09IHVuZGVmaW5lZCkgJiYgb3B0aW9ucy5wYWdlKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zLCB7cGFnZX0pO1xuXG4gICAgcmV0dXJuIHtwYWdlLCBvcHRpb25zfTtcbiAgfVxuXG4gIF9yZW1vdmVQYWdlcyh0aW1lcykge1xuICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5wYWdlcztcbiAgICBsZXQgdW50aWwgPSB0aW1lcyA9PT0gdW5kZWZpbmVkID8gMCA6IHBhZ2VzLmxlbmd0aCAtIHRpbWVzO1xuICAgIHVudGlsID0gdW50aWwgPCAwID8gMSA6IHVudGlsO1xuXG4gICAgZm9yIChsZXQgaSA9IHBhZ2VzLmxlbmd0aCAtIDI7IGkgPj0gdW50aWw7IGktLSkge1xuICAgICAgdGhpcy5fcGFnZU1hcC5kZWxldGUocGFnZXNbaV0pO1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQocGFnZXNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMucGFnZXNbaW5kZXhdLnVwZGF0ZUJhY2tCdXR0b24oaW5kZXggPiAwKTtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogTWF0aC5hYnModGhpcy5wYWdlcy5sZW5ndGggKyBpbmRleCkgJSB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBvcFBhZ2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICB9XG4gIH1cblxuICBfbGFzdEluZGV4T2ZQYWdlKHBhZ2VOYW1lKSB7XG4gICAgbGV0IGluZGV4O1xuICAgIGZvciAoaW5kZXggPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIGlmICghdGhpcy5fcGFnZU1hcC5oYXModGhpcy5wYWdlc1tpbmRleF0pKSB7XG4gICAgICAgIHV0aWwudGhyb3coJ0luY29ycmVjdCBzdGF0ZSBvZiBwYWdlTWFwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlTmFtZSA9PT0gdGhpcy5fcGFnZU1hcC5nZXQodGhpcy5wYWdlc1tpbmRleF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBfZW1pdFByZUV2ZW50KG5hbWUsIGRhdGEgPSB7fSkge1xuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZScgKyBuYW1lLCB1dGlsLmV4dGVuZCh7XG4gICAgICBuYXZpZ2F0b3I6IHRoaXMsXG4gICAgICBjdXJyZW50UGFnZTogdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0sIGRhdGEpKTtcblxuICAgIHJldHVybiBpc0NhbmNlbGVkO1xuICB9XG5cbiAgX2VtaXRQcmVQdXNoRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRQcmVFdmVudCgncHVzaCcpO1xuICB9XG5cbiAgX2VtaXRQcmVQb3BFdmVudCgpIHtcbiAgICBjb25zdCBsID0gdGhpcy5wYWdlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRQcmVFdmVudCgncG9wJywge1xuICAgICAgbGVhdmVQYWdlOiB0aGlzLnBhZ2VzW2wgLSAxXSxcbiAgICAgIGVudGVyUGFnZTogdGhpcy5wYWdlc1tsIC0gMl1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IOabuOOBjeebtOOBmVxuICBfY3JlYXRlUGFnZUVsZW1lbnQodGVtcGxhdGVIVE1MKSB7XG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwodGVtcGxhdGVIVE1MKSk7XG4gICAgdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgIHJldHVybiBwYWdlRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0b3BQYWdlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHRvcCBwYWdlIGVsZW1lbnQuIFVzZSB0aGlzIG1ldGhvZCB0byBhY2Nlc3Mgb3B0aW9ucyBwYXNzZWQgYnkgYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5rjg7zjgrjjgpLlj5blvpfjgZfjgb7jgZnjgIJwdXNoUGFnZSgp44KEcmVzZXRUb1BhZ2UoKeODoeOCveODg+ODieOBruW8leaVsOOCkuWPluW+l+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgdG9wUGFnZSgpIHtcbiAgICBsZXQgbGFzdCA9IHRoaXMubGFzdEVsZW1lbnRDaGlsZDtcbiAgICB3aGlsZSAobGFzdCAmJiBsYXN0LnRhZ05hbWUgIT09ICdPTlMtUEFHRScpIHsgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZzsgfVxuICAgIHJldHVybiBsYXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlc1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29weSBvZiB0aGUgbmF2aWdhdG9yJ3MgcGFnZSBzdGFjay5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkcmVuKVxuICAgICAgLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09OUy1QQUdFJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uU3dpcGVcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSG9vayBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgc2xpZGVzIHRoZSBuYXZpZ2F0b3IgKHN3aXBlLXRvLXBvcCkuIEl0IGdldHMgYSBkZWNpbWFsIHJhdGlvICgwLTEpIGFuZCBhbiBhbmltYXRpb25PcHRpb25zIG9iamVjdCBhcyBhcmd1bWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvblN3aXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9vblN3aXBlO1xuICB9XG5cbiAgc2V0IG9uU3dpcGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJvblN3aXBlXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGVmYXVsdCBvcHRpb25zIG9iamVjdC4gQXR0cmlidXRlcyBoYXZlIHByaW9yaXR5IG92ZXIgdGhpcyBwcm9wZXJ0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYC5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmNhbGxiYWNrXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvYmplY3QpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb2JqZWN0O1xuICB9XG5cbiAgc2V0IF9pc1J1bm5pbmcodmFsdWUpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnLCB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICB9XG4gIGdldCBfaXNSdW5uaW5nKCkge1xuICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJykpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5sb2FkZWQudGhlbigoKSA9PiB0aGlzLnRvcFBhZ2UgJiYgdGhpcy50b3BQYWdlLl9zaG93KCkpXG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLnRvcFBhZ2UgJiYgdGhpcy50b3BQYWdlLl9oaWRlKClcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE5hdmlnYXRvckFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdOYXZpZ2F0b3InKTtcbiAgICB9XG5cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTmF2aWdhdG9yQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIE5hdmlnYXRvckFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlcHVzaCcsICdwb3N0cHVzaCcsICdwcmVwb3AnLCAncG9zdHBvcCddO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxub25zRWxlbWVudHMuTmF2aWdhdG9yID0gTmF2aWdhdG9yRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW5hdmlnYXRvcicsIE5hdmlnYXRvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3Rvb2xiYXInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAndG9vbGJhci0tKicsXG4gICcudG9vbGJhcl9fbGVmdCc6ICd0b29sYmFyLS0qX19sZWZ0JyxcbiAgJy50b29sYmFyX19jZW50ZXInOiAndG9vbGJhci0tKl9fY2VudGVyJyxcbiAgJy50b29sYmFyX19yaWdodCc6ICd0b29sYmFyLS0qX19yaWdodCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvb2xiYXJcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgIFtlbl1UcmFuc3BhcmVudCB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV3pgI/mmI7jgarog4zmma/jgpLmjIHjgaTjg4Tjg7zjg6vjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGNvdmVyLWNvbnRlbnRcbiAqICAgW2VuXURpc3BsYXlzIHRoZSB0b29sYmFyIG9uIHRvcCBvZiB0aGUgcGFnZSdzIGNvbnRlbnQuIFNob3VsZCBiZSBjb21iaW5lZCB3aXRoIGB0cmFuc3BhcmVudGAgbW9kaWZpZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9zaGFkb3dcbiAqICAgW2VuXVRvb2xiYXIgd2l0aG91dCBzaGFkb3cuWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBq+W9seOCkuS7mOOBkeOBmuOBq+ihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRvb2xiYXIgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBuYXZpZ2F0aW9uLlxuICpcbiAqICAgICBMZWZ0LCBjZW50ZXIgYW5kIHJpZ2h0IGNvbnRhaW5lciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGNsYXNzIG5hbWVzLlxuICpcbiAqICAgICBUaGlzIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYXMgYSBNYXRlcmlhbCBEZXNpZ24gdG9vbGJhciB3aGVuIHJ1bm5pbmcgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44OK44OT44Ky44O844K344On44Oz44Gn5L2/55So44GZ44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Kv44Op44K55ZCN44Gr44KI44KK44CB5bem44CB5Lit5aSu44CB5Y+z44Gu44Kz44Oz44OG44OK44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdG9vbGJhclxuICogQGd1aWRlIGNvbXBpbGF0aW9uLmh0bWwjdG9vbGJhci1jb21waWxhdGlvbiBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dW2phXeODhOODvOODq+ODkOODvOOBrui/veWKoFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYm90dG9tLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1ib3R0b20tdG9vbGJhcj5gIGRpc3BsYXlzIGEgdG9vbGJhciBvbiB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtYm90dG9tLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWJhY2stYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtYmFjay1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhci1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyLWJ1dHRvbj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIHRvb2xiYXIgYnV0dG9uIGluc2lkZSB0aGUgdG9vbGJhci5bL2VuXVxuICogICBbamFdb25zLXRvb2xiYXItYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgICAgQmFja1xuICogICAgICAgPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgVGl0bGVcbiAqICAgICA8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICAgIDxvbnMtaWNvbiBpY29uPVwibWQtbWVudVwiPjwvb25zLWljb24+XG4gKiAgICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9vbnMtdG9vbGJhcj5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5saW5lXG4gICAqIEBpbml0b25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRGlzcGxheSB0aGUgdG9vbGJhciBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjgpLjgqTjg7Pjg6njgqTjg7Pjgavnva7jgY3jgb7jgZnjgILjgrnjgq/jg63jg7zjg6vpoJjln5/lhoXjgavjgZ3jga7jgb7jgb7ooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzdGF0aWNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVN0YXRpYyB0b29sYmFycyBhcmUgbm90IGFuaW1hdGVkIGJ5IGBvbnMtbmF2aWdhdG9yYCB3aGVuIHB1c2hpbmcgb3IgcG9wcGluZyBwYWdlcy4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgaW4gc29tZSBzaXR1YXRpb25zLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGVmdCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmNlbnRlcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcucmlnaHQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19sYWJlbCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9faWNvbicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIHRoaXMuX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMCA7IGktLSkge1xuICAgICAgLy8gY2FzZSBvZiBub3QgZWxlbWVudFxuICAgICAgaWYgKHRoaXMuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZE5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnY2VudGVyJyk7XG4gICAgY2VudGVyLmNsYXNzTGlzdC5hZGQoJ3Rvb2xiYXJfX3RpdGxlJyk7XG5cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgIXRoaXMuY2hpbGRyZW5bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdjZW50ZXInKSkge1xuICAgICAgY29uc3QgbGVmdCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdsZWZ0Jyk7XG4gICAgICBjb25zdCByaWdodCA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdyaWdodCcpO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlblswXSAhPT0gbGVmdCB8fCB0aGlzLmNoaWxkcmVuWzFdICE9PSBjZW50ZXIgfHwgdGhpcy5jaGlsZHJlblsyXSAhPT0gcmlnaHQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChsZWZ0KTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChjZW50ZXIpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHJpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW5zdXJlVG9vbGJhckVsZW1lbnQobmFtZSkge1xuICAgIGlmICh1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRvb2xiYXJfXycgKyBuYW1lKSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcudG9vbGJhcl9fJyArIG5hbWUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuJyArIG5hbWUpIHx8IHV0aWwuY3JlYXRlKCcuJyArIG5hbWUpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndG9vbGJhcl9fJyArIG5hbWUpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cblxub25zRWxlbWVudHMuVG9vbGJhciA9IFRvb2xiYXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9vbGJhcicsIFRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vb25zL2ludGVybmFsL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5pbXBvcnQgJy4vb25zLXRvb2xiYXInOyAvLyBlbnN1cmVzIHRoYXQgJ29ucy10b29sYmFyJyBlbGVtZW50IGlzIHJlZ2lzdGVyZWRcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdwYWdlJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdwYWdlLS0qJyxcbiAgJy5wYWdlX19jb250ZW50JzogJ3BhZ2UtLSpfX2NvbnRlbnQnLFxuICAnLnBhZ2VfX2JhY2tncm91bmQnOiAncGFnZS0tKl9fYmFja2dyb3VuZCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXBhZ2VcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzdHlsZVsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIHRoZSByb290IG9mIGVhY2ggcGFnZS4gSWYgdGhlIGNvbnRlbnQgaXMgbGFyZ2UgaXQgd2lsbCBiZWNvbWUgc2Nyb2xsYWJsZS5cbiAqXG4gKiAgICAgQSBuYXZpZ2F0aW9uIGJhciBjYW4gYmUgYWRkZWQgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSB1c2luZyB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjlrprnvqnjga7jgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7lhoXlrrnjga/jgrnjgq/jg63jg7zjg6vjgYzoqLHlj6/jgZXjgozjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBsaWZlY3ljbGUuaHRtbCNldmVudHNcbiAqICAgW2VuXU92ZXJ2aWV3IG9mIHBhZ2UgZXZlbnRzWy9lbl1cbiAqICAgW2phXU92ZXJ2aWV3IG9mIHBhZ2UgZXZlbnRzWy9qYV1cbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXNbL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVVzZSB0aGUgYDxvbnMtdG9vbGJhcj5gIGVsZW1lbnQgdG8gYWRkIGEgbmF2aWdhdGlvbiBiYXIgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8cD5QYWdlIGNvbnRlbnQ8L3A+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICBteUFwcC5oYW5kbGVyID0gZnVuY3Rpb24oZG9uZSkge1xuICogICAgIGxvYWRNb3JlKCkudGhlbihkb25lKTtcbiAqICAgfVxuICogPC9zY3JpcHQ+XG4gKlxuICogPG9ucy1wYWdlIG9uLWluZmluaXRlLXNjcm9sbD1cIm15QXBwLmhhbmRsZXJcIj5cbiAqICAgPG9ucy10b29sYmFyPlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5MaXN0PC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKlxuICogICA8b25zLWxpc3Q+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzE8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzI8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+IzM8L29ucy1saXN0LWl0ZW0+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLWxpc3Q+XG4gKiA8L29ucy1wYWdlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGluaXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIGF0dGFjaGVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOOCouOCv+ODg+ODgeOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgc2hvd24uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6KGo56S644GV44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBkZXN0cm95XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBiZWZvcmUgdGhlIHBhZ2UgaXMgZGVzdHJveWVkLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOegtOajhOOBleOCjOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IG1vZGlmaWVyIG5hbWUgdG8gc3BlY2lmeSBjdXN0b20gc3R5bGVzLlsvZW5dXG4gICAqICAgW2phXeOCueOCv+OCpOODq+Wumue+qeOCkuOCq+OCueOCv+ODnuOCpOOCuuOBmeOCi+OBn+OCgeOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9uLWluZmluaXRlLXNjcm9sbFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGF0aCBvZiB0aGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gaW5maW5pdGUgc2Nyb2xsaW5nLiBFeGFtcGxlOiBgYXBwLmxvYWREYXRhYC4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgZG9uZSBjYWxsYmFjayB0aGF0IG11c3QgYmUgY2FsbGVkIHdoZW4gaXQncyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fZGVyaXZlSG9va3MoKTtcblxuICAgIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUgPSBkZWZhdWx0Q2xhc3NOYW1lO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudCA9IHRoaXMuX2dldENvbnRlbnRFbGVtZW50KCk7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kRWxlbWVudCA9IHRoaXMuX2dldEJhY2tncm91bmRFbGVtZW50KCk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGNvbnN0IHRvb2xiYXIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKTtcblxuICAgIGNvbnN0IGJhY2tncm91bmQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKSB8fCB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2tncm91bmQnKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYWNrZ3JvdW5kLmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2JhY2tncm91bmQnKTtcbiAgICB0aGlzLmluc2VydEJlZm9yZShiYWNrZ3JvdW5kLCAhdG9vbGJhciAmJiB0aGlzLmZpcnN0Q2hpbGQgfHwgdG9vbGJhciAmJiB0b29sYmFyLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2NvbnRlbnQnKSB8fCB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmNvbnRlbnQnKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2NvbnRlbnQnKTtcbiAgICBpZiAoIWNvbnRlbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSB8fCB0aGlzLl9lbGVtZW50U2hvdWxkQmVNb3ZlZChub2RlKSkge1xuICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZSk7IC8vIENhbiB0cmlnZ2VyIGRldGFjaGVkIGNvbm5lY3RlZENhbGxiYWNrc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl90cnlUb0ZpbGxTdGF0dXNCYXIoY29udGVudCk7IC8vIE11c3QgcnVuIGJlZm9yZSBjaGlsZCBwYWdlcyB0cnkgdG8gZmlsbCBzdGF0dXMgYmFyLlxuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNvbnRlbnQsIGJhY2tncm91bmQubmV4dFNpYmxpbmcpOyAvLyBDYW4gdHJpZ2dlciBhdHRhY2hlZCBjb25uZWN0ZWRDYWxsYmFja3NcblxuICAgIGlmICgoIXRvb2xiYXIgfHwgIXV0aWwuaGFzTW9kaWZpZXIodG9vbGJhciwgJ3RyYW5zcGFyZW50JykpXG4gICAgICAmJiBjb250ZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMVxuICAgICAgJiYgdXRpbC5pc1BhZ2VDb250cm9sKGNvbnRlbnQuY2hpbGRyZW5bMF0pXG4gICAgKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lICs9ICcgcGFnZS0td3JhcHBlcic7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnY2xhc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCBib3R0b21Ub29sYmFyID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1ib3R0b20tdG9vbGJhcicpO1xuICAgIGlmIChib3R0b21Ub29sYmFyKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lICs9ICcgcGFnZS13aXRoLWJvdHRvbS10b29sYmFyJztcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdjbGFzcycpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9lbGVtZW50U2hvdWxkQmVNb3ZlZChlbCkge1xuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhZ2VfX2JhY2tncm91bmQnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0YWdOYW1lID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0YWdOYW1lID09PSAnb25zLWZhYicpIHtcbiAgICAgIHJldHVybiAhZWwuaGFzQXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBmaXhlZEVsZW1lbnRzID0gWydzY3JpcHQnLCAnb25zLXRvb2xiYXInLCAnb25zLWJvdHRvbS10b29sYmFyJywgJ29ucy1tb2RhbCcsICdvbnMtc3BlZWQtZGlhbCcsICdvbnMtZGlhbG9nJywgJ29ucy1hbGVydC1kaWFsb2cnLCAnb25zLXBvcG92ZXInLCAnb25zLWFjdGlvbi1zaGVldCddO1xuICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUoJ2lubGluZScpIHx8IGZpeGVkRWxlbWVudHMuaW5kZXhPZih0YWdOYW1lKSA9PT0gLTE7XG4gIH1cblxuICBfdHJ5VG9GaWxsU3RhdHVzQmFyKGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudCkge1xuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzdGF0dXMtYmFyLWZpbGwnLFxuICAgICAgICAhdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKSAvLyBOb3QgYWxyZWFkeSBmaWxsZWRcbiAgICAgICAgJiYgKHRoaXMuX2NhbkFuaW1hdGVUb29sYmFyKGNvbnRlbnQpIHx8ICF1dGlsLmZpbmRDaGlsZChjb250ZW50LCB1dGlsLmlzUGFnZUNvbnRyb2wpKSAvLyBIYXMgdG9vbGJhciBvciBjYW5ub3QgZGVsZWdhdGVcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBfY2FuQW5pbWF0ZVRvb2xiYXIoY29udGVudCA9IHRoaXMuX2NvbnRlbnRFbGVtZW50KSB7XG4gICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISF1dGlsLmZpbmRDaGlsZChjb250ZW50LCBlbCA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlbCwgJ29ucy10b29sYmFyJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwuaXNBdHRhY2hlZCh0aGlzKSkgeyAvLyBBdm9pZCBkZXRhY2hlZCBjYWxsc1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl90cnlUb0ZpbGxTdGF0dXNCYXIoKTsgLy8gRW5zdXJlIHN0YXR1cyBiYXIgd2hlbiB0aGUgZWxlbWVudCB3YXMgY29tcGlsZWQgYmVmb3JlIGNvbm5lY3RlZFxuXG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29uLWluZmluaXRlLXNjcm9sbCcpKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdvbi1pbmZpbml0ZS1zY3JvbGwnLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMub25Jbml0ICYmIHRoaXMub25Jbml0KCk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdpbml0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKSkge1xuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVCYWNrQnV0dG9uKHNob3cpIHtcbiAgICBpZiAodGhpcy5iYWNrQnV0dG9uKSB7XG4gICAgICBzaG93ID8gdGhpcy5iYWNrQnV0dG9uLnNob3coKSA6IHRoaXMuYmFja0J1dHRvbi5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5hbWUoc3RyKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBzdHIpO1xuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gIH1cblxuICBnZXQgYmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25JbmZpbml0ZVNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1GdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHNjcm9sbGluZyB0byB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgYSBkb25lIGNhbGxiYWNrIGFzIGFuIGFyZ3VtZW50IHRoYXQgbXVzdCBiZSBjYWxsZWQgd2hlbiBpdCdzIGZpbmlzaGVkLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBvbkluZmluaXRlU2Nyb2xsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHV0aWwudGhyb3coJ1wib25JbmZpbml0ZVNjcm9sbFwiIG11c3QgYmUgZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fb25JbmZpbml0ZVNjcm9sbCkge1xuICAgICAgICB0aGlzLl9pbmZpbml0ZVNjcm9sbExpbWl0ID0gMC45O1xuICAgICAgICB0aGlzLl9ib3VuZE9uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2NvbnRlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2JvdW5kT25TY3JvbGwpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwgPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBvbkluZmluaXRlU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkluZmluaXRlU2Nyb2xsO1xuICB9XG5cbiAgX29uU2Nyb2xsKCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLl9jb250ZW50RWxlbWVudCxcbiAgICAgIG92ZXJMaW1pdCA9IChjLnNjcm9sbFRvcCArIGMuY2xpZW50SGVpZ2h0KSAvIGMuc2Nyb2xsSGVpZ2h0ID49IHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQ7XG5cbiAgICBpZiAodGhpcy5fb25JbmZpbml0ZVNjcm9sbCAmJiAhdGhpcy5fbG9hZGluZ0NvbnRlbnQgJiYgb3ZlckxpbWl0KSB7XG4gICAgICB0aGlzLl9sb2FkaW5nQ29udGVudCA9IHRydWU7XG4gICAgICB0aGlzLl9vbkluZmluaXRlU2Nyb2xsKCgpID0+IHRoaXMuX2xvYWRpbmdDb250ZW50ID0gZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuICBnZXQgb25EZXZpY2VCYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcjtcbiAgfVxuXG4gIHNldCBvbkRldmljZUJhY2tCdXR0b24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fYmFja0J1dHRvbkhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIodGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgZ2V0IHNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgc2V0IHNjcm9sbFRvcChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnNjcm9sbFRvcCA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgX2dldENvbnRlbnRFbGVtZW50KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHV0aWwudGhyb3coJ0ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2NvbnRlbnRcIiBlbGVtZW50Jyk7XG4gIH1cblxuICBfZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdXRpbC50aHJvdygnRmFpbCB0byBnZXQgXCIucGFnZV9fYmFja2dyb3VuZFwiIGVsZW1lbnQnKTtcbiAgfVxuXG4gIF9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1ib3R0b20tdG9vbGJhcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2dldFRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtdG9vbGJhcicpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnb24taW5maW5pdGUtc2Nyb2xsJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb24taW5maW5pdGUtc2Nyb2xsJzpcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IChkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gdXRpbC5maW5kRnJvbVBhdGgoY3VycmVudCk7XG4gICAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmO1xuICAgICAgICAgICAgZihkb25lKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biAmJiB1dGlsLmlzQXR0YWNoZWQodGhpcykpIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3Nob3duJywgJycpO1xuICAgICAgdGhpcy5vblNob3cgJiYgdGhpcy5vblNob3coKTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnc2hvdycpO1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzaG93bicpO1xuICAgICAgdGhpcy5vbkhpZGUgJiYgdGhpcy5vbkhpZGUoKTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnaGlkZScpO1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5faGlkZSgpO1xuXG4gICAgdGhpcy5vbkRlc3Ryb3kgJiYgdGhpcy5vbkRlc3Ryb3koKTtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2Rlc3Ryb3knKTtcblxuICAgIGlmICh0aGlzLm9uRGV2aWNlQmFja0J1dHRvbikge1xuICAgICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIF9kZXJpdmVIb29rcygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICdvbicgKyBldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gdGhpc1tgXyR7a2V5fWBdLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgdXRpbC50aHJvdyhgXCIke2tleX1cIiBob29rIG11c3QgYmUgYSBmdW5jdGlvbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2BfJHtrZXl9YF0gPSB2YWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2luaXQnLCAnc2hvdycsICdoaWRlJywgJ2Rlc3Ryb3knXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGF0YVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZXIncyBjdXN0b20gZGF0YSBwYXNzZWQgdG8gYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbn1cblxub25zRWxlbWVudHMuUGFnZSA9IFBhZ2VFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcGFnZScsIFBhZ2VFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBjbGFzcyBQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgX2FuaW1hdGUoZWxlbWVudCwge2Zyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaywgcmVzdG9yZSA9IGZhbHNlLCBhbmltYXRpb259KSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgZnJvbSA9IGFuaW1hdGlvbi5mcm9tO1xuICAgICAgdG8gPSBhbmltYXRpb24udG87XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uID0gYW5pbWl0KGVsZW1lbnQpO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uc2F2ZVN0eWxlKCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZShmcm9tKS53YWl0KHRoaXMuZGVsYXkpLnF1ZXVlKHtcbiAgICAgIGNzczogdG8sXG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICB9KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnJlc3RvcmVTdHlsZSgpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5xdWV1ZSgoZG9uZSkgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuXG4gIF9hbmltYXRlQWxsKGVsZW1lbnQsIGFuaW1hdGlvbnMpIHtcbiAgICBPYmplY3Qua2V5cyhhbmltYXRpb25zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9hbmltYXRlKGVsZW1lbnRba2V5XSwgYW5pbWF0aW9uc1trZXldKS5wbGF5KCkpO1xuICB9XG5cbn1cblxuY29uc3QgZmFkZSA9IHtcbiAgb3V0OiB7XG4gICAgZnJvbToge29wYWNpdHk6IDEuMH0sXG4gICAgdG86IHtvcGFjaXR5OiAwfVxuICB9LFxuICBpbjoge1xuICAgIGZyb206IHtvcGFjaXR5OiAwfSxcbiAgICB0bzoge29wYWNpdHk6IDEuMH1cbiAgfVxufTtcblxuZXhwb3J0IGNsYXNzIE1ERmFkZVBvcG92ZXJBbmltYXRvciBleHRlbmRzIFBvcG92ZXJBbmltYXRvciB7XG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLmluLFxuICAgICAgX3BvcG92ZXI6IHthbmltYXRpb246IGZhZGUuaW4sIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG5cbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUub3V0LFxuICAgICAgX3BvcG92ZXI6IHthbmltYXRpb246IGZhZGUub3V0LCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSU9TRmFkZVBvcG92ZXJBbmltYXRvciBleHRlbmRzIE1ERmFkZVBvcG92ZXJBbmltYXRvciB7XG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLmluLFxuICAgICAgX3BvcG92ZXI6IHtcbiAgICAgICAgZnJvbToge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4zLCAxLjMsIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgdG86IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMCwgMS4wLCAgMS4wKScsXG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3RvcmU6IHRydWUsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBQb3BvdmVyQW5pbWF0b3IsIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsIE1ERmFkZVBvcG92ZXJBbmltYXRvciB9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcbmltcG9ydCBCYXNlRGlhbG9nRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZGlhbG9nJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucG9wb3Zlcic6ICdwb3BvdmVyLS0qJyxcbiAgJy5wb3BvdmVyLW1hc2snOiAncG9wb3Zlci1tYXNrLS0qJyxcbiAgJy5wb3BvdmVyX19jb250ZW50JzogJ3BvcG92ZXItLSpfX2NvbnRlbnQnLFxuICAnLnBvcG92ZXJfX2Fycm93JzogJ3BvcG92ZXItLSpfX2Fycm93J1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZVBvcG92ZXJBbmltYXRvciA6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdub25lJzogUG9wb3ZlckFuaW1hdG9yLFxuICAnZmFkZS1pb3MnOiBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yLFxuICAnZmFkZS1tZCc6IE1ERmFkZVBvcG92ZXJBbmltYXRvclxufTtcblxuY29uc3QgcG9zaXRpb25zID0ge1xuICB1cDogJ2JvdHRvbScsXG4gIGxlZnQ6ICdyaWdodCcsXG4gIGRvd246ICd0b3AnLFxuICByaWdodDogJ2xlZnQnXG59O1xuXG5jb25zdCBkaXJlY3Rpb25zID0gT2JqZWN0LmtleXMocG9zaXRpb25zKTtcbi8qKlxuICogQGVsZW1lbnQgb25zLXBvcG92ZXJcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgY29tcG9uZW50IHRoYXQgZGlzcGxheXMgYSBwb3BvdmVyIG5leHQgdG8gYW4gZWxlbWVudC4gVGhlIHBvcG92ZXIgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBleHRyYSBpbmZvcm1hdGlvbiBhYm91dCBhIGNvbXBvbmVudCBvciBhIHRvb2x0aXAuXG4gKlxuICogICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlUG9wb3Zlcih0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPHRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC4gRm9yIE1hdGVyaWFsIERlc2lnbiwgcG9wb3ZlciBsb29rcyBleGFjdGx5IGFzIGEgZHJvcGRvd24gbWVudS5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcG9wb3ZlclxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XG4gKiAgIENsaWNrIG1lIVxuICogPC9vbnMtYnV0dG9uPlxuICpcbiAqIDxvbnMtcG9wb3ZlciBkaXJlY3Rpb249XCJkb3duXCIgaWQ9XCJwb3BvdmVyXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBwb3BvdmVyITwvcD5cbiAqIDwvb25zLXBvcG92ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHZhciBwb3BvdmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcG92ZXInKTtcbiAqICAgICBwb3BvdmVyLnNob3coZWxlbWVudCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAg5oyH5a6a44Gn44GN44KL5pa55ZCR44Gv44CBXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBrjTjgaTjgafjgZnjgILnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJcbiAgICogICAg6KSH5pWw5oyH5a6a44GV44KM44Gf5aC05ZCI44CB5a++6LGh44Go44GZ44KL6KaB57Sg44Gr5ZCI44KP44Gb44Gm5oyH5a6a44GX44Gf5YCk44GL44KJ6Ieq5YuV55qE44Gr6YG45oqe44GV44KM44G+44GZ44CCXG4gICAqICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHNldCB0aGUgcG9wb3ZlciB3aWxsIGNvdmVyIHRoZSB0YXJnZXQgb24gdGhlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXItbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9wb3BvdmVyKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXInKTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgX2Fycm93KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2Fycm93Jyk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogUG9wb3ZlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1BvcG92ZXJBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gIH1cblxuICBfdG9nZ2xlU3R5bGUoc2hvdWxkU2hvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIob3B0aW9ucy50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLl9jbGVhclN0eWxlcygpO1xuICAgIH1cbiAgfVxuXG4gIF9wb3NpdGlvblBvcG92ZXIodGFyZ2V0KSB7XG4gICAgY29uc3Qge19yYWRpdXM6IHJhZGl1cywgX2NvbnRlbnQ6IGNvbnRlbnRFbGVtZW50LCBfbWFyZ2luOiBtYXJnaW59ID0gdGhpcztcbiAgICBjb25zdCBzYWZlQXJlYUxlbmd0aHMgPSBpUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFMZW5ndGhzKCk7XG4gICAgY29uc3Qgc2FmZUFyZWFSZWN0ID0gaVBob25lWFBhdGNoLmdldFNhZmVBcmVhRE9NUmVjdCgpO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaXNNRCA9IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJyk7XG4gICAgY29uc3QgY292ZXIgPSBpc01EICYmIHRoaXMuaGFzQXR0cmlidXRlKCdjb3Zlci10YXJnZXQnKTtcbiAgICBjb25zdCBwYXJlbnQgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJykgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBwYXJlbnREaW1lbnNpb25zID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IG1heFBvc2l0aW9ucyA9IHtcbiAgICAgIHRvcDogTWF0aC5tYXgocGFyZW50RGltZW5zaW9ucy50b3AsIHNhZmVBcmVhUmVjdC50b3ApLFxuICAgICAgbGVmdDogTWF0aC5tYXgocGFyZW50RGltZW5zaW9ucy5sZWZ0LCBzYWZlQXJlYVJlY3QubGVmdCksXG4gICAgICBib3R0b206IE1hdGgubWluKHBhcmVudERpbWVuc2lvbnMuYm90dG9tLCBzYWZlQXJlYVJlY3QuYm90dG9tKSxcbiAgICAgIHJpZ2h0OiBNYXRoLm1pbihwYXJlbnREaW1lbnNpb25zLnJpZ2h0LCBzYWZlQXJlYVJlY3QucmlnaHQpLFxuICAgIH07XG5cbiAgICAvLyBEaXN0YW5jZSBmcm9tIGVhY2ggc2lkZSBvZiB0aGUgc2FmZSBhcmVhICh3aXRoIG1hcmdpbikgdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgY29uc3QgdGFyZ2V0RGlzdGFuY2UgPSB7XG4gICAgICB0b3A6IHRhcmdldFJlY3QudG9wIC0gKG1heFBvc2l0aW9ucy50b3AgKyBtYXJnaW4pLFxuICAgICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0IC0gKG1heFBvc2l0aW9ucy5sZWZ0ICsgbWFyZ2luKSxcbiAgICAgIGJvdHRvbTogKG1heFBvc2l0aW9ucy5ib3R0b20gLSBtYXJnaW4pIC0gdGFyZ2V0UmVjdC5ib3R0b20sXG4gICAgICByaWdodDogKG1heFBvc2l0aW9ucy5yaWdodCAtIG1hcmdpbikgLSB0YXJnZXRSZWN0LnJpZ2h0XG4gICAgfTtcblxuICAgIC8vIERpc3RhbmNlIGZyb20gZWFjaCBzaWRlIG9mIHRoZSBzYWZlIGFyZWEgKHdpdGggbWFyZ2luKSB0byB0aGUgZ2VvbWV0cmljIGNlbnRlciBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBjb25zdCB0YXJnZXRDZW50ZXJEaXN0YW5jZUZyb20gPSB7XG4gICAgICB0b3A6IHRhcmdldFJlY3QudG9wICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LmhlaWdodCAvIDIpIC0gKG1heFBvc2l0aW9ucy50b3AgKyBtYXJnaW4pLFxuICAgICAgbGVmdDogdGFyZ2V0UmVjdC5sZWZ0ICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LndpZHRoIC8gMikgLSAobWF4UG9zaXRpb25zLmxlZnQgKyBtYXJnaW4pLFxuICAgICAgYm90dG9tOiAobWF4UG9zaXRpb25zLmJvdHRvbSAtIG1hcmdpbikgLSB0YXJnZXRSZWN0LmJvdHRvbSArIE1hdGgucm91bmQodGFyZ2V0UmVjdC5oZWlnaHQgLyAyKSxcbiAgICAgIHJpZ2h0OiAobWF4UG9zaXRpb25zLnJpZ2h0IC0gbWFyZ2luKSAtIHRhcmdldFJlY3QucmlnaHQgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3Qud2lkdGggLyAyKVxuICAgIH07XG5cbiAgICBjb25zdCB7dmVydGljYWwsIHByaW1hcnk6IHByaW1hcnlEaXJlY3Rpb24sIHNlY29uZGFyeTogc2Vjb25kYXJ5RGlyZWN0aW9ufSA9IHRoaXMuX2NhbGN1bGF0ZURpcmVjdGlvbnModGFyZ2V0RGlzdGFuY2UpO1xuICAgIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24gPSBwcmltYXJ5RGlyZWN0aW9uO1xuICAgIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgcHJpbWFyeURpcmVjdGlvbik7XG5cbiAgICBjb25zdCBzaXplTmFtZSA9IHZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIC8vIEdldCAucG9wb3Zlcl9fY29udGVudCBzaXplXG4gICAgY29uc3QgY29udGVudFNpemUgPSAoc3R5bGUgPT4gKHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpLCAxMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpLCAxMClcbiAgICB9KSkod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGVudEVsZW1lbnQpKTtcblxuICAgIC8vIFNldHRpbmcgLnBvcG92ZXIgcG9zaXRpb24uXG4gICAgY29uc3QgdGFyZ2V0QW5kQXJyb3dMZW5ndGggPSBjb3ZlciA/IDAgOiAodmVydGljYWwgPyB0YXJnZXRSZWN0LmhlaWdodCA6IHRhcmdldFJlY3Qud2lkdGgpICsgKGlzTUQgPyAwIDogMTQpO1xuICAgIGNvbnN0IHByaW1hcnlPZmZzZXQgPSBNYXRoLm1heChcbiAgICAgIHNhZmVBcmVhTGVuZ3Roc1twcmltYXJ5RGlyZWN0aW9uXSArIG1hcmdpbixcbiAgICAgIHNhZmVBcmVhTGVuZ3Roc1twcmltYXJ5RGlyZWN0aW9uXSArIG1hcmdpbiArIHRhcmdldERpc3RhbmNlW3ByaW1hcnlEaXJlY3Rpb25dICsgdGFyZ2V0QW5kQXJyb3dMZW5ndGhcbiAgICApO1xuICAgIGNvbnN0IHNlY29uZGFyeU9mZnNldCA9IE1hdGgubWF4KFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3NlY29uZGFyeURpcmVjdGlvbl0gKyBtYXJnaW4sXG4gICAgICBzYWZlQXJlYUxlbmd0aHNbc2Vjb25kYXJ5RGlyZWN0aW9uXSArIG1hcmdpbiArIHRhcmdldENlbnRlckRpc3RhbmNlRnJvbVtzZWNvbmRhcnlEaXJlY3Rpb25dIC0gKGNvbnRlbnRTaXplW3NpemVOYW1lXSAvIDIpXG4gICAgKTtcbiAgICB0aGlzLl9wb3BvdmVyLnN0eWxlW3ByaW1hcnlEaXJlY3Rpb25dID0gcHJpbWFyeU9mZnNldCArICdweCc7XG4gICAgdGhpcy5fcG9wb3Zlci5zdHlsZVtzZWNvbmRhcnlEaXJlY3Rpb25dID0gc2Vjb25kYXJ5T2Zmc2V0ICsgJ3B4JztcblxuICAgIC8vIFNldHRpbmcgLnBvcG92ZXJfX2Fycm93IHBvc2l0aW9uLlxuICAgIHRoaXMuX2Fycm93LnN0eWxlW3NlY29uZGFyeURpcmVjdGlvbl0gPSBNYXRoLm1heChcbiAgICAgIHJhZGl1cyxcbiAgICAgIChzYWZlQXJlYUxlbmd0aHNbc2Vjb25kYXJ5RGlyZWN0aW9uXSArIG1hcmdpbikgKyB0YXJnZXRDZW50ZXJEaXN0YW5jZUZyb21bc2Vjb25kYXJ5RGlyZWN0aW9uXSAtIHNlY29uZGFyeU9mZnNldFxuICAgICkgKyAncHgnO1xuICB9XG5cbiAgX2NhbGN1bGF0ZURpcmVjdGlvbnMoZGlzdGFuY2UpIHtcbiAgICBjb25zdCBvcHRpb25zID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSB8fCAndXAgZG93biBsZWZ0IHJpZ2h0Jykuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBwb3NpdGlvbnNbZV0pO1xuICAgIGNvbnN0IHByaW1hcnkgPSBvcHRpb25zLnNvcnQoKGEsIGIpID0+IGRpc3RhbmNlW2FdIC0gZGlzdGFuY2VbYl0pWzBdO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gJ3RvcCcgPT0gcHJpbWFyeSB8fCAnYm90dG9tJyA9PSBwcmltYXJ5O1xuICAgIGxldCBzZWNvbmRhcnk7XG5cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIHNlY29uZGFyeSA9IGRpc3RhbmNlLmxlZnQgPCBkaXN0YW5jZS5yaWdodCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlY29uZGFyeSA9IGRpc3RhbmNlLnRvcCA8IGRpc3RhbmNlLmJvdHRvbSA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt2ZXJ0aWNhbCwgcHJpbWFyeSwgc2Vjb25kYXJ5fTtcbiAgfVxuXG4gIF9jbGVhclN0eWxlcygpIHtcbiAgICB0aGlzLl9jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddLmZvckVhY2goZSA9PiB7XG4gICAgICB0aGlzLl9hcnJvdy5zdHlsZVtlXSA9IHRoaXMuX2NvbnRlbnQuc3R5bGVbZV0gPSB0aGlzLl9wb3BvdmVyLnN0eWxlW2VdID0gJyc7XG4gICAgICB1dGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRhcmdldCkge1xuICAgICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIodGhpcy5fY3VycmVudFRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGlmICh0aGlzLl9wb3BvdmVyICYmIHRoaXMuX21hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNEZWZhdWx0Q29udGFpbmVyID0gdGhpcy5fcG9wb3ZlciAmJiB0aGlzLl9jb250ZW50O1xuXG4gICAgaWYgKGhhc0RlZmF1bHRDb250YWluZXIpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWFzay5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyLW1hc2snKTtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobWFzaywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9hcnJvdykge1xuICAgICAgICBjb25zdCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhcnJvdy5jbGFzc0xpc3QuYWRkKCdwb3BvdmVyX19hcnJvdycpO1xuICAgICAgICB0aGlzLl9wb3BvdmVyLmFwcGVuZENoaWxkKGFycm93KTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVGcmFnbWVudChgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyLW1hc2tcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlcl9fY29udGVudFwiPjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19hcnJvd1wiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGApO1xuICAgICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlLnF1ZXJ5U2VsZWN0b3IoJy5wb3BvdmVyX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRSFcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIHRoaXMuX3BvcG92ZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpKTtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KHRhcmdldCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ3xFdmVudHxIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LiBDYW4gYmUgZWl0aGVyIGEgQ1NTIHNlbGVjdG9yLCBhbiBldmVudCBvYmplY3Qgb3IgYSBET00gZWxlbWVudC4gSXQgY2FuIGJlIGFsc28gcHJvdmlkZWQgYXMgJ29wdGlvbnMudGFyZ2V0JyBpbnN0ZWFkLiBbL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgr/jg7zjgrLjg4Pjg4jjgajjgarjgovopoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJDU1Pjgrvjg6zjgq/jgr/jgYtldmVudOOCquODluOCuOOCp+OCr+ODiOOBi0RPTeimgee0oOOBruOBhOOBmuOCjOOBi+OCkua4oeOBm+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbiB0aGUgcG9wb3ZlciBhbmQgcG9pbnQgaXQgYXQgYSB0YXJnZXQuIFRoZSB0YXJnZXQgY2FuIGJlIGVpdGhlciBhbiBldmVudCwgYSBDU1Mgc2VsZWN0b3Igb3IgYSBET00gZWxlbWVudC4uWy9lbl1cbiAgICogICBbamFd5a++6LGh44Go44GZ44KL6KaB57Sg44Gr44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GX44G+44GZ44CCdGFyZ2V05byV5pWw44Gr44Gv44CBJGV2ZW5044Kq44OW44K444Kn44Kv44OI44KERE9N44Ko44Os44Oh44Oz44OI44KEQ1NT44K744Os44Kv44K/44KS5rih44GZ44GT44Go44GM5Ye65p2l44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3codGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBDb3B5IG9wdGlvbnMgYW5kIGluY2x1ZGUgb3B0aW9ucy50YXJnZXRcbiAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmICEodGFyZ2V0IGluc3RhbmNlb2YgRXZlbnQpICYmICEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICBvcHRpb25zID0geyAuLi50YXJnZXQgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdGFyZ2V0IH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLnRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnRhcmdldCBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICBvcHRpb25zLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0LnRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoIShvcHRpb25zLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHRhcmdldCB0eXBlIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5zaG93KG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuICBVc2Ugb25lIG9mIGBcImZhZGUtaW9zXCJgLCBgXCJmYWRlLW1kXCJgLCBgXCJub25lXCJgIGFuZCBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZS1pb3NcIiwgXCJmYWRlLW1kXCIsIFwibm9uZVwiLCBcImRlZmF1bHRcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzpmqDjgozjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2xvc2UgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBBIGJvb2xlYW4gdmFsdWUgdGhhdCBzcGVjaWZpZXMgd2hldGhlciB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIG9yIG5vdC5cbiAgICpcbiAgICogICAgIFdoZW4gdGhlIHBvcG92ZXIgaXMgY2FuY2VsYWJsZSBpdCBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgICB0aGlzLl9tYXJnaW4gPSB0aGlzLl9tYXJnaW4gfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZ2V0UHJvcGVydHlWYWx1ZSgndG9wJykpO1xuICAgIHRoaXMuX21hcmdpbiA9IHRoaXMuX21hcmdpbiB8fCA2OyAvLyBGaXggZm9yIGlmcmFtZXNcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yYWRpdXMgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9jb250ZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItdG9wLWxlZnQtcmFkaXVzJykpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICdkaXJlY3Rpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdkaXJlY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYm91bmRPbkNoYW5nZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgdGhpcy5fY3VycmVudERpcmVjdGlvbiAmJiB1dGlsLmFkZE1vZGlmaWVyKHRoaXMsIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24pO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtQb3BvdmVyQW5pbWF0b3J9IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvcG92ZXJBbmltYXRvcikpIHtcbiAgICAgIHV0aWwudGhyb3dBbmltYXRvcignUG9wb3ZlcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgUG9wb3ZlckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBQb3BvdmVyQW5pbWF0b3I7XG4gIH1cbn1cblxub25zRWxlbWVudHMuUG9wb3ZlciA9IFBvcG92ZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcG9wb3ZlcicsIFBvcG92ZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1iYXInOiAncHJvZ3Jlc3MtYmFyLS0qJyxcbiAgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtYmFyLS0qX19wcmltYXJ5JyxcbiAgJy5wcm9ncmVzcy1iYXJfX3NlY29uZGFyeSc6ICdwcm9ncmVzcy1iYXItLSpfX3NlY29uZGFyeSdcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3NlY29uZGFyeVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJfX3ByaW1hcnlcIj48L2Rpdj5cbiAgPC9kaXY+XG5gKTtcblxuY29uc3QgSU5ERVQgPSAnaW5kZXRlcm1pbmF0ZSc7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXByb2dyZXNzLWJhclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIHByb2dyZXNzIGJhci5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44K544K/44Kk44Or44Gn44OX44Ot44Kw44Os44K544OQ44O844KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhlIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBsaW5lYXIgcHJvZ3Jlc3MgYmFyLiBJdCBjYW4gZWl0aGVyIGRpc3BsYXkgYSBwcm9ncmVzcyBiYXIgdGhhdCBzaG93cyB0aGUgdXNlciBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkLiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgcGVyY2VudGFnZSBpcyBub3Qga25vd24gaXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhbiBhbmltYXRlZCBwcm9ncmVzcyBiYXIgc28gdGhlIHVzZXIgY2FuIHNlZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB6dlFiR2pcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wcm9ncmVzc1xuICogQHNlZWFsc28gb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1iYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxuICpcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NCYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NvbXBpbGVkKCkpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fcHJpbWFyeScpO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5Jyk7XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9pc0NvbXBpbGVkKCkge1xuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhckVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZChiYXJFbGVtZW50LCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3ZhbHVlJywgJ3NlY29uZGFyeS12YWx1ZScsIElOREVUXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpICYmIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdzZWNvbmRhcnktdmFsdWUnKSB7XG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gSU5ERVQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB1dGlsLnRvZ2dsZU1vZGlmaWVyKHRoaXMsIElOREVULCB7IGZvcmNlOiB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCkgfSkpO1xuICB9XG5cbiAgX3VwZGF0ZVZhbHVlKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlLndpZHRoID0gKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICAgIHRoaXMuX3NlY29uZGFyeS5zdHlsZS53aWR0aCA9IHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSArICclJyA6ICcwJSc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdXRpbC50aHJvdygnSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdXRpbC50aHJvdygnSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgc2Vjb25kYXJ5VmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmRldGVybWluYXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShJTkRFVCwgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKElOREVUKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlByb2dyZXNzQmFyID0gUHJvZ3Jlc3NCYXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHJvZ3Jlc3MtYmFyJywgUHJvZ3Jlc3NCYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcic6ICdwcm9ncmVzcy1jaXJjdWxhci0tKicsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX2JhY2tncm91bmQnOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX2JhY2tncm91bmQnLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qX19wcmltYXJ5JyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qX19zZWNvbmRhcnknXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxzdmcgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhclwiPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fYmFja2dyb3VuZFwiIC8+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnlcIiBjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjQwJVwiIC8+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5XCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIHI9XCI0MCVcIiAvPlxuICA8L3N2Zz5cbmApO1xuXG5jb25zdCBJTkRFVCA9ICdpbmRldGVybWluYXRlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuIEl0IGNhbiBlaXRoZXIgYmUgdXNlZCB0byBzaG93IGhvdyBtdWNoIG9mIGEgdGFzayBoYXMgYmVlbiBjb21wbGV0ZWQgb3IgdG8gc2hvdyBhIGxvb3BpbmcgYW5pbWF0aW9uIHRvIGluZGljYXRlIHRoYXQgYW4gb3BlcmF0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIEVWek1qUlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzLWNpcmN1bGFyXG4gKiBAc2VlYWxzbyBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtcHJvZ3Jlc3MtYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFyIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgdmFsdWU9XCI1NVwiXG4gKiAgc2Vjb25kYXJ5LXZhbHVlPVwiODdcIj5cbiAqIDwvb25zLXByb2dyZXNzLWNpcmN1bGFyPlxuICpcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICBpbmRldGVybWluYXRlPlxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAndmFsdWUnLCAnc2Vjb25kYXJ5LXZhbHVlJywgSU5ERVRdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCkgJiYgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBJTkRFVCkge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHV0aWwudG9nZ2xlTW9kaWZpZXIodGhpcywgSU5ERVQsIHsgZm9yY2U6IHRoaXMuaGFzQXR0cmlidXRlKElOREVUKSB9KSk7XG4gIH1cblxuICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXIgPSBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fcHJpbWFyeS5zdHlsZVsnc3Ryb2tlLWRhc2hhcnJheSddID0gcGVyICsgJyUsIDI1MS4zMiUnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9ICBNYXRoLmNlaWwodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICogMjUxLjMyICogMC4wMSk7XG4gICAgICAgIHRoaXMuX3NlY29uZGFyeS5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdXRpbC50aHJvdygnSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd2YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2Vjb25kYXJ5VmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc2Vjb25kYXJ5IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7vvJLnlarnm67jga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCBzZWNvbmRhcnlWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdXRpbC50aHJvdygnSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgc2Vjb25kYXJ5VmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmRldGVybWluYXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShJTkRFVCwgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKElOREVUKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29tcGlsZWQoKSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaW1hcnkgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSwgJy5wcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeScpO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknKTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2lzQ29tcGlsZWQoKSB7XG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdmcgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHN2ZywgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHN2ZywgJy5wcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxub25zRWxlbWVudHMuUHJvZ3Jlc3NDaXJjdWxhciA9IFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHJvZ3Jlc3MtY2lyY3VsYXInLCBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi9vbnMvYW5pbWl0JztcblxuY29uc3QgU1RBVEVfSU5JVElBTCA9ICdpbml0aWFsJztcbmNvbnN0IFNUQVRFX1BSRUFDVElPTiA9ICdwcmVhY3Rpb24nO1xuY29uc3QgU1RBVEVfQUNUSU9OID0gJ2FjdGlvbic7XG5cbmNvbnN0IHRocm93VHlwZSA9IChlbCwgdHlwZSkgPT4gdXRpbC50aHJvdyhgXCIke2VsfVwiIG11c3QgYmUgJHt0eXBlfWApO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wdWxsLWhvb2tcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IGFkZHMgKipQdWxsIHRvIHJlZnJlc2gqKiBmdW5jdGlvbmFsaXR5IHRvIGFuIGA8b25zLXBhZ2U+YCBlbGVtZW50LlxuICpcbiAqICAgICBJdCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGEgdGFzayB3aGVuIHRoZSB1c2VyIHB1bGxzIGRvd24gYXQgdGhlIHRvcCBvZiB0aGUgcGFnZS4gQSBjb21tb24gdXNhZ2UgaXMgdG8gcmVmcmVzaCB0aGUgZGF0YSBkaXNwbGF5ZWQgaW4gYSBwYWdlLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIFdiSm9nTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3B1bGwtaG9va1xuICogQGV4YW1wbGVcbiAqIDxvbnMtcGFnZT5cbiAqICAgPG9ucy1wdWxsLWhvb2s+XG4gKiAgICAgUmVsZWFzZSB0byByZWZyZXNoXG4gKiAgIDwvb25zLXB1bGwtaG9vaz5cbiAqIDwvb25zLXBhZ2U+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignb25zLXB1bGwtaG9vaycpLm9uQWN0aW9uID0gZnVuY3Rpb24oZG9uZSkge1xuICogICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVsbEhvb2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2hhbmdlc3RhdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN0YXRlIGlzIGNoYW5nZWQuIFRoZSBzdGF0ZSBjYW4gYmUgZWl0aGVyIFwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiIG9yIFwiYWN0aW9uXCIuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu54q25oWL44GM5aSJ44KP44Gj44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CC54q25oWL44Gv44CBXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIsIFwiYWN0aW9uXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wdWxsSG9va1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5zdGF0ZVxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrueKtuaFi+WQjeOCkuWPgueFp+OBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIFwicHVsbC10by1yZWZyZXNoXCIgZnVuY3Rpb25hbGl0eSBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIFkaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOCouOCr+OCt+ODp+ODs+OBjOWun+ihjOOBleOCjOOBquOBj+OBquOCiuOBvuOBmVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaGVpZ2h0IG9mIHRoZSBjb21wb25lbnQuIFdoZW4gcHVsbGVkIGRvd24gZnVydGhlciB0aGFuIHRoaXMgdmFsdWUgaXQgd2lsbCBzd2l0Y2ggdG8gdGhlIFwicHJlYWN0aW9uXCIgc3RhdGUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiNjRweFwiLlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBrumrmOOBleS7peS4iuOBq3B1bGwgZG93buOBmeOCi+OBqFwicHJlYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga7lgKTjga9cIjY0cHhcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRocmVzaG9sZC1oZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIHRocmVzaG9sZCBoZWlnaHQuIFRoZSBjb21wb25lbnQgYXV0b21hdGljYWxseSBzd2l0Y2hlcyB0byB0aGUgXCJhY3Rpb25cIiBzdGF0ZSB3aGVuIHB1bGxlZCBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI5NnB4XCIuIEEgbmVnYXRpdmUgdmFsdWUgd2lsbCBkaXNhYmxlIHRoaXMgcHJvcGVydHkuIElmIHRoaXMgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgaGVpZ2h0LCBpdCB3aWxsIHNraXAgXCJwcmVhY3Rpb25cIiBzdGF0ZS5bL2VuXVxuICAgKiAgIFtqYV3plr7lgKTjgajjgarjgovpq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lgKTjgafmjIflrprjgZfjgZ/pq5jjgZXjgojjgorjgoJwdWxsIGRvd27jgZnjgovjgajjgIHjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/oh6rli5XnmoTjgatcImFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtY29udGVudFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjb250ZW50IG9mIHRoZSBwYWdlIHdpbGwgbm90IG1vdmUgd2hlbiBwdWxsaW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeODl+ODq+ODleODg+OCr+OBjOW8leOBjeWHuuOBleOCjOOBpuOBhOOCi+aZguOBq+OCguOCs+ODs+ODhuODs+ODhOOBr+WLleOBjeOBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9zaG91bGRGaXhTY3JvbGwgPSB1dGlsLmdsb2JhbHMuaXNVSVdlYlZpZXc7XG5cbiAgICB0aGlzLl9vbkRyYWcgPSB0aGlzLl9vbkRyYWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdTdGFydCA9IHRoaXMuX29uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnRW5kID0gdGhpcy5fb25EcmFnRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCwgdHJ1ZSk7XG4gICAgdGhpcy5faGlkZSgpOyAvLyBGaXggZm9yIHRyYW5zcGFyZW50IHRvb2xiYXIgdHJhbnNpdGlvbnNcbiAgfVxuXG4gIF9zZXRTdHlsZSgpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgc3R5bGVyKHRoaXMsIHsgaGVpZ2h0LCBsaW5lSGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID09PSAnJyAmJiB0aGlzLl9zaG93KCk7XG4gIH1cblxuICBfb25TY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCAwKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgX2NhbkNvbnN1bWVHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICByZXR1cm4gZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICd1cCcgfHwgZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICdkb3duJztcbiAgfVxuXG4gIF9vbkRyYWdTdGFydChldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGFwWSA9IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFkgKyB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgY29uc3QgbWF4WSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAvLyBPbmx5IHVzZSBkcmFncyB0aGF0IHN0YXJ0IG5lYXIgdGhlIHB1bGxIb29rIHRvIHJlZHVjZSBmbGlja2VyaW5nc1xuICAgIGNvbnN0IGRyYWdnYWJsZUFyZWFSYXRpbyA9IHRoaXMuX3Nob3VsZEZpeFNjcm9sbCA/IC44IDogMTtcblxuICAgIHRoaXMuX2lnbm9yZURyYWcgPSBldmVudC5jb25zdW1lZCB8fCAodGFwWSA+IG1heFkgKiBkcmFnZ2FibGVBcmVhUmF0aW8pO1xuXG4gICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBjb25zdCBjb25zdW1lID0gZXZlbnQuY29uc3VtZTtcbiAgICAgIGV2ZW50LmNvbnN1bWUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN1bWUgJiYgY29uc3VtZSgpO1xuICAgICAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyBlbGVtZW50cyByZXNpemVzIC5wYWdlX19jb250ZW50IHNvIGl0IGlzIHNhZmVyXG4gICAgICAgIC8vIHRvIGhpZGUgaXQgd2hlbiBvdGhlciBjb21wb25lbnRzIGFyZSBkcmFnZ2VkLlxuICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fY2FuQ29uc3VtZUdlc3R1cmUoZXZlbnQuZ2VzdHVyZSkpIHtcbiAgICAgICAgY29uc3VtZSAmJiBjb25zdW1lKCk7XG4gICAgICAgIGV2ZW50LmNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvdygpOyAvLyBOb3QgZW5vdWdoIGR1ZSB0byAnZHJhZ0xvY2tBeGlzJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0U2Nyb2xsID0gdGhpcy5fcGFnZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkIHx8IHRoaXMuX2lnbm9yZURyYWcgfHwgIXRoaXMuX2NhbkNvbnN1bWVHZXN0dXJlKGV2ZW50Lmdlc3R1cmUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmVjZXNzYXJ5IGR1ZSB0byAnZHJhZ0xvY2tBeGlzJyAoMjVweClcbiAgICBpZiAodGhpcy5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHRoaXMuX3Nob3coKTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IHRhcFkgPSBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRZICsgdGhpcy5fcGFnZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IG1heFkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAvLyBIYWNrIHRvIG1ha2UgaXQgd29yayBvbiBBbmRyb2lkIDQuNCBXZWJWaWV3IGFuZCBpT1MgVUlXZWJWaWV3LiBTY3JvbGxzIG1hbnVhbGx5XG4gICAgLy8gbmVhciB0aGUgdG9wIG9mIHRoZSBwYWdlIHNvIHRoZXJlIHdpbGwgYmUgbm8gaW5lcnRpYWwgc2Nyb2xsIHdoZW4gc2Nyb2xsaW5nIGRvd24uXG4gICAgLy8gQWxsb3dpbmcgZGVmYXVsdCBzY3JvbGxpbmcgd2lsbCBraWxsIGFsbCAndG91Y2htb3ZlJyBldmVudHMuXG4gICAgaWYgKHRoaXMuX3Nob3VsZEZpeFNjcm9sbCkge1xuICAgICAgdGhpcy5fcGFnZUVsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5fc3RhcnRTY3JvbGwgLSBldmVudC5nZXN0dXJlLmRlbHRhWTtcbiAgICAgIC8vIEFsbG93IGluZXJ0aWEgd2hlbiBzY3JvbGxpbmcgZG93biBiZWxvdyA1MCUgb2YgdGhlIHZpZXcgdG8gcmVkdWNlIGZsaWNrZXJpbmdzXG4gICAgICBpZiAoZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uICE9PSAndXAnIHx8ICh0YXBZIDw9IG1heFkgKiAuNSkpIHtcbiAgICAgICAgZXZlbnQuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbCA9IE1hdGgubWF4KGV2ZW50Lmdlc3R1cmUuZGVsdGFZIC0gdGhpcy5fc3RhcnRTY3JvbGwsIDApO1xuICAgIGlmIChzY3JvbGwgIT09IHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbikge1xuXG4gICAgICBjb25zdCB0aCA9IHRoaXMudGhyZXNob2xkSGVpZ2h0O1xuICAgICAgaWYgKHRoID4gMCAmJiBzY3JvbGwgPj0gdGgpIHtcbiAgICAgICAgZXZlbnQuZ2VzdHVyZS5zdG9wRGV0ZWN0KCk7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9maW5pc2goKSk7XG5cbiAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsID49IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX1BSRUFDVElPTik7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0lOSVRJQUwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90cmFuc2xhdGVUbyhzY3JvbGwpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50Lmdlc3R1cmUgfHwgdGhpcy5kaXNhYmxlZCB8fCB0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID4gMCkge1xuICAgICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uO1xuXG4gICAgICBpZiAoc2Nyb2xsID4gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25BY3Rpb25cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYGFjdGlvbmAgc3RhdGUgaWYgaXQgZXhpc3RzLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBnaXZlbiBhIGBkb25lYCBjYWxsYmFjayBhcyBpdCdzIGZpcnN0IGFyZ3VtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQWN0aW9uO1xuICB9XG5cbiAgc2V0IG9uQWN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93VHlwZSgnb25BY3Rpb24nLCAnZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cbiAgICB0aGlzLl9vbkFjdGlvbiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblB1bGxcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSG9vayBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcHVsbHMgdGhlIGVsZW1lbnQuIEl0IGdldHMgdGhlIHB1bGxlZCBkaXN0YW5jZSByYXRpbyAoc2Nyb2xsIC8gaGVpZ2h0KSBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25QdWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9vblB1bGw7XG4gIH1cblxuICBzZXQgb25QdWxsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93VHlwZSgnb25QdWxsJywgJ2Z1bmN0aW9uIG9yIG51bGwnKTtcbiAgICB9XG4gICAgdGhpcy5fb25QdWxsID0gdmFsdWU7XG4gIH1cblxuICBfZmluaXNoKCkge1xuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0FDVElPTik7XG4gICAgdGhpcy5fdHJhbnNsYXRlVG8odGhpcy5oZWlnaHQsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5vbkFjdGlvbiB8fCAoZG9uZSA9PiBkb25lKCkpO1xuICAgIGFjdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDY0cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93VHlwZSgnaGVpZ2h0JywgJ2ludGVnZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnNjQnLCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHRocmVzaG9sZEhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHRocmVzaG9sZEhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDk2cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgdGhyZXNob2xkSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93VHlwZSgndGhyZXNob2xkSGVpZ2h0JywgJ2ludGVnZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGhyZXNob2xkLWhlaWdodCcsIGAke3ZhbHVlfXB4YCk7XG4gIH1cblxuICBnZXQgdGhyZXNob2xkSGVpZ2h0KCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndGhyZXNob2xkLWhlaWdodCcpIHx8ICc5NicsIDEwKTtcbiAgfVxuXG4gIF9zZXRTdGF0ZShzdGF0ZSwgbm9FdmVudCkge1xuICAgIGNvbnN0IGxhc3RTdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3RhdGUnLCBzdGF0ZSk7XG5cbiAgICBpZiAoIW5vRXZlbnQgJiYgbGFzdFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NoYW5nZXN0YXRlJywge1xuICAgICAgICBwdWxsSG9vazogdGhpcyxcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBsYXN0U3RhdGU6IGxhc3RTdGF0ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzdGF0ZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0YXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHB1bGxEaXN0YW5jZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IG51bWJlciBvZiBwaXhlbHMgdGhlIHB1bGwgaG9vayBoYXMgbW92ZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gf6Led6Zui44KS44OU44Kv44K744Or5pWw44CCWy9qYV1cbiAgICovXG4gIGdldCBwdWxsRGlzdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICAvLyBSdW4gYXN5bmNyaG9ub3VzbHkgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggQW5pbWl0J3Mgc3R5bGUgY2xlYW5cbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICBpZiAodGhpcy5fcGFnZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcGFnZUVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gYC0ke3RoaXMuaGVpZ2h0fXB4YDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZiAodGhpcy5fcGFnZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3BhZ2VFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKi9cbiAgX3RyYW5zbGF0ZVRvKHNjcm9sbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9PSAwICYmIHNjcm9sbCA9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID0gc2Nyb2xsO1xuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMuYW5pbWF0ZSA/IHsgZHVyYXRpb246IC4zLCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknIH0gOiB7fTtcbiAgICB0aGlzLl9vblB1bGwgJiYgdGhpcy5fb25QdWxsKChzY3JvbGwgLyB0aGlzLmhlaWdodCkudG9GaXhlZCgyKSwgb3B0KTtcbiAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gIHRoaXMuaGFzQXR0cmlidXRlKCdmaXhlZC1jb250ZW50JykgPyB0aGlzIDogdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICBhbmltaXQoc2Nyb2xsRWxlbWVudClcbiAgICAgIC5xdWV1ZSh7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDBweCwgJHtzY3JvbGx9cHgsIDBweClgIH0sIG9wdClcbiAgICAgIC5wbGF5KCgpID0+IHtcbiAgICAgICAgc2Nyb2xsID09PSAwICYmIHN0eWxlci5jbGVhcihzY3JvbGxFbGVtZW50LCAndHJhbnNpdGlvbiB0cmFuc2Zvcm0nKTtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9kaXNhYmxlRHJhZ0xvY2soKSB7IC8vIGUyZSB0ZXN0cyBuZWVkIGl0XG4gICAgdGhpcy5fZHJhZ0xvY2tEaXNhYmxlZCA9IHRydWU7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnModHJ1ZSk7XG4gIH1cblxuICBfc2V0dXBMaXN0ZW5lcnMoYWRkKSB7XG4gICAgY29uc3Qgc2Nyb2xsVG9nZ2xlID0gYWN0aW9uID0+IHRoaXMuX3BhZ2VFbGVtZW50W2Ake2FjdGlvbn1FdmVudExpc3RlbmVyYF0oJ3Njcm9sbCcsIHRoaXMuX29uU2Nyb2xsLCBmYWxzZSk7XG4gICAgY29uc3QgZ2RUb2dnbGUgPSBhY3Rpb24gPT4ge1xuICAgICAgY29uc3QgcGFzc2l2ZSA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWcnLCB0aGlzLl9vbkRyYWcsIHBhc3NpdmUpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0LCBwYXNzaXZlKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnZW5kJywgdGhpcy5fb25EcmFnRW5kLCBwYXNzaXZlKTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgZ2RUb2dnbGUoJ29mZicpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHNjcm9sbFRvZ2dsZSgncmVtb3ZlJyk7XG5cbiAgICBpZiAoYWRkKSB7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuX3BhZ2VFbGVtZW50LCB7XG4gICAgICAgIGRyYWdNaW5EaXN0YW5jZTogMSxcbiAgICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogZmFsc2UsXG4gICAgICAgIGRyYWdMb2NrVG9BeGlzOiAhdGhpcy5fZHJhZ0xvY2tEaXNhYmxlZCxcbiAgICAgICAgcGFzc2l2ZTogIXRoaXMuX3Nob3VsZEZpeFNjcm9sbFxuICAgICAgfSk7XG5cbiAgICAgIGdkVG9nZ2xlKCdvbicpO1xuICAgICAgc2Nyb2xsVG9nZ2xlKCdhZGQnKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPSAwO1xuICAgIHRoaXMuX3BhZ2VFbGVtZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnModHJ1ZSk7XG4gICAgdGhpcy5fc2V0U3R5bGUoKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2hpZGUoKTtcbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycyhmYWxzZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydoZWlnaHQnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdoZWlnaHQnICYmIHRoaXMuX3BhZ2VFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2NoYW5nZXN0YXRlJ11cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5QdWxsSG9vayA9IFB1bGxIb29rRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXB1bGwtaG9vaycsIFB1bGxIb29rRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1pbnB1dCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdyYW5nZS0tKicsXG4gICcucmFuZ2VfX2lucHV0JzogJ3JhbmdlLS0qX19pbnB1dCcsXG4gICcucmFuZ2VfX2ZvY3VzLXJpbmcnOiAncmFuZ2UtLSpfX2ZvY3VzLXJpbmcnXG59O1xuXG5jb25zdCBhY3RpdmVDbGFzc1Rva2VuID0gJ3JhbmdlX19pbnB1dC0tYWN0aXZlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmFuZ2VcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzbGlkZXJbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgUmFuZ2UgaW5wdXQgY29tcG9uZW50LiBVc2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgc2xpZGVyLlxuICpcbiAqICAgICBXb3JrcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIGA8aW5wdXQgdHlwZT1cInJhbmdlXCI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhaUW9tTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JhbmdlXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLWlucHV0PmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSB0ZXh0IGlucHV0cywgcmFkaW8gYnV0dG9ucyBhbmQgY2hlY2tib3hlcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXJhbmdlIHZhbHVlPVwiMjBcIj48L29ucy1yYW5nZT5cbiAqIDxvbnMtcmFuZ2UgbW9kaWZpZXI9XCJtYXRlcmlhbFwiIHZhbHVlPVwiMTBcIj48L3JhbmdlPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlRWxlbWVudCBleHRlbmRzIEJhc2VJbnB1dEVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3VzZVVwID0gdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ub3VjaEVuZCA9IHRoaXMuX29uVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbklucHV0ID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnc3RhcnQgPSB0aGlzLl9vbkRyYWdzdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRHJhZ2VuZCA9IHRoaXMuX29uRHJhZ2VuZC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgc3VwZXIuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl91cGRhdGVEaXNhYmxlZCh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSk7XG4gIH1cblxuICAvKiBJbmhlcml0ZWQgcHJvcHMgKi9cblxuICBfdXBkYXRlKCkge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5faW5wdXQ7XG4gICAgY29uc3QgZm9jdXNSaW5nID0gdGhpcy5fZm9jdXNSaW5nO1xuXG4gICAgaW5wdXQuc3R5bGUuYmFja2dyb3VuZFNpemUgPSBgJHsxMDAgKiB0aGlzLl9yYXRpb30lIDJweGA7XG4gICAgZm9jdXNSaW5nLnZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgIC8vIE5PVEU6IFwiX3plcm9cIiBhdHRyaWJ1dGUgaXMgdXNlZCBmb3IgQ1NTIHN0eWxpbmcuXG4gICAgaWYgKChpbnB1dC5taW4gPT09ICcnICYmIGlucHV0LnZhbHVlID09PSAnMCcpIHx8IGlucHV0Lm1pbiA9PT0gaW5wdXQudmFsdWUpIHtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnX3plcm8nLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnX3plcm8nKTtcbiAgICB9XG5cbiAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKGF0dHIgPT4gZm9jdXNSaW5nW2F0dHJdID0gaW5wdXRbYXR0cl0pO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxpbnB1dCB0eXBlPVwiJHt0aGlzLnR5cGV9XCIgY2xhc3M9XCIke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19pbnB1dFwiPlxuICAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIGNsYXNzPVwicmFuZ2VfX2ZvY3VzLXJpbmdcIiB0YWJJbmRleD1cIi0xXCI+XG4gICAgYDtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ3JhbmdlJztcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAncmFuZ2UnO1xuICB9XG5cbiAgLyogT3duIHByb3BzICovXG5cbiAgX29uTW91c2VEb3duKGUpIHtcbiAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QuYWRkKGFjdGl2ZUNsYXNzVG9rZW4pO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9pbnB1dC5mb2N1cygpKTtcbiAgfVxuXG4gIF9vblRvdWNoU3RhcnQoZSkge1xuICAgIHRoaXMuX29uTW91c2VEb3duKCk7XG4gIH1cblxuICBfb25Nb3VzZVVwKGUpIHtcbiAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKGFjdGl2ZUNsYXNzVG9rZW4pO1xuICB9XG5cbiAgX29uVG91Y2hFbmQoZSkge1xuICAgIHRoaXMuX29uTW91c2VVcChlKTtcbiAgfVxuXG4gIF9vbkRyYWdzdGFydChlKSB7XG4gICAgZS5jb25zdW1lZCA9IHRydWU7XG4gICAgZS5nZXN0dXJlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgfVxuXG4gIF9vbkRyYWcoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBfb25EcmFnZW5kKGUpIHtcbiAgICB0aGlzLl9pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKGFjdGl2ZUNsYXNzVG9rZW4pO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gIH1cblxuICBnZXQgX2ZvY3VzUmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblsxXTtcbiAgfVxuXG4gIGdldCBfcmF0aW8oKSB7XG4gICAgLy8gUmV0dXJucyB0aGUgY3VycmVudCByYXRpby5cbiAgICBjb25zdCBtaW4gPSB0aGlzLl9pbnB1dC5taW4gPT09ICcnID8gMCA6IHBhcnNlSW50KHRoaXMuX2lucHV0Lm1pbik7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5faW5wdXQubWF4ID09PSAnJyA/IDEwMCA6IHBhcnNlSW50KHRoaXMuX2lucHV0Lm1heCk7XG5cbiAgICByZXR1cm4gKHRoaXMudmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydkaXNhYmxlZCcsIC4uLkJhc2VJbnB1dEVsZW1lbnQub2JzZXJ2ZWRBdHRyaWJ1dGVzXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKGN1cnJlbnQpO1xuICAgIH1cbiAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICAgKi9cbiAgX3VwZGF0ZURpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ3JhbmdlLS1kaXNhYmxlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ3JhbmdlLS1kaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHRydWUpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnMoZmFsc2UpO1xuICB9XG5cbiAgX3NldHVwTGlzdGVuZXJzKGFkZCkge1xuICAgIGNvbnN0IGFjdGlvbiA9IChhZGQgPyAnYWRkJyA6ICdyZW1vdmUnKSArICdFdmVudExpc3RlbmVyJztcbiAgICB1dGlsW2FjdGlvbl0odGhpcywgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgIHRoaXNbYWN0aW9uXSgndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcbiAgICB0aGlzW2FjdGlvbl0oJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ3N0YXJ0KTtcbiAgICB0aGlzW2FjdGlvbl0oJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdlbmQpO1xuICAgIHRoaXNbYWN0aW9uXSgnaW5wdXQnLCB0aGlzLl9vbklucHV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbn1cblxub25zRWxlbWVudHMuUmFuZ2UgPSBSYW5nZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yYW5nZScsIFJhbmdlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNiBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcblxuLyoqXG4gKiBAY2xhc3MgQW5pbWF0b3JDU1MgLSBpbXBsZW1lbnRhdGlvbiBvZiBBbmltYXRvciBjbGFzcyB1c2luZyBjc3MgdHJhbnNpdGlvbnNcbiAqL1xuY2xhc3MgQW5pbWF0b3JDU1Mge1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFuaW1hdGVcbiAgICogQGRlc2MgbWFpbiBhbmltYXRpb24gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaW5hbENTU1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gLSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC50aGVuKGNhbGxiYWNrKSAtIHNldHMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBzdG9wcGVkXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3RvcChvcHRpb25zKSAtIHN0b3BzIHRoZSBhbmltYXRpb247IGlmIG9wdGlvbnMuc3RvcE5leHQgaXMgdHJ1ZSB0aGVuIGl0IGRvZXNuJ3QgY2FsbCB0aGUgY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5maW5pc2gobXMpIC0gZmluaXNoZXMgdGhlIGFuaW1hdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3BlZWQobXMpIC0gc2V0cyB0aGUgYW5pbWF0aW9uIHNwZWVkIHNvIHRoYXQgaXQgZmluaXNoZXMgYXMgaWYgdGhlIG9yaWdpbmFsIGR1cmF0aW9uIHdhcyB0aGUgb25lIHNwZWNpZmllZCBoZXJlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGBcbiAgICogIHZhciByZXN1bHQgPSBhbmltYXRvci5hbmltYXRlKGVsLCB7b3BhY2l0eTogMC41fSwgMTAwMCk7XG4gICAqXG4gICAqICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgKiAgICByZXN1bHQuc3BlZWQoMjAwKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAqICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgICogICAgfSk7XG4gICAqICB9LCAzMDApO1xuICAgKiBgYGBgXG4gICAqL1xuICBhbmltYXRlKGVsLCBmaW5hbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICB2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICBpbml0aWFsID0ge30sXG4gICAgICAgIHN0b3BwZWQgPSBmYWxzZSxcbiAgICAgICAgbmV4dCA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0ID0gZmFsc2UsXG4gICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmaW5hbCk7XG5cbiAgICB2YXIgdXBkYXRlU3R5bGVzID0gKCkgPT4ge1xuICAgICAgbGV0IHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocy5nZXRQcm9wZXJ0eVZhbHVlLmJpbmQocykpO1xuICAgICAgcyA9IGVsLm9mZnNldEhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0b3A6IChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHZhciBrID0gTWF0aC5taW4oMSwgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbik7XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RvcE5leHQpIHtcbiAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRoZW46IChjYikgPT4ge1xuICAgICAgICBuZXh0ID0gY2I7XG4gICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBzcGVlZDogKG5ld0R1cmF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbmV3RHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgY29uc3QgcGFzc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICAgICAgICAgIGNvbnN0ICBrID0gcGFzc2VkIC8gZHVyYXRpb247XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gbmV3RHVyYXRpb24gKiAoMSAtIGspO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB1cGRhdGVTdHlsZXMoKTtcblxuICAgICAgICAgIHN0YXJ0ID0gZWwuc3BlZWRVcFRpbWU7XG4gICAgICAgICAgZHVyYXRpb24gPSByZW1haW5pbmc7XG5cbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9IGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiAobWlsbGlzZWNvbmRzID0gNTApID0+IHtcbiAgICAgICAgdmFyIGsgPSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICAgIHJlc3VsdC5zcGVlZChtaWxsaXNlY29uZHMgLyAoMSAtIGspKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBzdG9wcGVkIHx8IGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoZSkpO1xuICAgICAgaW5pdGlhbFtlXSA9IGlzTmFOKHYpID8gMCA6IHY7XG4gICAgfSk7XG5cblxuICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gcHJvcGVydGllcy5qb2luKCcsJyk7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgZWwuc3R5bGVbZV0gPSBmaW5hbFtlXSArIChlID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgZHVyYXRpb24pO1xuICAgIHRoaXMuX29uU3RvcEFuaW1hdGlvbnMoZWwsIHJlc3VsdC5zdG9wKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgfVxuXG4gIF9vblN0b3BBbmltYXRpb25zKGVsLCBsaXN0ZW5lcikge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpID0gdGhpcy5faW5kZXgrKztcbiAgICBxdWV1ZVtlbF0gPSBxdWV1ZVtlbF0gfHwgW107XG4gICAgcXVldWVbZWxdW2ldID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGRlbGV0ZSBxdWV1ZVtlbF1baV07XG4gICAgICBpZiAocXVldWVbZWxdICYmIHF1ZXVlW2VsXS5sZW5ndGggPT0gMCkge1xuICAgICAgICBkZWxldGUgcXVldWVbZWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVyKG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbmltYXRpb25zXG4gICogQGRlc2Mgc3RvcHMgYWN0aXZlIGFuaW1hdGlvbnMgb24gYSBzcGVjaWZpZWQgZWxlbWVudFxuICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWxlbWVudCAtIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgIHJldHVybiBlbC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAodGhpcy5fcXVldWVbZWxdIHx8IFtdKS5mb3JFYWNoKGUgPT4geyBlKG9wdGlvbnMgfHwge30pOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFsbFxuICAqIEBkZXNjIHN0b3BzIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFsbChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0b3BBbmltYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIGZhZGVcbiAgKiBAZGVzYyBmYWRlcyB0aGUgZWxlbWVudCAoc2hvcnQgdmVyc2lvbiBmb3IgYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9KSlcbiAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF1cbiAgKi9cbiAgZmFkZShlbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKGVsLCB7b3BhY2l0eTogMH0sIGR1cmF0aW9uKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdG9yQ1NTO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yLWNzcyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3JpcHBsZSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAncmlwcGxlLS0qJyxcbiAgJy5yaXBwbGVfX3dhdmUnOiAncmlwcGxlLS0qX193YXZlJyxcbiAgJy5yaXBwbGVfX2JhY2tncm91bmQnOiAncmlwcGxlLS0qX19iYWNrZ3JvdW5kJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXJpcHBsZVxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBZGRzIGEgTWF0ZXJpYWwgRGVzaWduIFwicmlwcGxlXCIgZWZmZWN0IHRvIGFuIGVsZW1lbnQuIFRoZSByaXBwbGUgZWZmZWN0IHdpbGwgc3ByZWFkIGZyb20gdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSB1c2VyIHRhcHMuXG4gKlxuICogICAgIFNvbWUgZWxlbWVudHMgc3VjaCBhcyBgPG9ucy1idXR0b24+YCBhbmQgYDxvbnMtZmFiPmAgIHN1cHBvcnQgYSBgcmlwcGxlYCBhdHRyaWJ1dGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg6rjg4Pjg5fjg6vlirnmnpzjgpJET03opoHntKDjgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gd0tRV2RaXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmlwcGxlXG4gKiBAbW9kaWZpZXIgbGlnaHQtZ3JheVxuICogICBbZW5dQ2hhbmdlIHRoZSBjb2xvciBvZiBlZmZlY3RzIHRvIGxpZ2h0IGdyYXkuWy9lbl1cbiAqICAgW2phXeOCqOODleOCp+OCr+ODiOOBruiJsuOBjOaYjuOCi+OBhOeBsOiJsuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmdcbiAqICBbZW5dQ3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dXG4gKiAgW2phXUNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxkaXYgY2xhc3M9XCJteS1kaXZcIj5cbiAqICA8b25zLXJpcHBsZT48L29ucy1yaXBwbGU+XG4gKiA8L2Rpdj5cbiAqXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gcmlwcGxlPkNsaWNrIG1lITwvb25zLWJ1dHRvbj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmlwcGxlRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIHJpcHBsZSBlZmZlY3QuWy9lbl1cbiAgICogICBbamFd44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICAgW2phXeOCqOODleOCp+OCr+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGJhY2tncm91bmRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kLlsvZW5dXG4gICAqICAgW2phXeiDjOaZr+OBruiJsuOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpemVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNpemluZyBvZiB0aGUgd2F2ZSBvbiByaXBwbGUgZWZmZWN0LiBTZXQgXCJjb3ZlclwiIG9yIFwiY29udGFpblwiLiBEZWZhdWx0IGlzIFwiY292ZXJcIi5bL2VuXVxuICAgKiAgIFtqYV3jgqjjg5Xjgqfjgq/jg4jjga7jgrXjgqTjgrrjgpLmjIflrprjgZfjgb7jgZnjgIJcImNvdmVyXCLjgoLjgZfjgY/jga9cImNvbnRhaW5cIuOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr1wiY292ZXJcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNlbnRlclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIHByZXNlbnRzLCBjaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHdhdmUgZWZmZWN0IHRvIGNlbnRlciBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44KS6Kit5a6a44GZ44KL44Go44CB44Ko44OV44Kn44Kv44OI44Gu5L2N572u44GM6KaB57Sg44Gu55yf44KT5Lit44GL44KJ5aeL44G+44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgdGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6rjg4Pjg5fjg6vjgqjjg5Xjgqfjgq/jg4jjga/nhKHlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fb25UYXAgPSB0aGlzLl9vblRhcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlbGVhc2UgPSB0aGlzLl9vblJlbGVhc2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuICAgIFsnY29sb3InLCAnY2VudGVyJywgJ3N0YXJ0LXJhZGl1cycsICdiYWNrZ3JvdW5kJywgJ21vZGlmaWVyJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIHRoaXMuX3dhdmUgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fd2F2ZScpWzBdO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fYmFja2dyb3VuZCcpWzBdO1xuXG4gICAgaWYgKCEodGhpcy5fYmFja2dyb3VuZCAmJiB0aGlzLl93YXZlKSkge1xuICAgICAgdGhpcy5fd2F2ZSA9IHV0aWwuY3JlYXRlKCcucmlwcGxlX193YXZlJyk7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdXRpbC5jcmVhdGUoJy5yaXBwbGVfX2JhY2tncm91bmQnKTtcblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl93YXZlKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2dldEVmZmVjdFNpemUoKSB7XG4gICAgY29uc3Qgc2l6ZXMgPSBbJ2NvdmVyJywgJ2NvbnRhaW4nXTtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3NpemUnKSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzaXplJyk7XG4gICAgICBpZiAoc2l6ZXMuaW5kZXhPZihzaXplKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICdjb3Zlcic7XG4gIH1cblxuICBfY2FsY3VsYXRlQ29vcmRzKGUpIHtcbiAgICBsZXQgeCwgeSwgaCwgdywgcjtcbiAgICBjb25zdCBiID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0RWZmZWN0U2l6ZSgpO1xuICAgIGNvbnN0IGVycm9yID0gKCkgPT4gdXRpbC50aHJvdygnUmlwcGxlIGludmFsaWQgc3RhdGUnKTtcblxuICAgIGlmICh0aGlzLl9jZW50ZXIpIHtcbiAgICAgIHggPSBiLndpZHRoIC8gMjtcbiAgICAgIHkgPSBiLmhlaWdodCAvIDI7XG5cbiAgICAgIGlmIChzaXplID09PSAnY292ZXInKSB7XG4gICAgICAgIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPT09ICdjb250YWluJykge1xuICAgICAgICByID0gTWF0aC5taW4oeCwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKHR5cGVvZiBlLmNsaWVudFggPT09ICdudW1iZXInID8gZS5jbGllbnRYIDogZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSAtIGIubGVmdDtcbiAgICAgIHkgPSAodHlwZW9mIGUuY2xpZW50WSA9PT0gJ251bWJlcicgPyBlLmNsaWVudFkgOiBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpIC0gYi50b3A7XG4gICAgICBoID0gTWF0aC5tYXgoeSwgYi5oZWlnaHQgLSB5KTtcbiAgICAgIHcgPSBNYXRoLm1heCh4LCBiLndpZHRoIC0geCk7XG5cbiAgICAgIGlmIChzaXplID09PSAnY292ZXInKSB7XG4gICAgICAgIHIgPSBNYXRoLnNxcnQoaCAqIGggKyB3ICogdyk7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPT09ICdjb250YWluJykge1xuICAgICAgICByID0gTWF0aC5taW4oTWF0aC5yb3VuZChoIC8gMiksIE1hdGgucm91bmQodyAvIDIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHt4LCB5LCByfTtcbiAgfVxuXG4gIF9yaXBwbGVBbmltYXRpb24oZSwgZHVyYXRpb24gPSAzMDApIHtcbiAgICBjb25zdCB7X2FuaW1hdG9yLCBfd2F2ZSwgX2JhY2tncm91bmQsIF9taW5SfSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHksIHJ9ID0gdGhpcy5fY2FsY3VsYXRlQ29vcmRzKGUpO1xuXG4gICAgX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiAxfSk7XG4gICAgX2FuaW1hdG9yLmFuaW1hdGUoX2JhY2tncm91bmQsIHtvcGFjaXR5OiAxfSwgZHVyYXRpb24pO1xuXG4gICAgdXRpbC5leHRlbmQoX3dhdmUuc3R5bGUsIHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0b3A6IHkgLSBfbWluUiArICdweCcsXG4gICAgICBsZWZ0OiB4IC0gX21pblIgKyAncHgnLFxuICAgICAgd2lkdGg6IDIgKiBfbWluUiArICdweCcsXG4gICAgICBoZWlnaHQ6IDIgKiBfbWluUiArICdweCdcbiAgICB9KTtcblxuICAgIHJldHVybiBfYW5pbWF0b3IuYW5pbWF0ZShfd2F2ZSwge1xuICAgICAgdG9wOiB5IC0gcixcbiAgICAgIGxlZnQ6IHggLSByLFxuICAgICAgaGVpZ2h0OiAyICogcixcbiAgICAgIHdpZHRoOiAyICogclxuICAgIH0sIGR1cmF0aW9uKTtcbiAgfVxuXG4gIF91cGRhdGVQYXJlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9wYXJlbnRVcGRhdGVkICYmIHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMucGFyZW50Tm9kZSk7XG4gICAgICBpZiAoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFyZW50VXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgX29uVGFwKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIWUucmlwcGxlKSB7XG4gICAgICBlLnJpcHBsZSA9IHRydWU7XG4gICAgICB0aGlzLl91cGRhdGVQYXJlbnQoKTtcbiAgICAgIHRoaXMuX3JpcHBsZUFuaW1hdGlvbihlLmdlc3R1cmUuc3JjRXZlbnQpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX3dhdmUpO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX2JhY2tncm91bmQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX29uSG9sZChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmICFlLnJpcHBsZSkge1xuICAgICAgZS5yaXBwbGUgPSB0cnVlO1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB9XG4gIH1cblxuICBfb25SZWxlYXNlKGUpIHtcbiAgICBpZiAodGhpcy5faG9sZGluZyAmJiAhZS5yaXBwbGUpIHtcbiAgICAgIGUucmlwcGxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2hvbGRpbmcuc3BlZWQoMzAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9ob2xkaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xuICAgIH1cbiAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgdGhpcy5fb25UYXAoZSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyZW50Tm9kZS5hZGRFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLl9vblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9vbkhvbGQpO1xuICAgICAgdGhpcy5fcGFyZW50Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29uc3QgcG4gPSB0aGlzLl9wYXJlbnROb2RlIHx8IHRoaXMucGFyZW50Tm9kZTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLl9vblRhcCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnc3RhcnQtcmFkaXVzJywgJ2NvbG9yJywgJ2JhY2tncm91bmQnLCAnY2VudGVyJywgJ2NsYXNzJywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuXG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RhcnQtcmFkaXVzJzpcbiAgICAgICAgdGhpcy5fbWluUiA9IE1hdGgubWF4KDAsIHBhcnNlRmxvYXQoY3VycmVudCkgfHwgMCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dhdmUuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKCdiYWNrZ3JvdW5kJykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmFja2dyb3VuZCc6XG4gICAgICAgIGlmIChjdXJyZW50IHx8IGxhc3QpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICBpZiAobmFtZSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0aGlzLl9jZW50ZXIgPSBjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudCAhPSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5SaXBwbGUgPSBSaXBwbGVFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcmlwcGxlJywgUmlwcGxlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcm93XG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sXG4gKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jb2xcbiAqICAgW2VuXVRoZSBgPG9ucy1jb2w+YCBjb21wb25lbnQgaXMgdXNlZCBhcyBjaGlsZHJlbiBvZiBgPG9ucy1yb3c+YC5bL2VuXVxuICogICBbamFdb25zLWNvbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgdmVydGljYWwtYWxpZ24uWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29s44KS57WE44G/5ZCI44KP44Gb44Gm44Gd44KM44Ge44KM44Gub25zLWNvbOimgee0oOOBrnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr5Yil44CF44Gu5YCk44KS5oyH5a6a44GZ44KL44Go44CB5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCdmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavjga/kuIDjgaTjga7lgKTjgaDjgZHjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3J0IGhhbmQgYXR0cmlidXRlIGZvciBhbGlnbmluZyB2ZXJ0aWNhbGx5LiBWYWxpZCB2YWx1ZXMgYXJlIHRvcCwgYm90dG9tLCBhbmQgY2VudGVyLlsvZW5dXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvd0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG59XG5cbm9uc0VsZW1lbnRzLlJvdyA9IFJvd0VsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yb3cnLCBSb3dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc2VnbWVudCc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc2VnbWVudC0tKicsXG4gICcuc2VnbWVudF9faXRlbSc6ICdzZWdtZW50LS0qX19pdGVtJyxcbiAgJy5zZWdtZW50X19pbnB1dCc6ICdzZWdtZW50LS0qX19pbnB1dCcsXG4gICcuc2VnbWVudF9fYnV0dG9uJzogJ3NlZ21lbnQtLSpfX2J1dHRvbidcbn07XG5cbmNvbnN0IGdlbmVyYXRlSWQgPSAoKCkgPT4ge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiAoKSA9PiAnb25zLXNlZ21lbnQtZ2VuLScgKyAoaSsrKTtcbn0pKCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNlZ21lbnRcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzZWdtZW50Wy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFNlZ21lbnQgY29tcG9uZW50LiBVc2UgdGhpcyBjb21wb25lbnQgdG8gaGF2ZSBhIGJ1dHRvbiBiYXIgd2l0aCBhdXRvbWF0aWMgc3R5bGVzIHRoYXQgc3dpdGNoIG9uIGNsaWNrIG9mIGFub3RoZXIgYnV0dG9uLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhcyBhIE1hdGVyaWFsIERlc2lnbiBzZWdtZW50IG9uIEFuZHJvaWQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gaExheXhcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zZWdtZW50XG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc2VnbWVudD5cbiAqICAgPG9ucy1idXR0b24+TGFiZWwgMTwvb25zLWJ1dHRvbj5cbiAqICAgPG9ucy1idXR0b24+TGFiZWwgMjwvb25zLWJ1dHRvbj5cbiAqICAgPG9ucy1idXR0b24+TGFiZWwgMzwvb25zLWJ1dHRvbj5cbiAqIDwvb25zLXNlZ21lbnQ+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VnbWVudEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBhZnRlciB0aGUgYWN0aXZlIGJ1dHRvbiBpcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmluZGV4XG4gICAqICAgW2VuXVRhcHBlZCBidXR0b24gaW5kZXguWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNlZ21lbnRJdGVtXG4gICAqICAgW2VuXVNlZ21lbnQgaXRlbSBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHNlZ21lbnQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0YWJiYXItaWRcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlEIG9mIHRoZSB0YWJiYXIgZWxlbWVudCB0byBcImNvbm5lY3RcIiB0byB0aGUgc2VnbWVudC4gTXVzdCBiZSBpbnNpZGUgdGhlIHNhbWUgcGFnZS5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFjdGl2ZS1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlZmF1bHQgMFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JbmRleCBvZiB0aGUgZmlyc3QgYWN0aXZlIGJ1dHRvbiwgb25seSB3b3JrcyBpZiB0aGVyZSBpcyBubyBjb25uZWN0ZWQgdGFiYmFyIChpbiB3aGljaCBjYXNlIHRoZSBhY3RpdmUgdGFiIHNldHMgdGhlIGFjdGl2ZSBidXR0b24pLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgc2VnbWVudCBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fc2VnbWVudElkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuX3RhYmJhciA9IG51bGw7XG4gICAgdGhpcy5fb25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVGFiYmFyUHJlQ2hhbmdlID0gdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKClcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSB0aGlzLl90YWJiYXIgPyB0aGlzLl90YWJiYXIuZ2V0QWN0aXZlVGFiSW5kZXgoKSA6IHRoaXMuZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKSk7XG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdzZWdtZW50X19pdGVtJyk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gdXRpbC5maW5kQ2hpbGQoaXRlbSwgJy5zZWdtZW50X19pbnB1dCcpIHx8IHV0aWwuY3JlYXRlKCdpbnB1dC5zZWdtZW50X19pbnB1dCcpO1xuICAgICAgaW5wdXQudHlwZSA9ICdyYWRpbyc7XG4gICAgICBpbnB1dC52YWx1ZSA9IGluZGV4O1xuICAgICAgaW5wdXQubmFtZSA9IGlucHV0Lm5hbWUgfHwgdGhpcy5fc2VnbWVudElkO1xuICAgICAgaW5wdXQuY2hlY2tlZCA9ICF0aGlzLmhhc0F0dHJpYnV0ZSgndGFiYmFyLWlkJykgJiYgaW5kZXggPT09IChwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlLWluZGV4JykpIHx8IDApO1xuXG4gICAgICBjb25zdCBidXR0b24gPSB1dGlsLmZpbmRDaGlsZChpdGVtLCAnLnNlZ21lbnRfX2J1dHRvbicpIHx8IHV0aWwuY3JlYXRlKCcuc2VnbWVudF9fYnV0dG9uJyk7XG4gICAgICBpZiAoYnV0dG9uLnBhcmVudEVsZW1lbnQgIT09IGl0ZW0pIHtcbiAgICAgICAgd2hpbGUgKGl0ZW0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChpdGVtLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgaXRlbS5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgndGFiYmFyLWlkJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgICAgIHRoaXMuX3RhYmJhciA9IHBhZ2UgJiYgcGFnZS5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMuZ2V0QXR0cmlidXRlKCd0YWJiYXItaWQnKSk7XG4gICAgICAgIGlmICghdGhpcy5fdGFiYmFyIHx8IHRoaXMuX3RhYmJhci50YWdOYW1lICE9PSAnT05TLVRBQkJBUicpIHtcbiAgICAgICAgICB1dGlsLnRocm93KGBObyB0YWJiYXIgd2l0aCBpZCAke3RoaXMuZ2V0QXR0cmlidXRlKCd0YWJiYXItaWQnKX0gd2FzIGZvdW5kLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGFiYmFyLnNldEF0dHJpYnV0ZSgnaGlkZS10YWJzJywgJycpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2V0Q2hlY2tlZCh0aGlzLl90YWJiYXIuZ2V0QWN0aXZlVGFiSW5kZXgoKSkpO1xuXG4gICAgICAgIHRoaXMuX3RhYmJhci5hZGRFdmVudExpc3RlbmVyKCdwcmVjaGFuZ2UnLCB0aGlzLl9vblRhYmJhclByZUNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fdGFiYmFyKSB7XG4gICAgICAgIHRoaXMuX3RhYmJhci5yZW1vdmVFdmVudExpc3RlbmVyKCdwcmVjaGFuZ2UnLCB0aGlzLl9vblRhYmJhclByZUNoYW5nZSk7XG4gICAgICAgIHRoaXMuX3RhYmJhciA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gIH1cblxuICBfc2V0Q2hlY2tlZChpbmRleCkge1xuICAgIHRoaXMuY2hpbGRyZW5baW5kZXhdLmZpcnN0RWxlbWVudENoaWxkLmNoZWNrZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlQnV0dG9uXG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlQnV0dG9uKGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1CdXR0b24gaW5kZXguWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LCB3b3JrcyBvbmx5IGlmIHRoZXJlIGlzIGEgY29ubmVjdGVkIHRhYmJhci4gU3VwcG9ydHMgdGhlIHNhbWUgb3B0aW9ucyBhcyBgb25zLXRhYmJhcmAncyBgc2V0QWN0aXZlVGFiYCBtZXRob2QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU1ha2UgYnV0dG9uIHdpdGggdGhlIHNwZWNpZmllZCBpbmRleCBhY3RpdmUuIElmIHRoZXJlIGlzIGEgY29ubmVjdGVkIHRhYmJhciBpdCBzaG93cyB0aGUgY29ycmVzcG9uZGluZyB0YWIgcGFnZS4gSW4gdGhpcyBjYXNlIGFuaW1hdGlvbnMgYW5kIHRoZWlyIG9wdGlvbnMgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgc2Vjb25kIHBhcmFtZXRlci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc2VsZWN0ZWQgaW5kZXggb3IgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQgaWYgdGhlcmUgaXMgYSBjb25uZWN0ZWQgdGFiYmFyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVCdXR0b24oaW5kZXgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fdGFiYmFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGFiYmFyLnNldEFjdGl2ZVRhYihpbmRleCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0Q2hlY2tlZChpbmRleCk7XG4gICAgdGhpcy5fcG9zdENoYW5nZShpbmRleCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRBY3RpdmVCdXR0b25JbmRleFxuICAgKiBAc2lnbmF0dXJlIGdldEFjdGl2ZUJ1dHRvbkluZGV4KClcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiAgIFtlbl1UaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIGJ1dHRvbiBpbmRleCBvZiBjdXJyZW50IGFjdGl2ZSBidXR0b24uIElmIGFjdGl2ZSBidXR0b24gaXMgbm90IGZvdW5kLCByZXR1cm5zIC0xLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXRBY3RpdmVCdXR0b25JbmRleCgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgeyAvLyBBcnJheS5maW5kSW5kZXhcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldLmZpcnN0RWxlbWVudENoaWxkLmNoZWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIF9vbkNoYW5nZShldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuX3RhYmJhclxuICAgICAgPyB0aGlzLl90YWJiYXIuc2V0QWN0aXZlVGFiKHRoaXMuZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKSwgeyByZWplY3Q6IGZhbHNlIH0pXG4gICAgICA6IHRoaXMuX3Bvc3RDaGFuZ2UodGhpcy5nZXRBY3RpdmVCdXR0b25JbmRleCgpKTtcbiAgfVxuXG4gIF9vblRhYmJhclByZUNoYW5nZShldmVudCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LmRldGFpbC5jYW5jZWxlZCkge1xuICAgICAgICB0aGlzLl9zZXRDaGVja2VkKGV2ZW50LmluZGV4KTtcbiAgICAgICAgdGhpcy5fcG9zdENoYW5nZShldmVudC5pbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfcG9zdENoYW5nZShpbmRleCkge1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIHtcbiAgICAgIGluZGV4LFxuICAgICAgYWN0aXZlSW5kZXg6IGluZGV4LFxuICAgICAgbGFzdEFjdGl2ZUluZGV4OiB0aGlzLl9sYXN0QWN0aXZlSW5kZXgsXG4gICAgICBzZWdtZW50SXRlbTogdGhpcy5jaGlsZHJlbltpbmRleF1cbiAgICB9KTtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzZWdtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydjbGFzcycsICdtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwb3N0Y2hhbmdlJ107XG4gIH1cbn1cblxub25zRWxlbWVudHMuU2VnbWVudCA9IFNlZ21lbnRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc2VnbWVudCcsIFNlZ21lbnRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWxlY3QtKiBzZWxlY3QtLSonLFxuICAnLnNlbGVjdC1pbnB1dCc6ICdzZWxlY3QtaW5wdXQtLSonXG59O1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3NlbGVjdCc7XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvZm9jdXMnLFxuICAnZGlzYWJsZWQnLFxuICAnZm9ybScsXG4gICdtdWx0aXBsZScsXG4gICduYW1lJyxcbiAgJ3JlcXVpcmVkJyxcbiAgJ3NpemUnXG5dO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zZWxlY3RcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc2VsZWN0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdW5kZXJiYXJcbiAqICBbZW5dRGlzcGxheXMgYSBob3Jpem9udGFsIGxpbmUgdW5kZXJuZWF0aCBhIHNlbGVjdCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBTZWxlY3QgY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBwbGFjZSBhIHNlbGVjdCB3aXRoIGFuIElEIG9mIGBteS1pZGAgb24gYSBwYWdlLCB1c2UgYDxvbnMtc2VsZWN0IHNlbGVjdC1pZD1cIm15LWlkXCI+YC5cbiAqXG4gKiAgICAgVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhcyBhIE1hdGVyaWFsIERlc2lnbiBzZWxlY3Qgb24gQW5kcm9pZC5cbiAqXG4gKiAgICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8c2VsZWN0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFd44K744Os44Kv44OI44Oc44OD44Kv44K544KS6KGo56S644GZ44KL44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCYHNlbGVjdGAg6KaB57Sg44Gr5L2/55So44Gn44GN44KL5bGe5oCn44Gu5aSa44GP44GMIGBvbnMtc2VsZWN0YCDopoHntKDjgafjgoLliKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gaExheXhcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zZWxlY3RcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWxlY3Q+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIxXCI+MTwvb3B0aW9uPlxuICogICA8b3B0aW9uIHZhbHVlPVwiMlwiPjJuZDwvb3B0aW9uPlxuICogICA8b3B0aW9uIHZhbHVlPVwiM1wiPjNyZCBvcHRpb248L29wdGlvbj5cbiAqIDwvb25zLXNlbGVjdD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG9mb2N1c1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWxlbWVudCBhdXRvbWF0aWNhbGx5IGdhaW5zIGZvY3VzIG9uIHBhZ2UgbG9hZC5bL2VuXVxuICAgKiAgW2phXeODmuODvOOCuOODreODvOODieaZguOBq+OBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBq+ODleOCqeODvOOCq+OCueOBjOenu+OCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBzZWxlY3QgaW5wdXQgc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZvcm1cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFzc29jaWF0ZSBhIHNlbGVjdCBlbGVtZW50IHRvIGFuIGV4aXN0aW5nIGZvcm0gb24gdGhlIHBhZ2UsIGV2ZW4gaWYgbm90IG5lc3RlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLjgIHmjIflrprjgZfjgZ8gYGZvcm1gIOimgee0oOOBq+e0kOS7mOOBkeOBvuOBmeOAguOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkiBgZm9ybWAg6KaB57Sg44Gu5aSW5YG044Gr6YWN572u44GZ44KL6Zqb44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbXVsdGlwbGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIG11bHRpcGxlIG9wdGlvbnMgY2FuIGJlIHNlbGVjdGVkIGF0IG9uY2UuWy9lbl1cbiAgICogIFtqYV3pgbjmip7ogqLjga7opIfmlbDpgbjmip7jgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBuYW1lXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1OYW1lIHRoZSBzZWxlY3QgZWxlbWVudCwgdXNlZnVsIGZvciBpbnN0YW5jZSBpZiBpdCBpcyBwYXJ0IG9mIGEgZm9ybS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjga7lkI3liY3jgpLmjIflrprjgZfjgb7jgZnjgILpgJrluLggYGZvcm1gIOimgee0oOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJlcXVpcmVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZSB0aGUgc2VsZWN0IGlucHV0IHJlcXVpcmVkIGZvciBzdWJtaXR0aW5nIHRoZSBmb3JtIGl0IGlzIHBhcnQgb2YuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544KS5YWl5Yqb5b+F6aCI44Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CC6YCa5bi4IGBmb3JtYCDopoHntKDjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWxlY3QtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlEIGdpdmVuIHRvIHRoZSBpbm5lciBzZWxlY3QsIHVzZWZ1bCBmb3IgZHluYW1pYyBtYW5pcHVsYXRpb24uWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544GM5YaF6YOo44Gr5oyB44GkIHNlbGVjdCDopoHntKDjgavkuI7jgYjjgosgSUQg44KS5oyH5a6a44GX44G+44GZ44CC44K744Os44Kv44OI44Oc44OD44Kv44K544Gu5YaF5a6544KS5YuV55qE44Gr5aSJ5pu044GZ44KL5b+F6KaB44GM44GC44KL5aC05ZCI44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2l6ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib3cgbWFueSBvcHRpb25zIGFyZSBkaXNwbGF5ZWQ7IGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdGhlIHNpemUgdGhlbiBhIHNjcm9sbCBhcHBlYXJzIHRvIG5hdmlnYXRlIHRoZW0uWy9lbl1cbiAgICogICBbamFd5LiA5bqm44Gr6KGo56S644GZ44KL6YG45oqe6IKi44Gu5YCL5pWw44KS5oyH5a6a44GX44G+44GZ44CC6YG45oqe6IKi44GM44GT44Gu5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCL5pWw44KI44KK44KC5aSa44GE5aC05ZCI44CB44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fZGVyaXZlR2V0dGVycygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnLCAuLi5JTlBVVF9BVFRSSUJVVEVTXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfc2VsZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpIHtcbiAgICBJTlBVVF9BVFRSSUJVVEVTLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Quc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3QucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBsZW5ndGhcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU51bWJlciBvZiBvcHRpb25zIGluIHRoZSBzZWxlY3QgYm94LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBq+WQq+OBvuOCjOOCi+mBuOaKnuiCouOBruWAi+aVsOOCkui/lOOBl+OBvuOBmeOAgiBgc2VsZWN0YCDopoHntKBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNldmVyYWwgb3B0aW9ucyBmb3IgaGFuZGxpbmcgdGhlIHNlbGVjdCBET00gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBq+WQq+OBvuOCjOOCiyBgb3B0aW9uYCDopoHntKDjga7phY3liJfjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNlbGVjdGVkSW5kZXhcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOmBuOaKnuOBleOCjOOBpuOBhOOCi+mBuOaKnuiCouOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVZhbHVlIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOmBuOaKnuOBleOCjOOBpuOBhOOCi+mBuOaKnuiCouOBruWApOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBjb25zdCBzZWwgPSB0aGlzLl9zZWxlY3QgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgaWYgKCFzZWwuaWQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlbGVjdC1pZCcpKSB7XG4gICAgICBzZWwuaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc2VsZWN0LWlkJyk7XG4gICAgfVxuICAgIHNlbC5jbGFzc0xpc3QuYWRkKCdzZWxlY3QtaW5wdXQnKTtcbiAgICBpZiAoIXRoaXMuX3NlbGVjdCkge1xuICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4gc2VsLmFwcGVuZENoaWxkKGVsZW1lbnQpKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc2VsKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZGVyaXZlR2V0dGVycygpIHtcbiAgICBbJ2Rpc2FibGVkJywgJ2xlbmd0aCcsICdtdWx0aXBsZScsICduYW1lJywgJ29wdGlvbnMnLCAnc2VsZWN0ZWRJbmRleCcsICdzaXplJywgJ3ZhbHVlJywgJ2Zvcm0nLCAndHlwZSddXG4gICAgICAuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLl9zZWxlY3Rba2V5XSxcbiAgICAgICAgICBzZXQ6IFsnZm9ybScsICd0eXBlJ10uaW5kZXhPZihrZXkpID09PSAtMVxuICAgICAgICAgICAgPyB2YWx1ZSA9PiBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fc2VsZWN0W2tleV0gPSB2YWx1ZSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gIH1cblxuICBhZGQob3B0aW9uLCBpbmRleCA9IG51bGwpIHtcbiAgICB0aGlzLl9zZWxlY3QuYWRkKG9wdGlvbiwgaW5kZXgpO1xuICB9XG5cbiAgcmVtb3ZlKGluZGV4KSB7XG4gICAgdGhpcy5fc2VsZWN0LnJlbW92ZShpbmRleCk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuU2VsZWN0ID0gU2VsZWN0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNlbGVjdCcsIFNlbGVjdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2ZhYiBmYWItLW1pbmkgc3BlZWQtZGlhbF9faXRlbSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdmYWItLSogc3BlZWQtZGlhbF9faXRlbS0tKidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWwtaXRlbVxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGlzcGxheXMgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgZGlhbCBjb21wb25lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICBNYXRlcmlhbCBEZXNpZ27jga5TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo54++44GZ44KL6KaB57Sg44Gn44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbFxuICogICBbZW5dVGhlIGA8b25zLXNwZWVkLWRpYWw+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1zcGVlZC1kaWFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICB1dGlsLmFkZE1vZGlmaWVyKHRoaXMsICdtaW5pJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBkZWZhdWx0Q2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuZm9yRWFjaCh0b2tlbiA9PiB0aGlzLmNsYXNzTGlzdC5hZGQodG9rZW4pKTtcblxuICAgIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ21pbmknKTtcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TcGVlZERpYWxJdGVtID0gU3BlZWREaWFsSXRlbUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGVlZC1kaWFsLWl0ZW0nLCBTcGVlZERpYWxJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vb25zL3N0eWxlcic7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc3BlZWQtZGlhbCc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3BlZWQtZGlhbC0tKicsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBFbGVtZW50IHRoYXQgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgRGlhbG9nIGNvbXBvbmVudC4gSXQgaXMgdXNlZnVsIHdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBhY3Rpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGluIGEgcGFnZS5cbiAqXG4gKiAgICAgVGhlIFNwZWVkIGRpYWwgbG9va3MgbGlrZSBhIGA8b25zLWZhYj5gIGVsZW1lbnQgYnV0IHdpbGwgZXhwYW5kIGEgbWVudSB3aGVuIHRhcHBlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbC1pdGVtPmAgcmVwcmVzZW50cyBhIG1lbnUgaXRlbS5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZmFiXG4gKiAgIFtlbl1vbnMtZmFiIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZmFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVlZERpYWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgc2hvd24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiAgICAgSS5lLiB0byBkaXNwbGF5IGl0IGluIHRoZSB0b3AgcmlnaHQgY29ybmVyIHNwZWNpZnkgXCJyaWdodCB0b3BcIi5cbiAgICogICAgIENob29zZSBmcm9tIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIgYW5kIFwiYm90dG9tXCIuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgZPjga7opoHntKDjgpLooajnpLrjgZnjgovlt6blj7PjgajkuIrkuIvjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOS+i+OBiOOBsOOAgeWPs+S4iuOBq+ihqOekuuOBmeOCi+WgtOWQiOOBq+OBr1wicmlnaHQgdG9wXCLjgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOW3puWPs+OBqOS4iuS4i+OBruS9jee9ruOBruaMh+WumuOBq+OBr+OAgXJpZ2h044GobGVmdOOAgXRvcOOBqGJvdHRvbeOBjOOBneOCjOOBnuOCjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgZGlyZWN0aW9uIHRoZSBpdGVtcyBhcmUgZGlzcGxheWVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDopoHntKDjgYzooajnpLrjgZnjgovmlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJ1cCwgZG93biwgbGVmdCwgcmlnaHTjgYzmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbih0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2NsYXNzJywgJ21vZGlmaWVyJywgJ3JpcHBsZScsICdkaXJlY3Rpb24nLCAncG9zaXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUmlwcGxlKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RpcmVjdGlvbic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVEaXJlY3Rpb24oY3VycmVudCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnb25zLXNwZWVkLWRpYWwtaXRlbScpKTtcbiAgfVxuXG4gIGdldCBfZmFiKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWZhYicpO1xuICB9XG5cbiAgX29uQ2xpY2soZSkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICAgIHRoaXMub25DbGljay5hcHBseSh0aGlzKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlSXRlbXMoKTtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuaGlkZSgpLnRoZW4ocmVzb2x2ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIGlmICh0aGlzLl9mYWIpIHtcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSA/IHRoaXMuX2ZhYi5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKSA6IHRoaXMuX2ZhYi5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IDI1ICogaSArICdtcycsXG4gICAgICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgICB0b3A6ICdhdXRvJyxcbiAgICAgICAgbGVmdDogJ2F1dG8nXG4gICAgICB9KTtcbiAgICB9XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmJvdHRvbSA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG93bic6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAnOHB4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB1dGlsLnRocm93KCdBcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB1cCwgZG93biwgbGVmdCBvciByaWdodC4nKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZmFiLS10b3BfX2xlZnQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxuICAgICAgJ2ZhYi0tdG9wX19yaWdodCcsXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRUcmFuc2xhdGUoKSB7XG4gICAgY29uc3QgaXNCb3R0b20gPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykgfHwgJycpLmluZGV4T2YoJ2JvdHRvbScpID49IDA7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gaXNCb3R0b20gPyBgdHJhbnNsYXRlM2QoMHB4LCAtJHt1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0IHx8IDB9cHgsIDBweCkgYCA6ICcnO1xuICAgIHJldHVybiB0cmFuc2xhdGU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLl9mYWIuc2hvdygpO1xuICAgIHN0eWxlcih0aGlzLCB7IHRyYW5zZm9ybTogdGhpcy5fZ2V0VHJhbnNsYXRlIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIHNwZWVkIGRpYWwuWy9lbl1cbiAgICogICBbamFdU3BlZWQgZGlhbOOCkumdnuihqOekuuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmhpZGVJdGVtcygpLnRoZW4oKCk9PiB0aGlzLl9mYWIuaGlkZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dJdGVtc1xuICAgKiBAc2lnbmF0dXJlIHNob3dJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBzcGVlZCBkaWFsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2hvd0l0ZW1zKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbih0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgfVxuXG4gICAgbGV0IHRvdGFsRGVsYXkgPSAwO1xuICAgIGlmICghdGhpcy5faXRlbVNob3duKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMjUgKiBpO1xuICAgICAgICB0b3RhbERlbGF5ICs9IGRlbGF5O1xuICAgICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKScsXG4gICAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSArICdtcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0b3RhbERlbGF5ICs9IDUwO1xuXG4gICAgICB0aGlzLl9pdGVtU2hvd24gPSB0cnVlO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvcGVuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgc2V0VGltZW91dChkZWZlcnJlZC5yZXNvbHZlLCB0b3RhbERlbGF5KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVJdGVtc1xuICAgKiBAc2lnbmF0dXJlIGhpZGVJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBzcGVlZCBkaWFsIGl0ZW1zLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaGlkZUl0ZW1zKCkge1xuICAgIGxldCB0b3RhbERlbGF5ID0gMDtcbiAgICBpZiAodGhpcy5faXRlbVNob3duKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMjUgKiAoY2hpbGRyZW4ubGVuZ3RoIC0gaSk7XG4gICAgICAgIHRvdGFsRGVsYXkgKz0gZGVsYXk7XG4gICAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJyxcbiAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5ICsgJ21zJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRvdGFsRGVsYXkgKz0gNTA7XG5cbiAgICAgIHRoaXMuX2l0ZW1TaG93biA9IGZhbHNlO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjbG9zZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHNldFRpbWVvdXQoZGVmZXJyZWQucmVzb2x2ZSwgdG90YWxEZWxheSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5oaWRlSXRlbXMoKTtcbiAgICB9XG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZHJlbikuZm9yRWFjaChlID0+IHtcbiAgICAgIHV0aWwubWF0Y2goZSwgJy5mYWInKSAmJiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZShlLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5saW5lXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgaW5saW5lIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg7Pjg6njgqTjg7PopoHntKDjga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGlubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2lubGluZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9mYWIudmlzaWJsZSAmJiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzT3BlblxuICAgKiBAc2lnbmF0dXJlIGlzT3BlbigpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIG1lbnUgaXMgb3BlbiBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbVNob3duO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7ooajnpLrpnZ7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnZpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlSXRlbXNcbiAgICogQHNpZ25hdHVyZSB0b2dnbGVJdGVtcygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgaXRlbSB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjga7lrZDopoHntKDjga7ooajnpLrpnZ7ooajnpLrjgpLliIfjgormm7/jgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgdG9nZ2xlSXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuKCkgPyB0aGlzLmhpZGVJdGVtcygpIDogdGhpcy5zaG93SXRlbXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ29wZW4nLCAnY2xvc2UnXTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TcGVlZERpYWwgPSBTcGVlZERpYWxFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BlZWQtZGlhbCcsIFNwZWVkRGlhbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlcn0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiBAY2F0ZWdvcnkgbWVudVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50IGlzIHVzZWQgYXMgYSBjaGlsZCBlbGVtZW50IG9mIGA8b25zLXNwbGl0dGVyPmAuXG4gKlxuICogICAgSXQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZSB3aGlsZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29udGFpbnMgdGhlIGxpc3QuXG4gKiAgWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGNvbXBvbmVudCBpcyB0aGUgcGFyZW50IGVsZW1lbnQuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtZW51LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyQ29udGVudEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgdXJsIG9mIHRoZSBjb250ZW50IHBhZ2UuIElmIHRoaXMgYXR0cmlidXRlIGlzIHVzZWQgdGhlIGNvbnRlbnQgd2lsbCBiZSBsb2FkZWQgZnJvbSBhIGA8dGVtcGxhdGU+YCB0YWcgb3IgYSByZW1vdGUgZmlsZS5cbiAgICpcbiAgICogICAgIEl0IGlzIGFsc28gcG9zc2libGUgdG8gcHV0IGA8b25zLXBhZ2U+YCBlbGVtZW50IGFzIGEgY2hpbGQgb2YgdGhlIGVsZW1lbnQuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHRoaXMuX2dldFBhZ2VUYXJnZXQoKTtcblxuICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgIHRoaXMubG9hZChwYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHV0aWwudGhyb3coJ1wib25zLXNwbGl0dGVyLWNvbnRlbnRcIiBtdXN0IGhhdmUgXCJvbnMtc3BsaXR0ZXJcIiBhcyBwYXJlbnQnKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7fVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHBhZ2UgdG8gbG9hZCBpbiB0aGUgc3BsaXR0ZXIgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBwYWdlXG4gICAqL1xuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBnZXQgX2NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBlbGVtZW50IGxvYWRlZCBpbiB0aGUgc3BsaXR0ZXIgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb2FkZXI7XG4gIH1cblxuICBzZXQgcGFnZUxvYWRlcihsb2FkZXIpIHtcbiAgICBpZiAoIShsb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdXRpbC50aHJvd1BhZ2VMb2FkZXIoKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UsIFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIGA8dGVtcGxhdGU+YCBpZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gYHBhZ2VgIGluIHRoZSBjb250ZW50LlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn1VSTOOCkuODoeOCpOODs+ODmuODvOOCuOOCkuiqreOBv+i+vOOBv+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgYDxvbnMtcGFnZT5gIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1gPG9ucy1wYWdlPmDopoHntKDjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgb2xkQ29udGVudCA9IHRoaXMuX2NvbnRlbnQgfHwgbnVsbDtcblxuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChvbGRDb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQob2xkQ29udGVudCk7XG4gICAgICAgICAgb2xkQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcblxuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMuX2NvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxub25zRWxlbWVudHMuU3BsaXR0ZXJDb250ZW50ID0gU3BsaXR0ZXJDb250ZW50RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLWNvbnRlbnQnLCBTcGxpdHRlckNvbnRlbnRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyTWFza0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5fc2lkZXMuZXZlcnkoc2lkZSA9PiBzaWRlLm1vZGUgPT09ICdzcGxpdCcpKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lICFpbXBvcnRhbnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9vbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMub25DbGljayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLm9uQ2xpY2soKTtcbiAgICB9IGVsc2UgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXNwbGl0dGVyJykpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5fc2lkZXMuZm9yRWFjaChzaWRlID0+IHNpZGUuY2xvc2UoJ2xlZnQnKS5jYXRjaCgoKSA9PiB7fSkpO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgICB1dGlsLmlvc01hc2tTY3JvbGxGaXgodGhpcywgdHJ1ZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgICB1dGlsLmlvc01hc2tTY3JvbGxGaXgodGhpcywgZmFsc2UpO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlNwbGl0dGVyTWFzayA9IFNwbGl0dGVyTWFza0VsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1tYXNrJywgU3BsaXR0ZXJNYXNrRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uLy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLCBkdXJhdGlvbiA9IDAuMywgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGR1cmF0aW9uLCBkZWxheSB9KTtcbiAgfVxuXG4gIHVwZGF0ZU9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgdXRpbC5leHRlbmQodGhpcywge1xuICAgICAgdGltaW5nOiB0aGlzLnRpbWluZywgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sIGRlbGF5OiB0aGlzLmRlbGF5XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzaWRlRWxlbWVudFxuICAgKi9cbiAgYWN0aXZhdGUoc2lkZUVsZW1lbnQpIHtcbiAgICBjb25zdCBzcGxpdHRlciA9IHNpZGVFbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICBjb250ZW50UmVhZHkoc3BsaXR0ZXIsICgpID0+IHtcbiAgICAgIHRoaXMuX3NpZGUgPSBzaWRlRWxlbWVudDtcbiAgICAgIHRoaXMuX29wcG9zaXRlU2lkZSA9IHNwbGl0dGVyLnJpZ2h0ICE9PSBzaWRlRWxlbWVudCAmJiBzcGxpdHRlci5yaWdodCB8fCBzcGxpdHRlci5sZWZ0ICE9PSBzaWRlRWxlbWVudCAmJiBzcGxpdHRlci5sZWZ0O1xuICAgICAgdGhpcy5fY29udGVudCA9IHNwbGl0dGVyLmNvbnRlbnQ7XG4gICAgICB0aGlzLl9tYXNrID0gc3BsaXR0ZXIubWFzaztcbiAgICB9KTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5jbGVhclRyYW5zaXRpb24oKTtcbiAgICB0aGlzLl9tYXNrICYmIHRoaXMuY2xlYXJNYXNrKCk7XG4gICAgdGhpcy5fY29udGVudCA9IHRoaXMuX3NpZGUgPSB0aGlzLl9vcHBvc2l0ZVNpZGUgPSB0aGlzLl9tYXNrID0gbnVsbDtcbiAgfVxuXG4gIGdldCBtaW51cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5zaWRlID09PSAncmlnaHQnID8gJy0nIDogJyc7XG4gIH1cblxuICBjbGVhclRyYW5zaXRpb24oKSB7XG4gICAgJ3NpZGUgbWFzayBjb250ZW50Jy5zcGxpdCgvXFxzKy8pXG4gICAgICAuZm9yRWFjaChlID0+IHRoaXNbJ18nICsgZV0gJiYgc3R5bGVyLmNsZWFyKHRoaXNbJ18nICsgZV0sICd0cmFuc2Zvcm0gdHJhbnNpdGlvbicpKVxuICB9XG5cbiAgY2xlYXJNYXNrKCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBvdGhlciBzaWRlIG5lZWRzIHRoZSBtYXNrIGJlZm9yZSBjbGVhcmluZ1xuICAgIGlmICghdGhpcy5fb3Bwb3NpdGVTaWRlIHx8IHRoaXMuX29wcG9zaXRlU2lkZS5tb2RlID09PSAnc3BsaXQnIHx8ICF0aGlzLl9vcHBvc2l0ZVNpZGUuaXNPcGVuKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgIHRoaXMuX21hc2suc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgU3BsaXR0ZXJBbmltYXRvciB7XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgLy8gQXZvaWQgY29udGVudCBjbGlja3NcblxuICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgZGlzdGFuY2V9cHgsIDAsIDApYFxuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgb3Blbihkb25lKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51c30xMDAlLCAwLCAwKWBcbiAgICAgICAgfSwgdGhpcy5kZWYpXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAnMSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0sIHRoaXMuZGVmKVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAnMCdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoU3BsaXR0ZXJBbmltYXRvciBleHRlbmRzIFNwbGl0dGVyQW5pbWF0b3Ige1xuXG4gIF9nZXRTbGlkaW5nRWxlbWVudHMoKSB7XG4gICAgY29uc3Qgc2xpZGluZ0VsZW1lbnRzID0gW3RoaXMuX3NpZGUsIHRoaXMuX2NvbnRlbnRdO1xuICAgIGlmICh0aGlzLl9vcHBvc2l0ZVNpZGUgJiYgdGhpcy5fb3Bwb3NpdGVTaWRlLm1vZGUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHNsaWRpbmdFbGVtZW50cy5wdXNoKHRoaXMuX29wcG9zaXRlU2lkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWRpbmdFbGVtZW50cztcbiAgfVxuXG4gIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuICAgIGlmICghdGhpcy5fc2xpZGluZ0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBBdm9pZCBjb250ZW50IGNsaWNrc1xuXG4gICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwLCAwKWBcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMuX3NpZGUub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBtYXh9cHgsIDAsIDApYFxuICAgICAgICB9LCB0aGlzLmRlZilcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG4gICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSwgdGhpcy5kZWYpXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICBzdXBlci5jbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uLy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXZlYWxTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgU3BsaXR0ZXJBbmltYXRvciB7XG5cbiAgX2dldFNsaWRpbmdFbGVtZW50cygpIHtcbiAgICBjb25zdCBzbGlkaW5nRWxlbWVudHMgPSBbdGhpcy5fY29udGVudCwgdGhpcy5fbWFza107XG4gICAgaWYgKHRoaXMuX29wcG9zaXRlU2lkZSAmJiB0aGlzLl9vcHBvc2l0ZVNpZGUubW9kZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgc2xpZGluZ0VsZW1lbnRzLnB1c2godGhpcy5fb3Bwb3NpdGVTaWRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpZGluZ0VsZW1lbnRzO1xuICB9XG5cbiAgYWN0aXZhdGUoc2lkZUVsZW1lbnQpIHtcbiAgICBzdXBlci5hY3RpdmF0ZShzaWRlRWxlbWVudCk7XG4gICAgaWYgKHNpZGVFbGVtZW50Lm1vZGUgPT09ICdjb2xsYXBzZScpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlcyhzaWRlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLl9zaWRlICYmIHRoaXMuX3Vuc2V0U3R5bGVzKHRoaXMuX3NpZGUpO1xuICAgIHN1cGVyLmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIF9zZXRTdHlsZXMoc2lkZUVsZW1lbnQpIHtcbiAgICBzdHlsZXIoc2lkZUVsZW1lbnQsIHtcbiAgICAgIGxlZnQ6IHNpZGVFbGVtZW50LnNpZGUgPT09ICdyaWdodCcgPyAnYXV0bycgOiAwLFxuICAgICAgcmlnaHQ6IHNpZGVFbGVtZW50LnNpZGUgPT09ICdyaWdodCcgID8gMCA6ICdhdXRvJyxcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsYWNrJyxcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUoMCkuY29udGFpbmVyLnRyYW5zZm9ybSxcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3BsaXR0ZXIgPSBzaWRlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4gc3BsaXR0ZXIuY29udGVudCAmJiBzdHlsZXIoc3BsaXR0ZXIuY29udGVudCwgeyBib3hTaGFkb3c6ICcwIDAgMTJweCAwIHJnYmEoMCwgMCwgMCwgMC4yKScgfSkpO1xuICB9XG5cbiAgX3Vuc2V0U3R5bGVzKHNpZGVFbGVtZW50KSB7XG4gICAgc3R5bGVyLmNsZWFyKHNpZGVFbGVtZW50LCAnbGVmdCByaWdodCB6SW5kZXggYmFja2dyb3VuZENvbG9yIGRpc3BsYXknKTtcbiAgICBpZiAoc2lkZUVsZW1lbnQuX2NvbnRlbnQpIHtcbiAgICAgIHNpZGVFbGVtZW50Ll9jb250ZW50LnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgb3RoZXIgc2lkZSBuZWVkcyB0aGUgY29tbW9uIHN0eWxlc1xuICAgIGlmICghdGhpcy5fb3Bwb3NpdGVTaWRlIHx8IHRoaXMuX29wcG9zaXRlU2lkZS5tb2RlID09PSAnc3BsaXQnKSB7XG4gICAgICBzaWRlRWxlbWVudC5wYXJlbnRFbGVtZW50LmNvbnRlbnQgJiYgc3R5bGVyLmNsZWFyKHNpZGVFbGVtZW50LnBhcmVudEVsZW1lbnQuY29udGVudCwgJ2JveFNoYWRvdycpO1xuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZShkaXN0YW5jZSkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4V2lkdGg7XG5cbiAgICBsZXQgYmVoaW5kRGlzdGFuY2UgPSAoZGlzdGFuY2UgLSBtYXgpIC8gbWF4ICogMTA7XG4gICAgYmVoaW5kRGlzdGFuY2UgPSBpc05hTihiZWhpbmREaXN0YW5jZSkgPyAwIDogTWF0aC5tYXgoTWF0aC5taW4oYmVoaW5kRGlzdGFuY2UsIDApLCAtMTApO1xuXG4gICAgY29uc3QgYmVoaW5kVHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7KHRoaXMubWludXMgPyAtMSA6IDEpICogYmVoaW5kRGlzdGFuY2V9JSwgMCwgMClgO1xuICAgIGNvbnN0IG9wYWNpdHkgPSAxICsgYmVoaW5kRGlzdGFuY2UgLyAxMDA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBvcGFjaXR5XG4gICAgICB9LFxuICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgIHRyYW5zZm9ybTogYmVoaW5kVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuekluZGV4ID0gMTtcbiAgICB0aGlzLm1heFdpZHRoID0gdGhpcy5tYXhXaWR0aCB8fCB0aGlzLl9nZXRNYXhXaWR0aCgpO1xuICAgIGNvbnN0IG1lbnVTdHlsZSA9IHRoaXMuX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKE1hdGgubWluKGRpc3RhbmNlLCB0aGlzLm1heFdpZHRoKSk7XG5cbiAgICBpZiAoIXRoaXMuX3NsaWRpbmdFbGVtZW50cykge1xuICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgLy8gQXZvaWQgY29udGVudCBjbGlja3NcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwLCAwKWBcbiAgICAgICAgfSksXG4gICAgICBhbmltaXQodGhpcy5fc2lkZS5fY29udGVudClcbiAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250ZW50KSxcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRhaW5lcilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuekluZGV4ID0gMTtcbiAgICB0aGlzLm1heFdpZHRoID0gdGhpcy5tYXhXaWR0aCB8fCB0aGlzLl9nZXRNYXhXaWR0aCgpO1xuICAgIGNvbnN0IG1lbnVTdHlsZSA9IHRoaXMuX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIEZpeDogVGltZSB0byB1cGRhdGUgcHJldmlvdXMgdHJhbnNsYXRlM2QgYWZ0ZXIgY2hhbmdpbmcgc3R5bGUuZGlzcGxheVxuICAgICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyB0aGlzLm1heFdpZHRofXB4LCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLmRlZiksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLl9zaWRlLl9jb250ZW50KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250ZW50LCB0aGlzLmRlZiksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRhaW5lciwgdGhpcy5kZWYpXG4gICAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuICAgIH0sIDEwMDAvNjApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGNsb3NlKGRvbmUpIHtcbiAgICBjb25zdCBtZW51U3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZSgwKTtcbiAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9LCB0aGlzLmRlZiksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUuX2NvbnRlbnQpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGVudCwgdGhpcy5kZWYpLFxuXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250YWluZXIsIHRoaXMuZGVmKVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fc2lkZS5zdHlsZS56SW5kZXggPSAwO1xuICAgICAgICAgIHRoaXMuX3NpZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB0aGlzLl9zaWRlLl9jb250ZW50LnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgX2dldE1heFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWRlLm9mZnNldFdpZHRoO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9vdmVybGF5LWFuaW1hdG9yJztcbmltcG9ydCBQdXNoU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL3B1c2gtYW5pbWF0b3InO1xuaW1wb3J0IFJldmVhbFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9yZXZlYWwtYW5pbWF0b3InO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gIGRlZmF1bHQ6IE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yLFxuICBvdmVybGF5OiBPdmVybGF5U3BsaXR0ZXJBbmltYXRvcixcbiAgcHVzaDogUHVzaFNwbGl0dGVyQW5pbWF0b3IsXG4gIHJldmVhbDogUmV2ZWFsU3BsaXR0ZXJBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXJcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNvbXBvbmVudCB0aGF0IGVuYWJsZXMgcmVzcG9uc2l2ZSBsYXlvdXQgYnkgaW1wbGVtZW50aW5nIGJvdGggYSB0d28tY29sdW1uIGxheW91dCBhbmQgYSBzbGlkaW5nIG1lbnUgbGF5b3V0LlxuICpcbiAqICAgIEl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGF1dG9tYXRpY2FsbHkgZXhwYW5kIGludG8gYSBjb2x1bW4gbGF5b3V0IG9uIGxhcmdlIHNjcmVlbnMgYW5kIGNvbGxhcHNlIHRoZSBtZW51IG9uIHNtYWxsZXIgc2NyZWVucy4gV2hlbiB0aGUgbWVudSBpcyBjb2xsYXBzZWQgdGhlIHVzZXIgY2FuIG9wZW4gaXQgYnkgc3dpcGluZy5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlciBpZD1cInNwbGl0dGVyXCI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2Ugc3dpcGVhYmxlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNwbGl0dGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwbGl0dGVyJyk7XG4gKiAgIHNwbGl0dGVyLmxlZnQub3BlbigpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBfZ2V0U2lkZShzaWRlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsIGUgPT4ge1xuICAgICAgcmV0dXJuIHV0aWwubWF0Y2goZSwgJ29ucy1zcGxpdHRlci1zaWRlJykgJiYgZS5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gc2lkZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbGVmdFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTGVmdCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ2xlZnQnKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IHJpZ2h0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SaWdodCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTaWRlKCdyaWdodCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzaWRlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJzdCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCByZWdhcmRsZXNzIHRoZSBhY3R1YWwgc2lkZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHNpZGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItc2lkZScpO1xuICB9XG5cbiAgZ2V0IF9zaWRlcygpIHtcbiAgICByZXR1cm4gW3RoaXMubGVmdCwgdGhpcy5yaWdodF0uZmlsdGVyKGUgPT4gZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjb250ZW50XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLWNvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCB0b3BQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuX2NvbnRlbnQ7XG4gIH1cblxuICBnZXQgbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1tYXNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICB0aGlzLl9zaWRlcy5zb21lKHMgPT4gcy5pc09wZW4gPyBzLmNsb3NlKCkgOiBmYWxzZSkgfHwgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgfVxuXG4gIF9vbk1vZGVDaGFuZ2UoZSkge1xuICAgIGlmIChlLnRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9sYXlvdXQoKSB7XG4gICAgdGhpcy5fc2lkZXMuZm9yRWFjaChzaWRlID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3NpZGUuc2lkZV0gPSBzaWRlLm1vZGUgPT09ICdzcGxpdCcgPyBzaWRlLnN0eWxlLndpZHRoIDogMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9vbk1vZGVDaGFuZ2UgPSB0aGlzLl9vbk1vZGVDaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAhdGhpcy5tYXNrICYmIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snKSk7XG4gICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgdGhpcy5fb25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX29uTW9kZUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHt9XG5cbiAgX3Nob3coKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yIGluc3RhbmNlb2YgU3BsaXR0ZXJBbmltYXRvcikpIHtcbiAgICAgIHV0aWwudGhyb3dBbmltYXRvcignU3BsaXR0ZXInKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBTcGxpdHRlckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBTcGxpdHRlckFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cbn1cblxub25zRWxlbWVudHMuU3BsaXR0ZXIgPSBTcGxpdHRlckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlcicsIFNwbGl0dGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IG9yaWVudGF0aW9uIGZyb20gJy4uL29ucy9vcmllbnRhdGlvbic7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9vbnMtc3BsaXR0ZXIvYW5pbWF0b3InO1xuaW1wb3J0IFN3aXBlUmV2ZWFsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9zd2lwZS1yZXZlYWwnO1xuaW1wb3J0IERvb3JMb2NrIGZyb20gJy4uL29ucy9kb29ybG9jayc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCB7IFBhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuaW1wb3J0IFNwbGl0dGVyRWxlbWVudCBmcm9tICcuL29ucy1zcGxpdHRlcic7XG5cbmNvbnN0IFNQTElUX01PREUgPSAnc3BsaXQnO1xuY29uc3QgQ09MTEFQU0VfTU9ERSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTE9TRURfU1RBVEUgPSAnY2xvc2VkJztcbmNvbnN0IE9QRU5fU1RBVEUgPSAnb3Blbic7XG5jb25zdCBDSEFOR0lOR19TVEFURSA9ICdjaGFuZ2luZyc7XG5cbmNvbnN0IHJld3JpdGFibGVzID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGxpdHRlclNpZGVFbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZWFkeShzcGxpdHRlclNpZGVFbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmNsYXNzIENvbGxhcHNlRGV0ZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fb25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRhcmdldCAmJiB0aGlzLmNoYW5nZVRhcmdldCh0YXJnZXQpO1xuICB9XG5cbiAgY2hhbmdlVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFsncG9ydHJhaXQnLCAnbGFuZHNjYXBlJ10uaW5kZXhPZih0YXJnZXQpICE9PSAtMTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfbWF0Y2godmFsdWUpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXQgPT09ICh2YWx1ZS5pc1BvcnRyYWl0ID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLm1hdGNoZXM7XG4gIH1cblxuICBfb25DaGFuZ2UodmFsdWUpIHtcbiAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVNb2RlKHRoaXMuX21hdGNoKHZhbHVlKSA/IENPTExBUFNFX01PREUgOiBTUExJVF9NT0RFKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub24oJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHtpc1BvcnRyYWl0OiBvcmllbnRhdGlvbi5pc1BvcnRyYWl0KCl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSB3aW5kb3cubWF0Y2hNZWRpYSh0aGlzLl90YXJnZXQpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQuYWRkTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy5fcXVlcnlSZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3F1ZXJ5UmVzdWx0KSB7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9vbkNoYW5nZSk7XG4gICAgICB0aGlzLl9xdWVyeVJlc3VsdCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHdpZHRoVG9QeCA9ICh3aWR0aCwgcGFyZW50KSA9PiB7XG4gIGNvbnN0IFt2YWx1ZSwgcHhdID0gW3BhcnNlSW50KHdpZHRoLCAxMCksIC9weC8udGVzdCh3aWR0aCldO1xuICByZXR1cm4gcHggPyB2YWx1ZSA6IE1hdGgucm91bmQocGFyZW50Lm9mZnNldFdpZHRoICogdmFsdWUgLyAxMDApO1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItc2lkZVxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IHdpbGwgYmUgZGlzcGxheWVkIG9uIGVpdGhlciB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudC5cbiAqXG4gKiAgICBJdCBzdXBwb3J0cyB0d28gbW9kZXM6IGNvbGxhcHNlZCBhbmQgc3BsaXQuIFdoZW4gaXQncyBpbiBjb2xsYXBzZWQgbW9kZSBpdCB3aWxsIGJlIGhpZGRlbiBmcm9tIHZpZXcgYW5kIGNhbiBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBzd2lwZXMgdGhlIHNjcmVlbiBvciB0YXBzIGEgYnV0dG9uLiBJbiBzcGxpdCBtb2RlIHRoZSBlbGVtZW50IGlzIGFsd2F5cyBzaG93bi4gSXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYXV0b21hdGljYWxseSBzd2l0Y2ggYmV0d2VlbiB0aGUgdHdvIG1vZGVzIGRlcGVuZGluZyBvbiB0aGUgc2NyZWVuIHNpemUuXG4gKiAgWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGlzIHRoZSBwYXJlbnQgY29tcG9uZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItY29udGVudFxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWFpbiBjb250ZW50IG9mIHRoZSBwYWdlLlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW5044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyU2lkZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBtb2RlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjb21wb25lbnQncyBtb2RlIGNoYW5nZXMuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu44Oi44O844OJ44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5tb2RlXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGN1cnJlbnQgbW9kZS4gQ2FuIGJlIGVpdGhlciBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg6Ljg7zjg4njgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZW9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdG8gY2FuY2VsIG9wZW5pbmcgc2xpZGluZyBtZW51LlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWi+OBj+OBruOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0b3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgYTjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmctbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgovjga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgc2xpZGluZyBtZW51IGlzIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplonjgZjjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5zaWRlXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0ICBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbi4gVXNlIG9uZSBvZiBgb3ZlcmxheWAsIGBwdXNoYCwgYHJldmVhbGAgb3IgIGBkZWZhdWx0YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglwib3ZlcmxheVwiLCBcInB1c2hcIiwgXCJyZXZlYWxcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgb3Blbi10aHJlc2hvbGRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgIDAuM1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGhvdyBtdWNoIHRoZSBtZW51IG5lZWRzIHRvIGJlIHN3aXBlZCBiZWZvcmUgb3BlbmluZy4gQSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDFgLlsvZW5dXG4gICAqICBbamFd44Gp44Gu44GP44KJ44GE44K544Ov44Kk44OX44GZ44KM44Gw44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844KS6ZaL44GP44GL44Gp44GG44GL44Gu5Ymy5ZCI44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTHjga7plpPjga7mlbDlgKTjgpLmjIflrprjgZfjgb7jgZnjgILjgrnjg6/jgqTjg5fjga7ot53pm6LjgYzjgZPjgZPjgafmjIflrprjgZfjgZ/mlbDlgKTmjpvjgZHjgovjgZPjga7opoHntKDjga7luYXjgojjgorjgoLlpKfjgY3jgZHjgozjgbDjgIHjgrnjg6/jgqTjg5fjgYzntYLjgo/jgaPjgZ/mmYLjgavjgZPjga7opoHntKDjgpLplovjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8wLjPjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb2xsYXBzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSBjb2xsYXBzZSBiZWhhdmlvci4gVmFsaWQgdmFsdWVzIGFyZSBgXCJwb3J0cmFpdFwiYCwgYFwibGFuZHNjYXBlXCJgIG9yIGEgbWVkaWEgcXVlcnkuXG4gICAqICAgICBUaGUgc3RyaW5ncyBgXCJwb3J0cmFpdFwiYCBhbmQgYFwibGFuZHNjYXBlXCJgIG1lYW5zIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiBkZXZpY2UgaXMgaW4gbGFuZHNjYXBlIG9yIHBvcnRyYWl0IG9yaWVudGF0aW9uLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIGEgbWVkaWEgcXVlcnksIHRoZSB2aWV3IHdpbGwgY29sbGFwc2Ugd2hlbiB0aGUgbWVkaWEgcXVlcnkgcmVzb2x2ZXMgdG8gYHRydWVgLlxuICAgKiAgICAgSWYgdGhlIHZhbHVlIGlzIG5vdCBkZWZpbmVkLCB0aGUgdmlldyBhbHdheXMgYmUgaW4gYFwiY29sbGFwc2VcImAgbW9kZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOW3puWBtOOBruODmuODvOOCuOOCkumdnuihqOekuuOBq+OBmeOCi+adoeS7tuOCkuaMh+WumuOBl+OBvuOBmeOAgnBvcnRyYWl0LCBsYW5kc2NhcGXjgIF3aWR0aCAjcHjjgoLjgZfjgY/jga/jg6Hjg4fjgqPjgqLjgq/jgqjjg6rjga7mjIflrprjgYzlj6/og73jgafjgZnjgIJcbiAgICogICAgIHBvcnRyYWl044KC44GX44GP44GvbGFuZHNjYXBl44KS5oyH5a6a44GZ44KL44Go44CB44OH44OQ44Kk44K544Gu55S76Z2i44GM57im5ZCR44GN44KC44GX44GP44Gv5qiq5ZCR44GN44Gr44Gq44Gj44Gf5pmC44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDjg6Hjg4fjgqPjgqLjgq/jgqjjg6rjgpLmjIflrprjgZnjgovjgajjgIHmjIflrprjgZfjgZ/jgq/jgqjjg6rjgavpganlkIjjgZfjgabjgYTjgovloLTlkIjjgavpgannlKjjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOWApOOBq+S9leOCguaMh+WumuOBl+OBquOBhOWgtOWQiOOBq+OBr+OAgeW4uOOBq2NvbGxhcHNl44Oi44O844OJ44Gr44Gq44KK44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGUtdGFyZ2V0LXdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXG4gICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHdpZHRoXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgc3BlY2lmaWVkIGluIGVpdGhlciBwaXhlbHMgb3IgYXMgYSBwZXJjZW50YWdlLCBlLmcuIGA5MCVgIG9yIGAyMDBweGAuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg44Gu5qiq5bmF44KS5oyH5a6a44GX44G+44GZ44CCcHjjgagl44Gn44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCZWcuIDkwJSwgMjAwcHhbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaWRlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGxlZnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgd2hpY2ggc2lkZSBvZiB0aGUgc2NyZWVuIHRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCBpcyBsb2NhdGVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImxlZnRcImAgYW5kIGBcInJpZ2h0XCJgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBjOW3puOBi+WPs+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAguaMh+WumuOBp+OBjeOCi+WApOOBr1wibGVmdFwi44GLXCJyaWdodFwi44Gu44G/44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImNvbGxhcHNlXCJgIG9yIGBcInNwbGl0XCJgLiBUaGlzIGF0dHJpYnV0ZSBpcyByZWFkIG9ubHkuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44GM6Kit5a6a44GV44KM44G+44GZ44CCXCJjb2xsYXBzZVwi44KC44GX44GP44GvXCJzcGxpdFwi44GM5oyH5a6a44GV44KM44G+44GZ44CC44GT44Gu5bGe5oCn44Gv6Kqt44G/6L6844G/5bCC55So44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBVUkwgb2YgdGhlIG1lbnUgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeimgee0oOOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdG8gZW5hYmxlIHN3aXBlIGludGVyYWN0aW9uIG9uIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4nmmYLjgavjgrnjg6/jgqTjg5fmk43kvZzjgpLmnInlirnjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fcGFnZSA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGUgPSBDTE9TRURfU1RBVEU7XG4gICAgdGhpcy5fbG9jayA9IG5ldyBEb29yTG9jaygpO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbiA9IG5ldyBDb2xsYXBzZURldGVjdGlvbih0aGlzKTtcblxuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBTcGxpdHRlckVsZW1lbnQuYW5pbWF0b3JzLFxuICAgICAgYmFzZUNsYXNzOiBTcGxpdHRlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1NwbGl0dGVyQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgLy8gVGhlc2UgYXR0cmlidXRlcyBhcmUgdXNlZCBlYXJseSBieSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCd3aWR0aCcpO1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnc2lkZScpKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzaWRlJywgJ2xlZnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV3cml0YWJsZXMucmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICAgICAgICBwYWdlICYmIHRoaXMubG9hZChwYWdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB1dGlsLnRocm93KCdQYXJlbnQgbXVzdCBiZSBhbiBvbnMtc3BsaXR0ZXIgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3N3aXBlID0gbmV3IFN3aXBlUmV2ZWFsKHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMsXG4gICAgICBlbGVtZW50SGFuZGxlcjogdGhpcy5wYXJlbnRFbGVtZW50LFxuICAgICAgc3dpcGVNYXg6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKDEsIHRoaXMuX2FuaW1hdGlvbk9wdCk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfSxcbiAgICAgIHN3aXBlTWlkOiAoZGlzdGFuY2UsIHdpZHRoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZShkaXN0YW5jZS93aWR0aCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgc3dpcGVNaW46ICgpID0+IHtcbiAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKDAsIHRoaXMuX2FuaW1hdGlvbk9wdCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0sXG4gICAgICBnZXRUaHJlc2hvbGQ6ICgpID0+IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ29wZW4tdGhyZXNob2xkJykpIHx8IDAuMykpLFxuICAgICAgZ2V0U2lkZTogKCkgPT4gdGhpcy5zaWRlLFxuICAgICAgaXNJbml0aWFsU3RhdGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgY2xvc2VkID0gdGhpcy5fc3RhdGUgPT09IENMT1NFRF9TVEFURTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcbiAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgIH0sXG4gICAgICBpZ25vcmVTd2lwZTogKGV2ZW50LCBkaXN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBpc09wZW4gPSB0aGlzLmlzT3BlbjtcbiAgICAgICAgY29uc3QgdmFsaWREcmFnID0gZCA9PiB0aGlzLnNpZGUgPT09ICdsZWZ0J1xuICAgICAgICAgID8gKChkID09PSAnbGVmdCcgJiYgaXNPcGVuKSB8fCAoZCA9PT0gJ3JpZ2h0JyAmJiAhaXNPcGVuKSlcbiAgICAgICAgICA6ICgoZCA9PT0gJ2xlZnQnICYmICFpc09wZW4pIHx8IChkID09PSAncmlnaHQnICYmIGlzT3BlbikpO1xuXG4gICAgICAgIGNvbnN0IGFyZWEgPSBNYXRoLm1heCgwLCBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGUtdGFyZ2V0LXdpZHRoJyksIDEwKSB8fCAwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZSA9PT0gU1BMSVRfTU9ERSB8fCB0aGlzLl9sb2NrLmlzTG9ja2VkKCkgfHwgdGhpcy5faXNPdGhlclNpZGVPcGVuKClcbiAgICAgICAgICB8fCAhdmFsaWREcmFnKGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uKVxuICAgICAgICAgIHx8ICghaXNPcGVuICYmIGFyZWEgIT09IDAgJiYgZGlzdGFuY2UgPiBhcmVhKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdzd2lwZWFibGUnKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLm9ic2VydmVkQXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4gdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBzaWRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc2lkZScpID09PSAncmlnaHQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3N3aXBlICYmIHRoaXMuX3N3aXBlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9hbmltYXRvciA9IHRoaXMuX2FuaW1hdGlvbk9wdCA9IHRoaXMuX3N3aXBlID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2FuaW1hdGlvbicsICd3aWR0aCcsICdjb2xsYXBzZScsICdzd2lwZWFibGUnLCAnYW5pbWF0aW9uLW9wdGlvbnMnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS51cGRhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTsgLy8gU29tZXRpbWVzIHVuZGVmaW5lZC4gQ0UgYnVnP1xuICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gL15cXGQrKHB4fCUpJC8udGVzdChjdXJyZW50KSA/IGN1cnJlbnQgOiAnODAlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzW3V0aWwuY2FtZWxpemUoYF91cGRhdGUtJHtuYW1lfWApXShjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBfZW1pdEV2ZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zbGljZSgwLCAzKSAhPT0gJ3ByZScpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge3NpZGU6IHRoaXN9KTtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7XG4gICAgICBzaWRlOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfaXNPdGhlclNpZGVPcGVuKCkge1xuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKHRoaXMucGFyZW50RWxlbWVudCxcbiAgICAgIGVsID0+IGVsIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciAmJiBlbCAhPT0gdGhpcyAmJiBlbC5fbW9kZSA9PT0gQ09MTEFQU0VfTU9ERSAmJiBlbC5pc09wZW5cbiAgICApO1xuICB9XG5cbiAgX3VwZGF0ZUNvbGxhcHNlKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbGxhcHNlJykpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKFNQTElUX01PREUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnY29sbGFwc2UnKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTW9kZShDT0xMQVBTRV9NT0RFKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5jaGFuZ2VUYXJnZXQodmFsdWUpO1xuICB9XG5cbiAgX3VwZGF0ZU1vZGUobW9kZSkge1xuICAgIGlmIChtb2RlICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RlJywgbW9kZSk7IC8vIHJlYWRvbmx5IGF0dHJpYnV0ZSBmb3IgdGhlIHVzZXJzXG5cbiAgICAgIGlmIChtb2RlID09PSBTUExJVF9NT0RFKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yICYmIHRoaXMuX2FuaW1hdG9yLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDTE9TRURfU1RBVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPT09IE9QRU5fU1RBVEUgJiYgdGhpcy5fYW5pbWF0b3Iub3BlbigpO1xuICAgICAgfVxuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ21vZGVjaGFuZ2UnLCB7IHNpZGU6IHRoaXMsIG1vZGUgfSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbihhbmltYXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykpIHtcbiAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5kZWFjdGl2YXRlKCk7XG4gICAgICB0aGlzLl9hbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcih7YW5pbWF0aW9ufSk7XG4gICAgICB0aGlzLl9hbmltYXRvci5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbk9wdCA9IHtcbiAgICAgICAgdGltaW5nOiB0aGlzLl9hbmltYXRvci5kdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb246IHRoaXMuX2FuaW1hdG9yLmR1cmF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb25PcHRpb25zKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIHtcbiAgICB0aGlzLl9hbmltYXRvci51cGRhdGVPcHRpb25zKEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgbG9jYXRpb24gdG8gbG9hZCBpbiB0aGUgc3BsaXR0ZXIgc2lkZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBwYWdlXG4gICAqL1xuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBnZXQgX2NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB1dGlsLnRocm93UGFnZUxvYWRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblN3aXBlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvb2sgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIHNsaWRlcyB0aGUgc3BsaXR0ZXIuIEl0IGdldHMgYSBkZWNpbWFsIHJhdGlvICgwLTEpIGFuZCBhbiBhbmltYXRpb25PcHRpb25zIG9iamVjdCBhcyBhcmd1bWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvblN3aXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9vblN3aXBlO1xuICB9XG5cbiAgc2V0IG9uU3dpcGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJvblN3aXBlXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG4gICAgdGhpcy5fb25Td2lwZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpc09wZW5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgd2hlbiB0aGUgbWVudSBpcyBvcGVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlID09PSBDT0xMQVBTRV9NT0RFICYmIHRoaXMuX3N0YXRlICE9PSBDTE9TRURfU1RBVEU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBvcGVuXG4gICAqIEBzaWduYXR1cmUgb3Blbihbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW4gbWVudSBpbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ44Gr44Gq44Gj44Gm44GE44KLb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIG9wZW4ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZShvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb3NlXG4gICAqIEBzaWduYXR1cmUgY2xvc2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY2xvc2Uob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZShvcHRpb25zLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVucyBpZiBpdCdzIGNsb3NlZC4gQ2xvc2VzIGlmIGl0J3Mgb3Blbi5bL2VuXVxuICAgKiAgIFtqYV3plovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplonjgZjjgb7jgZnjgZ3jgZfjgabplovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShvcHRpb25zID0ge30sIGZvcmNlKSB7XG4gICAgY29uc3Qgc2hvdWxkT3BlbiA9IHR5cGVvZiBmb3JjZSA9PT0gJ2Jvb2xlYW4nID8gZm9yY2UgOiAhdGhpcy5pc09wZW47XG4gICAgY29uc3QgYWN0aW9uID0gc2hvdWxkT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScsXG4gICAgICBGSU5BTF9TVEFURSA9IHNob3VsZE9wZW4gPyBPUEVOX1NUQVRFIDogQ0xPU0VEX1NUQVRFO1xuXG4gICAgaWYgKHRoaXMuX21vZGUgPT09IFNQTElUX01PREUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgc3BsaXR0ZXItc2lkZSBhY3Rpb24gaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkT3BlbiAmJiB0aGlzLl9pc090aGVyU2lkZU9wZW4oKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIG1lbnUgaXMgYWxyZWFkeSBvcGVuLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdEV2ZW50KGBwcmUke2FjdGlvbn1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke2FjdGlvbn0gZXZlbnQuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5sb2NrID0gdGhpcy5fbG9jay5sb2NrKCk7XG4gICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yW2FjdGlvbl0oKCkgPT4ge1xuICAgICAgICB1dGlsLmlvc1BhZ2VTY3JvbGxGaXgoc2hvdWxkT3Blbik7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gRklOQUxfU1RBVEU7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgICB0aGlzLl9lbWl0RXZlbnQoYHBvc3Qke2FjdGlvbn1gKTtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhIGA8dGVtcGxhdGU+YC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn1VSTOOCkuODoeOCpOODs+ODmuODvOOCuOOCkuiqreOBv+i+vOOBv+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8ICgoKSA9PiB7fSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgb2xkQ29udGVudCA9IHRoaXMuX2NvbnRlbnQgfHwgbnVsbDtcblxuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChvbGRDb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQob2xkQ29udGVudCk7XG4gICAgICAgICAgb2xkQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcblxuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMuX2NvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlb3BlbicsICdwb3N0b3BlbicsICdwcmVjbG9zZScsICdwb3N0Y2xvc2UnLCAnbW9kZWNoYW5nZSddO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxub25zRWxlbWVudHMuU3BsaXR0ZXJTaWRlID0gU3BsaXR0ZXJTaWRlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLXNpZGUnLCBTcGxpdHRlclNpZGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VDaGVja2JveEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtY2hlY2tib3gnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3N3aXRjaC0tKicsXG4gICcuc3dpdGNoX19pbnB1dCc6ICdzd2l0Y2gtLSpfX2lucHV0JyxcbiAgJy5zd2l0Y2hfX2hhbmRsZSc6ICdzd2l0Y2gtLSpfX2hhbmRsZScsXG4gICcuc3dpdGNoX190b2dnbGUnOiAnc3dpdGNoLS0qX190b2dnbGUnXG59O1xuXG5jb25zdCBsb2NhdGlvbnMgPSB7XG4gIGlvczogWzEsIDIxXSxcbiAgbWF0ZXJpYWw6IFswLCAxNl1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXN3aXRjaFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU3dpdGNoIGNvbXBvbmVudC4gVGhlIHN3aXRjaCBjYW4gYmUgdG9nZ2xlZCBib3RoIGJ5IGRyYWdnaW5nIGFuZCB0YXBwaW5nLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc3dpdGNoIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOCueOCpOODg+ODgeOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzd2l0Y2hbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIExwWFpRUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3N3aXRjaFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zd2l0Y2ggY2hlY2tlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBkaXNhYmxlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBtb2RpZmllcj1cIm1hdGVyaWFsXCI+PC9vbnMtc3dpdGNoPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN3aXRjaEVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdtb2RpZmllcicsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX29uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlbGVhc2UgPSB0aGlzLl9vblJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9sYXN0VGltZVN0YW1wID0gMDtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdzd2l0Y2gnO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9fdG9nZ2xlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19oYW5kbGVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9fdG91Y2hcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdjaGVja2JveCc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfZ2V0UG9zaXRpb24oZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgcmV0dXJuIE1hdGgubWluKGxbMV0sIE1hdGgubWF4KGxbMF0sIHRoaXMuX3N0YXJ0WCArIGUuZ2VzdHVyZS5kZWx0YVgpKTtcbiAgfVxuXG4gIF9lbWl0Q2hhbmdlRXZlbnQoKSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjaGFuZ2UnLCB7XG4gICAgICB2YWx1ZTogdGhpcy5jaGVja2VkLFxuICAgICAgc3dpdGNoOiB0aGlzLFxuICAgICAgaXNJbnRlcmFjdGl2ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gIH1cblxuICBfb25DbGljayhldikge1xuICAgIGlmIChldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGAke3RoaXMuZGVmYXVsdEVsZW1lbnRDbGFzc31fX3RvdWNoYClcbiAgICAgIHx8IChldi50aW1lU3RhbXAgLSB0aGlzLl9sYXN0VGltZVN0YW1wIDwgNTApIC8vIFByZXZlbnQgc2Vjb25kIGNsaWNrIHRyaWdnZXJlZCBieSA8bGFiZWw+XG4gICAgKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0VGltZVN0YW1wID0gZXYudGltZVN0YW1wO1xuICB9XG5cbiAgX29uSG9sZChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICBNb2RpZmllclV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ2FjdGl2ZScpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGUpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLmNvbnN1bWVkID0gdHJ1ZTtcblxuICAgIE1vZGlmaWVyVXRpbC5hZGRNb2RpZmllcih0aGlzLCAnYWN0aXZlJyk7XG4gICAgdGhpcy5fc3RhcnRYID0gdGhpcy5fbG9jYXRpb25zW3RoaXMuY2hlY2tlZCA/IDEgOiAwXTsvLyAtIGUuZ2VzdHVyZS5kZWx0YVg7XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9vblJlbGVhc2UpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl9oYW5kbGUuc3R5bGUubGVmdCA9IHRoaXMuX2dldFBvc2l0aW9uKGUpICsgJ3B4JztcbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihlKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5jaGVja2VkO1xuXG4gICAgdGhpcy5jaGVja2VkID0gcG9zaXRpb24gPj0gKGxbMF0gKyBsWzFdKSAvIDI7XG5cbiAgICBpZiAodGhpcy5jaGVja2VkICE9PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9vblJlbGVhc2UpO1xuXG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSAnJztcbiAgICBNb2RpZmllclV0aWwucmVtb3ZlTW9kaWZpZXIodGhpcywgJ2FjdGl2ZScpO1xuICB9XG5cbiAgY2xpY2soZXYgPSB7fSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgdGhpcy5fbGFzdFRpbWVTdGFtcCA9IGV2LnRpbWVTdGFtcCB8fCAwO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfaGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19oYW5kbGVgKTtcbiAgfVxuXG4gIGdldCBjaGVja2JveCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQ7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHsgZHJhZ01pbkRpc3RhbmNlOiAxLCBob2xkVGltZW91dDogMjUxLCBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLmNsaWNrKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBjb25zdCBtZCA9IChjdXJyZW50IHx8ICcnKS5pbmRleE9mKCdtYXRlcmlhbCcpICE9PSAtMTtcbiAgICAgIHRoaXMuX2xvY2F0aW9ucyA9IGxvY2F0aW9uc1ttZCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XG4gICAgfVxuXG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN3aXRjaCBpcyB0b2dnbGVkLlsvZW5dXG4gICAqICAgW2phXU9OL09GRuOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnN3aXRjaFxuICAgKiAgIFtlbl1Td2l0Y2ggb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn1N3aXRjaOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQudmFsdWVcbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7lgKTjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzSW50ZXJhY3RpdmVcbiAgICogICBbZW5dVHJ1ZSBpZiB0aGUgY2hhbmdlIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHVzZXIgY2xpY2tpbmcgb24gdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgarjganjga7jg6bjg7zjgrbjga7mk43kvZzjgavjgojjgaPjgablpInjgo/jgaPjgZ/loLTlkIjjgavjga90cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgW2phXeOCueOCpOODg+ODgeOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44KS54Sh5Yq544Gu54q25oWL44Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2hlY2tlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7nirbmhYvjgavjgZnjgovjgajjgY3jgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYGlkYCBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHZhbHVlIGlzIGB0cnVlYCBpZiB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tib3hcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB1bmRlcmx5aW5nIGNoZWNrYm94IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI5YaF6YOo44GuY2hlY2tib3jopoHntKDjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxufVxuXG5vbnNFbGVtZW50cy5Td2l0Y2ggPSBTd2l0Y2hFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3dpdGNoJywgU3dpdGNoRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBTd2lwZXIgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL3N3aXBlcic7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRhYmJhcl9fY29udGVudCc6ICd0YWJiYXItLSpfX2NvbnRlbnQnLFxuICAnLnRhYmJhcl9fYm9yZGVyJzogJ3RhYmJhci0tKl9fYm9yZGVyJyxcbiAgJy50YWJiYXInOiAndGFiYmFyLS0qJ1xufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHRhYmJhckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuY29uc3QgbnVsbFBhZ2UgPSBpbnRlcm5hbC5udWxsRWxlbWVudDtcbmNvbnN0IGxlcnAgPSAoeDAsIHgxLCB0KSA9PiAoMSAtIHQpICogeDAgKyB0ICogeDE7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYmJhclxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1BIGNvbXBvbmVudCB0byBkaXNwbGF5IGEgdGFiIGJhciBvbiB0aGUgYm90dG9tIG9mIGEgcGFnZS4gVXNlZCB3aXRoIGA8b25zLXRhYj5gIHRvIG1hbmFnZSBwYWdlcyB1c2luZyB0YWJzLlsvZW5dXG4gKiAgIFtqYV3jgr/jg5bjg5Djg7zjgpLjg5rjg7zjgrjkuIvpg6jjgavooajnpLrjgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJvbnMtdGFi44Go57WE44G/5ZCI44KP44Gb44Gm5L2/44GG44GT44Go44Gn44CB44Oa44O844K444KS566h55CG44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHBHdURMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXUEgdGFiYmFyIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBhdXRvZ3Jvd1xuICogICBbZW5dVGFicyBhdXRvbWF0aWNhbGx5IGdyb3cgZGVwZW5kaW5nIG9uIHRoZWlyIGNvbnRlbnQgaW5zdGVhZCBvZiBoYXZpbmcgYSBmaXhlZCB3aWR0aC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0b3AtYm9yZGVyXG4gKiAgIFtlbl1TaG93cyBhIHN0YXRpYyBib3JkZXItYm90dG9tIGluIHRhYnMgZm9yIGlPUyB0b3AgdGFiYmFycy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRhYlxuICogICBbZW5dVGhlIGA8b25zLXRhYj5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXRhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5dVGhlIGA8b25zLXBhZ2U+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuICpcbiAqIDx0ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGJlZm9yZSB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgY2hhbmdlIGV2ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBruWkieabtOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBhZnRlciB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44Gj44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHJlYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBpZiB0aGUgYWxyZWFkeSBvcGVuIHRhYiBpcyB0YXBwZWQgYWdhaW4uWy9lbl1cbiAgICogICBbamFd44GZ44Gn44Gr44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44GM44KC44GG5LiA5bqm44K/44OD44OX44KE44Kv44Oq44OD44Kv44GV44KM44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgbm9uZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgYm90dG9tXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UYWJiYXIncyBwb3NpdGlvbi4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwiYm90dG9tXCJgIGFuZCBgXCJ0b3BcImAuIFVzZSBgXCJhdXRvXCJgIHRvIGNob29zZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gcGxhdGZvcm0gKGJvdHRvbSBmb3IgaU9TIGZsYXQgZGVzaWduLCB0b3AgZm9yIE1hdGVyaWFsIERlc2lnbikuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXCJib3R0b21cIuOCguOBl+OBj+OBr1widG9wXCLjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImJvdHRvbVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHRhYiBiYXIgY2FuIGJlIHNjcm9sbGVkIGJ5IGRyYWcgb3Igc3dpcGUuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OW44OQ44O844KS44K544Ov44Kk44OX44KE44OJ44Op44OD44Kw44Gn56e75YuV44Gn44GN44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWdub3JlLWVkZ2Utd2lkdGhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMjBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3RhbmNlIGluIHBpeGVscyBmcm9tIGJvdGggZWRnZXMuIFN3aXBpbmcgb24gdGhlc2UgYXJlYXMgd2lsbCBwcmlvcml0aXplIHBhcmVudCBjb21wb25lbnRzIHN1Y2ggYXMgYG9ucy1zcGxpdHRlcmAgb3IgYG9ucy1uYXZpZ2F0b3JgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGhpZGUtdGFic1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0byBoaWRlIHRoZSB0YWJzLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluOCkumdnuihqOekuuOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYi1ib3JkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgdGFicyBzaG93IGEgZHluYW1pYyBib3R0b20gYm9yZGVyLiBPbmx5IHdvcmtzIGZvciBpT1MgZmxhdCBkZXNpZ24gc2luY2UgdGhlIGJvcmRlciBpcyBhbHdheXMgdmlzaWJsZSBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0YWJiYXIuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9sb2FkSW5hY3RpdmUgPSB1dGlsLmRlZmVyKCk7IC8vIEltcHJvdmVzICMyMzI0XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuX3N3aXBlcikge1xuICAgICAgdGhpcy5fc3dpcGVyID0gbmV3IFN3aXBlcih7XG4gICAgICAgIGdldEVsZW1lbnQ6ICgpID0+IHRoaXMuX2NvbnRlbnRFbGVtZW50LFxuICAgICAgICBnZXRJbml0aWFsSW5kZXg6ICgpID0+IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUtaW5kZXgnKSxcbiAgICAgICAgZ2V0QXV0b1Njcm9sbFJhdGlvOiB0aGlzLl9nZXRBdXRvU2Nyb2xsUmF0aW8uYmluZCh0aGlzKSxcbiAgICAgICAgZ2V0QnViYmxlV2lkdGg6ICgpID0+IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdpZ25vcmUtZWRnZS13aWR0aCcpIHx8IDI1LCAxMCksXG4gICAgICAgIGlzQXV0b1Njcm9sbGFibGU6ICgpID0+IHRydWUsXG4gICAgICAgIHByZUNoYW5nZUhvb2s6IHRoaXMuX29uUHJlQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICAgIHBvc3RDaGFuZ2VIb29rOiB0aGlzLl9vblBvc3RDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgcmVmcmVzaEhvb2s6IHRoaXMuX29uUmVmcmVzaC5iaW5kKHRoaXMpLFxuICAgICAgICBzY3JvbGxIb29rOiB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpXG4gICAgICB9KTtcblxuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGFiYmFyRWxlbWVudCwgJy50YWJiYXJfX2JvcmRlcicpO1xuICAgICAgICB0aGlzLl9zd2lwZXIuaW5pdCh7IHN3aXBlYWJsZTogdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgIGlmICghdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtcGFnZScsIHAgPT4gcCA9PT0gZG9jdW1lbnQuYm9keSkpIHtcbiAgICAgICAgdGhpcy5fc2hvdygpOyAvLyBUaGlzIHRhYmJhciBpcyB0aGUgdG9wIGNvbXBvbmVudFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N3aXBlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBudWxsO1xuICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3RhYnNSZWN0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4geyAuLi5ldmVudCwgaW5kZXg6IGV2ZW50LmFjdGl2ZUluZGV4LCB0YWJJdGVtOiB0aGlzLnRhYnNbZXZlbnQuYWN0aXZlSW5kZXhdIH07XG4gIH1cblxuICBfb25Qb3N0Q2hhbmdlKGV2ZW50KSB7XG4gICAgZXZlbnQgPSB0aGlzLl9ub3JtYWxpemVFdmVudChldmVudCk7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywgZXZlbnQpO1xuICAgIGNvbnN0IHBhZ2UgPSBldmVudC50YWJJdGVtLnBhZ2VFbGVtZW50O1xuICAgIHBhZ2UgJiYgcGFnZS5fc2hvdygpO1xuICB9XG5cbiAgX29uUHJlQ2hhbmdlKGV2ZW50KSB7XG4gICAgZXZlbnQgPSB0aGlzLl9ub3JtYWxpemVFdmVudChldmVudCk7XG4gICAgZXZlbnQuY2FuY2VsID0gKCkgPT4gZXZlbnQuY2FuY2VsZWQgPSB0cnVlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVjaGFuZ2UnLCBldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmNhbmNlbGVkKSB7XG4gICAgICBjb25zdCB7IGFjdGl2ZUluZGV4LCBsYXN0QWN0aXZlSW5kZXggfSA9IGV2ZW50O1xuICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFicztcblxuICAgICAgdGFic1thY3RpdmVJbmRleF0uc2V0QWN0aXZlKHRydWUpO1xuICAgICAgaWYgKGxhc3RBY3RpdmVJbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IHByZXZUYWIgPSB0YWJzW2xhc3RBY3RpdmVJbmRleF07XG4gICAgICAgIHByZXZUYWIuc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgICAgcHJldlRhYi5wYWdlRWxlbWVudCAmJiBwcmV2VGFiLnBhZ2VFbGVtZW50Ll9oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50LmNhbmNlbGVkXG4gIH1cblxuICBfb25TY3JvbGwoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90YWJiYXJCb3JkZXIpIHtcbiAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS50cmFuc2l0aW9uID0gYGFsbCAke29wdGlvbnMuZHVyYXRpb24gfHwgMH1zICR7b3B0aW9ucy50aW1pbmcgfHwgJyd9YDtcblxuICAgICAgaWYgKHRoaXMuX2F1dG9ncm93ICYmIHRoaXMuX3RhYnNSZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYSA9IE1hdGguZmxvb3IoaW5kZXgpLCBiID0gTWF0aC5jZWlsKGluZGV4KSwgciA9IGluZGV4ICUgMTtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLndpZHRoID0gbGVycCh0aGlzLl90YWJzUmVjdFthXS53aWR0aCwgdGhpcy5fdGFic1JlY3RbYl0ud2lkdGgsIHIpICsgJ3B4JztcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2xlcnAodGhpcy5fdGFic1JlY3RbYV0ubGVmdCwgdGhpcy5fdGFic1JlY3RbYl0ubGVmdCwgcil9cHgsIDAsIDApYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtpbmRleCAqIDEwMH0lLCAwLCAwKWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKGluZGV4LCBvcHRpb25zKTtcbiAgfVxuXG4gIF9vblJlZnJlc2goKSB7XG4gICAgdGhpcy5fYXV0b2dyb3cgPSB1dGlsLmhhc01vZGlmaWVyKHRoaXMsICdhdXRvZ3JvdycpO1xuICAgIHRoaXMuX3RhYnNSZWN0ID0gdGhpcy50YWJzLm1hcCh0YWIgPT4gdGFiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICBpZiAodGhpcy5fdGFiYmFyQm9yZGVyKSB7XG4gICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUuZGlzcGxheSA9IHRoaXMuaGFzQXR0cmlidXRlKCd0YWItYm9yZGVyJykgfHwgdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKTtcbiAgICAgIGlmICh0aGlzLl90YWJzUmVjdC5sZW5ndGggPiAwICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLndpZHRoID0gdGhpcy5fdGFic1JlY3RbaW5kZXhdLndpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0QXV0b1Njcm9sbFJhdGlvKG1hdGNoZXMsIHZlbG9jaXR5LCBzaXplKSB7XG4gICAgY29uc3QgcmF0aW8gPSAuNjsgLy8gQmFzZSByYXRpb1xuICAgIGNvbnN0IG1vZGlmaWVyID0gc2l6ZSAvIDMwMCAqIChtYXRjaGVzID8gLTEgOiAxKTsgLy8gQmFzZWQgb24gc2NyZWVuIHNpemVcbiAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgcmF0aW8gKyB2ZWxvY2l0eSAqIG1vZGlmaWVyKSk7XG4gIH1cblxuICBnZXQgX3RhYmJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiYmFyJyk7XG4gIH1cblxuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYmJhcl9fY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IF90YXJnZXRFbGVtZW50KCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudDtcbiAgICByZXR1cm4gY29udGVudCAmJiBjb250ZW50LmNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudCB8fCB1dGlsLmNyZWF0ZSgnLnRhYmJhcl9fY29udGVudCcpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnb25zLXRhYmJhcl9fY29udGVudCcpO1xuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhckVsZW1lbnQgfHwgdXRpbC5jcmVhdGUoJy50YWJiYXInKTtcbiAgICB0YWJiYXIuY2xhc3NMaXN0LmFkZCgnb25zLXRhYmJhcl9fZm9vdGVyJyk7XG5cbiAgICBpZiAoIXRhYmJhci5wYXJlbnROb2RlKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gTnVtYmVyKHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpKTsgLy8gMCBieSBkZWZhdWx0XG4gICAgaWYgKHRhYmJhci5jaGlsZHJlbi5sZW5ndGggPiBhY3RpdmVJbmRleCAmJiAhdXRpbC5maW5kQ2hpbGQodGFiYmFyLCAnW2FjdGl2ZV0nKSkge1xuICAgICAgdGFiYmFyLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICcnKTtcbiAgICB9XG5cbiAgICB0aGlzLl90YWJiYXJCb3JkZXIgPSB1dGlsLmZpbmRDaGlsZCh0YWJiYXIsICcudGFiYmFyX19ib3JkZXInKSB8fCB1dGlsLmNyZWF0ZSgnLnRhYmJhcl9fYm9yZGVyJyk7XG4gICAgdGFiYmFyLmFwcGVuZENoaWxkKHRoaXMuX3RhYmJhckJvcmRlcik7XG4gICAgdGFiYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy1zd2lwZXItdGFiYmFyJyk7IC8vIEhpZGVzIG1hdGVyaWFsIGJvcmRlclxuXG4gICAgIWNvbnRlbnQuY2hpbGRyZW5bMF0gJiYgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgIWNvbnRlbnQuY2hpbGRyZW5bMV0gJiYgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgY29udGVudC5hcHBlbmRDaGlsZCA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQuYmluZChjb250ZW50LmNoaWxkcmVuWzBdKTtcbiAgICBjb250ZW50Lmluc2VydEJlZm9yZSA9IGNvbnRlbnQuaW5zZXJ0QmVmb3JlLmJpbmQoY29udGVudC5jaGlsZHJlblswXSk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGFiYmFyKTsgLy8gVHJpZ2dlcnMgb25zLXRhYiBjb25uZWN0ZWRDYWxsYmFja1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKSk7XG4gICAgY29uc3QgYWN0aW9uID0gdG9wID8gdXRpbC5hZGRNb2RpZmllciA6IHV0aWwucmVtb3ZlTW9kaWZpZXI7XG5cbiAgICBhY3Rpb24odGhpcywgJ3RvcCcpO1xuXG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgY29udGVudFJlYWR5KHBhZ2UsICgpID0+IHtcbiAgICAgICAgbGV0IHAgPSAwO1xuICAgICAgICBpZiAocGFnZS5jaGlsZHJlblswXSAmJiB1dGlsLm1hdGNoKHBhZ2UuY2hpbGRyZW5bMF0sICdvbnMtdG9vbGJhcicpKSB7XG4gICAgICAgICAgYWN0aW9uKHBhZ2UuY2hpbGRyZW5bMF0sICdub3NoYWRvdycpO1xuICAgICAgICAgIHAgPSAxOyAvLyBWaXN1YWwgZml4IGZvciBzb21lIGRldmljZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpO1xuICAgICAgICBjb25zdCBjcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIG51bGwpXG5cbiAgICAgICAgdGhpcy5zdHlsZS50b3AgPSB0b3AgPyBwYXJzZUludChjcy5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXRvcCcpLCAxMCkgLSBwICsgJ3B4JyA6ICcnO1xuXG4gICAgICAgIC8vIFJlZnJlc2ggY29udGVudCB0b3AgLSBGaXggZm9yIGlPUyA4XG4gICAgICAgIGNvbnRlbnQuc3R5bGUudG9wID0gY3MudG9wO1xuICAgICAgICBjb250ZW50LnN0eWxlLnRvcCA9ICcnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcbiAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzdGF0dXMtYmFyLWZpbGwnLCB0b3AgJiYgIWZpbGxlZCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgdG9wUGFnZSgpIHtcbiAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzLFxuICAgICAgaW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgcmV0dXJuIHRhYnNbaW5kZXhdXG4gICAgICA/IHRhYnNbaW5kZXhdLnBhZ2VFbGVtZW50IHx8IHRoaXMucGFnZXNbMF0gfHwgbnVsbFxuICAgICAgOiBudWxsO1xuICB9XG5cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLl90YXJnZXRFbGVtZW50LmNoaWxkcmVuKTtcbiAgfVxuXG4gIGdldCB0YWJzKCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodGhpcy5fdGFiYmFyRWxlbWVudC5jaGlsZHJlbiwgZSA9PiBlLnRhZ05hbWUgPT09ICdPTlMtVEFCJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVUYWJcbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVUYWIoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRhYiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgcnVucyB3aGVuIHRoZSBuZXcgcGFnZSBoYXMgbG9hZGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgb3B0aW9uIGlzIFwibm9uZVwiLCB0aGUgdHJhbnNpdGlvbiB3b24ndCBzbGlkZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgc3BlY2lmaWVkIHRhYiBwYWdlLiBBbmltYXRpb25zIGFuZCB0aGVpciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gu44K/44OW44KS6KGo56S644GX44G+44GZ44CC44Ki44OL44Oh44O844K344On44Oz44Gq44Gp44Gu44Kq44OX44K344On44Oz44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZVRhYihuZXh0SW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByZXZJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKTtcbiAgICBjb25zdCBwcmV2VGFiID0gdGhpcy50YWJzW3ByZXZJbmRleF0sXG4gICAgICBuZXh0VGFiID0gdGhpcy50YWJzW25leHRJbmRleF07XG5cbiAgICBpZiAoIW5leHRUYWIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IG1hdGNoIGFueSB0YWIuJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRJbmRleCA9PT0gcHJldkluZGV4KSB7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3JlYWN0aXZlJywgeyBpbmRleDogbmV4dEluZGV4LCBhY3RpdmVJbmRleDogbmV4dEluZGV4LCB0YWJJdGVtOiBuZXh0VGFiIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXh0VGFiLnBhZ2VFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogbmV4dFRhYi5sb2FkZWQgaXMgYnJva2VuIGluIFpvbmUuanMgcHJvbWlzZXMgKEFuZ3VsYXIyKVxuICAgIGNvbnN0IG5leHRQYWdlID0gbmV4dFRhYi5wYWdlRWxlbWVudDtcbiAgICByZXR1cm4gKG5leHRQYWdlID8gUHJvbWlzZS5yZXNvbHZlKG5leHRQYWdlKSA6IG5leHRUYWIubG9hZGVkKVxuICAgICAgLnRoZW4obmV4dFBhZ2UgPT4gdGhpcy5fc3dpcGVyLnNldEFjdGl2ZUluZGV4KG5leHRJbmRleCwge1xuICAgICAgICByZWplY3Q6IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGFuaW1hdGlvbjogcHJldlRhYiAmJiBuZXh0UGFnZSA/IG9wdGlvbnMuYW5pbWF0aW9uIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSA6ICdub25lJyxcbiAgICAgICAgYW5pbWF0aW9uT3B0aW9uczogdXRpbC5leHRlbmQoXG4gICAgICAgICAgeyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguNCwgLjcsIC41LCAxKScgfSxcbiAgICAgICAgICB0aGlzLmhhc0F0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSA/IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSA6IHt9LFxuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgICApXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sobmV4dFBhZ2UpO1xuICAgICAgICByZXR1cm4gbmV4dFBhZ2U7XG4gICAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRUYWJiYXJWaXNpYmlsaXR5XG4gICAqIEBzaWduYXR1cmUgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZWQgdG8gaGlkZSBvciBzaG93IHRoZSB0YWIgYmFyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQuc3R5bGVbdGhpcy5fdG9wID8gJ3RvcCcgOiAnYm90dG9tJ10gPSB2aXNpYmxlID8gJycgOiAnMHB4JztcbiAgICAgIHRoaXMuX3RhYmJhckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgIHZpc2libGUgJiYgdGhpcy5fb25SZWZyZXNoKCk7XG4gICAgfSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eSh0cnVlKTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zZXRUYWJiYXJWaXNpYmlsaXR5KGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSB0YWJiYXIgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90YWJiYXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc3dpcGVhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRW5hYmxlIHN3aXBlIGludGVyYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXN3aXBlYWJsZeOBp+OBguOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHN3aXBlYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpO1xuICB9XG5cbiAgc2V0IHN3aXBlYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3dpcGVhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblN3aXBlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvb2sgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIHNsaWRlcyB0aGUgdGFiYmFyLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHV0aWwudGhyb3coYFwib25Td2lwZVwiIG11c3QgYmUgYSBmdW5jdGlvbmApXG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZVRhYkluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlVGFiSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YWIuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGFiIGluZGV4IG9uIGN1cnJlbnQgYWN0aXZlIHRhYi4gSWYgYWN0aXZlIHRhYiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CC54++5Zyo44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM44Gq44GE5aC05ZCI44Gr44GvLTHjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlVGFiSW5kZXgodGFicyA9IHRoaXMudGFicykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhYnNbaV0gJiYgdGFic1tpXS50YWdOYW1lID09PSAnT05TLVRBQicgJiYgdGFic1tpXS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLl9zd2lwZXIuc2hvdygpO1xuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnM7XG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgodGFicyk7XG4gICAgICB0aGlzLl9sb2FkSW5hY3RpdmUucmVzb2x2ZSgpO1xuICAgICAgaWYgKHRhYnMubGVuZ3RoID4gMCAmJiBhY3RpdmVJbmRleCA+PSAwKSB7XG4gICAgICAgIHRhYnNbYWN0aXZlSW5kZXhdLmxvYWRlZC50aGVuKGVsID0+IGVsICYmIHNldEltbWVkaWF0ZSgoKSA9PiBlbC5fc2hvdygpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLl9zd2lwZXIuaGlkZSgpO1xuICAgIGNvbnN0IHRvcFBhZ2UgPSB0aGlzLnRvcFBhZ2U7XG4gICAgdG9wUGFnZSAmJiB0b3BQYWdlLl9oaWRlKCk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLnRhYnMuZm9yRWFjaCh0YWIgPT4gdGFiLnJlbW92ZSgpKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncG9zaXRpb24nLCAnc3dpcGVhYmxlJywgJ3RhYi1ib3JkZXInLCAnaGlkZS10YWJzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgIGNvbnN0IGlzVG9wID0gbSA9PiAvKF58XFxzKyl0b3AoJHxcXHMrKS9pLnRlc3QobSk7XG4gICAgICBpc1RvcChsYXN0KSAhPT0gaXNUb3AoY3VycmVudCkgJiYgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSAmJiB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3N3aXBlYWJsZScpIHtcbiAgICAgIHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIudXBkYXRlU3dpcGVhYmxlKHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaGlkZS10YWJzJykge1xuICAgICAgdGhpcy5zZXRUYWJiYXJWaXNpYmlsaXR5KCF0aGlzLmhhc0F0dHJpYnV0ZSgnaGlkZS10YWJzJykgfHwgY3VycmVudCA9PT0gJ2ZhbHNlJyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVjaGFuZ2UnLCAncG9zdGNoYW5nZScsICdyZWFjdGl2ZSddO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlRhYmJhciA9IFRhYmJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWJiYXInLCBUYWJiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IFRhYmJhckVsZW1lbnQgZnJvbSAnLi9vbnMtdGFiYmFyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHsgUGFnZUxvYWRlciwgZGVmYXVsdFBhZ2VMb2FkZXIgfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3RhYmJhcl9faXRlbSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICd0YWJiYXItLSpfX2l0ZW0nLFxuICAnLnRhYmJhcl9fYnV0dG9uJzogJ3RhYmJhci0tKl9fYnV0dG9uJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGFiXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSB0YWIgaW5zaWRlIHRhYiBiYXIuIEVhY2ggYDxvbnMtdGFiPmAgcmVwcmVzZW50cyBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOCv+ODluODkOODvOOBq+mFjee9ruOBleOCjOOCi+WQhOOCouOCpOODhuODoOOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOBneOCjOOBnuOCjOOBrm9ucy10YWLjga/jg5rjg7zjgrjjgpLooajjgZfjgb7jgZnjgIJcbiAqICAgICBvbnMtdGFi6KaB57Sg44Gu5Lit44Gr44Gv44CB44K/44OW44Gr6KGo56S644GV44KM44KL44Kz44Oz44OG44Oz44OE44KS55u05o6l6KiY6L+w44GZ44KL44GT44Go44GM5Ye65p2l44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3RhYmJhclxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1dXG4gKiBAZ3VpZGUgYXBwc2l6ZS5odG1sI3JlbW92aW5nLWljb24tcGFja3MgW2VuXVJlbW92aW5nIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBndWlkZSBmYXEuaHRtbCNob3ctY2FuLWktdXNlLWN1c3RvbS1pY29uLXBhY2tzIFtlbl1BZGRpbmcgY3VzdG9tIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcbiAqICAgW2VuXW9ucy10YWJiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10YWJiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXW9ucy1wYWdlIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxuICogICBbZW5db25zLWljb24gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1pY29u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuICpcbiAqIDx0ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYiBpcyB0YXBwZWQuWy9lbl1cbiAgICogICBbamFdb25zLXRhYuOBjOWPgueFp+OBmeOCi+ODmuODvOOCuOOBuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZSBmb3IgdGhlIHRhYi4gQ2FuIHNwZWNpZnkgdGhlIHNhbWUgaWNvbiBuYW1lIGFzIGA8b25zLWljb24+YC4gQ2hlY2sgW1NlZSBhbHNvXSgjc2VlYWxzbykgc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgm9ucy1pY29u44Go5ZCM44GY44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgICDlgIvliKXjgavjgqLjgqTjgrPjg7PjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovloLTlkIjjga/jgIFiYWNrZ3JvdW5kLWltYWdl44Gq44Gp44GuQ1NT44K544K/44Kk44Or44KS55So44GE44Gm5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBuYW1lIG9mIHRoZSBpY29uIHdoZW4gdGhlIHRhYiBpcyBhY3RpdmUuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gu6Zqb44Gu44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbGFiZWxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBsYWJlbCBvZiB0aGUgdGFiIGl0ZW0uWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz5LiL44Gr6KGo56S644GV44KM44KL44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYmFkZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgYSBub3RpZmljYXRpb24gYmFkZ2Ugb24gdG9wIG9mIHRoZSB0YWIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44K444Gr6KGo56S644GZ44KL5YaF5a6544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0IHRvIHRoZSB0YWIgdGhhdCBpcyBhY3RpdmUgYnkgZGVmYXVsdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKFsnbGFiZWwnLCAnaWNvbicsICdiYWRnZSddLnNvbWUodGhpcy5oYXNBdHRyaWJ1dGUuYmluZCh0aGlzKSkpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuICAgIHRoaXMuX29uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBzZXQgcGFnZUxvYWRlcihsb2FkZXIpIHtcbiAgICBpZiAoIShsb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdXRpbC50aHJvd1BhZ2VMb2FkZXIoKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKHRoaXMuX2J1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuY3JlYXRlKCdidXR0b24udGFiYmFyX19idXR0b24nKTtcbiAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICBidXR0b24uYXBwZW5kQ2hpbGQodGhpcy5jaGlsZE5vZGVzWzBdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dCA9IHV0aWwuY3JlYXRlKCdpbnB1dCcsIHsgZGlzcGxheTogJ25vbmUnIH0pO1xuICAgIGlucHV0LnR5cGUgPSAncmFkaW8nO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgdGhpcy5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgdGhpcy5fdXBkYXRlQnV0dG9uQ29udGVudCgpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdGhpcy5fYnV0dG9uICYmIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMuX2J1dHRvbiwgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpKTtcbiAgfVxuXG4gIF91cGRhdGVCdXR0b25Db250ZW50KCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuX2J1dHRvbjtcblxuICAgIGxldCBpY29uV3JhcHBlciA9IHRoaXMuX2ljb247XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdpY29uJykpIHtcbiAgICAgIGljb25XcmFwcGVyID0gaWNvbldyYXBwZXIgfHwgdXRpbC5jcmVhdGVFbGVtZW50KCc8ZGl2IGNsYXNzPVwidGFiYmFyX19pY29uXCI+PG9ucy1pY29uPjwvb25zLWljb24+PC9kaXY+Jyk7XG4gICAgICBjb25zdCBpY29uID0gaWNvbldyYXBwZXIuY2hpbGRyZW5bMF07XG4gICAgICBjb25zdCBmaXggPSAobGFzdCA9PiAoKSA9PiBpY29uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnaWNvbicsIGxhc3QsIHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJykpKShpY29uLmdldEF0dHJpYnV0ZSgnaWNvbicpKTtcbiAgICAgIGljb24uc2V0QXR0cmlidXRlKCdpY29uJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSk7XG4gICAgICBpY29uV3JhcHBlci5wYXJlbnRFbGVtZW50ICE9PSBidXR0b24gJiYgYnV0dG9uLmluc2VydEJlZm9yZShpY29uV3JhcHBlciwgYnV0dG9uLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAvLyBkaXJ0eSBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9PbnNlblVJL09uc2VuVUkvaXNzdWVzLzE2NTRcbiAgICAgIGljb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgPyBmaXgoKVxuICAgICAgICA6IHNldEltbWVkaWF0ZSgoKSA9PiBpY29uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIGZpeCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWNvbldyYXBwZXIgJiYgaWNvbldyYXBwZXIucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgWydsYWJlbCcsICdiYWRnZSddLmZvckVhY2goKGF0dHIsIGluZGV4KSA9PiB7XG4gICAgICBsZXQgcHJvcCA9IHRoaXMucXVlcnlTZWxlY3RvcihgLnRhYmJhcl9fJHthdHRyfWApO1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHByb3AgPSBwcm9wIHx8IHV0aWwuY3JlYXRlKGAudGFiYmFyX18ke2F0dHJ9YCArIChhdHRyID09PSAnYmFkZ2UnID8gJyBub3RpZmljYXRpb24nIDogJycpKTtcbiAgICAgICAgcHJvcC50ZXh0Q29udGVudCA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICBwcm9wLnBhcmVudEVsZW1lbnQgIT09IGJ1dHRvbiAmJiBidXR0b24uYXBwZW5kQ2hpbGQocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wICYmIHByb3AucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX2lucHV0KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnaW5wdXQnKTtcbiAgfVxuXG4gIGdldCBfYnV0dG9uKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYmJhcl9fYnV0dG9uJyk7XG4gIH1cblxuICBnZXQgX2ljb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLnRhYmJhcl9faWNvbicpO1xuICB9XG5cbiAgZ2V0IF90YWJiYXIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXRhYmJhcicpO1xuICB9XG5cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMucGFyZW50RWxlbWVudC5jaGlsZHJlbiwgdGhpcyk7XG4gIH1cblxuICBfb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMub25DbGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90YWJiYXIuc2V0QWN0aXZlVGFiKHRoaXMuaW5kZXgsIHsgcmVqZWN0OiBmYWxzZSB9KTtcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmUoYWN0aXZlID0gdHJ1ZSkge1xuICAgIHRoaXMuX2lucHV0LmNoZWNrZWQgPSBhY3RpdmU7XG4gICAgdGhpcy5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnLCBhY3RpdmUpO1xuICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdhY3RpdmUnLCBhY3RpdmUpXG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnYWN0aXZlLWljb24nKSkge1xuICAgICAgdGhpcy5faWNvbi5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoJ2ljb24nLCB0aGlzLmdldEF0dHJpYnV0ZShhY3RpdmUgPyAnYWN0aXZlLWljb24nIDogJ2ljb24nKSk7XG4gICAgfVxuICB9XG5cbiAgX2xvYWRQYWdlRWxlbWVudChwYXJlbnQsIHBhZ2UpIHtcbiAgICB0aGlzLl9oYXNMb2FkZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHsgcGFyZW50LCBwYWdlIH0sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChwYWdlRWxlbWVudCwgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdKTsgLy8gRW5zdXJlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBwYWdlRWxlbWVudCgpIHtcbiAgICAvLyBJdCBoYXMgYmVlbiBsb2FkZWQgYnkgb25zLXRhYlxuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZGVkUGFnZTtcbiAgICB9XG4gICAgLy8gTWFudWFsbHkgYXR0YWNoZWQgdG8gRE9NLCAxIHBlciB0YWJcbiAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl90YWJiYXI7XG4gICAgaWYgKHRhYmJhci5wYWdlcy5sZW5ndGggPT09IHRhYmJhci50YWJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRhYmJhci5wYWdlc1t0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgLy8gTG9hZGVkIGluIGFub3RoZXIgd2F5XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgZmFsc2UpO1xuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9sb2FkZWRQYWdlKTtcbiAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5faGFzTG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvYWRlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIGZhbHNlKTtcblxuICAgIGlmICghdXRpbC5pc0F0dGFjaGVkKHRoaXMpIHx8IHRoaXMubG9hZGVkKSB7XG4gICAgICByZXR1cm47IC8vIG9ucy10YWJiYXIgY29tcGlsYXRpb24gbWF5IHRyaWdnZXIgdGhpc1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHRoaXMubG9hZGVkID0gZGVmZXJyZWQucHJvbWlzZTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl90YWJiYXI7XG4gICAgICBpZiAoIXRhYmJhcikge1xuICAgICAgICB1dGlsLnRocm93KCdUYWIgZWxlbWVudHMgbXVzdCBiZSBjaGlsZHJlbiBvZiBUYWJiYXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhYmJhci5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCB0YWJiYXIuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9oYXNMb2FkZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUnKSkge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICAgICAgICAgIHRhYmJhci5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZUluZGV4JywgaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSB0YWJiYXIudGFicy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGFiYmFyLl9vblJlZnJlc2goKTtcbiAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGFiYmFyLl9vblJlZnJlc2goKSk7XG4gICAgICAgIH1cblxuICAgICAgICBUYWJiYXJFbGVtZW50LnJld3JpdGFibGVzLnJlYWR5KHRhYmJhciwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhZ2VUYXJnZXQgPSB0aGlzLnBhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgICAgICAgICBpZiAoIXRoaXMucGFnZUVsZW1lbnQgJiYgcGFnZVRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50VGFyZ2V0ID0gdGFiYmFyLl90YXJnZXRFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgZHVtbXlQYWdlID0gdXRpbC5jcmVhdGUoJ2RpdicsIHsgaGVpZ2h0OiAnMTAwJScsIHdpZHRoOiAnMTAwJScsIHZpc2liaWxpdHk6ICdoaWRkZW4nIH0pO1xuICAgICAgICAgICAgcGFyZW50VGFyZ2V0Lmluc2VydEJlZm9yZShkdW1teVBhZ2UsIHBhcmVudFRhcmdldC5jaGlsZHJlbltpbmRleF0pOyAvLyBFbnN1cmUgcG9zaXRpb25cblxuICAgICAgICAgICAgY29uc3QgbG9hZCA9ICgpID0+IHRoaXMuX2xvYWRQYWdlRWxlbWVudChwYXJlbnRUYXJnZXQsIHBhZ2VUYXJnZXQpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZSgpID8gbG9hZCgpIDogdGFiYmFyLl9sb2FkSW5hY3RpdmUucHJvbWlzZS50aGVuKGxvYWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHRoaXMucGFnZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdpY29uJywgJ2xhYmVsJywgJ3BhZ2UnLCAnYmFkZ2UnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICBjYXNlICdsYWJlbCc6XG4gICAgICBjYXNlICdiYWRnZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCdXR0b25Db250ZW50KCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BhZ2UnOlxuICAgICAgICB0aGlzLnBhZ2UgPSBjdXJyZW50IHx8ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuVGFiID0gVGFiRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRhYicsIFRhYkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZVRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KHRvYXN0LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSlcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIlxuLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBBc2NlbmQgVG9hc3QgQW5pbWF0b3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFzY2VuZFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMjUgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcblxuICAgIHRoaXMubWVzc2FnZURlbGF5ID0gdGhpcy5kdXJhdGlvbiAqIDAuNCArIHRoaXMuZGVsYXk7IC8vIERlbGF5IG1lc3NhZ2Ugb3BhY2l0eSBjaGFuZ2VcbiAgICBpZiAocGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgIHRoaXMuYXNjZW5zaW9uID0gNDg7IC8vIFRvYXN0cyBhcmUgYWx3YXlzIDEgbGluZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLmFzY2Vuc2lvbiA9IDk4OyAvLyA2NCArIDM0XG4gICAgICB9IGVsc2UgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuYXNjZW5zaW9uID0gODU7IC8vIDY0ICsgMjFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXNjZW5zaW9uID0gNjQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuICAgIHV0aWwuZ2xvYmFscy5mYWJPZmZzZXQgPSB0aGlzLmFzY2Vuc2lvbjtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5hc2NlbnNpb259cHgsIDApYCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fZ2V0RmFicygpKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAtJHt0aGlzLmFzY2Vuc2lvbn1weCwgMCkgc2NhbGUoMSlgIH0sIHRoaXMuZGVmKSxcblxuICAgICAgYW5pbWl0KHV0aWwuYXJyYXlGcm9tKHRvYXN0LmNoaWxkcmVuKSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSlcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUodG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdXRpbC5nbG9iYWxzLmZhYk9mZnNldCA9IDA7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5hc2NlbnNpb259cHgsIDApYCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX2dldEZhYnMoKSwgdGhpcy5kZWYpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApIHNjYWxlKDEpYCB9LCB0aGlzLmRlZiksXG5cbiAgICAgIGFuaW1pdCh1dGlsLmFycmF5RnJvbSh0b2FzdC5jaGlsZHJlbiksIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRGYWJzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtZmFiW3Bvc2l0aW9ufj1ib3R0b21dLCBvbnMtc3BlZWQtZGlhbFtwb3NpdGlvbn49Ym90dG9tXScpKS5maWx0ZXIoZmFiID0+IGZhYi52aXNpYmxlKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBMaWZ0LWZhZGUgVG9hc3QgQW5pbWF0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlmdFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMzUgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgICB0aGlzLmJvZHlIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmxpZnRBbW91bnQgPSAnY2FsYygxMDAlICsgMzRweCknO1xuICAgIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyAyMXB4KSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICcxMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCwgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCwgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24odG9hc3QpIHtcbiAgICBpZiAocGFyc2VJbnQodG9hc3Quc3R5bGUudG9wLCAxMCkgPT09IDApIHtcbiAgICAgIHRvYXN0LnN0eWxlLnRvcCA9IHRvYXN0LnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIH1cbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBGYWxsLWZhZGUgVG9hc3QgQW5pbWF0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFsbFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMzUgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgICAgdGhpcy5mYWxsQW1vdW50ID0gJ2NhbGMoLTEwMCUgLSA0NHB4KSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFsbEFtb3VudCA9ICctMTAwJSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KHRvYXN0LCBjYWxsYmFjaykge1xuICAgIHRvYXN0ID0gdG9hc3QuX3RvYXN0O1xuICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvYXN0KTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5mYWxsQW1vdW50fSwgMClgLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUodG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9hc3QpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMuZmFsbEFtb3VudH0sIDApYCwgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKHRvYXN0LCB0cnVlKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHRvYXN0LCBjbGVhblVwKSB7XG4gICAgbGV0IGNvcnJlY3RUb3A7XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIGNvcnJlY3RUb3AgPSAnNDRweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcnJlY3RUb3AgPSAnMCc7XG4gICAgfVxuXG4gICAgaWYgKHRvYXN0LnN0eWxlLnRvcCAhPT0gY29ycmVjdFRvcCkge1xuICAgICAgdG9hc3Quc3R5bGUudG9wID0gY29ycmVjdFRvcDtcbiAgICAgIHRvYXN0LnN0eWxlLmJvdHRvbSA9ICdpbml0aWFsJztcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBGYWRlVG9hc3RBbmltYXRvciBmcm9tICcuL2ZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IEFzY2VuZFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9hc2NlbmQtYW5pbWF0b3InO1xuaW1wb3J0IExpZnRUb2FzdEFuaW1hdG9yIGZyb20gJy4vbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgRmFsbFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9mYWxsLWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy50b2FzdCc6ICd0b2FzdC0tKicsXG4gICcudG9hc3RfX21lc3NhZ2UnOiAndG9hc3QtLSpfX21lc3NhZ2UnLFxuICAnLnRvYXN0X19idXR0b24nOiAndG9hc3QtLSpfX2J1dHRvbidcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAndG9hc3QnO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQXNjZW5kVG9hc3RBbmltYXRvciA6IExpZnRUb2FzdEFuaW1hdG9yLFxuICAnZmFkZSc6IEZhZGVUb2FzdEFuaW1hdG9yLFxuICAnYXNjZW5kJzogQXNjZW5kVG9hc3RBbmltYXRvcixcbiAgJ2xpZnQnOiBMaWZ0VG9hc3RBbmltYXRvcixcbiAgJ2ZhbGwnOiBGYWxsVG9hc3RBbmltYXRvcixcbiAgJ25vbmUnOiBUb2FzdEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b2FzdFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgVG9hc3Qgb3IgU25hY2tiYXIgY29tcG9uZW50IGlzIHVzZWZ1bCBmb3IgZGlzcGxheWluZyBkaXNtaXNzYWJsZSBpbmZvcm1hdGlvbiBvciBzaW1wbGUgYWN0aW9ucyBhdCAobm9ybWFsbHkpIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IGRvZXMgbm90IGJsb2NrIHVzZXIgaW5wdXQsIGFsbG93aW5nIHRoZSBhcHAgdG8gY29udGludWUgaXRzIGZsb3cuIEZvciBzaW1wbGUgdG9hc3RzLCBjb25zaWRlciBgb25zLm5vdGlmaWNhdGlvbi50b2FzdGAgaW5zdGVhZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdG9hc3RcbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnQgaXMgcHJlZmVycmVkIGZvciBkaXNwbGF5aW5nIHVuZGlzbWlzc2FibGUgaW5mb3JtYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvYXN0RWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIHRvYXN0LiBDYW4gYmUgZWl0aGVyIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2RlZmF1bHREQkIgPSBlID0+IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX3RvYXN0KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCBgLiR7ZGVmYXVsdENsYXNzTmFtZX1gKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgLy8gUmVzZXQgcG9zaXRpb24gc3R5bGVcbiAgICB0aGlzLl90b2FzdCAmJiAodGhpcy5fdG9hc3Quc3R5bGUudG9wID0gdGhpcy5fdG9hc3Quc3R5bGUuYm90dG9tID0gJycpO1xuXG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBUb2FzdEFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1RvYXN0QW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAwOyAvLyBMb3dlciB0aGFuIGRpYWxvZ3NcblxuICAgIGNvbnN0IG1lc3NhZ2VDbGFzc05hbWUgPSAndG9hc3RfX21lc3NhZ2UnO1xuICAgIGNvbnN0IGJ1dHRvbkNsYXNzTmFtZSA9ICd0b2FzdF9fYnV0dG9uJztcblxuICAgIGxldCB0b2FzdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsIGAuJHtkZWZhdWx0Q2xhc3NOYW1lfWApO1xuICAgIGlmICghdG9hc3QpIHtcbiAgICAgIHRvYXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICB0b2FzdC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0b2FzdCwgYC4ke2J1dHRvbkNsYXNzTmFtZX1gKTtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodG9hc3QsIGUgPT4gdXRpbC5tYXRjaChlLCAnLmJ1dHRvbicpIHx8IHV0aWwubWF0Y2goZSwgJ2J1dHRvbicpKTtcbiAgICAgIGlmIChidXR0b24pIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChidXR0b25DbGFzc05hbWUpO1xuICAgICAgICB0b2FzdC5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodG9hc3QsIGAuJHttZXNzYWdlQ2xhc3NOYW1lfWApKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IHV0aWwuZmluZENoaWxkKHRvYXN0LCAnLm1lc3NhZ2UnKTtcbiAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0b2FzdC5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHRvYXN0LmNoaWxkTm9kZXNbaV0gIT09IGJ1dHRvbikge1xuICAgICAgICAgICAgbWVzc2FnZS5pbnNlcnRCZWZvcmUodG9hc3QuY2hpbGROb2Rlc1tpXSwgbWVzc2FnZS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UuY2xhc3NMaXN0LmFkZChtZXNzYWdlQ2xhc3NOYW1lKTtcblxuICAgICAgdG9hc3QuaW5zZXJ0QmVmb3JlKG1lc3NhZ2UsIHRvYXN0LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmICh0b2FzdC5wYXJlbnROb2RlICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRvYXN0KTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZGVmYXVsdFwiYCwgYFwiYXNjZW5kXCJgIChBbmRyb2lkKSwgYFwibGlmdFwiYCAoaU9TKSwgYFwiZmFsbFwiYCwgYFwiZmFkZVwiYCBvciBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRvYXN0IHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJkZWZhdWx0XCJgLCBgXCJhc2NlbmRcImAgKEFuZHJvaWQpLCBgXCJsaWZ0XCJgIChpT1MpLCBgXCJmYWxsXCJgLCBgXCJmYWRlXCJgIG9yIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRvYXN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBUb2FzdEFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJBbmltYXRvclwiIHBhcmFtIG11c3QgaW5oZXJpdCBPbnNUb2FzdEVsZW1lbnQuVG9hc3RBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgVG9hc3RBbmltYXRvcigpIHtcbiAgICByZXR1cm4gVG9hc3RBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Ub2FzdCA9IFRvYXN0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvYXN0JywgVG9hc3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VCdXR0b25FbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWJ1dHRvbic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvb2xiYXItYnV0dG9uXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhciBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgb3V0bGluZVxuICogICBbZW5dQSBidXR0b24gd2l0aCBhbiBvdXRsaW5lLlsvZW5dXG4gKiAgIFtqYV3jgqLjgqbjg4jjg6njgqTjg7PjgpLjgoLjgaPjgZ/jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1CdXR0b24gY29tcG9uZW50IGZvciBvbnMtdG9vbGJhciBhbmQgb25zLWJvdHRvbS10b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOBguOCi+OBhOOBr29ucy1ib3R0b20tdG9vbGJhcuOBq+ioree9ruOBp+OBjeOCi+ODnOOCv+ODs+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBjb21waWxhdGlvbi5odG1sI3Rvb2xiYXItY29tcGlsYXRpb25cbiAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIG5hdmlnYXRpb24gYmFyIGF0IHRoZSB0b3Agb2YgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW4gdGhlIG5hdmlnYXRpb24gYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgQnV0dG9uXG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgVGl0bGVcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICA8b25zLWljb24gaWNvbj1cImlvbi1uYXZpY29uXCIgc2l6ZT1cIjI4cHhcIj48L29ucy1pY29uPlxuICogICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xiYXJCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUJ1dHRvbkVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ3JlYXRlcyBhbiBgb25zLWljb25gIGNvbXBvbmVudCB3aXRoIHRoaXMgc3RyaW5nLlsvZW5dXG4gICAqICBbamFdYG9ucy1pY29uYOOCs+ODs+ODneODvOODjeODs+ODiOOCkuaCquaAp+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiB7ICcnOiAndG9vbGJhci1idXR0b24tLSonIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICd0b29sYmFyLWJ1dHRvbic7XG4gIH1cblxuICBnZXQgX3JpcHBsZU9wdCgpIHtcbiAgICByZXR1cm4gW3RoaXMsIHVuZGVmaW5lZCwgeyBjZW50ZXI6ICcnLCAnc2l6ZSc6ICdjb250YWluJywgJ2JhY2tncm91bmQnOiAndHJhbnNwYXJlbnQnIH1dO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlRvb2xiYXJCdXR0b24gPSBUb29sYmFyQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvb2xiYXItYnV0dG9uJywgVG9vbGJhckJ1dHRvbkVsZW1lbnQpO1xuIiwiaW1wb3J0IG9ucyBmcm9tICcuL29ucyc7IC8vIEFkZCBvbnMgaW50ZXJuYWxzXG5pbXBvcnQgc2V0dXAgZnJvbSAnLi9zZXR1cCc7IC8vIEFkZCBwb2x5ZmlsbHNcblxuLy8gQWRkIGFuZCByZWdpc3RlciBDdXN0b20gRWxlbWVudHNcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGVtcGxhdGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pZic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldC1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2ctYnV0dG9uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYmFjay1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1ib3R0b20tdG9vbGJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcmQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2Fyb3VzZWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jb2wnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1kaWFsb2cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1mYWInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaWNvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxhenktcmVwZWF0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LXRpdGxlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWlucHV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2hlY2tib3gnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yYWRpbyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNlYXJjaC1pbnB1dCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLW1vZGFsJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbmF2aWdhdG9yJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcGFnZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXBvcG92ZXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXB1bGwtaG9vayc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJhbmdlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmlwcGxlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcm93JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VnbWVudCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNlbGVjdCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzayc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXN3aXRjaCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRhYic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRhYmJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRvYXN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdG9vbGJhci1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10b29sYmFyJztcblxuc2V0dXAob25zKTsgLy8gU2V0dXAgaW5pdGlhbCBsaXN0ZW5lcnNcbndpbmRvdy5fc3VwZXJTZWNyZXRPbnMgPSBvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IG9ucztcbiJdLCJuYW1lcyI6WyJwcmVmaXgiLCJzdHlsZXMiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImpvaW4iLCJtYXRjaCIsIk9MaW5rIiwibmFtZSIsInV0aWwiLCJoeXBoZW5hdGUiLCJzdHlsZXIiLCJlbGVtZW50Iiwic3R5bGUiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIndhcm4iLCJjbGVhciIsImNsZWFybGlzdCIsInNwbGl0IiwicmVkdWNlIiwiciIsInMiLCJjb25jYXQiLCJpIiwibGVuZ3RoIiwic29tZSIsImluZGV4T2YiLCJwdXNoIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiTmF0aXZlSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIlBsYXRmb3JtIiwiX3NlbGVjdGVkUGxhdGZvcm0iLCJfaWdub3JlUGxhdGZvcm1TZWxlY3QiLCJwbGF0Zm9ybSIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImZuIiwicmVzdWx0IiwicmVhZHlTdGF0ZSIsIkVycm9yIiwiY29yZG92YSIsInBob25lZ2FwIiwiUGhvbmVHYXAiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJUGhvbmUiLCJzY3JlZW4iLCJ3aWR0aCIsImhlaWdodCIsIl9nZXRTZWxlY3RlZFBsYXRmb3JtIiwiZGV2aWNlIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwidmVyIiwicmVwbGFjZSIsInVhIiwiaXNJT1MiLCJzdGFuZGFsb25lIiwibHRlOSIsIndlYmtpdCIsIm1lc3NhZ2VIYW5kbGVycyIsImluZGV4ZWREQiIsImlzSU9TU2FmYXJpIiwiaXNXS1dlYlZpZXciLCJvcGVyYSIsIkluc3RhbGxUcmlnZ2VyIiwiT2JqZWN0IiwidG9TdHJpbmciLCJwIiwic2FmYXJpIiwicHVzaE5vdGlmaWNhdGlvbiIsImNocm9tZSIsImRvY3VtZW50TW9kZSIsImlzQW5kcm9pZCIsImlzV1AiLCJpc0lQYWQiLCJpc0lQb2QiLCJlcnJvciIsInRocm93IiwibWVzc2FnZSIsInBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIiwidmFsdWUiLCJvdmVyd3JpdGUiLCJfdmFyaWFibGVzIiwiaGFzT3duUHJvcGVydHkiLCJwYXJ0IiwiYyIsImluSW50ZXJwb2xhdGlvbiIsImN1cnJlbnRJbmRleCIsInRva2VucyIsImNoYXJBdCIsInRva2VuIiwic3Vic3RyaW5nIiwicmUiLCJ2YXJpYWJsZSIsImdldFZhcmlhYmxlIiwicnYiLCJtYXAiLCJfcmVwbGFjZVRva2VuIiwiYmluZCIsImV4cHJlc3Npb24iLCJfcGFyc2VQYXJ0IiwiX3JlcGxhY2VUb2tlbnMiLCJfcGFyc2VFeHByZXNzaW9uIiwiZGVmaW5lVmFyaWFibGUiLCJnZXRNb2JpbGVPUyIsImdldElPU0RldmljZSIsImlzV2ViVmlldyIsImludGVybmFsIiwiY29uZmlnIiwibnVsbEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwiLCJhdXRvU3RhdHVzQmFyRmlsbCIsIm5vcm1hbGl6ZVBhZ2VIVE1MIiwiaHRtbCIsIndhaXRET01Db250ZW50TG9hZGVkIiwid3JhcHBlZENhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJjYWxsYmFjayIsIm9uUmVhZHkiLCJzaG91bGRGaWxsU3RhdHVzQmFyIiwiaXNJT1M3YWJvdmUiLCJpc0lQaG9uZVgiLCJib2R5IiwicXVlcnlTZWxlY3RvciIsInRlbXBsYXRlU3RvcmUiLCJfc3RvcmFnZSIsInRlbXBsYXRlIiwiZSIsInRhcmdldCIsIm5vZGVOYW1lIiwic2V0IiwidGVtcGxhdGVJZCIsInJlZ2lzdGVyIiwicXVlcnkiLCJ0ZW1wbGF0ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidGV4dENvbnRlbnQiLCJjb250ZW50IiwiZ2V0VGVtcGxhdGVIVE1MQXN5bmMiLCJwYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWNoZSIsImdldCIsIkRvY3VtZW50RnJhZ21lbnQiLCJsb2NhbCIsImdldEVsZW1lbnRCeUlkIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwib25sb2FkIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzIiwiZnJhZ21lbnQiLCJjcmVhdGVGcmFnbWVudCIsImFycmF5RnJvbSIsInNjcmlwdCIsInR5cGUiLCJlbCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJ0ZXh0IiwiaW5uZXJIVE1MIiwicGFyZW50Tm9kZSIsInJlcGxhY2VDaGlsZCIsIm9uZXJyb3IiLCJzZW5kIiwiZ2V0UGFnZUhUTUxBc3luYyIsInBhZ2VzIiwiZXZhbHVhdGUiLCJnZXRQYWdlIiwiY2F0Y2giLCJzaGlmdCIsIkFuaW1hdG9yRmFjdG9yeSIsIm9wdHMiLCJfYW5pbWF0b3JzIiwiYW5pbWF0b3JzIiwiX2Jhc2VDbGFzcyIsImJhc2VDbGFzcyIsIl9iYXNlQ2xhc3NOYW1lIiwiYmFzZUNsYXNzTmFtZSIsIl9hbmltYXRpb24iLCJkZWZhdWx0QW5pbWF0aW9uIiwiX2FuaW1hdGlvbk9wdGlvbnMiLCJkZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyIsIm9wdGlvbnMiLCJkZWZhdWx0QW5pbWF0b3IiLCJhbmltYXRvciIsImFuaW1hdGlvbiIsIkFuaW1hdG9yIiwiYW5pbWF0aW9uT3B0cyIsImV4dGVuZCIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJkdXJhdGlvbiIsImRlbGF5IiwianNvblN0cmluZyIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZSIsImF1dG9TdHlsZUVuYWJsZWQiLCJtb2RpZmllcnNNYXAiLCJwbGF0Zm9ybXMiLCJhbmRyb2lkIiwiZWxlbWVudE5hbWUiLCJ0YWdOYW1lIiwiaGFzTW9kaWZpZXIiLCJvbGRNb2RpZmllciIsIm5ld01vZGlmaWVyIiwidW5zaGlmdCIsInNldEF0dHJpYnV0ZSIsImVsZW1lbnRzIiwiaGFzQXR0cmlidXRlIiwiaW9zIiwicmVtb3ZlTW9kaWZpZXIiLCJhZGRNb2RpZmllciIsInVubG9ja2VkIiwiZ2V0UGxhdGZvcm0iLCJmb3JjZSIsIm1vYmlsZU9TIiwib25zUGxhdGZvcm0iLCJwcmVwYXJlIiwibWFwTW9kaWZpZXIiLCJtb2RpZmllciIsIm0iLCJyZXN0b3JlTW9kaWZpZXIiLCJNb2RpZmllclV0aWwiLCJsYXN0IiwiY3VycmVudCIsIm1ha2VEaWN0IiwicmVtb3ZlZCIsImFkZGVkIiwiZGljdCIsImRpZmYiLCJjbGFzc0xpc3QiLCJrbGFzcyIsImFkZCIsImsiLCJyZW1vdmUiLCJzY2hlbWUiLCJ0YXJnZXRFbGVtZW50cyIsInNlbGVjdG9yIiwiZmlsdGVyIiwiZmluZFBhcmVudCIsInRhcmdldEVsZW1lbnQiLCJwYXJlbnQiLCJhcHBseURpZmZUb0NsYXNzTGlzdCIsImFwcGx5RGlmZlRvRWxlbWVudCIsIm1vZGlmaWVyVG9rZW4iLCJpbmRleCIsInNwbGljZSIsIl9kb21Db250ZW50TG9hZGVkIiwiX3JlYWR5IiwiX29uRE9NQ29udGVudExvYWRlZCIsIkhhbmRsZXJSZXBvc2l0b3J5IiwiaGFuZGxlciIsImRhdGFzZXQiLCJkZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkIiwiaWQiLCJfZ2VuSWQiLCJfc3RvcmUiLCJ1bmRlZmluZWQiLCJEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsIl9pc0VuYWJsZWQiLCJfYm91bmRDYWxsYmFjayIsIl9jYWxsYmFjayIsImFkZEJhY2tCdXR0b25MaXN0ZW5lciIsInJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lciIsImV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50IiwiRnVuY3Rpb24iLCJfZWxlbWVudCIsImVuYWJsZSIsInRyZWUiLCJfY2FwdHVyZVRyZWUiLCJfZmluZEhhbmRsZXJMZWFmRWxlbWVudCIsImNyZWF0ZVRyZWUiLCJhcHBseSIsImFycmF5T2YiLCJjaGlsZHJlbiIsImNoaWxkRWxlbWVudCIsImRpc3BsYXkiLCJfaXNTaG93biIsImhhcyIsInN1YlRyZWUiLCJmaW5kIiwibm9kZSIsImNoaWxkTm9kZSIsImxlZnQiLCJyaWdodCIsImxlZnRaIiwiekluZGV4IiwicmlnaHRaIiwiaXNOYU4iLCJkYmJEaXNwYXRjaGVyIiwiZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwiZW5kc1dpdGgiLCJ1bndyYXAiLCJpc09iamVjdFN0cmluZyIsImlzQXJyYXlTdHJpbmciLCJpc1F1b3RlZFN0cmluZyIsInN0cmluZyIsIm9yaWdpbmFsU3RyaW5nIiwicHJvY2Vzc1Rva2VuIiwicGFyc2VPYmplY3QiLCJwYXJzZUFycmF5IiwibmV4dFRva2VuIiwibGltaXQiLCJjaGFyQ29kZUF0IiwibmVzdGVkT2JqZWN0IiwiaXNWYWxpZEtleSIsIm9iamVjdCIsInJlYWRpbmdLZXkiLCJwcmV2aW91c1Rva2VuIiwiYXJyYXkiLCJwYXJzZSIsImVycm9yUHJlZml4IiwiZ2xvYmFscyIsIl9ydW5PbkFjdHVhbFBsYXRmb3JtIiwiYWN0dWFsTW9iaWxlT1MiLCJpc1VJV2ViVmlldyIsImRlZmluZVByb3BlcnR5Iiwic3VwcG9ydHNQYXNzaXZlIiwib3B0IiwiaXNHRCIsImNhcHR1cmUiLCJwcmVwYXJlUXVlcnkiLCJtYXRjaGVzIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJmaW5kQ2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwidW50aWwiLCJpc0F0dGFjaGVkIiwiY29udGFpbnMiLCJoYXNBbnlDb21wb25lbnRBc1BhcmVudCIsImdldEFsbENoaWxkTm9kZXMiLCJmcm9tIiwiY2hpbGRFbCIsImlzUGFnZUNvbnRyb2wiLCJwcm9wYWdhdGVBY3Rpb24iLCJhY3Rpb24iLCJjaGlsZCIsImNhbWVsaXplIiwibCIsInRvVXBwZXJDYXNlIiwiY3JlYXRlIiwiY2xhc3NOYW1lIiwid3JhcHBlciIsImltcG9ydE5vZGUiLCJkc3QiLCJhcmdzIiwiaiIsImFycmF5TGlrZSIsInBhcnNlSlNPTk9iamVjdFNhZmVseSIsImZhaWxTYWZlIiwiSlNPTiIsImZpbmRGcm9tUGF0aCIsInBhdGgiLCJnZXRUb3BQYWdlIiwiY29udGFpbmVyIiwidG9wUGFnZSIsImZpbmRUb29sYmFyUGFnZSIsIl9jYW5BbmltYXRlVG9vbGJhciIsIl9jb250ZW50RWxlbWVudCIsIm5leHRQYWdlIiwidHJpZ2dlckVsZW1lbnRFdmVudCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwibW9kaWZpZXJOYW1lIiwiUmVnRXhwIiwiYXV0b1N0eWxlIiwiZm9yY2VBdXRvU3R5bGUiLCJuZXdNb2RpZmllcnMiLCJ0b2dnbGVNb2RpZmllciIsInRvZ2dsZSIsInJlc3RvcmVDbGFzcyIsImRlZmF1bHRDbGFzcyIsInJlZnJlc2giLCJ1cGRhdGVQYXJlbnRQb3NpdGlvbiIsIl9wYXJlbnRVcGRhdGVkIiwicGFyZW50RWxlbWVudCIsImdldFByb3BlcnR5VmFsdWUiLCJwb3NpdGlvbiIsInRvZ2dsZUF0dHJpYnV0ZSIsImJpbmRMaXN0ZW5lcnMiLCJsaXN0ZW5lck5hbWVzIiwiYm91bmROYW1lIiwiZWFjaCIsIm9iaiIsImYiLCJ1cGRhdGVSaXBwbGUiLCJoYXNSaXBwbGUiLCJhdHRycyIsInJpcHBsZUVsZW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiaXNJbnRlZ2VyIiwiaXNGaW5pdGUiLCJNYXRoIiwiZmxvb3IiLCJkZWZlciIsImRlZmVycmVkIiwicHJvbWlzZSIsIndhcm5pbmdzRGlzYWJsZWQiLCJ0aHJvd0Fic3RyYWN0IiwidGhyb3dNZW1iZXIiLCJ0aHJvd1BhZ2VMb2FkZXIiLCJ0aHJvd0FuaW1hdG9yIiwicHJldmVudCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsImlvc1ByZXZlbnRTY3JvbGwiLCJjbGVhbiIsIm9mZiIsIm9uIiwiaW9zUGFnZVNjcm9sbEZpeCIsImZvcmNlVUlXZWJWaWV3U2Nyb2xsRml4IiwiaW9zTWFza1Njcm9sbEZpeCIsImlzVmFsaWRHZXN0dXJlIiwiZ2VzdHVyZSIsImRpc3RhbmNlIiwiZGVsdGFUaW1lIiwiY2hlY2tNaXNzaW5nSW1wb3J0IiwiZWxlbWVudE5hbWVzIiwib25zRWxlbWVudHMiLCJUSU1FT1VUX1JBVElPIiwiY2FwaXRhbGl6ZSIsInN0ciIsImJ1aWxkVHJhbnNpdGlvblZhbHVlIiwicGFyYW1zIiwicHJvcGVydHkiLCJ0aW1pbmciLCJwcm9wcyIsInByb3AiLCJvbmNlT25UcmFuc2l0aW9uRW5kIiwic3RvcFByb3BhZ2F0aW9uIiwicmVtb3ZlTGlzdGVuZXJzIiwiX3RyYW5zaXRpb25FbmRFdmVudHMiLCJ2ZW5kb3JQcmVmaXgiLCJfY3NzUHJvcGVydHlEaWN0IiwiYSIsInoiLCJ1cHBlciIsImhhc0Nzc1Byb3BlcnR5IiwicHJlIiwiZm9yY2VMYXlvdXRBdE9uY2UiLCJiYXRjaEltbWVkaWF0ZSIsIm9mZnNldEhlaWdodCIsImNhbGxiYWNrcyIsImNvbmNyZWF0ZUNhbGxiYWNrcyIsImJhdGNoQW5pbWF0aW9uRnJhbWUiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0cmFuc2l0aW9uUHJvcGVydHlOYW1lIiwiQW5pbWl0IiwiZGVmYXVsdHMiLCJ0cmFuc2l0aW9uUXVldWUiLCJsYXN0U3R5bGVBdHRyaWJ1dGVEaWN0IiwiZG9uZSIsInN0YXJ0QW5pbWF0aW9uIiwidG8iLCJzdGVwIiwiY3NzIiwic2F2ZVN0eWxlIiwicXVldWUiLCJ3YWl0IiwicmVzdG9yZVN0eWxlIiwidHJhbnNpdGlvbiIsIlRyYW5zaXRpb24iLCJidWlsZCIsInNlY29uZHMiLCJzZWxmIiwidHJhbnNpdGlvbk5hbWUiLCJ0cmFuc2l0aW9uVmFsdWUiLCJ0aW1lb3V0SWQiLCJjbGVhclRyYW5zaXRpb24iLCJzZXRUaW1lb3V0IiwibGVuIiwicmVzZXQiLCJfZGVxdWV1ZVRyYW5zaXRpb24iLCJfY3VycmVudFRyYW5zaXRpb24iLCJjYWxsZWQiLCJydW5BbGwiLCJhcmd1bWVudHMiLCJwbGF5IiwiY3JlYXRlQWN0dWFsQ3NzUHJvcHMiLCJ0aW1lb3V0IiwicHJlZml4ZWQiLCJFdmVudCIsIlV0aWxzIiwiRGV0ZWN0aW9uIiwiUG9pbnRlckV2ZW50IiwiR2VzdHVyZURldGVjdG9yIiwiSW5zdGFuY2UiLCJET0NVTUVOVCIsIkhBU19QT0lOVEVSRVZFTlRTIiwicG9pbnRlckVuYWJsZWQiLCJtc1BvaW50ZXJFbmFibGVkIiwiSEFTX1RPVUNIRVZFTlRTIiwiSVNfTU9CSUxFIiwiTk9fTU9VU0VFVkVOVFMiLCJDQUxDVUxBVEVfSU5URVJWQUwiLCJFVkVOVF9UWVBFUyIsIkRJUkVDVElPTl9ET1dOIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fVVAiLCJESVJFQ1RJT05fUklHSFQiLCJQT0lOVEVSX01PVVNFIiwiUE9JTlRFUl9UT1VDSCIsIlBPSU5URVJfUEVOIiwiRVZFTlRfU1RBUlQiLCJFVkVOVF9NT1ZFIiwiRVZFTlRfRU5EIiwiRVZFTlRfUkVMRUFTRSIsIkVWRU5UX1RPVUNIIiwiUkVBRFkiLCJwbHVnaW5zIiwiZ2VzdHVyZXMiLCJzZXR1cCIsImRldGVybWluZUV2ZW50VHlwZXMiLCJvblRvdWNoIiwiZGV0ZWN0IiwidXRpbHMiLCJkZXN0Iiwic3JjIiwibWVyZ2UiLCJpdGVyYXRvciIsImNvbnRleHQiLCJpblN0ciIsImluQXJyYXkiLCJkZWVwIiwiZXZlcnkiLCJ0b0FycmF5IiwiaGFzUGFyZW50IiwiZ2V0Q2VudGVyIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJjbGllbnRYIiwiY2xpZW50WSIsIm1pbiIsIm1heCIsInRvdWNoIiwiZ2V0VmVsb2NpdHkiLCJkZWx0YVgiLCJkZWx0YVkiLCJhYnMiLCJnZXRBbmdsZSIsInRvdWNoMSIsInRvdWNoMiIsIngiLCJ5IiwiYXRhbjIiLCJQSSIsImdldERpcmVjdGlvbiIsImdldERpc3RhbmNlIiwic3FydCIsImdldFNjYWxlIiwic3RhcnQiLCJlbmQiLCJnZXRSb3RhdGlvbiIsImlzVmVydGljYWwiLCJkaXJlY3Rpb24iLCJzZXRQcmVmaXhlZENzcyIsInByZWZpeGVzIiwidG9DYW1lbENhc2UiLCJ0b2dnbGVCZWhhdmlvciIsImZhbHNlRm4iLCJ1c2VyU2VsZWN0Iiwib25zZWxlY3RzdGFydCIsInVzZXJEcmFnIiwib25kcmFnc3RhcnQiLCJob29rIiwidHlwZXMiLCJldmVudFR5cGUiLCJvblRvdWNoSGFuZGxlciIsImV2Iiwic3JjVHlwZSIsImlzUG9pbnRlciIsImlzTW91c2UiLCJ0cmlnZ2VyVHlwZSIsInByZXZlbnRNb3VzZUV2ZW50cyIsImJ1dHRvbiIsInNob3VsZERldGVjdCIsImJ1dHRvbnMiLCJtYXRjaFR5cGUiLCJ1cGRhdGVQb2ludGVyIiwiZG9EZXRlY3QiLCJ0b3VjaExpc3QiLCJnZXRUb3VjaExpc3QiLCJ0b3VjaExpc3RMZW5ndGgiLCJ0cmlnZ2VyQ2hhbmdlIiwidHJpZ2dlciIsImNoYW5nZWRMZW5ndGgiLCJjaGFuZ2VkVG91Y2hlcyIsInN0YXJ0ZWQiLCJldkRhdGEiLCJjb2xsZWN0RXZlbnREYXRhIiwiaWRlbnRpZmllcnMiLCJpZGVudGlmaWVyIiwicG9pbnRlclR5cGUiLCJEYXRlIiwibm93Iiwic3JjRXZlbnQiLCJwcmV2ZW50TWFuaXB1bGF0aW9uIiwic3RvcERldGVjdCIsInRvdWNobGlzdCIsInBvaW50ZXJzIiwicG9pbnRlciIsInBvaW50ZXJFdmVudCIsInBvaW50ZXJJZCIsInB0IiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsIk1TUE9JTlRFUl9UWVBFX1BFTiIsInJlc2V0TGlzdCIsImRldGVjdGlvbiIsInN0YXJ0RGV0ZWN0IiwiaW5zdCIsImV2ZW50RGF0YSIsInN0b3BwZWQiLCJleHRlbmRFdmVudERhdGEiLCJpbnN0T3B0aW9ucyIsInRyaWdnZXJHZXN0dXJlIiwiZW5hYmxlZCIsImxhc3RFdmVudCIsInByZXZpb3VzIiwiZ2V0Q2FsY3VsYXRlZERhdGEiLCJjZW50ZXIiLCJjdXIiLCJyZWNhbGMiLCJjYWxjRXYiLCJsYXN0Q2FsY0V2ZW50IiwiY2FsY0RhdGEiLCJsYXN0Q2FsY0RhdGEiLCJ0aW1lU3RhbXAiLCJmdXR1cmVDYWxjRXZlbnQiLCJ2ZWxvY2l0eSIsImFuZ2xlIiwidmVsb2NpdHlYIiwidmVsb2NpdHlZIiwiaW50ZXJpbUFuZ2xlIiwiaW50ZXJpbURpcmVjdGlvbiIsInN0YXJ0RXYiLCJzdGFydEV2ZW50IiwibGFzdEV2Iiwic29ydCIsImIiLCJsaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiYmVoYXZpb3IiLCJldmVudFN0YXJ0SGFuZGxlciIsImV2ZW50SGFuZGxlcnMiLCJvbkV2ZW50Iiwib2ZmRXZlbnQiLCJ0cmlnZ2VyRXZlbnQiLCJzdGF0ZSIsImRpc3Bvc2UiLCJlaCIsInRyaWdnZXJlZCIsImRyYWdHZXN0dXJlIiwiZHJhZ01heFRvdWNoZXMiLCJkcmFnTWluRGlzdGFuY2UiLCJzdGFydENlbnRlciIsImRyYWdEaXN0YW5jZUNvcnJlY3Rpb24iLCJmYWN0b3IiLCJkcmFnTG9ja1RvQXhpcyIsImRyYWdMb2NrTWluRGlzdGFuY2UiLCJsYXN0RGlyZWN0aW9uIiwiZHJhZ0Jsb2NrVmVydGljYWwiLCJkcmFnQmxvY2tIb3Jpem9udGFsIiwiRHJhZyIsIkdlc3R1cmUiLCJyZWxlYXNlR2VzdHVyZSIsInRpbWVyIiwiaG9sZEdlc3R1cmUiLCJob2xkVGltZW91dCIsImhvbGRUaHJlc2hvbGQiLCJIb2xkIiwiUmVsZWFzZSIsIkluZmluaXR5IiwiU3dpcGUiLCJzd2lwZUdlc3R1cmUiLCJzd2lwZU1pblRvdWNoZXMiLCJzd2lwZU1heFRvdWNoZXMiLCJzd2lwZVZlbG9jaXR5WCIsInN3aXBlVmVsb2NpdHlZIiwiaGFzTW92ZWQiLCJ0YXBHZXN0dXJlIiwicHJldiIsInNpbmNlUHJldiIsImRpZERvdWJsZVRhcCIsInRhcE1heERpc3RhbmNlIiwidGFwTWF4VGltZSIsImRvdWJsZVRhcEludGVydmFsIiwiZG91YmxlVGFwRGlzdGFuY2UiLCJ0YXBBbHdheXMiLCJUYXAiLCJUb3VjaCIsInRvdWNoR2VzdHVyZSIsInByZXZlbnRNb3VzZSIsInRyYW5zZm9ybUdlc3R1cmUiLCJzY2FsZVRocmVzaG9sZCIsInNjYWxlIiwicm90YXRpb25UaHJlc2hvbGQiLCJyb3RhdGlvbiIsInRyYW5zZm9ybU1pblNjYWxlIiwidHJhbnNmb3JtTWluUm90YXRpb24iLCJUcmFuc2Zvcm0iLCJyZWFkeU1hcCIsInF1ZXVlTWFwIiwiaXNDb250ZW50UmVhZHkiLCJzZXRDb250ZW50UmVhZHkiLCJhZGRDYWxsYmFjayIsImNvbnN1bWVRdWV1ZSIsImRlbGV0ZSIsImNvbnRlbnRSZWFkeSIsIldlYWtNYXAiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsIlRvYXN0UXVldWUiLCJ0aGVuIiwiX3NldEF0dHJpYnV0ZXMiLCJfbm9ybWFsaXplQXJndW1lbnRzIiwibWVzc2FnZUhUTUwiLCJidXR0b25MYWJlbHMiLCJidXR0b25MYWJlbCIsImlzQXJyYXkiLCJwYXJhbSIsIm5vdGlmaWNhdGlvbiIsIl9jcmVhdGVBbGVydERpYWxvZyIsImlucHV0U3RyaW5nIiwiaXNQcm9tcHQiLCJpbnB1dFR5cGUiLCJwbGFjZWhvbGRlciIsImRlZmF1bHRWYWx1ZSIsImxhYmVsIiwicHJpbWFyeUJ1dHRvbkluZGV4IiwiX2Rlc3Ryb3lEaWFsb2ciLCJkaWFsb2ciLCJvbkRpYWxvZ0NhbmNlbCIsImRlc3Ryb3kiLCJtYXNrQ29sb3IiLCJ0aXRsZSIsInN1Ym1pdE9uRW50ZXIiLCJpbnB1dCIsIm9ua2V5cHJlc3MiLCJrZXlDb2RlIiwiaGlkZSIsInJlc29sdmVWYWx1ZSIsImZvb3RlciIsImJ1dHRvbkVsZW1lbnQiLCJvbmNsaWNrIiwiY29tcGlsZSIsInNob3ciLCJhdXRvZm9jdXMiLCJzdHJMZW5ndGgiLCJmb2N1cyIsInNldFNlbGVjdGlvblJhbmdlIiwiYWxlcnQiLCJjb25maXJtIiwicHJvbXB0IiwidG9hc3QiLCJmaW5pc2giLCJfdG9hc3QiLCJjaGVja09wdGlvbnMiLCJlcnIiLCJpbnN0YW5jZU9mIiwiY2IiLCJkIiwiYWN0aW9uU2hlZXQiLCJjbGFzcyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJpdGVtIiwiYnV0dG9uT3B0aW9ucyIsImRlc3RydWN0aXZlIiwiaWNvbiIsIk1pY3JvRXZlbnQiLCJmY3QiLCJfZXZlbnRzIiwiX2ZjdCIsIm1peGluIiwiZGVzdE9iamVjdCIsIl9pc1BvcnRyYWl0IiwiaXNQb3J0cmFpdCIsIl9vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX29uUmVzaXplIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwiX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24iLCJlbWl0Iiwib3JpZW50YXRpb24iLCJuSXRlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ3IiwiaCIsIl9pbml0IiwibW9kaWZpZXJzIiwic29mdHdhcmVLZXlib2FyZCIsIl92aXNpYmxlIiwib25TaG93Iiwib25IaWRlIiwiYmluZEV2ZW50cyIsIktleWJvYXJkIiwib25zaG93Iiwib25oaWRlIiwidmlzaWJsZSIsImlzVmlzaWJsZSIsIm5vUGx1Z2luRXJyb3IiLCJnZW5lcmF0ZUlkIiwiRG9vckxvY2siLCJfbG9ja0xpc3QiLCJfd2FpdExpc3QiLCJfbG9nIiwibG9nIiwidW5sb2NrIiwiX3VubG9jayIsIl90cnlUb0ZyZWVXYWl0TGlzdCIsImlzTG9ja2VkIiwibG9hZFBhZ2UiLCJwYWdlRWxlbWVudCIsInVubG9hZFBhZ2UiLCJfZGVzdHJveSIsIlBhZ2VMb2FkZXIiLCJsb2FkZXIiLCJ1bmxvYWRlciIsIl9sb2FkZXIiLCJfdW5sb2FkZXIiLCJFbGVtZW50IiwiZGVmYXVsdFBhZ2VMb2FkZXIiLCJpbnN0YW50UGFnZUxvYWRlciIsIm9ucyIsInNlbGVjdCIsImxvY2F0aW9uIiwic2VhcmNoIiwid2FpdERldmljZVJlYWR5IiwicmVhZHlFcnJvciIsImFmdGVyIiwiaXNSZWFkeSIsIl9yZWFkeUxvY2siLCJyZWFkeSIsIndhaXRVbmxvY2siLCJzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyIiwibGlzdGVuZXIiLCJfZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyIiwic2V0TGlzdGVuZXIiLCJkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJkaXNhYmxlIiwiZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50IiwiZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJtb2NrU3RhdHVzQmFyIiwibW9jayIsImRpc2FibGVBbmltYXRpb25zIiwiZW5hYmxlQW5pbWF0aW9ucyIsIl9kaXNhYmxlV2FybmluZ3MiLCJfZW5hYmxlV2FybmluZ3MiLCJkaXNhYmxlQXV0b1N0eWxpbmciLCJlbmFibGVBdXRvU3R5bGluZyIsImRpc2FibGVJY29uQXV0b1ByZWZpeCIsIkljb24iLCJzZXRBdXRvUHJlZml4IiwiZm9yY2VQbGF0Zm9ybVN0eWxpbmciLCJuZXdQbGF0Zm9ybSIsIl91dGlsIiwiX3BsYXRmb3JtVXBkYXRlIiwiX3VwZGF0ZVBvc2l0aW9uIiwicHJlbG9hZCIsImFsbCIsImFwcGVuZCIsImxpbmsiLCJjcmVhdGVQb3BvdmVyIiwiY3JlYXRlRGlhbG9nIiwiY3JlYXRlQWxlcnREaWFsb2ciLCJvcGVuQWN0aW9uU2hlZXQiLCJyZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyIiwiX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIiLCJfc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzIiwicmVtb3ZlQ2hpbGQiLCJ1bmxvY2tEZXZpY2VSZWFkeSIsImxvY2siLCJnZXRDUyIsImN1cnJlbnRTY3JpcHQiLCJzY3JpcHRzIiwiZ2V0U2NyaXB0UGFnZSIsIkZhc3RDbGljayIsImxheWVyIiwib2xkT25DbGljayIsInRyYWNraW5nQ2xpY2siLCJ0cmFja2luZ0NsaWNrU3RhcnQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoU3RhcnRZIiwibGFzdFRvdWNoSWRlbnRpZmllciIsInRvdWNoQm91bmRhcnkiLCJ0YXBEZWxheSIsInRhcFRpbWVvdXQiLCJub3ROZWVkZWQiLCJtZXRob2QiLCJtZXRob2RzIiwiZGV2aWNlSXNBbmRyb2lkIiwib25Nb3VzZSIsIm9uQ2xpY2siLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoTW92ZSIsIm9uVG91Y2hFbmQiLCJvblRvdWNoQ2FuY2VsIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicm12IiwiaGlqYWNrZWQiLCJhZHYiLCJwcm9wYWdhdGlvblN0b3BwZWQiLCJkZXZpY2VJc1dpbmRvd3NQaG9uZSIsImRldmljZUlzSU9TIiwiZGV2aWNlSXNJT1M0IiwiZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0IiwiZGV2aWNlSXNCbGFja0JlcnJ5MTAiLCJ0ZXh0RmllbGRzIiwibmVlZHNDbGljayIsImRpc2FibGVkIiwibmVlZHNGb2N1cyIsInJlYWRPbmx5Iiwic2VuZENsaWNrIiwiY2xpY2tFdmVudCIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwiaW5pdE1vdXNlRXZlbnQiLCJkZXRlcm1pbmVFdmVudFR5cGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsImZvcndhcmRlZFRvdWNoRXZlbnQiLCJ1cGRhdGVTY3JvbGxQYXJlbnQiLCJzY3JvbGxQYXJlbnQiLCJmYXN0Q2xpY2tTY3JvbGxQYXJlbnQiLCJzY3JvbGxIZWlnaHQiLCJmYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wIiwic2Nyb2xsVG9wIiwiZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCIsImV2ZW50VGFyZ2V0IiwiVEVYVF9OT0RFIiwiaXNUZXh0RmllbGQiLCJ0YXJnZXRUb3VjaGVzIiwiaXNDb250ZW50RWRpdGFibGUiLCJsYXN0Q2xpY2tUaW1lIiwidG91Y2hIYXNNb3ZlZCIsImJvdW5kYXJ5IiwiZmluZENvbnRyb2wiLCJsYWJlbEVsZW1lbnQiLCJjb250cm9sIiwiaHRtbEZvciIsImZvckVsZW1lbnQiLCJ0YXJnZXRUYWdOYW1lIiwiY2FuY2VsTmV4dENsaWNrIiwiZWxlbWVudEZyb21Qb2ludCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJ0b3AiLCJwZXJtaXR0ZWQiLCJtZXRhVmlld3BvcnQiLCJjaHJvbWVWZXJzaW9uIiwiYmxhY2tiZXJyeVZlcnNpb24iLCJmaXJlZm94VmVyc2lvbiIsIm9udG91Y2hzdGFydCIsImV4ZWMiLCJzY3JvbGxXaWR0aCIsIm91dGVyV2lkdGgiLCJtc1RvdWNoQWN0aW9uIiwidG91Y2hBY3Rpb24iLCJhdHRhY2giLCJkZWZpbmUiLCJiYWJlbEhlbHBlcnMudHlwZW9mIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsImN1c3RvbUVsZW1lbnRzIiwiZm9yY2VQb2x5ZmlsbCIsImdsb2JhbCIsIl9fZyIsImNvcmUiLCJfX2UiLCJpdCIsImlzT2JqZWN0IiwiVHlwZUVycm9yIiwicmVxdWlyZSQkMCIsImlzIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJTIiwidmFsIiwidmFsdWVPZiIsImRQIiwiTyIsIlAiLCJBdHRyaWJ1dGVzIiwidG9QcmltaXRpdmUiLCJJRThfRE9NX0RFRklORSIsImJpdG1hcCIsImNyZWF0ZURlc2MiLCJweCIsInJhbmRvbSIsIlNSQyIsIlRPX1NUUklORyIsIiR0b1N0cmluZyIsIlRQTCIsImluc3BlY3RTb3VyY2UiLCJzYWZlIiwiaXNGdW5jdGlvbiIsIlN0cmluZyIsInRoYXQiLCJQUk9UT1RZUEUiLCIkZXhwb3J0Iiwic291cmNlIiwiSVNfRk9SQ0VEIiwiRiIsIklTX0dMT0JBTCIsIkciLCJJU19TVEFUSUMiLCJJU19QUk9UTyIsIklTX0JJTkQiLCJCIiwiZXhwUHJvdG8iLCJvd24iLCJvdXQiLCJleHAiLCJjdHgiLCJyZWRlZmluZSIsIlUiLCJXIiwiUiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY29mIiwiSU9iamVjdCIsImRlZmluZWQiLCJnT1BEIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidG9JT2JqZWN0IiwicElFIiwiY2hlY2siLCJwcm90byIsInNldFByb3RvdHlwZU9mIiwiYnVnZ3kiLCJfX3Byb3RvX18iLCJTSEFSRUQiLCJzdG9yZSIsIlN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsInVpZCIsIlRBRyIsIkFSRyIsInRyeUdldCIsIlQiLCJjYWxsZWUiLCJjbGFzc29mIiwiY2VpbCIsInBvcyIsInRvSW50ZWdlciIsIklTX0lOQ0xVREVTIiwiJHRoaXMiLCJmcm9tSW5kZXgiLCJ0b0xlbmd0aCIsInRvQWJzb2x1dGVJbmRleCIsInNoYXJlZCIsImFycmF5SW5kZXhPZiIsIklFX1BST1RPIiwibmFtZXMiLCIka2V5cyIsImVudW1CdWdLZXlzIiwiZGVmaW5lUHJvcGVydGllcyIsIlByb3BlcnRpZXMiLCJnZXRLZXlzIiwiRW1wdHkiLCJjcmVhdGVEaWN0IiwiaWZyYW1lIiwibHQiLCJndCIsImlmcmFtZURvY3VtZW50IiwiY29udGVudFdpbmRvdyIsIndyaXRlIiwiY2xvc2UiLCJhbk9iamVjdCIsImRQcyIsImRlZiIsInRhZyIsInN0YXQiLCJjb25maWd1cmFibGUiLCJJdGVyYXRvclByb3RvdHlwZSIsIkNvbnN0cnVjdG9yIiwiTkFNRSIsIm5leHQiLCJkZXNjcmlwdG9yIiwiT2JqZWN0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsInRvT2JqZWN0IiwiY29uc3RydWN0b3IiLCJJVEVSQVRPUiIsIkJVR0dZIiwiRkZfSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwicmV0dXJuVGhpcyIsIkJhc2UiLCJERUZBVUxUIiwiSVNfU0VUIiwiRk9SQ0VEIiwiZ2V0TWV0aG9kIiwia2luZCIsInZhbHVlcyIsImVudHJpZXMiLCJERUZfVkFMVUVTIiwiVkFMVUVTX0JVRyIsIiRuYXRpdmUiLCIkZGVmYXVsdCIsIiRlbnRyaWVzIiwiJGFueU5hdGl2ZSIsIkxJQlJBUlkiLCIkYXQiLCJpdGVyYXRlZCIsIl90IiwiX2kiLCJwb2ludCIsIlVOU0NPUEFCTEVTIiwiQXJyYXlQcm90byIsIl9rIiwiSXRlcmF0b3JzIiwiQXJndW1lbnRzIiwiYWRkVG9VbnNjb3BhYmxlcyIsIndrcyIsIlRPX1NUUklOR19UQUciLCJBcnJheVZhbHVlcyIsIkRPTUl0ZXJhYmxlcyIsImNvbGxlY3Rpb25zIiwiZXhwbGljaXQiLCJDb2xsZWN0aW9uIiwiJGl0ZXJhdG9ycyIsImZvcmJpZGRlbkZpZWxkIiwicmV0IiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJCUkVBSyIsIlJFVFVSTiIsIml0ZXJhYmxlIiwiaXRlckZuIiwiZ2V0SXRlckZuIiwiaXNBcnJheUl0ZXIiLCJTUEVDSUVTIiwiS0VZIiwiQyIsIkRFU0NSSVBUT1JTIiwiTUVUQSIsInNldERlc2MiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJmYXN0S2V5IiwiZ2V0V2VhayIsIm9uRnJlZXplIiwibWV0YSIsIk5FRUQiLCJUWVBFIiwiU0laRSIsImdldEVudHJ5IiwiZW50cnkiLCJfZiIsIm4iLCJJU19NQVAiLCJBRERFUiIsIl9sIiwiZm9yT2YiLCJ2YWxpZGF0ZSIsImRhdGEiLCJjYWxsYmFja2ZuIiwidiIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJhcnIiLCJpdGVyIiwiY29tbW9uIiwiSVNfV0VBSyIsImZpeE1ldGhvZCIsImZhaWxzIiwiZ2V0Q29uc3RydWN0b3IiLCJpbnN0YW5jZSIsIkhBU05UX0NIQUlOSU5HIiwiVEhST1dTX09OX1BSSU1JVElWRVMiLCJBQ0NFUFRfSVRFUkFCTEVTIiwiJGl0ZXJEZXRlY3QiLCJCVUdHWV9aRVJPIiwiJGluc3RhbmNlIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJzZXRTdHJvbmciLCJTRVQiLCJTZXQiLCJzdHJvbmciLCJ0b0pTT04iLCJDT0xMRUNUSU9OIiwib2YiLCJBIiwibWFwRm4iLCJtYXBwaW5nIiwiYUZ1bmN0aW9uIiwibmV4dEl0ZW0iLCJyZXF1aXJlJCQ3IiwiTUFQIiwiTWFwIiwiYXJnIiwib3JpZ2luYWwiLCJzcGVjaWVzQ29uc3RydWN0b3IiLCIkY3JlYXRlIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIk5PX0hPTEVTIiwiYXNjIiwicmVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiJGFzc2lnbiIsImFzc2lnbiIsIksiLCJhTGVuIiwiZ2V0U3ltYm9scyIsImdPUFMiLCJpc0VudW0iLCJhcnJheUZpbmQiLCJjcmVhdGVBcnJheU1ldGhvZCIsImFycmF5RmluZEluZGV4IiwidW5jYXVnaHRGcm96ZW5TdG9yZSIsIlVuY2F1Z2h0RnJvemVuU3RvcmUiLCJmaW5kVW5jYXVnaHRGcm96ZW4iLCIkaGFzIiwiV0VBS19NQVAiLCJ3ZWFrIiwidWZzdG9yZSIsInRtcCIsIkludGVybmFsTWFwIiwiJFdlYWtNYXAiLCJmcmVlemUiLCJyZXF1aXJlJCQ1IiwiJGRlZmluZVByb3BlcnR5IiwibWFwZm4iLCJyZXNlcnZlZFRhZ0xpc3QiLCJpc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUiLCJsb2NhbE5hbWUiLCJyZXNlcnZlZCIsInZhbGlkRm9ybSIsImlzQ29ubmVjdGVkIiwibmF0aXZlVmFsdWUiLCJfX0NFX2lzSW1wb3J0RG9jdW1lbnQiLCJEb2N1bWVudCIsIlNoYWRvd1Jvb3QiLCJob3N0IiwibmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyIsInJvb3QiLCJuZXh0U2libGluZyIsIm5leHROb2RlIiwid2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMiLCJ2aXNpdGVkSW1wb3J0cyIsImltcG9ydCIsInNoYWRvd1Jvb3QiLCJfX0NFX3NoYWRvd1Jvb3QiLCJzZXRQcm9wZXJ0eVVuY2hlY2tlZCIsImRlc3RpbmF0aW9uIiwiQ3VzdG9tRWxlbWVudFN0YXRlIiwiQ3VzdG9tRWxlbWVudEludGVybmFscyIsIl9sb2NhbE5hbWVUb0RlZmluaXRpb24iLCJfY29uc3RydWN0b3JUb0RlZmluaXRpb24iLCJfcGF0Y2hlcyIsIl9oYXNQYXRjaGVzIiwiZGVmaW5pdGlvbiIsInBhdGNoIiwiX19DRV9wYXRjaGVkIiwiX19DRV9zdGF0ZSIsIkNFU3RhdGUiLCJjdXN0b20iLCJVdGlsaXRpZXMiLCJjb25uZWN0ZWRDYWxsYmFjayIsInVwZ3JhZGVFbGVtZW50IiwiZGlzY29ubmVjdGVkQ2FsbGJhY2siLCJnYXRoZXJFbGVtZW50cyIsIl9fQ0VfaGFzUmVnaXN0cnkiLCJfX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQiLCJwYXRjaEFuZFVwZ3JhZGVUcmVlIiwiY3VycmVudFN0YXRlIiwibG9jYWxOYW1lVG9EZWZpbml0aW9uIiwiY29uc3RydWN0aW9uU3RhY2siLCJwb3AiLCJmYWlsZWQiLCJfX0NFX2RlZmluaXRpb24iLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJfX0NFX2lzQ29ubmVjdGVkQ2FsbGJhY2tDYWxsZWQiLCJvbGRWYWx1ZSIsIm5ld1ZhbHVlIiwibmFtZXNwYWNlIiwiRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciIsImludGVybmFscyIsImRvYyIsIl9pbnRlcm5hbHMiLCJfZG9jdW1lbnQiLCJfb2JzZXJ2ZXIiLCJfaGFuZGxlTXV0YXRpb25zIiwiZGlzY29ubmVjdCIsIm11dGF0aW9ucyIsImFkZGVkTm9kZXMiLCJEZWZlcnJlZCIsIl92YWx1ZSIsIl9yZXNvbHZlIiwiX3Byb21pc2UiLCJDdXN0b21FbGVtZW50UmVnaXN0cnkiLCJfZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmciLCJfd2hlbkRlZmluZWREZWZlcnJlZCIsIl9mbHVzaENhbGxiYWNrIiwiX2ZsdXNoUGVuZGluZyIsIl91bmZsdXNoZWRMb2NhbE5hbWVzIiwiX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIiLCJTeW50YXhFcnJvciIsImFkb3B0ZWRDYWxsYmFjayIsImdldENhbGxiYWNrIiwiY2FsbGJhY2tWYWx1ZSIsInNldERlZmluaXRpb24iLCJfZmx1c2giLCJwcmlvciIsInRvUHJvbWlzZSIsIm91dGVyIiwiaW5uZXIiLCJmbHVzaCIsIndoZW5EZWZpbmVkIiwicG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayIsImNyZWF0ZUVsZW1lbnROUyIsImNsb25lTm9kZSIsImdldEF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsIkFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlciIsImNvbnN0cnVjdG9yVG9EZWZpbml0aW9uIiwiTmF0aXZlIiwiRG9jdW1lbnRfY3JlYXRlRWxlbWVudCIsImxhc3RJbmRleCIsImJ1aWx0SW4iLCJub2RlcyIsImNvbm5lY3RlZEJlZm9yZSIsInByZXBlbmQiLCJkaXNjb25uZWN0VHJlZSIsImNvbm5lY3RUcmVlIiwiY2xvbmUiLCJEb2N1bWVudF9pbXBvcnROb2RlIiwicGF0Y2hUcmVlIiwiTlNfSFRNTCIsIkRvY3VtZW50X2NyZWF0ZUVsZW1lbnROUyIsIkRvY3VtZW50X3ByZXBlbmQiLCJEb2N1bWVudF9hcHBlbmQiLCJyZWZOb2RlIiwiaW5zZXJ0ZWROb2RlcyIsIm5hdGl2ZVJlc3VsdCIsIk5vZGVfaW5zZXJ0QmVmb3JlIiwibm9kZVdhc0Nvbm5lY3RlZCIsIk5vZGVfYXBwZW5kQ2hpbGQiLCJOb2RlX2Nsb25lTm9kZSIsIm93bmVyRG9jdW1lbnQiLCJOb2RlX3JlbW92ZUNoaWxkIiwibm9kZVRvSW5zZXJ0Iiwibm9kZVRvUmVtb3ZlIiwiTm9kZV9yZXBsYWNlQ2hpbGQiLCJub2RlVG9JbnNlcnRXYXNDb25uZWN0ZWQiLCJ0aGlzSXNDb25uZWN0ZWQiLCJwYXRjaF90ZXh0Q29udGVudCIsImJhc2VEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImFzc2lnbmVkVmFsdWUiLCJyZW1vdmVkTm9kZXMiLCJjaGlsZE5vZGVzTGVuZ3RoIiwiTm9kZV90ZXh0Q29udGVudCIsImFkZFBhdGNoIiwicGFydHMiLCJiZWZvcmUiLCJ3YXNDb25uZWN0ZWQiLCJyZXBsYWNlV2l0aCIsIkVsZW1lbnRfYXR0YWNoU2hhZG93IiwiaW5pdCIsInBhdGNoX2lubmVySFRNTCIsImh0bWxTdHJpbmciLCJyZW1vdmVkRWxlbWVudHMiLCJFbGVtZW50X2lubmVySFRNTCIsIkhUTUxFbGVtZW50X2lubmVySFRNTCIsInJhd0RpdiIsIkVsZW1lbnRfc2V0QXR0cmlidXRlIiwiRWxlbWVudF9nZXRBdHRyaWJ1dGUiLCJFbGVtZW50X3NldEF0dHJpYnV0ZU5TIiwiRWxlbWVudF9nZXRBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlIiwiRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUyIsInBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudCIsImJhc2VNZXRob2QiLCJ3aGVyZSIsImluc2VydGVkRWxlbWVudCIsIkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCIsIkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiRWxlbWVudF9wcmVwZW5kIiwiRWxlbWVudF9hcHBlbmQiLCJFbGVtZW50X2JlZm9yZSIsIkVsZW1lbnRfYWZ0ZXIiLCJFbGVtZW50X3JlcGxhY2VXaXRoIiwiRWxlbWVudF9yZW1vdmUiLCJwcmlvckN1c3RvbUVsZW1lbnRzIiwiSnNNdXRhdGlvbk9ic2VydmVyIiwicmVnaXN0cmF0aW9uc1RhYmxlIiwic2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlUXVldWUiLCJzZW50aW5lbCIsImZ1bmMiLCJwb3N0TWVzc2FnZSIsImlzU2NoZWR1bGVkIiwic2NoZWR1bGVkT2JzZXJ2ZXJzIiwic2NoZWR1bGVDYWxsYmFjayIsImRpc3BhdGNoQ2FsbGJhY2tzIiwid3JhcElmTmVlZGVkIiwiU2hhZG93RE9NUG9seWZpbGwiLCJvYnNlcnZlcnMiLCJvMSIsIm8yIiwidWlkXyIsImFueU5vbkVtcHR5IiwidGFrZVJlY29yZHMiLCJjYWxsYmFja18iLCJyZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3IiLCJub2Rlc18iLCJyZWdpc3RyYXRpb25zIiwicmVnaXN0cmF0aW9uIiwicmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzIiwiZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkIiwic3VidHJlZSIsInJlY29yZCIsImVucXVldWUiLCJ1aWRDb3VudGVyIiwicmVjb3Jkc18iLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlT2xkVmFsdWUiLCJhdHRyaWJ1dGVGaWx0ZXIiLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJSZWdpc3RyYXRpb24iLCJhZGRMaXN0ZW5lcnMiLCJjb3B5T2ZSZWNvcmRzIiwiTXV0YXRpb25SZWNvcmQiLCJwcmV2aW91c1NpYmxpbmciLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwiY29weU11dGF0aW9uUmVjb3JkIiwiY3VycmVudFJlY29yZCIsInJlY29yZFdpdGhPbGRWYWx1ZSIsImdldFJlY29yZCIsImdldFJlY29yZFdpdGhPbGRWYWx1ZSIsImNsZWFyUmVjb3JkcyIsInJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24iLCJzZWxlY3RSZWNvcmQiLCJsYXN0UmVjb3JkIiwibmV3UmVjb3JkIiwidHJhbnNpZW50T2JzZXJ2ZWROb2RlcyIsInJlY29yZHMiLCJyZWNvcmRUb1JlcGxhY2VMYXN0IiwiYWRkTGlzdGVuZXJzXyIsInJlbW92ZUxpc3RlbmVyc18iLCJhdHRyTmFtZSIsInJlbGF0ZWROb2RlIiwibmFtZXNwYWNlVVJJIiwiYXR0ckNoYW5nZSIsIk11dGF0aW9uRXZlbnQiLCJBRERJVElPTiIsInByZXZWYWx1ZSIsImFkZFRyYW5zaWVudE9ic2VydmVyIiwiY2hhbmdlZE5vZGUiLCJfaXNQb2x5ZmlsbGVkIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzIiwicGFydGlhbGx5QXBwbGllZCIsInJ1bklmUHJlc2VudCIsImhhbmRsZSIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwibmV4dFRpY2siLCJjYW5Vc2VQb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwicHJvY2VzcyIsIkRFRkFVTFRfVklFV1BPUlQiLCJWaWV3cG9ydCIsInZpZXdwb3J0RWxlbWVudCIsImhlYWQiLCJlbnN1cmVWaWV3cG9ydEVsZW1lbnQiLCJfb25zTG9hZGVkIiwiZmFzdENsaWNrIiwic3VwcG9ydFRvdWNoQWN0aW9uIiwiX2ludGVybmFsIiwiY3JlYXRlSGFuZGxlciIsImFwcCIsImV4aXRBcHAiLCJfZ2VzdHVyZURldGVjdG9yIiwiZ2V0RWxlbWVudENsYXNzIiwiQmFzZUVsZW1lbnQiLCJUZW1wbGF0ZUVsZW1lbnQiLCJvdXRlckhUTUwiLCJidWJibGVzIiwiVGVtcGxhdGUiLCJJZkVsZW1lbnQiLCJfaXNBbGxvd2VkUGxhdGZvcm0iLCJjb25kaXRpb25hbE9yaWVudGF0aW9uIiwiY3VycmVudE9yaWVudGF0aW9uIiwiSWYiLCJCYXNlQW5pbWF0b3IiLCJwcm9wZXJ0aWVzIiwiZXh0ZW5kZWRBbmltYXRvciIsIm5ld0FuaW1hdG9yIiwiaVBob25lWFBhdGNoIiwiaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSIsImlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlIiwiZ2V0U2FmZUFyZWFMZW5ndGhzIiwic2FmZUFyZWFMZW5ndGhzIiwiZ2V0U2FmZUFyZWFET01SZWN0Iiwic2FmZUFyZWFSZWN0IiwiQWN0aW9uU2hlZXRBbmltYXRvciIsIk1EQWN0aW9uU2hlZXRBbmltYXRvciIsIm1hc2tUaW1pbmciLCJtYXNrRHVyYXRpb24iLCJhbmltaXQiLCJfbWFzayIsIm9wYWNpdHkiLCJfc2hlZXQiLCJkZWZhdWx0IiwidHJhbnNmb3JtIiwiSU9TQWN0aW9uU2hlZXRBbmltYXRvciIsImxpZnRBbW91bnQiLCJjbGllbnRIZWlnaHQiLCJCYXNlRGlhbG9nRWxlbWVudCIsInNob3VsZFNob3ciLCJfZG9vckxvY2siLCJfY2FuY2VsIiwiX3NlbGZDYW1lbE5hbWUiLCJfZGVmYXVsdERCQiIsImNhbGxQYXJlbnRIYW5kbGVyIiwiX2FuaW1hdG9yRmFjdG9yeSIsIl91cGRhdGVBbmltYXRvckZhY3RvcnkiLCJfcnVubmluZyIsIl9zZXRWaXNpYmxlIiwicGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nIiwiY2FuY2VsZWQiLCJfdG9nZ2xlU3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvbkRldmljZUJhY2tCdXR0b24iLCJfYmFja0J1dHRvbkhhbmRsZXIiLCJvbk1vZGlmaWVyQ2hhbmdlZCIsIl9zY2hlbWUiLCJfdXBkYXRlTWFzayIsIl9hbmltYXRvckRpY3QiLCJBY3Rpb25TaGVldEVsZW1lbnQiLCJfY29tcGlsZSIsInNoZWV0IiwiX3RpdGxlIiwibWFzayIsImluaXRNb2RpZmllciIsIl91cGRhdGVUaXRsZSIsIkFjdGlvblNoZWV0IiwiQmFzZUJ1dHRvbkVsZW1lbnQiLCJfZGVmYXVsdENsYXNzTmFtZSIsIl9pY29uIiwiX3VwZGF0ZVJpcHBsZSIsIl9yaXBwbGVPcHQiLCJfdXBkYXRlSWNvbiIsIkFjdGlvblNoZWV0QnV0dG9uRWxlbWVudCIsIkFjdGlvblNoZWV0QnV0dG9uIiwiQWxlcnREaWFsb2dBbmltYXRvciIsIkFuZHJvaWRBbGVydERpYWxvZ0FuaW1hdG9yIiwiX2RpYWxvZyIsIklPU0FsZXJ0RGlhbG9nQW5pbWF0b3IiLCJBbGVydERpYWxvZ0VsZW1lbnQiLCJBbGVydERpYWxvZyIsIkFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudCIsIkFsZXJ0RGlhbG9nQnV0dG9uIiwiZGVmYXVsdENsYXNzTmFtZSIsIkJhY2tCdXR0b25FbGVtZW50IiwiX29wdGlvbnMiLCJfYm91bmRPbkNsaWNrIiwiX29uQ2xpY2siLCJtZEJhY2tCdXR0b25JY29uIiwiaW9zQmFja0J1dHRvbkljb24iLCJwb3BQYWdlIiwiQmFja0J1dHRvbiIsIkJvdHRvbVRvb2xiYXJFbGVtZW50IiwiQm90dG9tVG9vbGJhciIsIkJ1dHRvbkVsZW1lbnQiLCJCdXR0b24iLCJDYXJkRWxlbWVudCIsIkNhcmQiLCJDYXJvdXNlbEl0ZW1FbGVtZW50IiwiQ2Fyb3VzZWxJdGVtIiwiZGlyZWN0aW9uTWFwIiwiU3dpcGVyIiwiRkFMU0UiLCJnZXRFbGVtZW50Iiwic2Nyb2xsSG9vayIsIml0ZW1TaXplIiwiZ2V0QXV0b1Njcm9sbFJhdGlvIiwicmF0aW8iLCJzaG91bGRCbG9jayIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnIiwib25EcmFnRW5kIiwib25SZXNpemUiLCJfc2hvdWxkRml4U2Nyb2xsIiwic3dpcGVhYmxlIiwiYXV0b1JlZnJlc2giLCJpbml0aWFsaXplZCIsImJsb2NrZXIiLCJfbXV0YXRpb25PYnNlcnZlciIsInVwZGF0ZVN3aXBlYWJsZSIsInVwZGF0ZUF1dG9SZWZyZXNoIiwiX3Njcm9sbCIsIl9vZmZzZXQiLCJfbGFzdEFjdGl2ZUluZGV4IiwiX3VwZGF0ZUxheW91dCIsIl9zZXR1cEluaXRpYWxJbmRleCIsInNldHVwUmVzaXplIiwidGFyZ2V0U2l6ZSIsIl9yZXNldCIsInNldEFjdGl2ZUluZGV4Iiwicm91bmQiLCJOdW1iZXIiLCJnZXRJbml0aWFsSW5kZXgiLCJpdGVtQ291bnQiLCJpdGVtTnVtU2l6ZSIsIl9zY3JvbGxUbyIsIl9zZXRTd2lwaW5nIiwic2Nyb2xsIiwibWF4U2Nyb2xsIiwiYXJyYXlPZkFycmF5IiwiY29udGVudHMiLCJfY2hhbmdlVG8iLCJjb3VudCIsInNpemUiLCJzaG91bGRVcGRhdGUiLCJzaG91bGRXYXRjaCIsIm5ld1NpemUiLCJibG9jayIsInBvaW50ZXJFdmVudHMiLCJpc0ZpcnN0IiwiaXNPdmVyU2Nyb2xsYWJsZSIsImlzTGFzdCIsIl9pZ25vcmVEcmFnIiwiY29uc3VtZWQiLCJjb25zdW1lIiwiX2NhbkNvbnN1bWVHZXN0dXJlIiwic3RhcnRYIiwiZGlzdEZyb21FZGdlIiwiZ2V0QnViYmxlV2lkdGgiLCJfc3RhcnRlZCIsInRvZ2dsZUJsb2NrZXIiLCJfY29udGludWVkIiwiX2dldERlbHRhIiwidGhyb3R0bGUiLCJub3JtYWxpemVkU2Nyb2xsIiwiX25vcm1hbGl6ZVNjcm9sbCIsIl9zdGFydE1vbWVudHVtU2Nyb2xsIiwiX2tpbGxPdmVyU2Nyb2xsIiwiX2dldFZlbG9jaXR5IiwibWF0Y2hlc0RpcmVjdGlvbiIsImRNIiwiZGlyIiwibmV4dFNjcm9sbCIsIl9nZXRBdXRvU2Nyb2xsIiwic3dpcGUiLCJraWxsT3ZlclNjcm9sbCIsIm92ZXJTY3JvbGxIb29rIiwiYWN0aXZlSW5kZXgiLCJnZXRBY3RpdmVJbmRleCIsImxhc3RBY3RpdmVJbmRleCIsImNoYW5nZSIsInByZUNoYW5nZUhvb2siLCJwb3N0Q2hhbmdlSG9vayIsInRvRml4ZWQiLCJfZ2V0VHJhbnNmb3JtIiwib2Zmc2V0IiwiaXNBdXRvU2Nyb2xsYWJsZSIsImxhc3RTY3JvbGwiLCJzY3JvbGxSYXRpbyIsIl90YXJnZXRTaXplIiwiX2l0ZW1OdW1TaXplIiwicmVmcmVzaEhvb2siLCJheGlzIiwidDNkIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiaXNDZW50ZXJlZCIsIl9jYWxjdWxhdGVJdGVtU2l6ZSIsIkNhcm91c2VsRWxlbWVudCIsIl9zd2lwZXIiLCJhdXRvU2Nyb2xsUmF0aW8iLCJ2ZXJ0aWNhbCIsIm92ZXJzY3JvbGxhYmxlIiwiY2VudGVyZWQiLCJhdXRvU2Nyb2xsIiwiX29uT3ZlclNjcm9sbCIsIl9vbkNoYW5nZSIsIl9vblJlZnJlc2giLCJfb25Td2lwZSIsInVwZGF0ZUl0ZW1TaXplIiwid2FpdEZvckFjdGlvbiIsImNhcm91c2VsIiwiaXRlbVNpemVBdHRyIiwicGFyc2VGbG9hdCIsIkNhcm91c2VsIiwiQ29sRWxlbWVudCIsIl91cGRhdGVXaWR0aCIsIkNvbCIsIkRpYWxvZ0FuaW1hdG9yIiwiQW5kcm9pZERpYWxvZ0FuaW1hdG9yIiwiSU9TRGlhbG9nQW5pbWF0b3IiLCJib2R5SGVpZ2h0IiwiU2xpZGVEaWFsb2dBbmltYXRvciIsIkRpYWxvZ0VsZW1lbnQiLCJEaWFsb2ciLCJGYWJFbGVtZW50IiwiaXNCb3R0b20iLCJ0cmFuc2xhdGUiLCJmYWJPZmZzZXQiLCJGYWIiLCJHZXN0dXJlRGV0ZWN0b3JFbGVtZW50IiwiYXV0b1ByZWZpeCIsIkljb25FbGVtZW50IiwiX2NsZWFuQ2xhc3NBdHRyaWJ1dGUiLCJfdXBkYXRlIiwiX2J1aWxkQ2xhc3NBbmRTdHlsZSIsIl9wYXJzZUF0dHIiLCJhdHRyIiwibWQiLCJsYXN0SWNvbiIsImxhc3RNb2RpZmllciIsIl9wcmVmaXhJY29uIiwiY3VzdG9tUHJlZml4UkUiLCJpY29uTmFtZSIsInJlbW92ZVByb3BlcnR5IiwiZm9udFNpemUiLCJMYXp5UmVwZWF0RGVsZWdhdGUiLCJ1c2VyRGVsZWdhdGUiLCJ0ZW1wbGF0ZUVsZW1lbnQiLCJfdXNlckRlbGVnYXRlIiwiX3RlbXBsYXRlRWxlbWVudCIsIl9yZW5kZXIiLCJsb2FkSXRlbUVsZW1lbnQiLCJjcmVhdGVJdGVtQ29udGVudCIsImNvdW50SXRlbXMiLCJ1cGRhdGVJdGVtQ29udGVudCIsImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCJkZXN0cm95SXRlbSIsIml0ZW1IZWlnaHQiLCJMYXp5UmVwZWF0UHJvdmlkZXIiLCJ3cmFwcGVyRWxlbWVudCIsImRlbGVnYXRlIiwiX3dyYXBwZXJFbGVtZW50IiwiX2RlbGVnYXRlIiwiX2luc2VydEluZGV4IiwiX3BhZ2VDb250ZW50IiwiX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQiLCJsYXN0U2Nyb2xsVG9wIiwicGFkZGluZyIsIl90b3BQb3NpdGlvbnMiLCJfcmVuZGVyZWRJdGVtcyIsIl91bmtub3duSXRlbUhlaWdodCIsIl9hZGRFdmVudExpc3RlbmVycyIsInBhZ2VDb250ZW50IiwiX2l0ZW1IZWlnaHQiLCJ2aXNpYmlsaXR5Iiwic3RhdGljSXRlbUhlaWdodCIsIl9nZXRJdGVtSGVpZ2h0IiwiZm9yY2VSZW5kZXIiLCJmb3JjZVNjcm9sbERvd24iLCJmaXJzdEl0ZW1JbmRleCIsIl9maXJzdEl0ZW1SZW5kZXJlZCIsIl9jYWxjdWxhdGVSZW5kZXJlZEhlaWdodCIsImZvcmNlRmlyc3RJbmRleCIsIl9yZW1vdmVBbGxFbGVtZW50cyIsImZvcmNlTGFzdEluZGV4IiwiX2NoZWNrSXRlbUhlaWdodCIsImlzU2Nyb2xsVXAiLCJrZWVwIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2NvdW50SXRlbXMiLCJfY2FsY3VsYXRlU3RhcnRJbmRleCIsImhhc1JlbmRlckZ1bmN0aW9uIiwiX3JlbmRlckVsZW1lbnQiLCJfcmVtb3ZlRWxlbWVudCIsInVwZGF0ZUl0ZW0iLCJsYXN0SXRlbUluZGV4IiwiX2xhc3RJdGVtUmVuZGVyZWQiLCJfcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMiLCJtaWRkbGUiLCJpbW1lZGlhdGUiLCJjYWxsTm93IiwiX2RlYm91bmNlIiwiX2JvdW5kT25DaGFuZ2UiLCJfYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCIsIl9wYXJlbnRFbGVtZW50IiwiX3JlbW92ZUV2ZW50TGlzdGVuZXJzIiwicGFkZGluZ1RvcCIsIkxhenlSZXBlYXRFbGVtZW50IiwiX2xhenlSZXBlYXRQcm92aWRlciIsIkxhenlSZXBlYXQiLCJMaXN0SGVhZGVyRWxlbWVudCIsIkxpc3RIZWFkZXIiLCJMaXN0VGl0bGVFbGVtZW50IiwiTGlzdFRpdGxlIiwiTGlzdEl0ZW1BbmltYXRvciIsImxpc3RJdGVtIiwiU2xpZGVMaXN0SXRlbUFuaW1hdG9yIiwiX2FuaW1hdGVFeHBhbnNpb24iLCJzaG91bGRPcGVuIiwib2xkSGVpZ2h0IiwiZXhwYW5kYWJsZUNvbnRlbnQiLCJvbGREaXNwbGF5IiwiY29tcHV0ZWRTdHlsZSIsImV4cGFuc2lvbk9wZW5UcmFuc2l0aW9uIiwicGFkZGluZ0JvdHRvbSIsImljb25PcGVuVHJhbnNpdGlvbiIsInJldmVyc2UiLCJleHBhbmRDaGV2cm9uIiwiTGlzdEl0ZW1FbGVtZW50IiwidG9nZ2xlRXhwYW5zaW9uIiwiX3Nob3VsZElnbm9yZVRhcCIsInNob3dFeHBhbnNpb24iLCJoaWRlRXhwYW5zaW9uIiwiY2hpbGRFbHMiLCJjaGV2cm9uIiwiX3RvcCIsIl9leHBhbmRpbmciLCJleHBhbmRlZCIsIl9zZXR1cExpc3RlbmVycyIsIl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciIsInRhcHBlZCIsIl9vblRvdWNoIiwiX29uUmVsZWFzZSIsIl9vbkRyYWciLCJ0b3VjaFN0eWxlIiwiYm94U2hhZG93IiwiTGlzdEl0ZW0iLCJMaXN0RWxlbWVudCIsIkxpc3QiLCJJTlBVVF9BVFRSSUJVVEVTIiwiQmFzZUlucHV0RWxlbWVudCIsIl9ib3VuZERlbGVnYXRlRXZlbnQiLCJfZGVsZWdhdGVFdmVudCIsIl90ZW1wbGF0ZSIsIl9zZXRJbnB1dElkIiwiX3VwZGF0ZUJvdW5kQXR0cmlidXRlcyIsIl9pbnB1dCIsInRvSVNPU3RyaW5nIiwiSW5wdXRFbGVtZW50IiwiX2JvdW5kT25JbnB1dCIsIl9ib3VuZE9uRm9jdXNpbiIsIl91cGRhdGVMYWJlbCIsIl91cGRhdGVMYWJlbENsYXNzIiwiX2hlbHBlciIsImlubmVyVGV4dCIsIklucHV0IiwiQmFzZUNoZWNrYm94RWxlbWVudCIsImNoZWNrZWQiLCJDaGVja2JveEVsZW1lbnQiLCJDaGVja2JveCIsIlJhZGlvRWxlbWVudCIsIlJhZGlvIiwiU2VhcmNoSW5wdXRFbGVtZW50IiwiU2VhcmNoSW5wdXQiLCJNb2RhbEFuaW1hdG9yIiwibW9kYWwiLCJGYWRlTW9kYWxBbmltYXRvciIsIkxpZnRNb2RhbEFuaW1hdG9yIiwiTW9kYWxFbGVtZW50IiwiTW9kYWwiLCJ3aWR0aFRvUHgiLCJvZmZzZXRXaWR0aCIsIlN3aXBlUmV2ZWFsIiwiZWxlbWVudEhhbmRsZXIiLCJnZXRUaHJlc2hvbGQiLCJnZXRTaWRlIiwiaGFuZGxlR2VzdHVyZSIsImdlc3R1cmVEZXRlY3RvciIsImlnbm9yZVN3aXBlIiwiX3dpZHRoIiwiX3N0YXJ0RGlzdGFuY2UiLCJfZGlzdGFuY2UiLCJpc0luaXRpYWxTdGF0ZSIsImRlbHRhIiwic3dpcGVNaWQiLCJpc1N3aXBlTWF4Iiwic3dpcGVNYXgiLCJzd2lwZU1pbiIsIk5hdmlnYXRvckFuaW1hdG9yIiwiZW50ZXJQYWdlIiwibGVhdmVQYWdlIiwiSU9TU3dpcGVOYXZpZ2F0b3JBbmltYXRvciIsImR1cmF0aW9uUmVzdG9yZSIsImR1cmF0aW9uU3dpcGUiLCJ0aW1pbmdTd2lwZSIsInJlc3QiLCJvcHRTd2lwZSIsIm9wdFJlc3RvcmUiLCJzd2lwZVNoYWRvdyIsImlzRHJhZ1N0YXJ0IiwidW5ibG9jayIsImJhY2tncm91bmRNYXNrIiwiZGVjb21wIiwiX2RlY29tcG9zZSIsImVudGVyIiwibGVhdmUiLCJfY2FsY3VsYXRlRGVsdGEiLCJzaG91bGRBbmltYXRlVG9vbGJhciIsIl9zaG91bGRBbmltYXRlVG9vbGJhciIsInRvb2xiYXIiLCJfc2F2ZVN0eWxlIiwib3ZlcmZsb3dFbGVtZW50IiwibWF4V2lkdGgiLCJpc1N3aXBpbmciLCJfZHJhZ1N0YXJ0U2V0dXAiLCJzd2lwZVJhdGlvIiwiYm90dG9tVG9vbGJhciIsImJhY2tncm91bmQiLCJ0b29sYmFyQ2VudGVyIiwiYmFja0J1dHRvbkxhYmVsIiwib3RoZXIiLCJfc2F2ZWRTdHlsZSIsInNhdmUiLCJyZXN0b3JlIiwiX3Jlc3RvcmVTdHlsZSIsInRyYW5zbGF0ZTNkIiwiSU9TU2xpZGVOYXZpZ2F0b3JBbmltYXRvciIsIl9nZXRUb29sYmFyRWxlbWVudCIsIl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCIsIl9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQiLCJleGNsdWRlQmFja0J1dHRvbiIsIl9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50IiwiX2dldFRvb2xiYXJCYWNrQnV0dG9uSWNvbkVsZW1lbnQiLCJfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQiLCJfZ2V0Q29udGVudEVsZW1lbnQiLCJfZ2V0QmFja2dyb3VuZEVsZW1lbnQiLCJfZ2V0Qm90dG9tVG9vbGJhckVsZW1lbnQiLCJ0b29sYmFycyIsImVudGVyVG9vbGJhciIsImxlYXZlVG9vbGJhciIsImlzU3RhdGljIiwiaXNNYXRlcmlhbCIsImlzVHJhbnNwYXJlbnQiLCJkZWNvbXBvc2l0aW9uIiwicGFnZVJlY3QiLCJsYWJlbFJlY3QiLCJiYWNrQnV0dG9uSWNvbiIsImVudGVyUGFnZVRhcmdldCIsImxlYXZlUGFnZVRhcmdldCIsImVudGVyUGFnZURlY29tcG9zaXRpb24iLCJsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uIiwicG9wU3dpcGUiLCJJT1NMaWZ0TmF2aWdhdG9yQW5pbWF0b3IiLCJJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IiLCJNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IiLCJibGFja01hc2tPcGFjaXR5IiwiTURMaWZ0TmF2aWdhdG9yQW5pbWF0b3IiLCJtYXNrQ2xlYXIiLCJNREZhZGVOYXZpZ2F0b3JBbmltYXRvciIsInRpbWluZ1BvcCIsIk5vbmVOYXZpZ2F0b3JBbmltYXRvciIsInJld3JpdGFibGVzIiwibmF2aWdhdG9yRWxlbWVudCIsInZlcmlmeVBhZ2VFbGVtZW50IiwiTmF2aWdhdG9yRWxlbWVudCIsIl9pc1J1bm5pbmciLCJfaW5pdGlhbGl6ZWQiLCJfcGFnZUxvYWRlciIsIl9wYWdlTWFwIiwiX3BhZ2UiLCJfb25EZXZpY2VCYWNrQnV0dG9uIiwic3dpcGVBbmltYXRvciIsIl9zd2lwZSIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJhcmVhIiwiaXNCQiIsInB1c2hlZE9wdGlvbnMiLCJhbmltYXRvckZhY3RvcnkiLCJsb2FkZWQiLCJfZ2V0UGFnZVRhcmdldCIsInB1c2hQYWdlIiwiX3Nob3ciLCJfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uIiwidXBkYXRlIiwiX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyIsInRpbWVzIiwiX3JlbW92ZVBhZ2VzIiwicG9wVXBkYXRlIiwidW5sb2FkIiwiX3BvcFBhZ2UiLCJfZW1pdFByZVBvcEV2ZW50IiwidXBkYXRlQmFja0J1dHRvbiIsIl9oaWRlIiwicGFnZUhUTUwiLCJfcHVzaFBhZ2UiLCJsb2FkIiwiX2VtaXRQcmVQdXNoRXZlbnQiLCJwYWdlTGVuZ3RoIiwiX3JlcGxhY2VQYWdlIiwicmVzb2x2ZWRWYWx1ZSIsIl9ub3JtYWxpemVJbmRleCIsImluc2VydFBhZ2UiLCJuZXdQYWdlIiwiX2xhc3RJbmRleE9mUGFnZSIsInBhZ2VOYW1lIiwiaXNDYW5jZWxlZCIsIl9lbWl0UHJlRXZlbnQiLCJ0ZW1wbGF0ZUhUTUwiLCJwYWdlTG9hZGVyIiwibGFzdEVsZW1lbnRDaGlsZCIsIk5hdmlnYXRvciIsIlRvb2xiYXJFbGVtZW50IiwiX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMiLCJfZW5zdXJlVG9vbGJhckVsZW1lbnQiLCJUb29sYmFyIiwiUGFnZUVsZW1lbnQiLCJfZGVyaXZlSG9va3MiLCJfYmFja2dyb3VuZEVsZW1lbnQiLCJfZWxlbWVudFNob3VsZEJlTW92ZWQiLCJfdHJ5VG9GaWxsU3RhdHVzQmFyIiwiZml4ZWRFbGVtZW50cyIsIm9uSW5pdCIsImJhY2tCdXR0b24iLCJvdmVyTGltaXQiLCJfaW5maW5pdGVTY3JvbGxMaW1pdCIsIl9vbkluZmluaXRlU2Nyb2xsIiwiX2xvYWRpbmdDb250ZW50Iiwib25JbmZpbml0ZVNjcm9sbCIsIm9uRGVzdHJveSIsImV2ZW50cyIsIl9ib3VuZE9uU2Nyb2xsIiwiX29uU2Nyb2xsIiwiUGFnZSIsIlBvcG92ZXJBbmltYXRvciIsInBvcG92ZXIiLCJhbmltYXRpb25zIiwiX2FuaW1hdGUiLCJmYWRlIiwiTURGYWRlUG9wb3ZlckFuaW1hdG9yIiwiX2FuaW1hdGVBbGwiLCJpbiIsIklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IiLCJwb3NpdGlvbnMiLCJQb3BvdmVyRWxlbWVudCIsIl9jdXJyZW50VGFyZ2V0IiwiX3Bvc2l0aW9uUG9wb3ZlciIsIl9jbGVhclN0eWxlcyIsInJhZGl1cyIsIl9yYWRpdXMiLCJjb250ZW50RWxlbWVudCIsIl9jb250ZW50IiwibWFyZ2luIiwiX21hcmdpbiIsInRhcmdldFJlY3QiLCJpc01EIiwiY292ZXIiLCJwYXJlbnREaW1lbnNpb25zIiwibWF4UG9zaXRpb25zIiwiYm90dG9tIiwidGFyZ2V0RGlzdGFuY2UiLCJ0YXJnZXRDZW50ZXJEaXN0YW5jZUZyb20iLCJfY2FsY3VsYXRlRGlyZWN0aW9ucyIsInByaW1hcnlEaXJlY3Rpb24iLCJwcmltYXJ5Iiwic2Vjb25kYXJ5RGlyZWN0aW9uIiwic2Vjb25kYXJ5IiwiX2N1cnJlbnREaXJlY3Rpb24iLCJzaXplTmFtZSIsImNvbnRlbnRTaXplIiwidGFyZ2V0QW5kQXJyb3dMZW5ndGgiLCJwcmltYXJ5T2Zmc2V0Iiwic2Vjb25kYXJ5T2Zmc2V0IiwiX3BvcG92ZXIiLCJfYXJyb3ciLCJoYXNEZWZhdWx0Q29udGFpbmVyIiwiYXJyb3ciLCJQb3BvdmVyIiwiSU5ERVQiLCJQcm9ncmVzc0JhckVsZW1lbnQiLCJfaXNDb21waWxlZCIsIl9wcmltYXJ5IiwiX3NlY29uZGFyeSIsIl91cGRhdGVEZXRlcm1pbmF0ZSIsIl91cGRhdGVWYWx1ZSIsImJhckVsZW1lbnQiLCJQcm9ncmVzc0JhciIsIlByb2dyZXNzQ2lyY3VsYXJFbGVtZW50IiwicGVyIiwic3ZnIiwiUHJvZ3Jlc3NDaXJjdWxhciIsIlNUQVRFX0lOSVRJQUwiLCJTVEFURV9QUkVBQ1RJT04iLCJTVEFURV9BQ1RJT04iLCJ0aHJvd1R5cGUiLCJQdWxsSG9va0VsZW1lbnQiLCJfb25EcmFnU3RhcnQiLCJfb25EcmFnRW5kIiwiX3NldFN0YXRlIiwibGluZUhlaWdodCIsIl9wYWdlRWxlbWVudCIsInRhcFkiLCJtYXhZIiwiZHJhZ2dhYmxlQXJlYVJhdGlvIiwiX3N0YXJ0U2Nyb2xsIiwiX2N1cnJlbnRUcmFuc2xhdGlvbiIsInRoIiwidGhyZXNob2xkSGVpZ2h0IiwiX2ZpbmlzaCIsIl90cmFuc2xhdGVUbyIsImFuaW1hdGUiLCJvbkFjdGlvbiIsIm5vRXZlbnQiLCJsYXN0U3RhdGUiLCJtYXJnaW5Ub3AiLCJfb25QdWxsIiwic2Nyb2xsRWxlbWVudCIsIl9kcmFnTG9ja0Rpc2FibGVkIiwic2Nyb2xsVG9nZ2xlIiwiZ2RUb2dnbGUiLCJfc2V0U3R5bGUiLCJfb25BY3Rpb24iLCJQdWxsSG9vayIsImFjdGl2ZUNsYXNzVG9rZW4iLCJSYW5nZUVsZW1lbnQiLCJfb25Nb3VzZURvd24iLCJfb25Nb3VzZVVwIiwiX29uVG91Y2hTdGFydCIsIl9vblRvdWNoRW5kIiwiX29uSW5wdXQiLCJfb25EcmFnc3RhcnQiLCJfb25EcmFnZW5kIiwiX3VwZGF0ZURpc2FibGVkIiwiZm9jdXNSaW5nIiwiX2ZvY3VzUmluZyIsImJhY2tncm91bmRTaXplIiwiX3JhdGlvIiwiUmFuZ2UiLCJBbmltYXRvckNTUyIsImZpbmFsIiwiZ2V0VGltZSIsImluaXRpYWwiLCJ1cGRhdGVTdHlsZXMiLCJjbGVhclRpbWVvdXQiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJzdG9wTmV4dCIsIm5ld0R1cmF0aW9uIiwicGFzc2VkIiwicmVtYWluaW5nIiwic3BlZWRVcFRpbWUiLCJzdG9wIiwibWlsbGlzZWNvbmRzIiwic3BlZWQiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJfb25TdG9wQW5pbWF0aW9ucyIsIl9xdWV1ZSIsIl9pbmRleCIsInN0b3BBbmltYXRpb25zIiwiUmlwcGxlRWxlbWVudCIsIl9vblRhcCIsIl9vbkhvbGQiLCJfYW5pbWF0b3IiLCJfd2F2ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYmFja2dyb3VuZCIsInNpemVzIiwiX2dldEVmZmVjdFNpemUiLCJfY2VudGVyIiwiX21pblIiLCJfY2FsY3VsYXRlQ29vcmRzIiwic3RvcEFsbCIsInJpcHBsZSIsIl91cGRhdGVQYXJlbnQiLCJfcmlwcGxlQW5pbWF0aW9uIiwiX2hvbGRpbmciLCJfcGFyZW50Tm9kZSIsInBuIiwiUmlwcGxlIiwiUm93RWxlbWVudCIsIlJvdyIsIlNlZ21lbnRFbGVtZW50IiwiX3NlZ21lbnRJZCIsIl90YWJiYXIiLCJfb25UYWJiYXJQcmVDaGFuZ2UiLCJnZXRBY3RpdmVUYWJJbmRleCIsImdldEFjdGl2ZUJ1dHRvbkluZGV4IiwiX3NldENoZWNrZWQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsInNldEFjdGl2ZVRhYiIsIl9wb3N0Q2hhbmdlIiwiU2VnbWVudCIsIlNlbGVjdEVsZW1lbnQiLCJfZGVyaXZlR2V0dGVycyIsIl9zZWxlY3QiLCJzZWwiLCJvcHRpb24iLCJTZWxlY3QiLCJTcGVlZERpYWxJdGVtRWxlbWVudCIsIlNwZWVkRGlhbEl0ZW0iLCJTcGVlZERpYWxFbGVtZW50IiwiX2l0ZW1TaG93biIsIl91cGRhdGVEaXJlY3Rpb24iLCJ0b2dnbGVJdGVtcyIsImlubGluZSIsIl9mYWIiLCJpdGVtcyIsIl9nZXRUcmFuc2xhdGUiLCJoaWRlSXRlbXMiLCJ0b3RhbERlbGF5IiwiaXNPcGVuIiwic2hvd0l0ZW1zIiwiU3BlZWREaWFsIiwiU3BsaXR0ZXJDb250ZW50RWxlbWVudCIsIm9sZENvbnRlbnQiLCJTcGxpdHRlckNvbnRlbnQiLCJTcGxpdHRlck1hc2tFbGVtZW50IiwiX3NpZGVzIiwic2lkZSIsIm1vZGUiLCJTcGxpdHRlck1hc2siLCJTcGxpdHRlckFuaW1hdG9yIiwic2lkZUVsZW1lbnQiLCJzcGxpdHRlciIsIl9zaWRlIiwiX29wcG9zaXRlU2lkZSIsImNsZWFyTWFzayIsIk92ZXJsYXlTcGxpdHRlckFuaW1hdG9yIiwibWludXMiLCJQdXNoU3BsaXR0ZXJBbmltYXRvciIsInNsaWRpbmdFbGVtZW50cyIsIl9zbGlkaW5nRWxlbWVudHMiLCJfZ2V0U2xpZGluZ0VsZW1lbnRzIiwiUmV2ZWFsU3BsaXR0ZXJBbmltYXRvciIsIl9zZXRTdHlsZXMiLCJfdW5zZXRTdHlsZXMiLCJfZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUiLCJiZWhpbmREaXN0YW5jZSIsImJlaGluZFRyYW5zZm9ybSIsIl9nZXRNYXhXaWR0aCIsIm1lbnVTdHlsZSIsIlNwbGl0dGVyRWxlbWVudCIsIl9sYXlvdXQiLCJfZ2V0U2lkZSIsIl9vbk1vZGVDaGFuZ2UiLCJTcGxpdHRlciIsIlNQTElUX01PREUiLCJDT0xMQVBTRV9NT0RFIiwiQ0xPU0VEX1NUQVRFIiwiT1BFTl9TVEFURSIsIkNIQU5HSU5HX1NUQVRFIiwic3BsaXR0ZXJTaWRlRWxlbWVudCIsIkNvbGxhcHNlRGV0ZWN0aW9uIiwiY2hhbmdlVGFyZ2V0IiwiX3RhcmdldCIsIl9vcmllbnRhdGlvbiIsImFjdGl2YXRlIiwiX3VwZGF0ZU1vZGUiLCJfbWF0Y2giLCJfcXVlcnlSZXN1bHQiLCJtYXRjaE1lZGlhIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIlNwbGl0dGVyU2lkZUVsZW1lbnQiLCJfc3RhdGUiLCJfbG9jayIsIl9jb2xsYXBzZURldGVjdGlvbiIsIl9hbmltYXRpb25PcHQiLCJjbG9zZWQiLCJ2YWxpZERyYWciLCJfbW9kZSIsIl9pc090aGVyU2lkZU9wZW4iLCJkZWFjdGl2YXRlIiwidXBkYXRlT3B0aW9ucyIsIkZJTkFMX1NUQVRFIiwiX2VtaXRFdmVudCIsIlNwbGl0dGVyU2lkZSIsImxvY2F0aW9ucyIsIlN3aXRjaEVsZW1lbnQiLCJfbGFzdFRpbWVTdGFtcCIsIl9sb2NhdGlvbnMiLCJfc3RhcnRYIiwiX2VtaXRDaGFuZ2VFdmVudCIsImRlZmF1bHRFbGVtZW50Q2xhc3MiLCJfaGFuZGxlIiwiX2dldFBvc2l0aW9uIiwicHJldmlvdXNWYWx1ZSIsImNsaWNrIiwiU3dpdGNoIiwidGFiYmFyRWxlbWVudCIsImxlcnAiLCJ4MCIsIngxIiwidCIsIlRhYmJhckVsZW1lbnQiLCJfbG9hZEluYWN0aXZlIiwiX2dldEF1dG9TY3JvbGxSYXRpbyIsIl9vblByZUNoYW5nZSIsIl9vblBvc3RDaGFuZ2UiLCJfdGFiYmFyQm9yZGVyIiwiX3RhYmJhckVsZW1lbnQiLCJfdGFic1JlY3QiLCJ0YWJJdGVtIiwidGFicyIsIl9ub3JtYWxpemVFdmVudCIsImNhbmNlbCIsInNldEFjdGl2ZSIsInByZXZUYWIiLCJfYXV0b2dyb3ciLCJ0YWIiLCJ0YWJiYXIiLCJjcyIsImZpbGxlZCIsIm5leHRJbmRleCIsInByZXZJbmRleCIsIm5leHRUYWIiLCJzZXRUYWJiYXJWaXNpYmlsaXR5IiwiaXNBY3RpdmUiLCJpc1RvcCIsIl90YXJnZXRFbGVtZW50IiwiVGFiYmFyIiwiVGFiRWxlbWVudCIsIl9idXR0b24iLCJfdXBkYXRlQnV0dG9uQ29udGVudCIsImljb25XcmFwcGVyIiwiZml4IiwiYWN0aXZlIiwiX2hhc0xvYWRlZCIsIl9sb2FkZWRQYWdlIiwicGFnZVRhcmdldCIsInBhcmVudFRhcmdldCIsImR1bW15UGFnZSIsIl9sb2FkUGFnZUVsZW1lbnQiLCJUYWIiLCJUb2FzdEFuaW1hdG9yIiwiRmFkZVRvYXN0QW5pbWF0b3IiLCJBc2NlbmRUb2FzdEFuaW1hdG9yIiwibWVzc2FnZURlbGF5IiwiYXNjZW5zaW9uIiwiX2dldEZhYnMiLCJmYWIiLCJMaWZ0VG9hc3RBbmltYXRvciIsIkZhbGxUb2FzdEFuaW1hdG9yIiwiZmFsbEFtb3VudCIsImNsZWFuVXAiLCJjb3JyZWN0VG9wIiwiVG9hc3RFbGVtZW50IiwibWVzc2FnZUNsYXNzTmFtZSIsImJ1dHRvbkNsYXNzTmFtZSIsIlRvYXN0IiwiVG9vbGJhckJ1dHRvbkVsZW1lbnQiLCJUb29sYmFyQnV0dG9uIiwiX3N1cGVyU2VjcmV0T25zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGtCQUFlLEVBQWY7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBRUE7Ozs7OztBQU1BLElBQU1BLFNBQVUsWUFBVztNQUNuQkMsU0FBU0MsT0FBT0MsZ0JBQVAsQ0FBd0JDLFNBQVNDLGVBQWpDLEVBQWtELEVBQWxELENBQWY7TUFDTUwsU0FBUyxDQUFDTSxNQUFNQyxTQUFOLENBQWdCQyxLQUFoQixDQUNiQyxJQURhLENBQ1JSLE1BRFEsRUFFYlMsSUFGYSxDQUVSLEVBRlEsRUFHYkMsS0FIYSxDQUdQLG1CQUhPLEtBR2tCVixPQUFPVyxLQUFQLEtBQWlCLEVBQWpCLElBQXVCLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FIMUMsRUFJYixDQUphLENBQWY7O1NBTU8sVUFBU0MsSUFBVCxFQUFlO1dBQ2IsTUFBTWIsTUFBTixHQUFlLEdBQWYsR0FBcUJjLE9BQUtDLFNBQUwsQ0FBZUYsSUFBZixDQUE1QjtHQURGO0NBUmEsRUFBZjs7Ozs7Ozs7OztBQXNCQSxJQUFNRyxTQUFTLFNBQVRBLE1BQVMsQ0FBU0MsT0FBVCxFQUFrQkMsS0FBbEIsRUFBeUI7U0FDL0JDLElBQVAsQ0FBWUQsS0FBWixFQUFtQkUsT0FBbkIsQ0FBMkIsVUFBU0MsR0FBVCxFQUFjO1FBQ25DQSxPQUFPSixRQUFRQyxLQUFuQixFQUEwQjtjQUNoQkEsS0FBUixDQUFjRyxHQUFkLElBQXFCSCxNQUFNRyxHQUFOLENBQXJCO0tBREYsTUFFTyxJQUFJckIsT0FBT3FCLEdBQVAsS0FBZUosUUFBUUMsS0FBM0IsRUFBa0M7Y0FDL0JBLEtBQVIsQ0FBY2xCLE9BQU9xQixHQUFQLENBQWQsSUFBNkJILE1BQU1HLEdBQU4sQ0FBN0I7S0FESyxNQUVBO2FBQ0FDLElBQUwsQ0FBVSw2QkFBNkJELEdBQXZDOztHQU5KO1NBU09KLE9BQVA7Q0FWRjs7Ozs7O0FBaUJBRCxPQUFPTyxLQUFQLEdBQWUsVUFBU04sT0FBVCxFQUErQjtNQUFiaEIsTUFBYSx1RUFBSixFQUFJOztNQUN0Q3VCLFlBQVl2QixPQUFPd0IsS0FBUCxDQUFhLEtBQWIsRUFBb0JDLE1BQXBCLENBQTJCLFVBQUNDLENBQUQsRUFBSUMsQ0FBSjtXQUFVRCxFQUFFRSxNQUFGLENBQVMsQ0FBQ2YsT0FBS0MsU0FBTCxDQUFlYSxDQUFmLENBQUQsRUFBb0I1QixPQUFPNEIsQ0FBUCxDQUFwQixDQUFULENBQVY7R0FBM0IsRUFBK0UsRUFBL0UsQ0FBbEI7TUFDRVQsT0FBTyxFQURUOzs2QkFHU1csQ0FKbUM7UUFLcENULE1BQU1KLFFBQVFDLEtBQVIsQ0FBY1ksQ0FBZCxDQUFaO1FBQ0lOLFVBQVVPLE1BQVYsS0FBcUIsQ0FBckIsSUFBMEJQLFVBQVVRLElBQVYsQ0FBZTthQUFLWCxJQUFJWSxPQUFKLENBQVlMLENBQVosTUFBbUIsQ0FBeEI7S0FBZixDQUE5QixFQUF5RTtXQUNsRU0sSUFBTCxDQUFVYixHQUFWLEVBRHVFOzs7O09BRnRFLElBQUlTLElBQUliLFFBQVFDLEtBQVIsQ0FBY2EsTUFBZCxHQUF1QixDQUFwQyxFQUF1Q0QsS0FBSyxDQUE1QyxFQUErQ0EsR0FBL0MsRUFBb0Q7VUFBM0NBLENBQTJDOzs7T0FPL0NWLE9BQUwsQ0FBYTtXQUFPSCxRQUFRQyxLQUFSLENBQWNHLEdBQWQsSUFBcUIsRUFBNUI7R0FBYjtVQUNRYyxZQUFSLENBQXFCLE9BQXJCLE1BQWtDLEVBQWxDLElBQXdDbEIsUUFBUW1CLGVBQVIsQ0FBd0IsT0FBeEIsQ0FBeEM7Q0FaRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLElBQU1DLG9CQUFvQm5DLE9BQU9vQyxXQUFqQzs7Ozs7Ozs7OztJQVNNQzs7Ozs7O3NCQU1VOzs7U0FDUEMsaUJBQUwsR0FBeUIsSUFBekI7U0FDS0MscUJBQUwsR0FBNkIsS0FBN0I7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQWFLQyxVQUFVO1VBQ1gsT0FBT0EsUUFBUCxLQUFvQixRQUF4QixFQUFrQzthQUMzQkYsaUJBQUwsR0FBeUJFLFNBQVNDLElBQVQsR0FBZ0JDLFdBQWhCLEVBQXpCOzs7OzsyQ0FJbUI7YUFDZCxLQUFLSCxxQkFBTCxHQUE2QixJQUE3QixHQUFvQyxLQUFLRCxpQkFBaEQ7Ozs7eUNBR21CSyxJQUFJO1dBQ2xCSixxQkFBTCxHQUE2QixJQUE3QjtVQUNNSyxTQUFTRCxJQUFmO1dBQ0tKLHFCQUFMLEdBQTZCLEtBQTdCOzthQUVPSyxNQUFQOzs7Ozs7Ozs7Ozs7Ozs7OztnQ0FjVTtVQUNOMUMsU0FBUzJDLFVBQVQsS0FBd0IsU0FBeEIsSUFBcUMzQyxTQUFTMkMsVUFBVCxJQUF1QixlQUFoRSxFQUFpRjtjQUN6RSxJQUFJQyxLQUFKLENBQVUsNERBQVYsQ0FBTjs7O2FBR0ssQ0FBQyxFQUFFOUMsT0FBTytDLE9BQVAsSUFBa0IvQyxPQUFPZ0QsUUFBekIsSUFBcUNoRCxPQUFPaUQsUUFBOUMsQ0FBUjs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBY1M7d0JBQ1FDLElBQVYsQ0FBZUMsVUFBVUMsU0FBekI7Ozs7Ozs7Ozs7Ozs7OztnQ0FXRzs7O2FBR0gsS0FBS0MsUUFBTCxPQUNKckQsT0FBT3NELE1BQVAsQ0FBY0MsS0FBZCxLQUF3QixHQUF4QixJQUErQnZELE9BQU9zRCxNQUFQLENBQWNFLE1BQWQsS0FBeUIsR0FBeEQsSUFDQXhELE9BQU9zRCxNQUFQLENBQWNDLEtBQWQsS0FBd0IsR0FBeEIsSUFBK0J2RCxPQUFPc0QsTUFBUCxDQUFjRSxNQUFkLEtBQXlCLEdBRnBELENBQVA7Ozs7Ozs7Ozs7Ozs7OzZCQWFPO3NCQUNRTixJQUFSLENBQWFDLFVBQVVDLFNBQXZCOzs7Ozs7Ozs7OzZCQU1BO3NCQUNRRixJQUFSLENBQWFDLFVBQVVDLFNBQXZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBY0Q7VUFDRixLQUFLSyxvQkFBTCxFQUFKLEVBQWlDO2VBQ3hCLEtBQUtBLG9CQUFMLE9BQWdDLEtBQXZDOzs7VUFHRSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCLENBQUMsV0FBV1IsSUFBWCxDQUFnQlEsT0FBT2xCLFFBQXZCLENBQW5DLEVBQXFFO3VCQUNyRFUsSUFBUCxDQUFZUSxPQUFPbEIsUUFBbkI7O09BRFQsTUFFTztvQ0FDc0JVLElBQXBCLENBQXlCQyxVQUFVQyxTQUFuQzs7Ozs7Ozs7Ozs7Ozs7OztrQ0FZRztVQUNSLFFBQU9NLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEIsQ0FBQyxXQUFXUixJQUFYLENBQWdCUSxPQUFPbEIsUUFBdkIsQ0FBbkMsRUFBcUU7dUJBQ3BEVSxJQUFQLENBQVlRLE9BQU9sQixRQUFuQixLQUFpQ21CLFNBQVNELE9BQU9FLE9BQVAsQ0FBZXJDLEtBQWYsQ0FBcUIsR0FBckIsRUFBMEIsQ0FBMUIsQ0FBVCxLQUEwQzs7T0FEckYsTUFFTyxJQUFJLG9CQUFvQjJCLElBQXBCLENBQXlCQyxVQUFVQyxTQUFuQyxDQUFKLEVBQW1EO1lBQ2xEUyxNQUFNLENBQUNWLFVBQVVDLFNBQVYsQ0FBb0IzQyxLQUFwQixDQUEwQiwrQkFBMUIsS0FBOEQsQ0FBQyxFQUFELENBQS9ELEVBQXFFLENBQXJFLEVBQXdFcUQsT0FBeEUsQ0FBZ0YsSUFBaEYsRUFBc0YsR0FBdEYsQ0FBWjtlQUNRSCxTQUFTRSxJQUFJdEMsS0FBSixDQUFVLEdBQVYsRUFBZSxDQUFmLENBQVQsS0FBK0IsQ0FBdkM7O2FBRUssS0FBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBY1k7VUFDTjRCLFlBQVluRCxPQUFPbUQsU0FBekI7VUFDTVksS0FBS1osVUFBVUMsU0FBckI7O2FBRU8sQ0FBQyxFQUFFLEtBQUtZLEtBQUwsTUFBZ0JELEdBQUdoQyxPQUFILENBQVcsUUFBWCxNQUF5QixDQUFDLENBQTFDLElBQStDZ0MsR0FBR2hDLE9BQUgsQ0FBVyxTQUFYLE1BQTBCLENBQUMsQ0FBMUUsSUFBK0UsQ0FBQ29CLFVBQVVjLFVBQTVGLENBQVI7Ozs7Ozs7Ozs7Ozs7O2tDQVdZO1VBQ05DLE9BQU8sZUFBZWhCLElBQWYsQ0FBb0JmLGlCQUFwQixDQUFiO2FBQ08sQ0FBQyxFQUFFLEtBQUs2QixLQUFMLE1BQWdCaEUsT0FBT21FLE1BQXZCLElBQWlDbkUsT0FBT21FLE1BQVAsQ0FBY0MsZUFBL0MsSUFBa0VwRSxPQUFPcUUsU0FBekUsSUFBc0YsQ0FBQ0gsSUFBekYsQ0FBUjs7Ozs7Ozs7Ozs7Ozs7a0NBV1k7YUFDTCxDQUFDLEVBQUUsS0FBS0YsS0FBTCxNQUFnQixDQUFDLEtBQUtNLFdBQUwsRUFBakIsSUFBdUMsQ0FBQyxLQUFLQyxXQUFMLEVBQTFDLENBQVI7Ozs7Ozs7Ozs7Ozs7Ozs7O3FDQWNlO3lCQUNHckIsSUFBWCxDQUFnQkMsVUFBVUMsU0FBMUIsS0FBd0MsVUFBVUYsSUFBVixDQUFlQyxVQUFVQyxTQUF6Qjs7Ozs7Ozs7Ozs7Ozs7O3NDQVcvQjt5QkFDRUYsSUFBWCxDQUFnQkMsVUFBVUMsU0FBMUIsS0FBd0MsQ0FBQyxVQUFVRixJQUFWLENBQWVDLFVBQVVDLFNBQXpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBY3RDO1VBQ04sS0FBS0ssb0JBQUwsRUFBSixFQUFpQztlQUN4QixLQUFLQSxvQkFBTCxPQUFnQyxTQUF2Qzs7O1VBR0UsUUFBT0MsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QixDQUFDLFdBQVdSLElBQVgsQ0FBZ0JRLE9BQU9sQixRQUF2QixDQUFuQyxFQUFxRTsyQkFDakRVLElBQVgsQ0FBZ0JRLE9BQU9sQixRQUF2Qjs7T0FEVCxNQUVPOzJCQUNhVSxJQUFYLENBQWdCQyxVQUFVQyxTQUExQjs7Ozs7Ozs7Ozs7Ozs7MkJBVUo7VUFDRCxLQUFLSyxvQkFBTCxFQUFKLEVBQWlDO2VBQ3hCLEtBQUtBLG9CQUFMLE9BQWdDLElBQXZDOzs7VUFHRSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCLENBQUMsV0FBV1IsSUFBWCxDQUFnQlEsT0FBT2xCLFFBQXZCLENBQW5DLEVBQXFFO2lDQUMzQ1UsSUFBakIsQ0FBc0JRLE9BQU9sQixRQUE3Qjs7T0FEVCxNQUVPO29EQUNzQ1UsSUFBcEMsQ0FBeUNDLFVBQVVDLFNBQW5EOzs7Ozs7Ozs7Ozs7Ozs7O21DQVlJO1VBQ1QsS0FBS0ssb0JBQUwsRUFBSixFQUFpQztlQUN4QixLQUFLQSxvQkFBTCxPQUFnQyxZQUF2Qzs7O1VBR0UsUUFBT0MsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QixDQUFDLFdBQVdSLElBQVgsQ0FBZ0JRLE9BQU9sQixRQUF2QixDQUFuQyxFQUFxRTs4QkFDOUNVLElBQWQsQ0FBbUJRLE9BQU9sQixRQUExQjs7T0FEVCxNQUVPO2lEQUNtQ1UsSUFBakMsQ0FBc0NDLFVBQVVDLFNBQWhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQWVEO1VBQ0osS0FBS0ssb0JBQUwsRUFBSixFQUFpQztlQUN4QixLQUFLQSxvQkFBTCxPQUFnQyxPQUF2Qzs7O2FBR00sQ0FBQyxDQUFDekQsT0FBT3dFLEtBQVQsSUFBa0JyQixVQUFVQyxTQUFWLENBQW9CckIsT0FBcEIsQ0FBNEIsT0FBNUIsS0FBd0MsQ0FBbEU7Ozs7Ozs7Ozs7Ozs7O2dDQVdVO1VBQ04sS0FBSzBCLG9CQUFMLEVBQUosRUFBaUM7ZUFDeEIsS0FBS0Esb0JBQUwsT0FBZ0MsU0FBdkM7OzthQUdNLE9BQU9nQixjQUFQLEtBQTBCLFdBQWxDOzs7Ozs7Ozs7Ozs7OzsrQkFXUztVQUNMLEtBQUtoQixvQkFBTCxFQUFKLEVBQWlDO2VBQ3hCLEtBQUtBLG9CQUFMLE9BQWdDLFFBQXZDOzs7YUFHTWlCLE9BQU9yRSxTQUFQLENBQWlCc0UsUUFBakIsQ0FBMEJwRSxJQUExQixDQUErQlAsT0FBT29DLFdBQXRDLEVBQW1ETCxPQUFuRCxDQUEyRCxhQUEzRCxJQUE0RSxDQUE3RSxJQUFvRixVQUFVNkMsQ0FBVixFQUFhO2VBQVNBLEVBQUVELFFBQUYsT0FBaUIsbUNBQXhCO09BQWhCLENBQStFLENBQUMzRSxPQUFPLFFBQVAsQ0FBRCxJQUFxQjZFLE9BQU9DLGdCQUEzRyxDQUExRjs7Ozs7Ozs7Ozs7Ozs7K0JBV1M7VUFDTCxLQUFLckIsb0JBQUwsRUFBSixFQUFpQztlQUN4QixLQUFLQSxvQkFBTCxPQUFnQyxRQUF2Qzs7O2FBR00sQ0FBQyxDQUFDekQsT0FBTytFLE1BQVQsSUFBbUIsRUFBRSxDQUFDLENBQUMvRSxPQUFPd0UsS0FBVCxJQUFrQnJCLFVBQVVDLFNBQVYsQ0FBb0JyQixPQUFwQixDQUE0QixPQUE1QixLQUF3QyxDQUE1RCxDQUFuQixJQUFxRixFQUFFb0IsVUFBVUMsU0FBVixDQUFvQnJCLE9BQXBCLENBQTRCLFFBQTVCLEtBQXlDLENBQTNDLENBQTdGOzs7Ozs7Ozs7Ozs7OzsyQkFXSztVQUNELEtBQUswQixvQkFBTCxFQUFKLEVBQWlDO2VBQ3hCLEtBQUtBLG9CQUFMLE9BQWdDLElBQXZDOzs7YUFHSyxTQUFTLENBQUMsQ0FBQ3ZELFNBQVM4RSxZQUEzQjs7Ozs7Ozs7Ozs7Ozs7NkJBV087VUFDSCxLQUFLdkIsb0JBQUwsRUFBSixFQUFpQztlQUN4QixLQUFLQSxvQkFBTCxPQUFnQyxNQUF2Qzs7O2FBR0tOLFVBQVVDLFNBQVYsQ0FBb0JyQixPQUFwQixDQUE0QixRQUE1QixLQUF5QyxDQUFoRDs7Ozs7Ozs7Ozs7O2tDQVNZO1VBQ1IsS0FBS2tELFNBQUwsRUFBSixFQUFzQjtlQUNiLFNBQVA7T0FERixNQUdLLElBQUksS0FBS2pCLEtBQUwsRUFBSixFQUFrQjtlQUNkLEtBQVA7T0FERyxNQUdBLElBQUksS0FBS2tCLElBQUwsRUFBSixFQUFpQjtlQUNiLElBQVA7T0FERyxNQUdBO2VBQ0ksT0FBUDs7Ozs7Ozs7OzttQ0FPVztVQUNULEtBQUs3QixRQUFMLEVBQUosRUFBcUI7ZUFDWixRQUFQO09BREYsTUFHSyxJQUFJLEtBQUs4QixNQUFMLEVBQUosRUFBbUI7ZUFDZixNQUFQO09BREcsTUFHQSxJQUFJLEtBQUtDLE1BQUwsRUFBSixFQUFtQjtlQUNmLE1BQVA7T0FERyxNQUdBO2VBQ0ksSUFBUDs7Ozs7OztBQU1OLGVBQWUsSUFBSS9DLFFBQUosRUFBZjs7QUMvYkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBR0EsSUFBTWdELFFBQVEsU0FBUkEsS0FBUTtTQUFXekUsT0FBSzBFLEtBQUwsa0NBQTBDQyxPQUExQyxDQUFYO0NBQWQ7O0FBRUEsSUFBTUMsMEJBQTBCO2NBQ2xCLEVBRGtCOzs7Ozs7Ozs7a0JBVWQsd0JBQVM3RSxJQUFULEVBQWU4RSxLQUFmLEVBQXVDO1FBQWpCQyxTQUFpQix1RUFBUCxLQUFPOztRQUNqRCxPQUFPL0UsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtZQUN0QixnQ0FBTjtLQURGLE1BR0ssSUFBSSxPQUFPOEUsS0FBUCxLQUFpQixRQUFqQixJQUE2QixPQUFPQSxLQUFQLEtBQWlCLFVBQWxELEVBQThEO1lBQzNELCtDQUFOO0tBREcsTUFHQSxJQUFJLEtBQUtFLFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCakYsSUFBL0IsS0FBd0MsQ0FBQytFLFNBQTdDLEVBQXdEO2tCQUNqRC9FLElBQVY7O1NBRUdnRixVQUFMLENBQWdCaEYsSUFBaEIsSUFBd0I4RSxLQUF4QjtHQXBCNEI7Ozs7Ozs7O2VBNkJqQixxQkFBUzlFLElBQVQsRUFBZTtRQUN0QixDQUFDLEtBQUtnRixVQUFMLENBQWdCQyxjQUFoQixDQUErQmpGLElBQS9CLENBQUwsRUFBMkM7YUFDbEMsSUFBUDs7O1dBR0ssS0FBS2dGLFVBQUwsQ0FBZ0JoRixJQUFoQixDQUFQO0dBbEM0Qjs7Ozs7OztrQkEwQ2Qsd0JBQVNBLElBQVQsRUFBZTtXQUN0QixLQUFLZ0YsVUFBTCxDQUFnQmhGLElBQWhCLENBQVA7R0EzQzRCOzs7Ozs7O21CQW1EYiwyQkFBVztXQUNuQixLQUFLZ0YsVUFBWjtHQXBENEI7Y0FzRGxCLG9CQUFTRSxJQUFULEVBQWU7UUFDckJDLFVBQUo7UUFDRUMsa0JBQWtCLEtBRHBCO1FBRUVDLGVBQWUsQ0FGakI7O1FBSU1DLFNBQVMsRUFBZjs7UUFFSUosS0FBS2hFLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7WUFDZiw4QkFBTjs7O1NBR0csSUFBSUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaUUsS0FBS2hFLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztVQUNoQ2lFLEtBQUtLLE1BQUwsQ0FBWXRFLENBQVosQ0FBSjs7VUFFSWtFLE1BQU0sR0FBTixJQUFhRCxLQUFLSyxNQUFMLENBQVl0RSxJQUFJLENBQWhCLE1BQXVCLEdBQXhDLEVBQTZDO1lBQ3ZDbUUsZUFBSixFQUFxQjtnQkFDYixvQ0FBTjs7O1lBR0lJLFFBQVFOLEtBQUtPLFNBQUwsQ0FBZUosWUFBZixFQUE2QnBFLENBQTdCLENBQWQ7WUFDSXVFLE1BQU10RSxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7aUJBQ2JHLElBQVAsQ0FBWTZELEtBQUtPLFNBQUwsQ0FBZUosWUFBZixFQUE2QnBFLENBQTdCLENBQVo7Ozt1QkFHYUEsQ0FBZjswQkFDa0IsSUFBbEI7T0FYRixNQWFLLElBQUlrRSxNQUFNLEdBQVYsRUFBZTtZQUNkLENBQUNDLGVBQUwsRUFBc0I7Z0JBQ2QsMkJBQU47OztZQUdJSSxTQUFRTixLQUFLTyxTQUFMLENBQWVKLFlBQWYsRUFBNkJwRSxJQUFJLENBQWpDLENBQWQ7WUFDSXVFLE9BQU10RSxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7aUJBQ2JHLElBQVAsQ0FBWTZELEtBQUtPLFNBQUwsQ0FBZUosWUFBZixFQUE2QnBFLElBQUksQ0FBakMsQ0FBWjs7O3VCQUdhQSxJQUFJLENBQW5COzBCQUNrQixLQUFsQjs7OztRQUlBbUUsZUFBSixFQUFxQjtZQUNiLDRCQUFOOzs7V0FHSy9ELElBQVAsQ0FBWTZELEtBQUtPLFNBQUwsQ0FBZUosWUFBZixFQUE2QkgsS0FBS2hFLE1BQWxDLENBQVo7O1dBRU9vRSxNQUFQO0dBdEc0QjtpQkF3R2YsdUJBQVNFLEtBQVQsRUFBZ0I7UUFDdkJFLEtBQUssYUFBWDtRQUNFNUYsUUFBUTBGLE1BQU0xRixLQUFOLENBQVk0RixFQUFaLENBRFY7O1FBR0k1RixLQUFKLEVBQVc7VUFDSEUsT0FBT0YsTUFBTSxDQUFOLEVBQVNnQyxJQUFULEVBQWI7VUFDTTZELFdBQVcsS0FBS0MsV0FBTCxDQUFpQjVGLElBQWpCLENBQWpCOztVQUVJMkYsYUFBYSxJQUFqQixFQUF1Qjs2QkFDRjNGLElBQW5CO09BREYsTUFHSyxJQUFJLE9BQU8yRixRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO2VBQzlCQSxRQUFQO09BREcsTUFHQTtZQUNHRSxLQUFLRixVQUFYOztZQUVJLE9BQU9FLEVBQVAsS0FBYyxRQUFsQixFQUE0QjtnQkFDcEIsc0JBQU47OztlQUdLQSxFQUFQOztLQWpCSixNQW9CSzthQUNJTCxLQUFQOztHQWpJMEI7a0JBb0lkLHdCQUFTRixNQUFULEVBQWlCO1dBQ3hCQSxPQUFPUSxHQUFQLENBQVcsS0FBS0MsYUFBTCxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBWCxDQUFQO0dBckk0QjtvQkF1SVosMEJBQVNDLFVBQVQsRUFBcUI7V0FDOUJBLFdBQVdyRixLQUFYLENBQWlCLEdBQWpCLEVBQ0prRixHQURJLENBRUgsVUFBU1osSUFBVCxFQUFlO2FBQ05BLEtBQUtwRCxJQUFMLEVBQVA7S0FIQyxFQU1KZ0UsR0FOSSxDQU1BLEtBQUtJLFVBQUwsQ0FBZ0JGLElBQWhCLENBQXFCLElBQXJCLENBTkEsRUFPSkYsR0FQSSxDQU9BLEtBQUtLLGNBQUwsQ0FBb0JILElBQXBCLENBQXlCLElBQXpCLENBUEEsRUFRSkYsR0FSSSxDQVFBLFVBQUNaLElBQUQ7YUFBVUEsS0FBS3JGLElBQUwsQ0FBVSxFQUFWLENBQVY7S0FSQSxDQUFQO0dBeEk0Qjs7Ozs7Ozs7WUF5SnBCLGtCQUFTb0csVUFBVCxFQUFxQjtRQUN6QixDQUFDQSxVQUFMLEVBQWlCO2FBQ1IsRUFBUDs7O1dBR0ssS0FBS0csZ0JBQUwsQ0FBc0JILFVBQXRCLENBQVA7O0NBOUpKOzs7QUFtS0FwQix3QkFBd0J3QixjQUF4QixDQUF1QyxVQUF2QyxFQUFtRHhFLFNBQVN5RSxXQUFULEVBQW5EO0FBQ0F6Qix3QkFBd0J3QixjQUF4QixDQUF1QyxXQUF2QyxFQUFvRHhFLFNBQVMwRSxZQUFULEVBQXBEO0FBQ0ExQix3QkFBd0J3QixjQUF4QixDQUF1QyxTQUF2QyxFQUFrRCxZQUFNO1NBQy9DeEUsU0FBUzJFLFNBQVQsS0FBdUIsU0FBdkIsR0FBbUMsU0FBMUM7Q0FERjs7QUMzTEE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBSUEsSUFBTUMsYUFBVyxFQUFqQjs7QUFFQUEsV0FBU0MsTUFBVCxHQUFrQjtxQkFDRyxJQURIO3NCQUVJLEtBRko7b0JBR0U7Q0FIcEI7O0FBTUFELFdBQVNFLFdBQVQsR0FBdUJ0SCxPQUFPRSxRQUFQLENBQWdCcUgsYUFBaEIsQ0FBOEIsS0FBOUIsQ0FBdkI7Ozs7O0FBS0FILFdBQVNJLDBCQUFULEdBQXNDLFlBQU07U0FDbkMsQ0FBQyxDQUFDSixXQUFTQyxNQUFULENBQWdCSSxpQkFBekI7Q0FERjs7Ozs7O0FBUUFMLFdBQVNNLGlCQUFULEdBQTZCO1NBQVEsQ0FBQyxLQUFLQyxJQUFOLEVBQVlsRixJQUFaLEVBQVI7Q0FBN0I7O0FBRUEyRSxXQUFTUSxvQkFBVCxHQUFnQyxvQkFBWTtNQUN0QzVILE9BQU9FLFFBQVAsQ0FBZ0IyQyxVQUFoQixLQUErQixTQUEvQixJQUE0QzdDLE9BQU9FLFFBQVAsQ0FBZ0IyQyxVQUFoQixJQUE4QixlQUE5RSxFQUErRjtRQUN2RmdGLGtCQUFrQixTQUFsQkEsZUFBa0IsR0FBTTs7YUFFckIzSCxRQUFQLENBQWdCNEgsbUJBQWhCLENBQW9DLGtCQUFwQyxFQUF3REQsZUFBeEQ7S0FGRjtXQUlPM0gsUUFBUCxDQUFnQjZILGdCQUFoQixDQUFpQyxrQkFBakMsRUFBcURGLGVBQXJEO0dBTEYsTUFNTztpQkFDUUcsUUFBYjs7Q0FSSjs7QUFZQVosV0FBU0ssaUJBQVQsR0FBNkIsa0JBQVU7TUFDL0JRLFVBQVUsU0FBVkEsT0FBVSxHQUFNO1FBQ2hCYixXQUFTYyxtQkFBVCxFQUFKLEVBQW9DOzs7YUFHM0JKLG1CQUFULENBQTZCLGFBQTdCLEVBQTRDRyxPQUE1QztHQUpGOztNQU9JLFFBQU92RSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDO2FBQ3JCcUUsZ0JBQVQsQ0FBMEIsYUFBMUIsRUFBeUNFLE9BQXpDO0dBREYsTUFFTyxJQUFJLENBQUMsVUFBRCxFQUFhLGFBQWIsRUFBNEJsRyxPQUE1QixDQUFvQzdCLFNBQVMyQyxVQUE3QyxNQUE2RCxDQUFDLENBQWxFLEVBQXFFO2VBQ2pFK0Usb0JBQVQsQ0FBOEJLLE9BQTlCO0dBREssTUFFQTs7O0NBWlQ7O0FBaUJBYixXQUFTYyxtQkFBVCxHQUErQjtTQUFNZCxXQUFTSSwwQkFBVCxPQUNsQ2hGLFNBQVMyRSxTQUFULE1BQXdCM0UsU0FBUzJGLFdBQVQsRUFBeEIsSUFBa0QsQ0FBQzNGLFNBQVM0RixTQUFULEVBQW5ELElBQTJFbEksU0FBU21JLElBQVQsQ0FBY0MsYUFBZCxDQUE0QiwwQkFBNUIsQ0FEekMsQ0FBTjtDQUEvQjs7QUFHQWxCLFdBQVNtQixhQUFULEdBQXlCO1lBQ2IsRUFEYTs7Ozs7O0tBQUEsa0JBT25CcEgsR0FQbUIsRUFPZDtXQUNBaUcsV0FBU21CLGFBQVQsQ0FBdUJDLFFBQXZCLENBQWdDckgsR0FBaEMsS0FBd0MsSUFBL0M7R0FScUI7Ozs7Ozs7S0FBQSxrQkFlbkJBLEdBZm1CLEVBZWRzSCxRQWZjLEVBZUo7ZUFDUkYsYUFBVCxDQUF1QkMsUUFBdkIsQ0FBZ0NySCxHQUFoQyxJQUF1Q3NILFFBQXZDOztDQWhCSjs7QUFvQkF6SSxPQUFPRSxRQUFQLENBQWdCNkgsZ0JBQWhCLENBQWlDLGlCQUFqQyxFQUFvRCxVQUFTVyxDQUFULEVBQVk7TUFDMURBLEVBQUVDLE1BQUYsQ0FBU0MsUUFBVCxDQUFrQmxHLFdBQWxCLE9BQW9DLGNBQXhDLEVBQXdEO2VBQzdDNkYsYUFBVCxDQUF1Qk0sR0FBdkIsQ0FBMkJILEVBQUVJLFVBQTdCLEVBQXlDSixFQUFFRCxRQUEzQzs7Q0FGSixFQUlHLEtBSkg7O0FBTUFyQixXQUFTUSxvQkFBVCxDQUE4QixZQUFXO1dBQzlCLGtDQUFUO1dBQ1MsOEJBQVQ7V0FDUyxpQ0FBVDtXQUNTLFVBQVQ7O1dBRVNtQixRQUFULENBQWtCQyxLQUFsQixFQUF5QjtRQUNqQkMsWUFBWWpKLE9BQU9FLFFBQVAsQ0FBZ0JnSixnQkFBaEIsQ0FBaUNGLEtBQWpDLENBQWxCO1NBQ0ssSUFBSXBILElBQUksQ0FBYixFQUFnQkEsSUFBSXFILFVBQVVwSCxNQUE5QixFQUFzQ0QsR0FBdEMsRUFBMkM7aUJBQ2hDMkcsYUFBVCxDQUF1Qk0sR0FBdkIsQ0FBMkJJLFVBQVVySCxDQUFWLEVBQWFLLFlBQWIsQ0FBMEIsSUFBMUIsQ0FBM0IsRUFBNERnSCxVQUFVckgsQ0FBVixFQUFhdUgsV0FBYixJQUE0QkYsVUFBVXJILENBQVYsRUFBYXdILE9BQXJHOzs7Q0FUTjs7Ozs7O0FBa0JBaEMsV0FBU2lDLG9CQUFULEdBQWdDLFVBQVNDLElBQVQsRUFBZTtTQUN0QyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO2VBQzdCN0Isb0JBQVQsQ0FBOEIsWUFBTTtVQUM1QjhCLFFBQVF0QyxXQUFTbUIsYUFBVCxDQUF1Qm9CLEdBQXZCLENBQTJCTCxJQUEzQixDQUFkO1VBQ0lJLEtBQUosRUFBVztZQUNMQSxpQkFBaUJFLGdCQUFyQixFQUF1QztpQkFDOUJKLFFBQVFFLEtBQVIsQ0FBUDs7O1lBR0kvQixPQUFPLE9BQU8rQixLQUFQLEtBQWlCLFFBQWpCLEdBQTRCQSxLQUE1QixHQUFvQ0EsTUFBTSxDQUFOLENBQWpEO2VBQ09GLFFBQVFwQyxXQUFTTSxpQkFBVCxDQUEyQkMsSUFBM0IsQ0FBUixDQUFQOzs7VUFHSWtDLFFBQVE3SixPQUFPRSxRQUFQLENBQWdCNEosY0FBaEIsQ0FBK0JSLElBQS9CLENBQWQ7VUFDSU8sS0FBSixFQUFXO1lBQ0hsQyxRQUFPa0MsTUFBTVYsV0FBTixJQUFxQlUsTUFBTVQsT0FBeEM7ZUFDT0ksUUFBUTdCLEtBQVIsQ0FBUDs7O1VBR0lvQyxNQUFNLElBQUlDLGNBQUosRUFBWjtVQUNJQyxJQUFKLENBQVMsS0FBVCxFQUFnQlgsSUFBaEIsRUFBc0IsSUFBdEI7VUFDSVksTUFBSixHQUFhLFlBQVc7WUFDaEJ2QyxPQUFPb0MsSUFBSUksWUFBakI7WUFDSUosSUFBSUssTUFBSixJQUFjLEdBQWQsSUFBcUJMLElBQUlLLE1BQUosR0FBYSxHQUF0QyxFQUEyQztpQkFDbEN6QyxJQUFQO1NBREYsTUFFTzs7Y0FFQzBDLFdBQVd6SixPQUFLMEosY0FBTCxDQUFvQjNDLElBQXBCLENBQWpCO2lCQUNLNEMsU0FBTCxDQUFlRixTQUFTbkIsZ0JBQVQsQ0FBMEIsUUFBMUIsQ0FBZixFQUFvRGhJLE9BQXBELENBQTRELGNBQU07Z0JBQzFEc0osU0FBU3RLLFNBQVNxSCxhQUFULENBQXVCLFFBQXZCLENBQWY7bUJBQ09rRCxJQUFQLEdBQWNDLEdBQUdELElBQUgsSUFBVyxpQkFBekI7bUJBQ09FLFdBQVAsQ0FBbUJ6SyxTQUFTMEssY0FBVCxDQUF3QkYsR0FBR0csSUFBSCxJQUFXSCxHQUFHdkIsV0FBZCxJQUE2QnVCLEdBQUdJLFNBQXhELENBQW5CO2VBQ0dDLFVBQUgsQ0FBY0MsWUFBZCxDQUEyQlIsTUFBM0IsRUFBbUNFLEVBQW5DO1dBSkY7O3FCQU9TbkMsYUFBVCxDQUF1Qk0sR0FBdkIsQ0FBMkJTLElBQTNCLEVBQWlDZSxRQUFqQztrQkFDUUEsUUFBUjs7T0FmSjtVQWtCSVksT0FBSixHQUFjLFlBQVc7ZUFDbEIzRixLQUFMLCtCQUF1Q2dFLElBQXZDO09BREY7VUFHSTRCLElBQUosQ0FBUyxJQUFUO0tBeENGO0dBREssQ0FBUDtDQURGOzs7Ozs7QUFtREE5RCxXQUFTK0QsZ0JBQVQsR0FBNEIsVUFBUzdCLElBQVQsRUFBZTtNQUNuQzhCLFFBQVE1Rix3QkFBd0I2RixRQUF4QixDQUFpQy9CLElBQWpDLENBQWQ7O01BRU1nQyxVQUFVLFNBQVZBLE9BQVUsQ0FBQ2hDLElBQUQsRUFBVTtRQUNwQixPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO2FBQ3JCQyxRQUFRRSxNQUFSLENBQWUsc0JBQWYsQ0FBUDs7O1dBR0tyQyxXQUFTaUMsb0JBQVQsQ0FBOEJDLElBQTlCLEVBQ0ppQyxLQURJLENBQ0UsVUFBU2xHLEtBQVQsRUFBZ0I7VUFDakIrRixNQUFNdkosTUFBTixLQUFpQixDQUFyQixFQUF3QjtlQUNmMEgsUUFBUUUsTUFBUixDQUFlcEUsS0FBZixDQUFQOzs7YUFHS2lHLFFBQVFGLE1BQU1JLEtBQU4sRUFBUixDQUFQO0tBTkcsQ0FBUDtHQUxGOztTQWVPRixRQUFRRixNQUFNSSxLQUFOLEVBQVIsQ0FBUDtDQWxCRjs7QUMzS0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBR3FCQzs7Ozs7Ozs7OzsyQkFVUEMsSUFBWixFQUFrQjs7O1NBQ1hDLFVBQUwsR0FBa0JELEtBQUtFLFNBQXZCO1NBQ0tDLFVBQUwsR0FBa0JILEtBQUtJLFNBQXZCO1NBQ0tDLGNBQUwsR0FBc0JMLEtBQUtNLGFBQUwsSUFBc0JOLEtBQUtJLFNBQUwsQ0FBZW5MLElBQTNEO1NBQ0tzTCxVQUFMLEdBQWtCUCxLQUFLUSxnQkFBTCxJQUF5QixTQUEzQztTQUNLQyxpQkFBTCxHQUF5QlQsS0FBS1UsdUJBQUwsSUFBZ0MsRUFBekQ7O1FBRUksQ0FBQyxLQUFLVCxVQUFMLENBQWdCLEtBQUtNLFVBQXJCLENBQUwsRUFBdUM7YUFDaEMzRyxLQUFMLENBQVcsd0JBQXdCLEtBQUsyRyxVQUF4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NBNEJnQkksU0FBUztXQUN0QkYsaUJBQUwsR0FBeUJFLE9BQXpCOzs7Ozs7Ozs7Ozs7O2tDQVV5QztVQUEvQkEsT0FBK0IsdUVBQXJCLEVBQXFCO1VBQWpCQyxlQUFpQjs7O1VBRXJDQyxXQUFXLElBQWY7O1VBRUlGLFFBQVFHLFNBQVIsWUFBNkIsS0FBS1gsVUFBdEMsRUFBa0Q7ZUFDekNRLFFBQVFHLFNBQWY7OztVQUdFQyxXQUFXLElBQWY7O1VBRUksT0FBT0osUUFBUUcsU0FBZixLQUE2QixRQUFqQyxFQUEyQzttQkFDOUIsS0FBS2IsVUFBTCxDQUFnQlUsUUFBUUcsU0FBeEIsQ0FBWDs7O1VBR0UsQ0FBQ0MsUUFBRCxJQUFhSCxlQUFqQixFQUFrQzttQkFDckJBLGVBQVg7T0FERixNQUVPO21CQUNNRyxZQUFZLEtBQUtkLFVBQUwsQ0FBZ0IsS0FBS00sVUFBckIsQ0FBdkI7O1lBRU1TLGdCQUFnQjlMLE9BQUsrTCxNQUFMLENBQ3BCLEVBRG9CLEVBRXBCLEtBQUtSLGlCQUZlLEVBR3BCRSxRQUFRTyxnQkFBUixJQUE0QixFQUhSLEVBSXBCeEYsV0FBU0MsTUFBVCxDQUFnQndGLGtCQUFoQixHQUFxQyxFQUFDQyxVQUFVLENBQVgsRUFBY0MsT0FBTyxDQUFyQixFQUFyQyxHQUErRCxFQUozQyxDQUF0Qjs7bUJBT1csSUFBSU4sUUFBSixDQUFhQyxhQUFiLENBQVg7O1lBRUksT0FBT0gsUUFBUCxLQUFvQixVQUF4QixFQUFvQztxQkFDdkIsSUFBSUEsUUFBSixDQUFhRyxhQUFiLENBQVgsQ0FEa0M7Ozs7VUFLbEMsRUFBRUgsb0JBQW9CLEtBQUtWLFVBQTNCLENBQUosRUFBNEM7ZUFDckN2RyxLQUFMLHVDQUErQyxLQUFLeUcsY0FBcEQ7OzthQUdLUSxRQUFQOzs7O2dEQXBFaUNTLFlBQVk7VUFDekM7WUFDRSxPQUFPQSxVQUFQLEtBQXNCLFFBQTFCLEVBQW9DO2NBQzVCcEssU0FBU2hDLE9BQUtxTSxxQkFBTCxDQUEyQkQsVUFBM0IsQ0FBZjtjQUNJLFFBQU9wSyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCQSxXQUFXLElBQTdDLEVBQW1EO21CQUMxQ0EsTUFBUDtXQURGLE1BRU87b0JBQ0d5QyxLQUFSLENBQWMsaUVBQWlFMkgsVUFBL0U7OztlQUdHLEVBQVA7T0FURixDQVVFLE9BQU90RSxDQUFQLEVBQVU7Z0JBQ0ZyRCxLQUFSLENBQWMsaUVBQWlFMkgsVUFBL0U7ZUFDTyxFQUFQOzs7Ozs7O0FDM0ROOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUdBLElBQUlFLG1CQUFtQixJQUF2Qjs7O0FBR0EsSUFBTUMsZUFBZTtXQUNWLGdCQURVO1dBRVYsZ0JBRlU7YUFHUixnQkFIUTtTQUlaLEVBSlk7a0JBS0gsc0JBTEc7Z0JBTUwsT0FOSztjQU9QLEVBUE87Y0FRUDtDQVJkOztBQVdBLElBQU1DLFlBQVksRUFBbEI7O0FBRUFBLFVBQVVDLE9BQVYsR0FBb0IsbUJBQVc7O01BRXZCQyxjQUFjdk0sUUFBUXdNLE9BQVIsQ0FBZ0I3SyxXQUFoQixFQUFwQjs7TUFFSSxDQUFDOUIsT0FBSzRNLFdBQUwsQ0FBaUJ6TSxPQUFqQixFQUEwQixVQUExQixDQUFMLEVBQTRDO1FBQ3BDME0sY0FBYzFNLFFBQVFrQixZQUFSLENBQXFCLFVBQXJCLEtBQW9DLEVBQXhEOztRQUVNeUwsY0FBY0QsWUFBWWhMLElBQVosR0FBbUJsQixLQUFuQixDQUF5QixLQUF6QixFQUFnQ2tGLEdBQWhDLENBQW9DO2FBQUswRyxhQUFhdkgsY0FBYixDQUE0QjhDLENBQTVCLElBQWlDeUUsYUFBYXpFLENBQWIsQ0FBakMsR0FBbURBLENBQXhEO0tBQXBDLENBQXBCO2dCQUNZaUYsT0FBWixDQUFvQixVQUFwQjs7WUFFUUMsWUFBUixDQUFxQixVQUFyQixFQUFpQ0YsWUFBWWxOLElBQVosQ0FBaUIsR0FBakIsRUFBc0JpQyxJQUF0QixFQUFqQzs7O01BR0lvTCxXQUFXLENBQ2YseUJBRGUsRUFFZixvQkFGZSxFQUdmLGlCQUhlLEVBSWYsWUFKZSxFQUtmLGVBTGUsRUFNZixTQU5lLEVBT2YsZ0JBUGUsRUFRZixxQkFSZSxFQVNmLFNBVGUsQ0FBakI7OztNQWNJQSxTQUFTOUwsT0FBVCxDQUFpQnVMLFdBQWpCLE1BQWtDLENBQUMsQ0FBbkMsSUFDQyxDQUFDdk0sUUFBUStNLFlBQVIsQ0FBcUIsUUFBckIsQ0FERixJQUVDLENBQUMvTSxRQUFRdUgsYUFBUixDQUFzQixZQUF0QixDQUZOLEVBRTJDOztRQUVyQ2dGLGdCQUFnQixlQUFwQixFQUFxQztVQUMvQnZNLFFBQVErTSxZQUFSLENBQXFCLFVBQXJCLENBQUosRUFBc0M7Z0JBQzVCRixZQUFSLENBQXFCLFFBQXJCLEVBQStCLEVBQS9CO2dCQUNRMUwsZUFBUixDQUF3QixVQUF4Qjs7S0FISixNQUtPO2NBQ0cwTCxZQUFSLENBQXFCLFFBQXJCLEVBQStCLEVBQS9COzs7Q0FyQ047O0FBMENBUixVQUFVVyxHQUFWLEdBQWdCLG1CQUFXOzs7TUFHdEJuTixPQUFLb04sY0FBTCxDQUFvQmpOLE9BQXBCLEVBQTZCLFVBQTdCLENBQUosRUFBOEM7UUFDeENILE9BQUtvTixjQUFMLENBQW9Cak4sT0FBcEIsRUFBNkIsZ0JBQTdCLENBQUosRUFBb0Q7YUFDN0NrTixXQUFMLENBQWlCbE4sT0FBakIsRUFBMkJILE9BQUtvTixjQUFMLENBQW9Cak4sT0FBcEIsRUFBNkIsT0FBN0IsQ0FBRCxHQUEwQyxjQUExQyxHQUEyRCxPQUFyRjs7O1FBR0UsQ0FBQ0EsUUFBUWtCLFlBQVIsQ0FBcUIsVUFBckIsQ0FBTCxFQUF1QztjQUM3QkMsZUFBUixDQUF3QixVQUF4Qjs7Ozs7TUFLQW5CLFFBQVErTSxZQUFSLENBQXFCLFFBQXJCLENBQUosRUFBb0M7UUFDOUIvTSxRQUFRd00sT0FBUixDQUFnQjdLLFdBQWhCLE9BQWtDLGVBQXRDLEVBQXVEO2NBQzdDa0wsWUFBUixDQUFxQixVQUFyQixFQUFpQyxFQUFqQzs7O1lBR00xTCxlQUFSLENBQXdCLFFBQXhCOztDQW5CSDs7QUF1QkEsSUFBTWdNLFdBQVc7V0FDTjtDQURYOztBQUlBLElBQU1DLGNBQWMsU0FBZEEsV0FBYyxDQUFDcE4sT0FBRCxFQUFVcU4sS0FBVixFQUFvQjtNQUNsQ2xCLG9CQUFvQixDQUFDbk0sUUFBUStNLFlBQVIsQ0FBcUIsc0JBQXJCLENBQXpCLEVBQXVFO1FBQy9ETyxXQUFXQyxTQUFZckgsV0FBWixFQUFqQjtRQUNJbUcsVUFBVXhILGNBQVYsQ0FBeUJ5SSxRQUF6QixNQUF1Q0gsU0FBU3RJLGNBQVQsQ0FBd0J5SSxRQUF4QixLQUFxQ0QsS0FBNUUsQ0FBSixFQUF3RjthQUMvRUMsUUFBUDs7O1NBR0csSUFBUDtDQVBGOztBQVVBLElBQU1FLFVBQVUsU0FBVkEsT0FBVSxDQUFDeE4sT0FBRCxFQUFVcU4sS0FBVixFQUFvQjtNQUM1QnhKLElBQUl1SixZQUFZcE4sT0FBWixFQUFxQnFOLEtBQXJCLENBQVY7T0FDS2hCLFVBQVV4SSxDQUFWLEVBQWE3RCxPQUFiLENBQUw7Q0FGRjs7QUFLQSxJQUFNeU4sY0FBYyxTQUFkQSxXQUFjLENBQUNDLFFBQUQsRUFBVzFOLE9BQVgsRUFBb0JxTixLQUFwQixFQUE4QjtNQUM1Q0QsWUFBWXBOLE9BQVosRUFBcUJxTixLQUFyQixDQUFKLEVBQWlDO1dBQ3hCSyxTQUFTbE4sS0FBVCxDQUFlLEtBQWYsRUFBc0JrRixHQUF0QixDQUEwQjthQUFLMEcsYUFBYXZILGNBQWIsQ0FBNEI4SSxDQUE1QixJQUFpQ3ZCLGFBQWF1QixDQUFiLENBQWpDLEdBQW1EQSxDQUF4RDtLQUExQixFQUFxRmxPLElBQXJGLENBQTBGLEdBQTFGLENBQVA7O1NBRUtpTyxRQUFQO0NBSkY7O0FBT0EsSUFBTUUsa0JBQWtCLFNBQWxCQSxlQUFrQixVQUFXO01BQzdCUixZQUFZcE4sT0FBWixNQUF5QixTQUE3QixFQUF3QztRQUNoQzBOLFdBQVcxTixRQUFRa0IsWUFBUixDQUFxQixVQUFyQixLQUFvQyxFQUFyRDtRQUNJeUwsY0FBY2MsWUFBWUMsUUFBWixFQUFzQjFOLE9BQXRCLENBQWxCOztRQUVJLENBQUMsMEJBQTBCbUMsSUFBMUIsQ0FBK0J1TCxRQUEvQixDQUFMLEVBQStDO29CQUMvQixjQUFjZixXQUE1Qjs7O1FBR0VBLGdCQUFnQmUsUUFBcEIsRUFBOEI7Y0FDcEJiLFlBQVIsQ0FBcUIsVUFBckIsRUFBaUNGLFlBQVlqTCxJQUFaLEVBQWpDO2FBQ08sSUFBUDs7O1NBR0csS0FBUDtDQWRGOztBQWlCQSxnQkFBZTthQUNGO1dBQU15SyxnQkFBTjtHQURFO1VBRUw7V0FBTUEsbUJBQW1CLElBQXpCO0dBRks7V0FHSjtXQUFNQSxtQkFBbUIsS0FBekI7R0FISTtrQkFBQTswQkFBQTswQkFBQTs7Q0FBZjs7QUNoSkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBR3FCMEI7Ozs7Ozs7Ozs7Ozt5QkFLUEMsTUFBTUMsU0FBUzthQUNsQkMsU0FBUyxDQUFDLEtBQUtGLElBQU4sRUFBWXBNLElBQVosRUFBVCxDQUFQO2dCQUNVc00sU0FBUyxDQUFDLEtBQUtELE9BQU4sRUFBZXJNLElBQWYsRUFBVCxDQUFWOztVQUVNdU0sVUFBVXRLLE9BQU96RCxJQUFQLENBQVk0TixJQUFaLEVBQWtCck4sTUFBbEIsQ0FBeUIsVUFBQ29CLE1BQUQsRUFBU3VELEtBQVQsRUFBbUI7WUFDdEQsQ0FBQzJJLFFBQVEzSSxLQUFSLENBQUwsRUFBcUI7aUJBQ1puRSxJQUFQLENBQVltRSxLQUFaOztlQUVLdkQsTUFBUDtPQUpjLEVBS2IsRUFMYSxDQUFoQjs7VUFPTXFNLFFBQVF2SyxPQUFPekQsSUFBUCxDQUFZNk4sT0FBWixFQUFxQnROLE1BQXJCLENBQTRCLFVBQUNvQixNQUFELEVBQVN1RCxLQUFULEVBQW1CO1lBQ3ZELENBQUMwSSxLQUFLMUksS0FBTCxDQUFMLEVBQWtCO2lCQUNUbkUsSUFBUCxDQUFZbUUsS0FBWjs7ZUFFS3ZELE1BQVA7T0FKWSxFQUtYLEVBTFcsQ0FBZDs7YUFPTyxFQUFDcU0sWUFBRCxFQUFRRCxnQkFBUixFQUFQOztlQUVTRCxRQUFULENBQWtCTixRQUFsQixFQUE0QjtZQUNwQlMsT0FBTyxFQUFiO3FCQUNhM04sS0FBYixDQUFtQmtOLFFBQW5CLEVBQTZCdk4sT0FBN0IsQ0FBcUM7aUJBQVNnTyxLQUFLL0ksS0FBTCxJQUFjQSxLQUF2QjtTQUFyQztlQUNPK0ksSUFBUDs7Ozs7Ozs7Ozs7Ozs7eUNBV3dCQyxNQUFNQyxXQUFXM0csVUFBVTtXQUNoRHdHLEtBQUwsQ0FDR3hJLEdBREgsQ0FDTztlQUFZZ0MsU0FBUzNFLE9BQVQsQ0FBaUIsS0FBakIsRUFBd0IySyxRQUF4QixDQUFaO09BRFAsRUFFR3ZOLE9BRkgsQ0FFVztlQUFTbU8sTUFBTTlOLEtBQU4sQ0FBWSxLQUFaLEVBQW1CTCxPQUFuQixDQUEyQjtpQkFBS2tPLFVBQVVFLEdBQVYsQ0FBY0MsQ0FBZCxDQUFMO1NBQTNCLENBQVQ7T0FGWDs7V0FJS1AsT0FBTCxDQUNHdkksR0FESCxDQUNPO2VBQVlnQyxTQUFTM0UsT0FBVCxDQUFpQixLQUFqQixFQUF3QjJLLFFBQXhCLENBQVo7T0FEUCxFQUVHdk4sT0FGSCxDQUVXO2VBQVNtTyxNQUFNOU4sS0FBTixDQUFZLEtBQVosRUFBbUJMLE9BQW5CLENBQTJCO2lCQUFLa08sVUFBVUksTUFBVixDQUFpQkQsQ0FBakIsQ0FBTDtTQUEzQixDQUFUO09BRlg7Ozs7Ozs7Ozs7Ozs7dUNBWXdCSixNQUFNcE8sU0FBUzBPLFFBQVE7YUFDeEN4TyxJQUFQLENBQVl3TyxNQUFaLEVBQW9Cdk8sT0FBcEIsQ0FBNEIsb0JBQVk7WUFDaEN3TyxpQkFBaUIsQ0FBQ0MsUUFBRCxJQUFhL08sT0FBS0gsS0FBTCxDQUFXTSxPQUFYLEVBQW9CNE8sUUFBcEIsQ0FBYixHQUNuQixDQUFDNU8sT0FBRCxDQURtQixHQUVuQlgsTUFBTUMsU0FBTixDQUFnQnVQLE1BQWhCLENBQXVCclAsSUFBdkIsQ0FDRVEsUUFBUW1JLGdCQUFSLENBQXlCeUcsUUFBekIsQ0FERixFQUVFO2lCQUFpQixDQUFDL08sT0FBS2lQLFVBQUwsQ0FBZ0JDLGFBQWhCLEVBQStCL08sUUFBUXdNLE9BQXZDLEVBQWdEO21CQUFVd0MsV0FBV2hQLE9BQXJCO1dBQWhELENBQWxCO1NBRkYsQ0FGSjs7YUFPSyxJQUFJYSxJQUFJLENBQWIsRUFBZ0JBLElBQUk4TixlQUFlN04sTUFBbkMsRUFBMkNELEdBQTNDLEVBQWdEO3VCQUNqQ29PLG9CQUFiLENBQWtDYixJQUFsQyxFQUF3Q08sZUFBZTlOLENBQWYsRUFBa0J3TixTQUExRCxFQUFxRUssT0FBT0UsUUFBUCxDQUFyRTs7T0FUSjs7Ozs7Ozs7Ozs7O3NDQW9CdUJkLE1BQU1DLFNBQVMvTixTQUFTME8sUUFBUTttQkFDMUNRLGtCQUFiLENBQWdDckIsYUFBYU8sSUFBYixDQUFrQk4sSUFBbEIsRUFBd0JDLE9BQXhCLENBQWhDLEVBQWtFL04sT0FBbEUsRUFBMkUwTyxNQUEzRTtnQkFDVWQsZUFBVixDQUEwQjVOLE9BQTFCOzs7OzRCQUdhQSxTQUFTME8sUUFBUTttQkFDakJRLGtCQUFiLENBQWdDckIsYUFBYU8sSUFBYixDQUFrQixFQUFsQixFQUFzQnBPLFFBQVFrQixZQUFSLENBQXFCLFVBQXJCLEtBQW9DLEVBQTFELENBQWhDLEVBQStGbEIsT0FBL0YsRUFBd0cwTyxNQUF4Rzs7Ozs7Ozs7OztpQ0FPa0IxTyxTQUFTME8sUUFBUTtVQUM3QmhCLFdBQVcxTixRQUFRa0IsWUFBUixDQUFxQixVQUFyQixDQUFqQjtVQUNJLE9BQU93TSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDOzs7O21CQUlyQndCLGtCQUFiLENBQWdDO2lCQUNyQixFQURxQjtlQUV2QnJCLGFBQWFyTixLQUFiLENBQW1Ca04sUUFBbkI7T0FGVCxFQUdHMU4sT0FISCxFQUdZME8sTUFIWjs7OzswQkFNV2hCLFVBQVU7VUFDakIsT0FBT0EsUUFBUCxLQUFvQixRQUF4QixFQUFrQztlQUN6QixFQUFQOzs7YUFHS0EsU0FBU2hNLElBQVQsR0FBZ0JsQixLQUFoQixDQUFzQixJQUF0QixFQUE0QnFPLE1BQTVCLENBQW1DO2VBQVN6SixVQUFVLEVBQW5CO09BQW5DLENBQVA7Ozs7Ozs7OztnQ0FNaUJwRixTQUFTbVAsZUFBZTtVQUNyQyxDQUFDblAsUUFBUStNLFlBQVIsQ0FBcUIsVUFBckIsQ0FBTCxFQUF1QztnQkFDN0JGLFlBQVIsQ0FBcUIsVUFBckIsRUFBaUNzQyxhQUFqQztPQURGLE1BRU87WUFDQ2pLLFNBQVMySSxhQUFhck4sS0FBYixDQUFtQlIsUUFBUWtCLFlBQVIsQ0FBcUIsVUFBckIsQ0FBbkIsQ0FBZjtZQUNJZ0UsT0FBT2xFLE9BQVAsQ0FBZW1PLGFBQWYsS0FBaUMsQ0FBQyxDQUF0QyxFQUF5QztpQkFDaENsTyxJQUFQLENBQVlrTyxhQUFaO2tCQUNRdEMsWUFBUixDQUFxQixVQUFyQixFQUFpQzNILE9BQU96RixJQUFQLENBQVksR0FBWixDQUFqQzs7Ozs7Ozs7Ozs7bUNBUWdCTyxTQUFTbVAsZUFBZTtVQUN4Q25QLFFBQVErTSxZQUFSLENBQXFCLFVBQXJCLENBQUosRUFBc0M7WUFDOUI3SCxTQUFTMkksYUFBYXJOLEtBQWIsQ0FBbUJSLFFBQVFrQixZQUFSLENBQXFCLFVBQXJCLENBQW5CLENBQWY7WUFDTWtPLFFBQVFsSyxPQUFPbEUsT0FBUCxDQUFlbU8sYUFBZixDQUFkO1lBQ0lDLFVBQVUsQ0FBQyxDQUFmLEVBQWtCO2lCQUNUQyxNQUFQLENBQWNELEtBQWQsRUFBcUIsQ0FBckI7a0JBQ1F2QyxZQUFSLENBQXFCLFVBQXJCLEVBQWlDM0gsT0FBT3pGLElBQVAsQ0FBWSxHQUFaLENBQWpDOzs7Ozs7OztBQzFKUjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFFQSxJQUFNSSxTQUFPO1VBQ0gsS0FERzs7cUJBR1EsS0FIUjs7dUJBS1UsK0JBQU07V0FDcEJ5UCxpQkFBTCxHQUF5QixJQUF6Qjs7UUFFSTdOLFNBQVMyRSxTQUFULEVBQUosRUFBMEI7YUFDakJqSCxRQUFQLENBQWdCNkgsZ0JBQWhCLENBQWlDLGFBQWpDLEVBQWdELFlBQU07ZUFDL0N1SSxNQUFMLEdBQWMsSUFBZDtPQURGLEVBRUcsS0FGSDtLQURGLE1BSU87YUFDQUEsTUFBTCxHQUFjLElBQWQ7O0dBYk87O3lCQWlCWSwrQkFBUzNOLEVBQVQsRUFBYTtRQUM5QixDQUFDLEtBQUswTixpQkFBVixFQUE2QjtZQUNyQixJQUFJdk4sS0FBSixDQUFVLGlEQUFWLENBQU47OztRQUdFLEtBQUt3TixNQUFULEVBQWlCO2FBQ1JwUSxRQUFQLENBQWdCNkgsZ0JBQWhCLENBQWlDLFlBQWpDLEVBQStDcEYsRUFBL0MsRUFBbUQsS0FBbkQ7S0FERixNQUVPO2FBQ0V6QyxRQUFQLENBQWdCNkgsZ0JBQWhCLENBQWlDLGFBQWpDLEVBQWdELFlBQVc7ZUFDbEQ3SCxRQUFQLENBQWdCNkgsZ0JBQWhCLENBQWlDLFlBQWpDLEVBQStDcEYsRUFBL0MsRUFBbUQsS0FBbkQ7T0FERjs7R0F6Qk87OzRCQStCZSxrQ0FBU0EsRUFBVCxFQUFhO1FBQ2pDLENBQUMsS0FBSzBOLGlCQUFWLEVBQTZCO1lBQ3JCLElBQUl2TixLQUFKLENBQVUsaURBQVYsQ0FBTjs7O1FBR0UsS0FBS3dOLE1BQVQsRUFBaUI7YUFDUnBRLFFBQVAsQ0FBZ0I0SCxtQkFBaEIsQ0FBb0MsWUFBcEMsRUFBa0RuRixFQUFsRCxFQUFzRCxLQUF0RDtLQURGLE1BRU87YUFDRXpDLFFBQVAsQ0FBZ0I2SCxnQkFBaEIsQ0FBaUMsYUFBakMsRUFBZ0QsWUFBVztlQUNsRDdILFFBQVAsQ0FBZ0I0SCxtQkFBaEIsQ0FBb0MsWUFBcEMsRUFBa0RuRixFQUFsRCxFQUFzRCxLQUF0RDtPQURGOzs7Q0F2Q047QUE2Q0EzQyxPQUFPK0gsZ0JBQVAsQ0FBd0Isa0JBQXhCLEVBQTRDO1NBQU1uSCxPQUFLMlAsbUJBQUwsRUFBTjtDQUE1QyxFQUE4RSxLQUE5RTs7QUFFQSxJQUFNQyxvQkFBb0I7VUFDaEIsRUFEZ0I7O1VBR2YsWUFBTTtRQUNUNU8sSUFBSSxDQUFSO1dBQ087YUFBTUEsR0FBTjtLQUFQO0dBRk0sRUFIZ0I7O09BUW5CLGdCQUFTYixPQUFULEVBQWtCMFAsT0FBbEIsRUFBMkI7UUFDMUIxUCxRQUFRMlAsT0FBUixDQUFnQkMseUJBQXBCLEVBQStDO1dBQ3hDbkIsTUFBTCxDQUFZek8sT0FBWjs7UUFFSTZQLEtBQUs3UCxRQUFRMlAsT0FBUixDQUFnQkMseUJBQWhCLEdBQTRDSCxrQkFBa0JLLE1BQWxCLEVBQXZEO1NBQ0tDLE1BQUwsQ0FBWUYsRUFBWixJQUFrQkgsT0FBbEI7R0Fic0I7O1VBZ0JoQixnQkFBUzFQLE9BQVQsRUFBa0I7UUFDcEJBLFFBQVEyUCxPQUFSLENBQWdCQyx5QkFBcEIsRUFBK0M7YUFDdEMsS0FBS0csTUFBTCxDQUFZL1AsUUFBUTJQLE9BQVIsQ0FBZ0JDLHlCQUE1QixDQUFQO2FBQ081UCxRQUFRMlAsT0FBUixDQUFnQkMseUJBQXZCOztHQW5Cb0I7O09BdUJuQixnQkFBUzVQLE9BQVQsRUFBa0I7UUFDakIsQ0FBQ0EsUUFBUTJQLE9BQVIsQ0FBZ0JDLHlCQUFyQixFQUFnRDthQUN2Q0ksU0FBUDs7O1FBR0lILEtBQUs3UCxRQUFRMlAsT0FBUixDQUFnQkMseUJBQTNCOztRQUVJLENBQUMsS0FBS0csTUFBTCxDQUFZRixFQUFaLENBQUwsRUFBc0I7WUFDZCxJQUFJOU4sS0FBSixFQUFOOzs7V0FHSyxLQUFLZ08sTUFBTCxDQUFZRixFQUFaLENBQVA7R0FsQ3NCOztPQXFDbkIsYUFBUzdQLE9BQVQsRUFBa0I7UUFDakIsQ0FBQ0EsUUFBUTJQLE9BQWIsRUFBc0I7YUFDYixLQUFQOzs7UUFHSUUsS0FBSzdQLFFBQVEyUCxPQUFSLENBQWdCQyx5QkFBM0I7O1dBRU8sQ0FBQyxDQUFDLEtBQUtHLE1BQUwsQ0FBWUYsRUFBWixDQUFUOztDQTVDSjs7SUFnRE1JO3dDQUNVOzs7U0FDUEMsVUFBTCxHQUFrQixLQUFsQjtTQUNLQyxjQUFMLEdBQXNCLEtBQUtDLFNBQUwsQ0FBZXhLLElBQWYsQ0FBb0IsSUFBcEIsQ0FBdEI7Ozs7Ozs7Ozs7NkJBT087VUFDSCxDQUFDLEtBQUtzSyxVQUFWLEVBQXNCO2VBQ2ZHLHFCQUFMLENBQTJCLEtBQUtGLGNBQWhDO2FBQ0tELFVBQUwsR0FBa0IsSUFBbEI7Ozs7Ozs7Ozs7OEJBT007VUFDSixLQUFLQSxVQUFULEVBQXFCO2VBQ2RJLHdCQUFMLENBQThCLEtBQUtILGNBQW5DO2FBQ0tELFVBQUwsR0FBa0IsS0FBbEI7Ozs7Ozs7Ozs7Z0RBT3dCO1VBQ3BCSyxRQUFRcFIsU0FBU3FSLFdBQVQsQ0FBcUIsT0FBckIsQ0FBZDtZQUNNQyxTQUFOLENBQWdCLFlBQWhCLEVBQThCLElBQTlCLEVBQW9DLElBQXBDO2VBQ1NDLGFBQVQsQ0FBdUJILEtBQXZCOzs7O2dDQUdVO1dBQ0xJLDhCQUFMOzs7Ozs7Ozs7O2tDQU9ZM1EsU0FBU2lILFVBQVU7VUFDM0IsRUFBRWpILG1CQUFtQnFCLFdBQXJCLENBQUosRUFBdUM7Y0FDL0IsSUFBSVUsS0FBSixDQUFVLDRDQUFWLENBQU47OztVQUdFLEVBQUVrRixvQkFBb0IySixRQUF0QixDQUFKLEVBQXFDO2NBQzdCLElBQUk3TyxLQUFKLENBQVUsMENBQVYsQ0FBTjs7O1VBR0kyTixVQUFVO21CQUNIekksUUFERztrQkFFSmpILE9BRkk7O2lCQUlMLG1CQUFXOzRCQUNBeU8sTUFBbEIsQ0FBeUJ6TyxPQUF6QjtTQUxZOztxQkFRRCxxQkFBU2lILFFBQVQsRUFBbUI7ZUFDekJtSixTQUFMLEdBQWlCbkosUUFBakI7U0FUWTs7Z0JBWU4sa0JBQVc7NEJBQ0NhLEdBQWxCLENBQXNCOUgsT0FBdEIsRUFBK0IsSUFBL0I7U0FiWTs7bUJBZ0JILHFCQUFXO2lCQUNieVAsa0JBQWtCN0csR0FBbEIsQ0FBc0I1SSxPQUF0QixNQUFtQyxJQUExQztTQWpCWTs7aUJBb0JMLG1CQUFXOzRCQUNBeU8sTUFBbEIsQ0FBeUJ6TyxPQUF6QjtlQUNLb1EsU0FBTCxHQUFpQixLQUFLUyxRQUFMLEdBQWdCLElBQWpDOztPQXRCSjs7Y0EwQlFDLE1BQVI7O2FBRU9wQixPQUFQOzs7O3FEQUcrQjtVQUN6QnFCLE9BQU8sS0FBS0MsWUFBTCxFQUFiOztVQUVNaFIsVUFBVSxLQUFLaVIsdUJBQUwsQ0FBNkJGLElBQTdCLENBQWhCOztVQUVJckIsVUFBVUQsa0JBQWtCN0csR0FBbEIsQ0FBc0I1SSxPQUF0QixDQUFkO2NBQ1FvUSxTQUFSLENBQWtCSSxZQUFZeFEsT0FBWixDQUFsQjs7ZUFFU3dRLFdBQVQsQ0FBcUJ4USxPQUFyQixFQUE4QjtlQUNyQjtvQkFDS0EsT0FETDs2QkFFYyw2QkFBVztnQkFDeEJnUCxTQUFTLEtBQUs2QixRQUFMLENBQWM3RyxVQUEzQjs7bUJBRU9nRixNQUFQLEVBQWU7d0JBQ0hTLGtCQUFrQjdHLEdBQWxCLENBQXNCb0csTUFBdEIsQ0FBVjtrQkFDSVUsT0FBSixFQUFhO3VCQUNKQSxRQUFRVSxTQUFSLENBQWtCSSxZQUFZeEIsTUFBWixDQUFsQixDQUFQOzt1QkFFT0EsT0FBT2hGLFVBQWhCOzs7U0FWTjs7Ozs7Ozs7OzttQ0FvQlc7YUFDTmtILFdBQVcvUixTQUFTbUksSUFBcEIsQ0FBUDs7ZUFFUzRKLFVBQVQsQ0FBb0JsUixPQUFwQixFQUE2QjtZQUNyQitRLE9BQU87bUJBQ0YvUSxPQURFO29CQUVEWCxNQUFNQyxTQUFOLENBQWdCc0IsTUFBaEIsQ0FBdUJ1USxLQUF2QixDQUE2QixFQUE3QixFQUFpQ0MsUUFBUXBSLFFBQVFxUixRQUFoQixFQUEwQjNMLEdBQTFCLENBQThCLFVBQVM0TCxZQUFULEVBQXVCOztnQkFFMUZBLGFBQWFyUixLQUFiLENBQW1Cc1IsT0FBbkIsS0FBK0IsTUFBL0IsSUFBeUNELGFBQWFFLFFBQWIsS0FBMEIsS0FBdkUsRUFBOEU7cUJBQ3JFLEVBQVA7OztnQkFHRUYsYUFBYUQsUUFBYixDQUFzQnZRLE1BQXRCLEtBQWlDLENBQWpDLElBQXNDLENBQUMyTyxrQkFBa0JnQyxHQUFsQixDQUFzQkgsWUFBdEIsQ0FBM0MsRUFBZ0Y7cUJBQ3ZFLEVBQVA7OztnQkFHSXpQLFNBQVNxUCxXQUFXSSxZQUFYLENBQWY7O2dCQUVJelAsT0FBT3dQLFFBQVAsQ0FBZ0J2USxNQUFoQixLQUEyQixDQUEzQixJQUFnQyxDQUFDMk8sa0JBQWtCZ0MsR0FBbEIsQ0FBc0I1UCxPQUFPN0IsT0FBN0IsQ0FBckMsRUFBNEU7cUJBQ25FLEVBQVA7OzttQkFHSyxDQUFDNkIsTUFBRCxDQUFQO1dBaEJ5QyxDQUFqQztTQUZaOztZQXNCSSxDQUFDNE4sa0JBQWtCZ0MsR0FBbEIsQ0FBc0JWLEtBQUsvUSxPQUEzQixDQUFMLEVBQTBDO2VBQ25DLElBQUlhLElBQUksQ0FBYixFQUFnQkEsSUFBSWtRLEtBQUtNLFFBQUwsQ0FBY3ZRLE1BQWxDLEVBQTBDRCxHQUExQyxFQUE4QztnQkFDdEM2USxVQUFVWCxLQUFLTSxRQUFMLENBQWN4USxDQUFkLENBQWhCO2dCQUNJNE8sa0JBQWtCZ0MsR0FBbEIsQ0FBc0JDLFFBQVExUixPQUE5QixDQUFKLEVBQTRDO3FCQUNuQzBSLE9BQVA7Ozs7O2VBS0NYLElBQVA7OztlQUdPSyxPQUFULENBQWlCeEosTUFBakIsRUFBeUI7WUFDakIvRixTQUFTLEVBQWY7YUFDSyxJQUFJaEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJK0csT0FBTzlHLE1BQTNCLEVBQW1DRCxHQUFuQyxFQUF3QztpQkFDL0JJLElBQVAsQ0FBWTJHLE9BQU8vRyxDQUFQLENBQVo7O2VBRUtnQixNQUFQOzs7Ozs7Ozs7Ozs0Q0FRb0JrUCxNQUFNO2FBQ3JCWSxLQUFLWixJQUFMLENBQVA7O2VBRVNZLElBQVQsQ0FBY0MsSUFBZCxFQUFvQjtZQUNkQSxLQUFLUCxRQUFMLENBQWN2USxNQUFkLEtBQXlCLENBQTdCLEVBQWdDO2lCQUN2QjhRLEtBQUs1UixPQUFaOzs7WUFHRTRSLEtBQUtQLFFBQUwsQ0FBY3ZRLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0M7aUJBQ3ZCNlEsS0FBS0MsS0FBS1AsUUFBTCxDQUFjLENBQWQsQ0FBTCxDQUFQOzs7ZUFHS08sS0FBS1AsUUFBTCxDQUFjM0wsR0FBZCxDQUFrQixVQUFTbU0sU0FBVCxFQUFvQjtpQkFDcENBLFVBQVU3UixPQUFqQjtTQURLLEVBRUpTLE1BRkksQ0FFRyxVQUFTcVIsSUFBVCxFQUFlQyxLQUFmLEVBQXNCO2NBQzFCLENBQUNELElBQUwsRUFBVzttQkFDRkMsS0FBUDs7O2NBR0lDLFFBQVFwUCxTQUFTM0QsT0FBT0MsZ0JBQVAsQ0FBd0I0UyxJQUF4QixFQUE4QixFQUE5QixFQUFrQ0csTUFBM0MsRUFBbUQsRUFBbkQsQ0FBZDtjQUNNQyxTQUFTdFAsU0FBUzNELE9BQU9DLGdCQUFQLENBQXdCNlMsS0FBeEIsRUFBK0IsRUFBL0IsRUFBbUNFLE1BQTVDLEVBQW9ELEVBQXBELENBQWY7O2NBRUksQ0FBQ0UsTUFBTUgsS0FBTixDQUFELElBQWlCLENBQUNHLE1BQU1ELE1BQU4sQ0FBdEIsRUFBcUM7bUJBQzVCRixRQUFRRSxNQUFSLEdBQWlCSixJQUFqQixHQUF3QkMsS0FBL0I7OztnQkFHSSxJQUFJaFEsS0FBSixDQUFVLDBDQUFWLENBQU47U0FkSyxFQWVKLElBZkksQ0FBUDs7Ozs7OztBQW9CTixpQ0FBZSxJQUFJa08sMEJBQUosRUFBZjs7QUN0VEE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsQUFLQTVKLFdBQVNxRSxlQUFULEdBQTJCQSxlQUEzQjtBQUNBckUsV0FBU3dILFlBQVQsR0FBd0JBLFlBQXhCO0FBQ0F4SCxXQUFTK0wsYUFBVCxHQUF5QkMsMEJBQXpCOztBQ3ZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFFQSxJQUFNQyxhQUFhLFNBQWJBLFVBQWEsQ0FBQzNSLENBQUQsRUFBSW9FLENBQUo7U0FBVXBFLEVBQUU0UixNQUFGLENBQVMsQ0FBVCxFQUFZeE4sRUFBRWpFLE1BQWQsTUFBMEJpRSxDQUFwQztDQUFuQjtBQUNBLElBQU15TixXQUFXLFNBQVhBLFFBQVcsQ0FBQzdSLENBQUQsRUFBSW9FLENBQUo7U0FBVXBFLEVBQUU0UixNQUFGLENBQVM1UixFQUFFRyxNQUFGLEdBQVdpRSxFQUFFakUsTUFBdEIsRUFBOEJpRSxFQUFFakUsTUFBaEMsTUFBNENpRSxDQUF0RDtDQUFqQjtBQUNBLElBQU0wTixTQUFTLFNBQVRBLE1BQVM7U0FBSzlSLEVBQUVwQixLQUFGLENBQVEsQ0FBUixFQUFXLENBQUMsQ0FBWixDQUFMO0NBQWY7QUFDQSxJQUFNbVQsaUJBQWlCLFNBQWpCQSxjQUFpQjtTQUFLSixXQUFXM1IsQ0FBWCxFQUFjLEdBQWQsS0FBc0I2UixTQUFTN1IsQ0FBVCxFQUFZLEdBQVosQ0FBM0I7Q0FBdkI7QUFDQSxJQUFNZ1MsZ0JBQWdCLFNBQWhCQSxhQUFnQjtTQUFLTCxXQUFXM1IsQ0FBWCxFQUFjLEdBQWQsS0FBc0I2UixTQUFTN1IsQ0FBVCxFQUFZLEdBQVosQ0FBM0I7Q0FBdEI7QUFDQSxJQUFNaVMsaUJBQWlCLFNBQWpCQSxjQUFpQjtTQUFNTixXQUFXM1IsQ0FBWCxFQUFjLElBQWQsS0FBdUI2UixTQUFTN1IsQ0FBVCxFQUFZLElBQVosQ0FBeEIsSUFBK0MyUixXQUFXM1IsQ0FBWCxFQUFjLEdBQWQsS0FBc0I2UixTQUFTN1IsQ0FBVCxFQUFZLEdBQVosQ0FBMUU7Q0FBdkI7O0FBRUEsSUFBTTJELFVBQVEsU0FBUkEsS0FBUSxDQUFDYyxLQUFELEVBQVF5TixNQUFSLEVBQWdCQyxjQUFoQixFQUFtQztRQUN6QyxJQUFJL1EsS0FBSixDQUFVLHdCQUF3QnFELEtBQXhCLEdBQWdDLGlCQUFoQyxJQUFxRDBOLGVBQWVoUyxNQUFmLEdBQXdCK1IsT0FBTy9SLE1BQS9CLEdBQXdDLENBQTdGLElBQWtHLGdCQUFsRyxHQUFxSGdTLGNBQXJILEdBQXNJLElBQWhKLENBQU47Q0FERjs7QUFJQSxJQUFNQyxlQUFlLFNBQWZBLFlBQWUsQ0FBQzNOLEtBQUQsRUFBUXlOLE1BQVIsRUFBZ0JDLGNBQWhCLEVBQW1DO01BQ2xEMU4sVUFBVSxNQUFWLElBQW9CQSxVQUFVLE9BQWxDLEVBQTJDO1dBQ2xDQSxVQUFVLE1BQWpCO0dBREYsTUFFTyxJQUFJd04sZUFBZXhOLEtBQWYsQ0FBSixFQUEyQjtXQUN6QnFOLE9BQU9yTixLQUFQLENBQVA7R0FESyxNQUVBLElBQUksQ0FBQytNLE1BQU0vTSxLQUFOLENBQUwsRUFBbUI7V0FDakIsQ0FBRUEsS0FBVDtHQURLLE1BRUEsSUFBSXNOLGVBQWV0TixLQUFmLENBQUosRUFBMkI7V0FDekI0TixZQUFZUCxPQUFPck4sS0FBUCxDQUFaLENBQVA7R0FESyxNQUVBLElBQUl1TixjQUFjdk4sS0FBZCxDQUFKLEVBQTBCO1dBQ3hCNk4sV0FBV1IsT0FBT3JOLEtBQVAsQ0FBWCxDQUFQO0dBREssTUFFQTtZQUNDQSxLQUFOLEVBQWF5TixNQUFiLEVBQXFCQyxjQUFyQjs7Q0FaSjs7QUFnQkEsSUFBTUksWUFBWSxTQUFaQSxTQUFZLENBQUNMLE1BQUQsRUFBWTtXQUNuQkEsT0FBT25SLElBQVAsRUFBVDtNQUNJeVIsUUFBUU4sT0FBTy9SLE1BQW5COztNQUVJK1IsT0FBTyxDQUFQLE1BQWMsR0FBZCxJQUFxQkEsT0FBTyxDQUFQLE1BQWMsR0FBdkMsRUFBNEM7O1lBRWxDLENBQVI7R0FGRixNQUlPLElBQUlBLE9BQU8sQ0FBUCxNQUFjLEdBQWQsSUFBcUJBLE9BQU8sQ0FBUCxNQUFjLEdBQXZDLEVBQTRDOztRQUUzQzlOLElBQUk4TixPQUFPTyxVQUFQLENBQWtCLENBQWxCLENBQVY7UUFDSUMsZUFBZSxDQUFuQjtTQUNLLElBQUl4UyxJQUFJLENBQWIsRUFBZ0JBLElBQUlnUyxPQUFPL1IsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDO1VBQ2xDZ1MsT0FBT08sVUFBUCxDQUFrQnZTLENBQWxCLE1BQXlCa0UsQ0FBN0IsRUFBZ0M7O09BQWhDLE1BRU8sSUFBSThOLE9BQU9PLFVBQVAsQ0FBa0J2UyxDQUFsQixNQUF5QmtFLElBQUksQ0FBakMsRUFBb0M7O1lBRXJDc08saUJBQWlCLENBQXJCLEVBQXdCO2tCQUNkeFMsSUFBSSxDQUFaOzs7OztHQVZELE1BZ0JBLElBQUlnUyxPQUFPLENBQVAsTUFBYyxJQUFkLElBQXNCQSxPQUFPLENBQVAsTUFBYyxHQUF4QyxFQUE2Qzs7U0FFN0MsSUFBSWhTLEtBQUksQ0FBYixFQUFnQkEsS0FBSWdTLE9BQU8vUixNQUEzQixFQUFtQ0QsSUFBbkMsRUFBd0M7VUFDbENnUyxPQUFPaFMsRUFBUCxNQUFjZ1MsT0FBTyxDQUFQLENBQWxCLEVBQTZCO2dCQUNuQmhTLEtBQUksQ0FBWjs7OztHQUpDLE1BU0E7O1NBRUEsSUFBSUEsTUFBSSxDQUFiLEVBQWdCQSxNQUFJZ1MsT0FBTy9SLE1BQTNCLEVBQW1DRCxLQUFuQyxFQUF3QztVQUNsQyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQkcsT0FBaEIsQ0FBd0I2UixPQUFPaFMsR0FBUCxDQUF4QixNQUF1QyxDQUFDLENBQTVDLEVBQStDO2dCQUNyQ0EsR0FBUjs7Ozs7O1NBT0NnUyxPQUFPdFQsS0FBUCxDQUFhLENBQWIsRUFBZ0I0VCxLQUFoQixDQUFQO0NBNUNGOztBQStDQSxJQUFNSCxjQUFjLFNBQWRBLFdBQWMsQ0FBQ0gsTUFBRCxFQUFZO01BQ3hCUyxhQUFhLFNBQWJBLFVBQWE7b0NBQStCblIsSUFBeEIsQ0FBNkIvQixHQUE3Qjs7R0FBMUI7O1dBRVN5UyxPQUFPblIsSUFBUCxFQUFUO01BQ01vUixpQkFBaUJELE1BQXZCO01BQ01VLFNBQVMsRUFBZjtNQUNJQyxhQUFhLElBQWpCO01BQXVCcFQsWUFBdkI7TUFBNEJxVCxzQkFBNUI7TUFBMkNyTyxjQUEzQzs7U0FFT3lOLE9BQU8vUixNQUFQLEdBQWdCLENBQXZCLEVBQTBCO29CQUNSc0UsS0FBaEI7WUFDUThOLFVBQVVMLE1BQVYsQ0FBUjthQUNTQSxPQUFPdFQsS0FBUCxDQUFhNkYsTUFBTXRFLE1BQW5CLEVBQTJCK1IsT0FBTy9SLE1BQWxDLEVBQTBDWSxJQUExQyxFQUFUOztRQUVLMEQsVUFBVSxHQUFWLEtBQWtCLENBQUNvTyxVQUFELElBQWUsQ0FBQ0MsYUFBaEIsSUFBaUNBLGtCQUFrQixHQUFyRSxDQUFELElBQ0dyTyxVQUFVLEdBQVYsSUFBaUJvTyxVQURwQixJQUVHcE8sVUFBVSxHQUFWLElBQWlCQSxVQUFVLEdBQTNCLElBQW1DcU8saUJBQWlCQSxrQkFBa0IsR0FBbkMsSUFBMENBLGtCQUFrQixHQUZ0RyxFQUU2RztjQUNyR3JPLEtBQU4sRUFBYXlOLE1BQWIsRUFBcUJDLGNBQXJCO0tBSEYsTUFJTyxJQUFJMU4sVUFBVSxHQUFWLElBQWlCb08sVUFBakIsSUFBK0JDLGFBQW5DLEVBQWtEO3NCQUN2Q2IsZUFBZWEsYUFBZixJQUFnQ2hCLE9BQU9nQixhQUFQLENBQWhDLEdBQXdEQSxhQUF4RTtVQUNJSCxXQUFXRyxhQUFYLENBQUosRUFBK0I7Y0FDdkJBLGFBQU47cUJBQ2EsS0FBYjtPQUZGLE1BR087Y0FDQyxJQUFJMVIsS0FBSixDQUFVLHlCQUF5QjBSLGFBQXpCLEdBQXlDLGdDQUF6QyxHQUE0RVgsY0FBNUUsR0FBNkYsSUFBdkcsQ0FBTjs7S0FORyxNQVFBLElBQUkxTixVQUFVLEdBQVYsSUFBaUIsQ0FBQ29PLFVBQWxCLElBQWdDQyxhQUFwQyxFQUFtRDthQUNqRHJULEdBQVAsSUFBYzJTLGFBQWFVLGFBQWIsRUFBNEJaLE1BQTVCLEVBQW9DQyxjQUFwQyxDQUFkO21CQUNhLElBQWI7Ozs7TUFJQTFOLEtBQUosRUFBVztXQUNGaEYsR0FBUCxJQUFjMlMsYUFBYTNOLEtBQWIsRUFBb0J5TixNQUFwQixFQUE0QkMsY0FBNUIsQ0FBZDs7O1NBR0tTLE1BQVA7Q0FuQ0Y7O0FBc0NBLElBQU1OLGFBQWEsU0FBYkEsVUFBYSxDQUFDSixNQUFELEVBQVk7V0FDcEJBLE9BQU9uUixJQUFQLEVBQVQ7TUFDTW9SLGlCQUFpQkQsTUFBdkI7TUFDTWEsUUFBUSxFQUFkO01BQ0lELHNCQUFKO01BQW1Cck8sY0FBbkI7O1NBRU95TixPQUFPL1IsTUFBUCxHQUFnQixDQUF2QixFQUEwQjtvQkFDUnNFLEtBQWhCO1lBQ1E4TixVQUFVTCxNQUFWLENBQVI7YUFDU0EsT0FBT3RULEtBQVAsQ0FBYTZGLE1BQU10RSxNQUFuQixFQUEyQitSLE9BQU8vUixNQUFsQyxFQUEwQ1ksSUFBMUMsRUFBVDs7UUFFSTBELFVBQVUsR0FBVixLQUFrQixDQUFDcU8sYUFBRCxJQUFrQkEsa0JBQWtCLEdBQXRELENBQUosRUFBZ0U7Y0FDeERyTyxLQUFOLEVBQWF5TixNQUFiLEVBQXFCQyxjQUFyQjtLQURGLE1BRU8sSUFBSTFOLFVBQVUsR0FBZCxFQUFtQjtZQUNsQm5FLElBQU4sQ0FBVzhSLGFBQWFVLGFBQWIsRUFBNEJaLE1BQTVCLEVBQW9DQyxjQUFwQyxDQUFYOzs7O01BSUExTixLQUFKLEVBQVc7UUFDTEEsVUFBVSxHQUFkLEVBQW1CO1lBQ1huRSxJQUFOLENBQVc4UixhQUFhM04sS0FBYixFQUFvQnlOLE1BQXBCLEVBQTRCQyxjQUE1QixDQUFYO0tBREYsTUFFTztjQUNDMU4sS0FBTixFQUFheU4sTUFBYixFQUFxQkMsY0FBckI7Ozs7U0FJR1ksS0FBUDtDQTFCRjs7QUE2QkEsSUFBTUMsUUFBUSxTQUFSQSxLQUFRLENBQUNkLE1BQUQsRUFBWTtXQUNmQSxPQUFPblIsSUFBUCxFQUFUOztNQUVJZ1IsZUFBZUcsTUFBZixDQUFKLEVBQTRCO1dBQ25CRyxZQUFZUCxPQUFPSSxNQUFQLENBQVosQ0FBUDtHQURGLE1BRU8sSUFBSUYsY0FBY0UsTUFBZCxDQUFKLEVBQTJCO1dBQ3pCSSxXQUFXUixPQUFPSSxNQUFQLENBQVgsQ0FBUDtHQURLLE1BRUE7VUFDQyxJQUFJOVEsS0FBSixDQUFVLG1EQUFtRDhRLE1BQTdELENBQU47O0NBUko7O0FDaEtBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQVFBLElBQU1oVCxTQUFPLEVBQWI7QUFDQSxJQUFNK1QsY0FBYyxZQUFwQjs7QUFFQS9ULE9BQUtnVSxPQUFMLEdBQWU7YUFDRixDQURFOzBCQUFBO21CQUdJO0NBSG5COztBQU1BcFMsU0FBU3FTLG9CQUFULENBQThCLFlBQU07U0FDN0JELE9BQUwsQ0FBYUUsY0FBYixHQUE4QnRTLFNBQVN5RSxXQUFULEVBQTlCO1NBQ0syTixPQUFMLENBQWFHLFdBQWIsR0FBMkJ2UyxTQUFTdVMsV0FBVCxFQUEzQjtTQUNLSCxPQUFMLENBQWFyUSxXQUFiLEdBQTJCL0IsU0FBUytCLFdBQVQsRUFBM0I7Q0FIRjs7QUFNQSxJQUFJO01BQ0ltSCxPQUFPaEgsT0FBT3NRLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsU0FBMUIsRUFBcUM7T0FBQSxvQkFDMUM7YUFBT0osT0FBTCxDQUFhSyxlQUFiLEdBQStCLElBQS9COztHQURHLENBQWI7U0FHT2xOLGdCQUFQLENBQXdCLGFBQXhCLEVBQXVDLElBQXZDLEVBQTZDMkQsSUFBN0M7U0FDTzVELG1CQUFQLENBQTJCLGFBQTNCLEVBQTBDLElBQTFDLEVBQWdENEQsSUFBaEQ7Q0FMRixDQU1FLE9BQU9oRCxDQUFQLEVBQVU7Ozs7Ozs7Ozs7O0FBU1o5SCxPQUFLbUgsZ0JBQUwsR0FBd0IsVUFBQzJDLEVBQUQsRUFBSy9KLElBQUwsRUFBVzhQLE9BQVgsRUFBb0J5RSxHQUFwQixFQUF5QkMsSUFBekIsRUFBa0M7S0FDckRwTixnQkFBSCxDQUFvQnBILElBQXBCLEVBQTBCOFAsT0FBMUIsRUFBbUM3UCxPQUFLZ1UsT0FBTCxDQUFhSyxlQUFiLEdBQStCQyxHQUEvQixHQUFxQyxDQUFDQSxPQUFPLEVBQVIsRUFBWUUsT0FBcEY7Q0FERjtBQUdBeFUsT0FBS2tILG1CQUFMLEdBQTJCLFVBQUM0QyxFQUFELEVBQUsvSixJQUFMLEVBQVc4UCxPQUFYLEVBQW9CeUUsR0FBcEIsRUFBeUJDLElBQXpCLEVBQWtDO0tBQ3hEck4sbUJBQUgsQ0FBdUJuSCxJQUF2QixFQUE2QjhQLE9BQTdCLEVBQXNDN1AsT0FBS2dVLE9BQUwsQ0FBYUssZUFBYixHQUErQkMsR0FBL0IsR0FBcUMsQ0FBQ0EsT0FBTyxFQUFSLEVBQVlFLE9BQXZGO0NBREY7Ozs7OztBQVFBeFUsT0FBS3lVLFlBQUwsR0FBb0IsVUFBQ3JNLEtBQUQsRUFBVztTQUN0QkEsaUJBQWlCMkksUUFBakIsR0FBNEIzSSxLQUE1QixHQUFvQyxVQUFDakksT0FBRDtXQUFhSCxPQUFLSCxLQUFMLENBQVdNLE9BQVgsRUFBb0JpSSxLQUFwQixDQUFiO0dBQTNDO0NBREY7Ozs7Ozs7QUFTQXBJLE9BQUtILEtBQUwsR0FBYSxVQUFDaUksQ0FBRCxFQUFJaEgsQ0FBSjtTQUFVLENBQUNnSCxFQUFFNE0sT0FBRixJQUFhNU0sRUFBRTZNLHFCQUFmLElBQXdDN00sRUFBRThNLGtCQUExQyxJQUFnRTlNLEVBQUUrTSxpQkFBbkUsRUFBc0ZsVixJQUF0RixDQUEyRm1JLENBQTNGLEVBQThGaEgsQ0FBOUYsQ0FBVjtDQUFiOzs7Ozs7O0FBT0FkLE9BQUs4VSxTQUFMLEdBQWlCLFVBQUMzVSxPQUFELEVBQVVpSSxLQUFWLEVBQW9CO01BQzdCdkksUUFBUUcsT0FBS3lVLFlBQUwsQ0FBa0JyTSxLQUFsQixDQUFkOzs7T0FHSyxJQUFJcEgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJYixRQUFRNFUsVUFBUixDQUFtQjlULE1BQXZDLEVBQStDRCxHQUEvQyxFQUFvRDtRQUM1QytRLE9BQU81UixRQUFRNFUsVUFBUixDQUFtQi9ULENBQW5CLENBQWI7UUFDSStRLEtBQUtpRCxRQUFMLEtBQWtCQyxLQUFLQyxZQUEzQixFQUF5Qzs7OztRQUdyQ3JWLE1BQU1rUyxJQUFOLENBQUosRUFBaUI7YUFDUkEsSUFBUDs7O1NBR0csSUFBUDtDQWJGOzs7Ozs7O0FBcUJBL1IsT0FBS2lQLFVBQUwsR0FBa0IsVUFBQzlPLE9BQUQsRUFBVWlJLEtBQVYsRUFBaUIrTSxLQUFqQixFQUEyQjtNQUNyQ3RWLFFBQVFHLE9BQUt5VSxZQUFMLENBQWtCck0sS0FBbEIsQ0FBZDs7TUFFSStHLFNBQVNoUCxRQUFRZ0ssVUFBckI7V0FDUztRQUNILENBQUNnRixNQUFELElBQVdBLFdBQVc3UCxRQUF0QixJQUFrQzZQLGtCQUFrQm5HLGdCQUFwRCxJQUF5RW1NLFNBQVNBLE1BQU1oRyxNQUFOLENBQXRGLEVBQXNHO2FBQzdGLElBQVA7S0FERixNQUVPLElBQUl0UCxNQUFNc1AsTUFBTixDQUFKLEVBQW1CO2FBQ2pCQSxNQUFQOzthQUVPQSxPQUFPaEYsVUFBaEI7O0NBVko7Ozs7OztBQWtCQW5LLE9BQUtvVixVQUFMLEdBQWtCO1NBQVc5VixTQUFTbUksSUFBVCxDQUFjNE4sUUFBZCxDQUF1QmxWLE9BQXZCLENBQVg7Q0FBbEI7Ozs7OztBQU1BSCxPQUFLc1YsdUJBQUwsR0FBK0IsVUFBQ25WLE9BQUQsRUFBYTtTQUNuQ0EsV0FBV2IsU0FBU0MsZUFBVCxLQUE2QlksT0FBL0MsRUFBd0Q7Y0FDNUNBLFFBQVFnSyxVQUFsQjtRQUNJaEssV0FBV0EsUUFBUTZILFFBQVIsQ0FBaUJsRyxXQUFqQixHQUErQmpDLEtBQS9CLENBQXFDLHNDQUFyQyxDQUFmLEVBQTZGO2FBQ3BGLElBQVA7OztTQUdHLEtBQVA7Q0FQRjs7Ozs7O0FBY0FHLE9BQUt1VixnQkFBTCxHQUF3QixVQUFDcFYsT0FBRCxFQUFhOzs7U0FDNUIsU0FBQ0EsT0FBRCxHQUFVWSxNQUFWLCtCQUNGdkIsTUFBTWdXLElBQU4sQ0FBV3JWLFFBQVFxUixRQUFuQixFQUE2QjNMLEdBQTdCLENBQWlDLG1CQUFXO1dBQ3RDN0YsT0FBS3VWLGdCQUFMLENBQXNCRSxPQUF0QixDQUFQO0dBREMsQ0FERSxFQUFQO0NBREY7Ozs7OztBQVlBelYsT0FBSzBWLGFBQUwsR0FBcUI7U0FBV3ZWLFFBQVE2SCxRQUFSLENBQWlCbkksS0FBakIsQ0FBdUIseUNBQXZCLENBQVg7Q0FBckI7Ozs7OztBQU1BRyxPQUFLMlYsZUFBTCxHQUF1QixVQUFDeFYsT0FBRCxFQUFVeVYsTUFBVixFQUFxQjtPQUNyQyxJQUFJNVUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJYixRQUFRNFUsVUFBUixDQUFtQjlULE1BQXZDLEVBQStDRCxHQUEvQyxFQUFvRDtRQUM1QzZVLFFBQVExVixRQUFRNFUsVUFBUixDQUFtQi9ULENBQW5CLENBQWQ7UUFDSTZVLE1BQU1ELE1BQU4sYUFBeUI3RSxRQUE3QixFQUF1QztZQUMvQjZFLE1BQU47S0FERixNQUVPO2FBQ0FELGVBQUwsQ0FBcUJFLEtBQXJCLEVBQTRCRCxNQUE1Qjs7O0NBTk47Ozs7OztBQWVBNVYsT0FBSzhWLFFBQUwsR0FBZ0I7U0FBVTlDLE9BQU9sUixXQUFQLEdBQXFCb0IsT0FBckIsQ0FBNkIsV0FBN0IsRUFBMEMsVUFBQzRLLENBQUQsRUFBSWlJLENBQUo7V0FBVUEsRUFBRUMsV0FBRixFQUFWO0dBQTFDLENBQVY7Q0FBaEI7Ozs7OztBQU1BaFcsT0FBS0MsU0FBTCxHQUFpQjtTQUFVK1MsT0FBTzlQLE9BQVAsQ0FBZSxvQkFBZixFQUFxQyxPQUFyQyxFQUE4Q3BCLFdBQTlDLEVBQVY7Q0FBakI7Ozs7Ozs7QUFPQTlCLE9BQUtpVyxNQUFMLEdBQWMsWUFBK0I7TUFBOUJsSCxRQUE4Qix1RUFBbkIsRUFBbUI7TUFBZjNPLEtBQWUsdUVBQVAsRUFBTzs7TUFDckNvTyxZQUFZTyxTQUFTcE8sS0FBVCxDQUFlLEdBQWYsQ0FBbEI7TUFDTVIsVUFBVWIsU0FBU3FILGFBQVQsQ0FBdUI2SCxVQUFVNUQsS0FBVixNQUFxQixLQUE1QyxDQUFoQjs7TUFFSTRELFVBQVV2TixNQUFkLEVBQXNCO1lBQ1ppVixTQUFSLEdBQW9CMUgsVUFBVTVPLElBQVYsQ0FBZSxHQUFmLENBQXBCOzs7U0FHS08sT0FBUCxFQUFnQkMsS0FBaEI7O1NBRU9ELE9BQVA7Q0FWRjs7Ozs7O0FBaUJBSCxPQUFLMkcsYUFBTCxHQUFxQixVQUFDSSxJQUFELEVBQVU7TUFDdkJvUCxVQUFVN1csU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7O01BRUlJLGdCQUFnQmlDLGdCQUFwQixFQUFzQztZQUM1QmUsV0FBUixDQUFvQnpLLFNBQVM4VyxVQUFULENBQW9CclAsSUFBcEIsRUFBMEIsSUFBMUIsQ0FBcEI7R0FERixNQUVPO1lBQ0dtRCxTQUFSLEdBQW9CbkQsS0FBS2xGLElBQUwsRUFBcEI7OztNQUdFc1UsUUFBUTNFLFFBQVIsQ0FBaUJ2USxNQUFqQixHQUEwQixDQUE5QixFQUFpQztXQUMxQnlELEtBQUwsQ0FBVyxrREFBWDs7O01BR0l2RSxVQUFVZ1csUUFBUTNFLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBaEI7VUFDUUEsUUFBUixDQUFpQixDQUFqQixFQUFvQjVDLE1BQXBCO1NBQ096TyxPQUFQO0NBZkY7Ozs7OztBQXNCQUgsT0FBSzBKLGNBQUwsR0FBc0IsVUFBQzNDLElBQUQsRUFBVTtNQUN4QmMsV0FBV3ZJLFNBQVNxSCxhQUFULENBQXVCLFVBQXZCLENBQWpCO1dBQ1N1RCxTQUFULEdBQXFCbkQsSUFBckI7U0FDT3pILFNBQVM4VyxVQUFULENBQW9Cdk8sU0FBU1csT0FBN0IsRUFBc0MsSUFBdEMsQ0FBUDtDQUhGOzs7Ozs7O0FBV0F4SSxPQUFLK0wsTUFBTCxHQUFjLFVBQUNzSyxHQUFELEVBQWtCO29DQUFUQyxJQUFTO1FBQUE7OztPQUN6QixJQUFJdFYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc1YsS0FBS3JWLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztRQUNoQ3NWLEtBQUt0VixDQUFMLENBQUosRUFBYTtVQUNMWCxPQUFPeUQsT0FBT3pELElBQVAsQ0FBWWlXLEtBQUt0VixDQUFMLENBQVosQ0FBYjtXQUNLLElBQUl1VixJQUFJLENBQWIsRUFBZ0JBLElBQUlsVyxLQUFLWSxNQUF6QixFQUFpQ3NWLEdBQWpDLEVBQXNDO1lBQzlCaFcsTUFBTUYsS0FBS2tXLENBQUwsQ0FBWjtZQUNJaFcsR0FBSixJQUFXK1YsS0FBS3RWLENBQUwsRUFBUVQsR0FBUixDQUFYOzs7OztTQUtDOFYsR0FBUDtDQVhGOzs7Ozs7QUFrQkFyVyxPQUFLMkosU0FBTCxHQUFpQixVQUFDNk0sU0FBRCxFQUFlO1NBQ3ZCaFgsTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0I0UixLQUF0QixDQUE0QmtGLFNBQTVCLENBQVA7Q0FERjs7Ozs7OztBQVNBeFcsT0FBS3lXLHFCQUFMLEdBQTZCLFVBQUNySyxVQUFELEVBQStCO01BQWxCc0ssUUFBa0IsdUVBQVAsRUFBTzs7TUFDdEQ7UUFDSTFVLFNBQVMyVSxLQUFLN0MsS0FBTCxDQUFXLEtBQUsxSCxVQUFoQixDQUFmO1FBQ0ksUUFBT3BLLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEJBLFdBQVcsSUFBN0MsRUFBbUQ7YUFDMUNBLE1BQVA7O0dBSEosQ0FLRSxPQUFPOEYsQ0FBUCxFQUFVO1dBQ0g0TyxRQUFQOztTQUVLQSxRQUFQO0NBVEY7Ozs7OztBQWdCQTFXLE9BQUs0VyxZQUFMLEdBQW9CLFVBQUNDLElBQUQsRUFBVTtTQUNyQkEsS0FBS2xXLEtBQUwsQ0FBVyxHQUFYLENBQVA7TUFDSW1KLEtBQUsxSyxNQUFUO01BQWlCbUIsR0FBakI7U0FDT0EsTUFBTXNXLEtBQUtqTSxLQUFMLEVBQWIsRUFBMkI7O1NBQ3BCZCxHQUFHdkosR0FBSCxDQUFMOztTQUVLdUosRUFBUDtDQU5GOzs7Ozs7QUFhQTlKLE9BQUs4VyxVQUFMLEdBQWtCO1NBQWFDLGNBQWNBLFVBQVVwSyxPQUFWLENBQWtCN0ssV0FBbEIsT0FBb0MsVUFBcEMsR0FBaURpVixTQUFqRCxHQUE2REEsVUFBVUMsT0FBckYsS0FBaUcsSUFBOUc7Q0FBbEI7Ozs7OztBQU1BaFgsT0FBS2lYLGVBQUwsR0FBdUIscUJBQWE7TUFDNUJ2TyxPQUFPMUksT0FBSzhXLFVBQUwsQ0FBZ0JDLFNBQWhCLENBQWI7O01BRUlyTyxJQUFKLEVBQVU7UUFDSkEsS0FBS3dPLGtCQUFMLEVBQUosRUFBK0I7YUFDdEJ4TyxJQUFQOzs7U0FHRyxJQUFJMUgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMEgsS0FBS3lPLGVBQUwsQ0FBcUIzRixRQUFyQixDQUE4QnZRLE1BQWxELEVBQTBERCxHQUExRCxFQUErRDtVQUN2RG9XLFdBQVdwWCxPQUFLOFcsVUFBTCxDQUFnQnBPLEtBQUt5TyxlQUFMLENBQXFCM0YsUUFBckIsQ0FBOEJ4USxDQUE5QixDQUFoQixDQUFqQjtVQUNJb1csWUFBWSxDQUFDLGNBQWM5VSxJQUFkLENBQW1Cb0csS0FBS3lPLGVBQUwsQ0FBcUIzRixRQUFyQixDQUE4QnhRLENBQTlCLEVBQWlDMkwsT0FBcEQsQ0FBakIsRUFBK0U7ZUFDdEUzTSxPQUFLaVgsZUFBTCxDQUFxQkcsUUFBckIsQ0FBUDs7Ozs7U0FLQyxJQUFQO0NBaEJGOzs7Ozs7OztBQXlCQXBYLE9BQUtxWCxtQkFBTCxHQUEyQixVQUFDdFAsTUFBRCxFQUFTdVAsU0FBVCxFQUFvQztNQUFoQkMsTUFBZ0IsdUVBQVAsRUFBTzs7O01BRXZEN0csUUFBUSxJQUFJOEcsV0FBSixDQUFnQkYsU0FBaEIsRUFBMkI7YUFDOUIsSUFEOEI7Z0JBRTNCLElBRjJCO1lBRy9CQztHQUhJLENBQWQ7O1NBTU9sWCxJQUFQLENBQVlrWCxNQUFaLEVBQW9CalgsT0FBcEIsQ0FBNEIsZUFBTztVQUMzQkMsR0FBTixJQUFhZ1gsT0FBT2hYLEdBQVAsQ0FBYjtHQURGOztTQUlPc1EsYUFBUCxDQUFxQkgsS0FBckI7O1NBRU9BLEtBQVA7Q0FkRjs7Ozs7OztBQXNCQTFRLE9BQUs0TSxXQUFMLEdBQW1CLFVBQUM3RSxNQUFELEVBQVMwUCxZQUFULEVBQTBCO01BQ3ZDLENBQUMxUCxPQUFPbUYsWUFBUCxDQUFvQixVQUFwQixDQUFMLEVBQXNDO1dBQzdCLEtBQVA7OztTQUdLd0ssb0JBQWtCRCxZQUFsQixlQUEwQyxHQUExQyxFQUErQ25WLElBQS9DLENBQW9EeUYsT0FBTzFHLFlBQVAsQ0FBb0IsVUFBcEIsQ0FBcEQsQ0FBUDtDQUxGOzs7Ozs7Ozs7QUFlQXJCLE9BQUtxTixXQUFMLEdBQW1CLFVBQUN0RixNQUFELEVBQVMwUCxZQUFULEVBQXdDO01BQWpCaE0sT0FBaUIsdUVBQVAsRUFBTzs7TUFDckRBLFFBQVFrTSxTQUFaLEVBQXVCO21CQUNOQSxVQUFVL0osV0FBVixDQUFzQjZKLFlBQXRCLEVBQW9DMVAsTUFBcEMsRUFBNEMwRCxRQUFRbU0sY0FBcEQsQ0FBZjs7O01BR0U1WCxPQUFLNE0sV0FBTCxDQUFpQjdFLE1BQWpCLEVBQXlCMFAsWUFBekIsQ0FBSixFQUE0QztXQUNuQyxLQUFQOzs7U0FHS3pLLFlBQVAsQ0FBb0IsVUFBcEIsRUFBZ0MsQ0FBQyxDQUFDakYsT0FBTzFHLFlBQVAsQ0FBb0IsVUFBcEIsS0FBbUMsRUFBcEMsSUFBMEMsR0FBMUMsR0FBZ0RvVyxZQUFqRCxFQUErRDVWLElBQS9ELEVBQWhDO1NBQ08sSUFBUDtDQVZGOzs7Ozs7Ozs7QUFvQkE3QixPQUFLb04sY0FBTCxHQUFzQixVQUFDckYsTUFBRCxFQUFTMFAsWUFBVCxFQUF3QztNQUFqQmhNLE9BQWlCLHVFQUFQLEVBQU87O01BQ3hEQSxRQUFRa00sU0FBWixFQUF1QjttQkFDTkEsVUFBVS9KLFdBQVYsQ0FBc0I2SixZQUF0QixFQUFvQzFQLE1BQXBDLEVBQTRDMEQsUUFBUW1NLGNBQXBELENBQWY7OztNQUdFLENBQUM3UCxPQUFPMUcsWUFBUCxDQUFvQixVQUFwQixDQUFELElBQW9DLENBQUNyQixPQUFLNE0sV0FBTCxDQUFpQjdFLE1BQWpCLEVBQXlCMFAsWUFBekIsQ0FBekMsRUFBaUY7V0FDeEUsS0FBUDs7O01BR0lJLGVBQWU5UCxPQUFPMUcsWUFBUCxDQUFvQixVQUFwQixFQUFnQ1YsS0FBaEMsQ0FBc0MsS0FBdEMsRUFBNkNxTyxNQUE3QyxDQUFvRDtXQUFLbEIsS0FBS0EsTUFBTTJKLFlBQWhCO0dBQXBELENBQXJCO2VBQ2F4VyxNQUFiLEdBQXNCOEcsT0FBT2lGLFlBQVAsQ0FBb0IsVUFBcEIsRUFBZ0M2SyxhQUFhalksSUFBYixDQUFrQixHQUFsQixDQUFoQyxDQUF0QixHQUFnRm1JLE9BQU96RyxlQUFQLENBQXVCLFVBQXZCLENBQWhGO1NBQ08sSUFBUDtDQVhGOzs7Ozs7Ozs7O0FBc0JBdEIsT0FBSzhYLGNBQUwsR0FBc0IsWUFBYTtNQUMzQnJNLFVBQVUsVUFBS3hLLE1BQUwsR0FBYyxDQUFkLHNEQUE0QixFQUE1QztNQUNNdU0sUUFBUSxPQUFPL0IsT0FBUCxLQUFtQixTQUFuQixHQUErQkEsT0FBL0IsR0FBeUNBLFFBQVErQixLQUEvRDs7TUFFTXVLLFNBQVMsT0FBT3ZLLEtBQVAsS0FBaUIsU0FBakIsR0FBNkJBLEtBQTdCLEdBQXFDLENBQUN4TixPQUFLNE0sV0FBTCx5QkFBckQ7V0FDUzVNLE9BQUtxTixXQUFMLHlCQUFULEdBQXFDck4sT0FBS29OLGNBQUwseUJBQXJDO0NBTEY7Ozs7Ozs7QUFhQXBOLE9BQUtnWSxZQUFMLEdBQW9CLFVBQUNsTyxFQUFELEVBQUttTyxZQUFMLEVBQW1CcEosTUFBbkIsRUFBOEI7ZUFDbkNsTyxLQUFiLENBQW1CLEtBQW5CLEVBQTBCTCxPQUExQixDQUFrQztXQUFLNEUsTUFBTSxFQUFOLElBQVksQ0FBQzRFLEdBQUcwRSxTQUFILENBQWE2RyxRQUFiLENBQXNCblEsQ0FBdEIsQ0FBYixJQUF5QzRFLEdBQUcwRSxTQUFILENBQWFFLEdBQWIsQ0FBaUJ4SixDQUFqQixDQUE5QztHQUFsQztLQUNHZ0ksWUFBSCxDQUFnQixVQUFoQixLQUErQmMsYUFBYWtLLE9BQWIsQ0FBcUJwTyxFQUFyQixFQUF5QitFLE1BQXpCLENBQS9CO0NBRkY7OztBQU1BN08sT0FBS21ZLG9CQUFMLEdBQTRCLFVBQUNyTyxFQUFELEVBQVE7TUFDOUIsQ0FBQ0EsR0FBR3NPLGNBQUosSUFBc0J0TyxHQUFHdU8sYUFBN0IsRUFBNEM7UUFDdENqWixPQUFPQyxnQkFBUCxDQUF3QnlLLEdBQUd1TyxhQUEzQixFQUEwQ0MsZ0JBQTFDLENBQTJELFVBQTNELE1BQTJFLFFBQS9FLEVBQXlGO1NBQ3BGRCxhQUFILENBQWlCalksS0FBakIsQ0FBdUJtWSxRQUF2QixHQUFrQyxVQUFsQzs7T0FFQ0gsY0FBSCxHQUFvQixJQUFwQjs7Q0FMSjs7QUFTQXBZLE9BQUt3WSxlQUFMLEdBQXVCLFVBQUNyWSxPQUFELEVBQVVKLElBQVYsRUFBZ0I4RSxLQUFoQixFQUEwQjtNQUMzQ0EsS0FBSixFQUFXO1lBQ0RtSSxZQUFSLENBQXFCak4sSUFBckIsRUFBMkIsT0FBTzhFLEtBQVAsS0FBaUIsU0FBakIsR0FBNkIsRUFBN0IsR0FBa0NBLEtBQTdEO0dBREYsTUFFTztZQUNHdkQsZUFBUixDQUF3QnZCLElBQXhCOztDQUpKOztBQVFBQyxPQUFLeVksYUFBTCxHQUFxQixVQUFDdFksT0FBRCxFQUFVdVksYUFBVixFQUE0QjtnQkFDakNwWSxPQUFkLENBQXNCLGdCQUFRO1FBQ3RCcVksWUFBWTVZLEtBQUttRCxPQUFMLENBQWEsU0FBYixFQUF3QixXQUFXbkQsS0FBSyxDQUFMLEVBQVFpVyxXQUFSLEVBQW5DLENBQWxCO1lBQ1EyQyxTQUFSLElBQXFCeFksUUFBUXdZLFNBQVIsS0FBc0J4WSxRQUFRSixJQUFSLEVBQWNnRyxJQUFkLENBQW1CNUYsT0FBbkIsQ0FBM0M7R0FGRjtDQURGOztBQU9BSCxPQUFLNFksSUFBTCxHQUFZLFVBQUNDLEdBQUQsRUFBTUMsQ0FBTjtTQUFZaFYsT0FBT3pELElBQVAsQ0FBWXdZLEdBQVosRUFBaUJ2WSxPQUFqQixDQUF5QjtXQUFPd1ksRUFBRXZZLEdBQUYsRUFBT3NZLElBQUl0WSxHQUFKLENBQVAsQ0FBUDtHQUF6QixDQUFaO0NBQVo7Ozs7Ozs7QUFRQVAsT0FBSytZLFlBQUwsR0FBb0IsVUFBQ2hSLE1BQUQsRUFBU2lSLFNBQVQsRUFBbUM7TUFBZkMsS0FBZSx1RUFBUCxFQUFPOztNQUNqREQsY0FBYzdJLFNBQWxCLEVBQTZCO2dCQUNmcEksT0FBT21GLFlBQVAsQ0FBb0IsUUFBcEIsQ0FBWjs7O01BR0lnTSxnQkFBZ0JsWixPQUFLOFUsU0FBTCxDQUFlL00sTUFBZixFQUF1QixZQUF2QixDQUF0Qjs7TUFFSWlSLFNBQUosRUFBZTtRQUNULENBQUNFLGFBQUwsRUFBb0I7VUFDWi9ZLFVBQVViLFNBQVNxSCxhQUFULENBQXVCLFlBQXZCLENBQWhCO2FBQ090RyxJQUFQLENBQVk0WSxLQUFaLEVBQW1CM1ksT0FBbkIsQ0FBMkI7ZUFBT0gsUUFBUTZNLFlBQVIsQ0FBcUJ6TSxHQUFyQixFQUEwQjBZLE1BQU0xWSxHQUFOLENBQTFCLENBQVA7T0FBM0I7YUFDTzRZLFlBQVAsQ0FBb0JoWixPQUFwQixFQUE2QjRILE9BQU9xUixVQUFwQzs7R0FKSixNQU1PLElBQUlGLGFBQUosRUFBbUI7a0JBQ1Z0SyxNQUFkOztDQWRKOzs7Ozs7QUFzQkE1TyxPQUFLcU0scUJBQUwsR0FBNkJBLEtBQTdCOzs7OztBQUtBck0sT0FBS3FaLFNBQUwsR0FBaUIsVUFBQ3hVLEtBQUQsRUFBVztTQUNuQixPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQ0x5VSxTQUFTelUsS0FBVCxDQURLLElBRUwwVSxLQUFLQyxLQUFMLENBQVczVSxLQUFYLE1BQXNCQSxLQUZ4QjtDQURGOzs7OztBQVNBN0UsT0FBS3laLEtBQUwsR0FBYSxZQUFNO01BQ1hDLFdBQVcsRUFBakI7V0FDU0MsT0FBVCxHQUFtQixJQUFJaFIsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVUMsTUFBVixFQUFxQjthQUN6Q0QsT0FBVCxHQUFtQkEsT0FBbkI7YUFDU0MsTUFBVCxHQUFrQkEsTUFBbEI7R0FGaUIsQ0FBbkI7U0FJTzZRLFFBQVA7Q0FORjs7Ozs7OztBQWNBMVosT0FBS1EsSUFBTCxHQUFZLFlBQWE7cUNBQVQ4VixJQUFTO1FBQUE7OztNQUNuQixDQUFDOVAsV0FBU0MsTUFBVCxDQUFnQm1ULGdCQUFyQixFQUF1Qzs7O3lCQUM3QnBaLElBQVIsa0JBQWF1VCxXQUFiLFNBQTZCdUMsSUFBN0I7O0NBRko7O0FBTUF0VyxPQUFLMEUsS0FBTCxHQUFhLFVBQUNDLE9BQUQsRUFBYTtRQUNsQixJQUFJekMsS0FBSixDQUFhNlIsV0FBYixTQUE0QnBQLE9BQTVCLENBQU47Q0FERjs7QUFJQTNFLE9BQUs2WixhQUFMLEdBQXFCO1NBQU03WixPQUFLMEUsS0FBTCxDQUFXLG1DQUFYLENBQU47Q0FBckI7QUFDQTFFLE9BQUs4WixXQUFMLEdBQW1CO1NBQU05WixPQUFLMEUsS0FBTCxDQUFXLGtDQUFYLENBQU47Q0FBbkI7QUFDQTFFLE9BQUsrWixlQUFMLEdBQXVCO1NBQU0vWixPQUFLMEUsS0FBTCxDQUFXLHFEQUFYLENBQU47Q0FBdkI7QUFDQTFFLE9BQUtnYSxhQUFMLEdBQXFCLFVBQUNsUSxFQUFEO1NBQVE5SixPQUFLMEUsS0FBTCxvQ0FBNENvRixFQUE1QyxjQUFSO0NBQXJCOztBQUdBLElBQU1tUSxVQUFVLFNBQVZBLE9BQVU7U0FBS25TLEVBQUVvUyxVQUFGLElBQWdCcFMsRUFBRXFTLGNBQUYsRUFBckI7Q0FBaEI7Ozs7Ozs7QUFPQW5hLE9BQUtvYSxnQkFBTCxHQUF3QixjQUFNO01BQ3hCcGEsT0FBS2dVLE9BQUwsQ0FBYUUsY0FBYixLQUFnQyxLQUFwQyxFQUEyQztRQUNuQ21HLFFBQVEsU0FBUkEsS0FBUSxDQUFDdlMsQ0FBRCxFQUFPO1NBQ2hCd1MsR0FBSCxDQUFPLFdBQVAsRUFBb0JMLE9BQXBCO1NBQ0dLLEdBQUgsQ0FBTyxTQUFQLEVBQWtCRCxLQUFsQjtLQUZGOztPQUtHRSxFQUFILENBQU0sV0FBTixFQUFtQk4sT0FBbkI7T0FDR00sRUFBSCxDQUFNLFNBQU4sRUFBaUJGLEtBQWpCOztDQVJKOzs7Ozs7OztBQWtCQXJhLE9BQUt3YSxnQkFBTCxHQUF3QixVQUFDOUwsR0FBRCxFQUFTOztNQUMzQjFPLE9BQUtnVSxPQUFMLENBQWFFLGNBQWIsS0FBZ0MsS0FBcEMsRUFBMkM7YUFDaEN6TSxJQUFULENBQWMrRyxTQUFkLENBQXdCdUosTUFBeEIsQ0FBK0IsZ0JBQS9CLEVBQWlEckosR0FBakQsRUFEeUM7UUFFckMsQ0FBQzFPLE9BQUtnVSxPQUFMLENBQWFHLFdBQWQsSUFBNkIzTixXQUFTQyxNQUFULENBQWdCZ1UsdUJBQWpELEVBQTBFO2VBQy9EaFQsSUFBVCxDQUFjK0csU0FBZCxDQUF3QnVKLE1BQXhCLENBQStCLG9CQUEvQixFQUFxRHJKLEdBQXJEOzs7Q0FKTjtBQVFBMU8sT0FBSzBhLGdCQUFMLEdBQXdCLFVBQUM1USxFQUFELEVBQUs0RSxHQUFMLEVBQWE7O01BQy9CMU8sT0FBS2dVLE9BQUwsQ0FBYUcsV0FBakIsRUFBOEI7UUFDdEJ5QixTQUFTLENBQUNsSCxNQUFNLEtBQU4sR0FBYyxRQUFmLElBQTJCLGVBQTFDO09BQ0drSCxNQUFILEVBQVcsV0FBWCxFQUF3QnFFLE9BQXhCLEVBQWlDLEtBQWpDOztDQUhKOzs7Ozs7O0FBWUFqYSxPQUFLMmEsY0FBTCxHQUFzQjtTQUFTakssTUFBTWtLLE9BQU4sS0FBa0J6SyxTQUFsQixLQUFnQ08sTUFBTWtLLE9BQU4sQ0FBY0MsUUFBZCxJQUEwQixFQUExQixJQUFnQ25LLE1BQU1rSyxPQUFOLENBQWNFLFNBQWQsSUFBMkIsR0FBM0YsQ0FBVDtDQUF0Qjs7QUFFQTlhLE9BQUsrYSxrQkFBTCxHQUEwQixZQUFxQjtxQ0FBakJDLFlBQWlCO2dCQUFBOzs7ZUFDaEMxYSxPQUFiLENBQXFCLGdCQUFRO1FBQ3ZCLENBQUMyYSxZQUFZbGIsSUFBWixDQUFMLEVBQXdCO2FBQ2pCMkUsS0FBTCxTQUFpQjNFLElBQWpCOztHQUZKO0NBREY7O0FDdmpCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsQUFFQSxJQUFJbWIsZ0JBQWdCLEdBQXBCOztBQUVBLElBQUlsYixTQUFPLEVBQVg7OztBQUlBQSxPQUFLbWIsVUFBTCxHQUFrQixVQUFTQyxHQUFULEVBQWM7U0FDdkJBLElBQUk5VixNQUFKLENBQVcsQ0FBWCxFQUFjMFEsV0FBZCxLQUE4Qm9GLElBQUkxYixLQUFKLENBQVUsQ0FBVixDQUFyQztDQURGOzs7Ozs7OztBQVVBTSxPQUFLcWIsb0JBQUwsR0FBNEIsVUFBU0MsTUFBVCxFQUFpQjtTQUNwQ0MsUUFBUCxHQUFrQkQsT0FBT0MsUUFBUCxJQUFtQixLQUFyQztTQUNPclAsUUFBUCxHQUFrQm9QLE9BQU9wUCxRQUFQLElBQW1CLEdBQXJDO1NBQ09zUCxNQUFQLEdBQWdCRixPQUFPRSxNQUFQLElBQWlCLFFBQWpDOztNQUVJQyxRQUFRSCxPQUFPQyxRQUFQLENBQWdCNWEsS0FBaEIsQ0FBc0IsSUFBdEIsQ0FBWjs7U0FFTzhhLE1BQU01VixHQUFOLENBQVUsVUFBUzZWLElBQVQsRUFBZTtXQUN2QkEsT0FBTyxHQUFQLEdBQWFKLE9BQU9wUCxRQUFwQixHQUErQixJQUEvQixHQUFzQ29QLE9BQU9FLE1BQXBEO0dBREssRUFFSjViLElBRkksQ0FFQyxJQUZELENBQVA7Q0FQRjs7Ozs7QUFlQUksT0FBSzJiLG1CQUFMLEdBQTJCLFVBQVN4YixPQUFULEVBQWtCaUgsUUFBbEIsRUFBNEI7TUFDakQsQ0FBQ2pILE9BQUwsRUFBYztXQUNMLFlBQVcsRUFBbEI7OztNQUdFNEIsS0FBSyxTQUFMQSxFQUFLLENBQVMyTyxLQUFULEVBQWdCO1FBQ25CdlEsV0FBV3VRLE1BQU0zSSxNQUFyQixFQUE2QjtZQUNyQjZULGVBQU47Ozs7O0dBRko7O01BU0lDLGtCQUFrQixTQUFsQkEsZUFBa0IsR0FBVztXQUMxQkMsb0JBQUwsQ0FBMEJ4YixPQUExQixDQUFrQyxVQUFTZ1gsU0FBVCxFQUFvQjtjQUM1Q3BRLG1CQUFSLENBQTRCb1EsU0FBNUIsRUFBdUN2VixFQUF2QyxFQUEyQyxLQUEzQztLQURGO0dBREY7O1NBTUsrWixvQkFBTCxDQUEwQnhiLE9BQTFCLENBQWtDLFVBQVNnWCxTQUFULEVBQW9CO1lBQzVDblEsZ0JBQVIsQ0FBeUJtUSxTQUF6QixFQUFvQ3ZWLEVBQXBDLEVBQXdDLEtBQXhDO0dBREY7O1NBSU84WixlQUFQO0NBeEJGOztBQTJCQTdiLE9BQUs4YixvQkFBTCxHQUE2QixZQUFXOztNQUVsQyxxQkFBcUIxYyxNQUF6QixFQUFpQztXQUN4QixDQUFDLGVBQUQsQ0FBUDs7O01BR0UsMkJBQTJCQSxNQUEvQixFQUF1QztXQUM5QixDQUFDLHFCQUFELENBQVA7OztNQUdFWSxPQUFLK2IsWUFBTCxLQUFzQixRQUF0QixJQUFrQy9iLE9BQUsrYixZQUFMLEtBQXNCLEdBQXhELElBQStEL2IsT0FBSytiLFlBQUwsS0FBc0IsS0FBckYsSUFBOEYvYixPQUFLK2IsWUFBTCxLQUFzQixJQUF4SCxFQUE4SDtXQUNySCxDQUFDL2IsT0FBSytiLFlBQUwsR0FBb0IsZUFBckIsRUFBc0MsZUFBdEMsQ0FBUDs7O1NBR0ssRUFBUDtDQWQwQixFQUE1Qjs7QUFpQkEvYixPQUFLZ2MsZ0JBQUwsR0FBeUIsWUFBVztNQUM5QjdjLFNBQVNDLE9BQU9DLGdCQUFQLENBQXdCQyxTQUFTQyxlQUFqQyxFQUFrRCxFQUFsRCxDQUFiO01BQ0krTyxPQUFPLEVBQVg7TUFDSTJOLElBQUksSUFBSTFJLFVBQUosQ0FBZSxDQUFmLENBQVI7TUFDSTJJLElBQUksSUFBSTNJLFVBQUosQ0FBZSxDQUFmLENBQVI7O01BRUk0SSxRQUFRLFNBQVJBLEtBQVEsQ0FBU3JiLENBQVQsRUFBWTtXQUNmQSxFQUFFNFIsTUFBRixDQUFTLENBQVQsRUFBWXNELFdBQVosRUFBUDtHQURGOztPQUlLLElBQUloVixJQUFJLENBQWIsRUFBZ0JBLElBQUk3QixPQUFPOEIsTUFBM0IsRUFBbUNELEdBQW5DLEVBQXdDOztRQUVsQ1QsTUFBTXBCLE9BQU82QixDQUFQLEVBQ1RrQyxPQURTLENBQ0QsT0FEQyxFQUNRLEVBRFIsRUFFVEEsT0FGUyxDQUVELFdBRkMsRUFFWWlaLEtBRlosRUFHVGpaLE9BSFMsQ0FHRCxNQUhDLEVBR08sS0FIUCxDQUFWOztRQUtJK1ksS0FBSzFiLElBQUlnVCxVQUFKLENBQWUsQ0FBZixDQUFMLElBQTBCMkksS0FBSzNiLElBQUlnVCxVQUFKLENBQWUsQ0FBZixDQUFuQyxFQUFzRDtVQUNoRGhULFFBQVEsU0FBUixJQUFxQkEsUUFBUSxZQUFqQyxFQUErQzthQUN4Q0EsR0FBTCxJQUFZLElBQVo7Ozs7O1NBS0MrTixJQUFQO0NBeEJzQixFQUF4Qjs7QUEyQkF0TyxPQUFLb2MsY0FBTCxHQUFzQixVQUFTcmMsSUFBVCxFQUFlO1NBQzVCQSxRQUFRQyxPQUFLZ2MsZ0JBQXBCO0NBREY7Ozs7O0FBT0FoYyxPQUFLK2IsWUFBTCxHQUFxQixZQUFXO01BQzFCNWMsU0FBU0MsT0FBT0MsZ0JBQVAsQ0FBd0JDLFNBQVNDLGVBQWpDLEVBQWtELEVBQWxELENBQWI7TUFDRThjLE1BQU0sQ0FBQzdjLE1BQU1DLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQ0pDLElBREksQ0FDQ1IsTUFERCxFQUVKUyxJQUZJLENBRUMsRUFGRCxFQUdKQyxLQUhJLENBR0UsbUJBSEYsS0FHMkJWLE9BQU9XLEtBQVAsS0FBaUIsRUFBakIsSUFBdUIsQ0FBQyxFQUFELEVBQUssR0FBTCxDQUhuRCxFQUlKLENBSkksQ0FEUjtTQU1TdWMsR0FBUDtDQVBnQixFQUFwQjs7QUFVQXJjLE9BQUtzYyxpQkFBTCxHQUF5QixVQUFTclAsUUFBVCxFQUFtQjdGLFFBQW5CLEVBQTZCO09BQy9DbVYsY0FBTCxDQUFvQixZQUFXO2FBQ3BCamMsT0FBVCxDQUFpQixVQUFTSCxPQUFULEVBQWtCOztjQUV6QnFjLFlBQVI7S0FGRjs7R0FERjtDQURGOztBQVVBeGMsT0FBS3VjLGNBQUwsR0FBdUIsWUFBVztNQUM1QkUsWUFBWSxFQUFoQjs7U0FFTyxVQUFTclYsUUFBVCxFQUFtQjtRQUNwQnFWLFVBQVV4YixNQUFWLEtBQXFCLENBQXpCLEVBQTRCO21CQUNiLFlBQVc7WUFDbEJ5YixxQkFBcUJELFVBQVUvYyxLQUFWLENBQWdCLENBQWhCLENBQXpCO29CQUNZLEVBQVo7MkJBQ21CWSxPQUFuQixDQUEyQixVQUFTOEcsUUFBVCxFQUFtQjs7U0FBOUM7T0FIRjs7O2NBU1FoRyxJQUFWLENBQWVnRyxRQUFmO0dBWEY7Q0FIb0IsRUFBdEI7O0FBa0JBcEgsT0FBSzJjLG1CQUFMLEdBQTRCLFlBQVc7TUFDakNGLFlBQVksRUFBaEI7O01BRUlHLE1BQU14ZCxPQUFPeWQscUJBQVAsSUFDUnpkLE9BQU8wZCwyQkFEQyxJQUVSMWQsT0FBTzJkLHdCQUZDLElBR1IzZCxPQUFPNGQsc0JBSEMsSUFJUjVkLE9BQU82ZCx1QkFKQyxJQUtSLFVBQVM3VixRQUFULEVBQW1CO2VBQ1JBLFFBQVgsRUFBcUIsT0FBTyxFQUE1QjtHQU5GOztTQVNPLFVBQVNBLFFBQVQsRUFBbUI7UUFDcEJxVixVQUFVeGIsTUFBVixLQUFxQixDQUF6QixFQUE0QjtVQUN0QixZQUFXO1lBQ1R5YixxQkFBcUJELFVBQVUvYyxLQUFWLENBQWdCLENBQWhCLENBQXpCO29CQUNZLEVBQVo7MkJBQ21CWSxPQUFuQixDQUEyQixVQUFTOEcsUUFBVCxFQUFtQjs7U0FBOUM7T0FIRjs7O2NBU1FoRyxJQUFWLENBQWVnRyxRQUFmO0dBWEY7Q0FaeUIsRUFBM0I7O0FBMkJBcEgsT0FBS2tkLHNCQUFMLEdBQStCLFlBQVc7TUFDcENsZCxPQUFLb2MsY0FBTCxDQUFvQixvQkFBcEIsQ0FBSixFQUErQztXQUN0QyxZQUFQOzs7TUFHRXBjLE9BQUtvYyxjQUFMLENBQW9CcGMsT0FBSytiLFlBQUwsR0FBb0Isb0JBQXhDLENBQUosRUFBbUU7V0FDMUQvYixPQUFLK2IsWUFBTCxHQUFvQixZQUEzQjs7O1FBR0ksSUFBSTdaLEtBQUosQ0FBVSxlQUFWLENBQU47Q0FUNEIsRUFBOUI7Ozs7O0FBZ0JBLElBQUlpYixTQUFTLFNBQVRBLE1BQVMsQ0FBU2hkLE9BQVQsRUFBa0JpZCxRQUFsQixFQUE0QjtNQUNuQyxFQUFFLGdCQUFnQkQsTUFBbEIsQ0FBSixFQUErQjtXQUN0QixJQUFJQSxNQUFKLENBQVdoZCxPQUFYLEVBQW9CaWQsUUFBcEIsQ0FBUDs7O01BR0VqZCxtQkFBbUJxQixXQUF2QixFQUFvQztTQUM3QnlMLFFBQUwsR0FBZ0IsQ0FBQzlNLE9BQUQsQ0FBaEI7R0FERixNQUVPLElBQUkyRCxPQUFPckUsU0FBUCxDQUFpQnNFLFFBQWpCLENBQTBCcEUsSUFBMUIsQ0FBK0JRLE9BQS9CLE1BQTRDLGdCQUFoRCxFQUFrRTtTQUNsRThNLFFBQUwsR0FBZ0I5TSxPQUFoQjtHQURLLE1BR0E7VUFDQyxJQUFJK0IsS0FBSixDQUFVLGdFQUFWLENBQU47OztPQUdHa2IsUUFBTCxHQUFnQkEsUUFBaEI7T0FDS0MsZUFBTCxHQUF1QixFQUF2QjtPQUNLQyxzQkFBTCxHQUE4QixFQUE5QjtDQWhCRjs7QUFtQkFILE9BQU8xZCxTQUFQLEdBQW1COzs7OzttQkFLQTBRLFNBTEE7Ozs7O1lBVVBBLFNBVk87Ozs7O1lBZVBBLFNBZk87Ozs7Ozs7UUFzQlgsY0FBUy9JLFFBQVQsRUFBbUI7UUFDbkIsT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztXQUM3QmlXLGVBQUwsQ0FBcUJqYyxJQUFyQixDQUEwQixVQUFTbWMsSUFBVCxFQUFlOzs7T0FBekM7OztTQU1HQyxjQUFMOztXQUVPLElBQVA7R0FoQ2U7Ozs7Ozs7OztXQTBDUixrQkFBU2hJLElBQVQsRUFBZWlJLEVBQWYsRUFBbUJ0UixLQUFuQixFQUEwQjthQUN4QnVSLElBQVQsQ0FBY3BDLE1BQWQsRUFBc0JwUCxRQUF0QixFQUFnQ3NQLE1BQWhDLEVBQXdDO1VBQ2xDRixPQUFPcFAsUUFBUCxLQUFvQmlFLFNBQXhCLEVBQW1DO21CQUN0Qm1MLE9BQU9wUCxRQUFsQjs7VUFFRW9QLE9BQU9FLE1BQVAsS0FBa0JyTCxTQUF0QixFQUFpQztpQkFDdEJtTCxPQUFPRSxNQUFoQjs7O2FBR0s7YUFDQUYsT0FBT3FDLEdBQVAsSUFBY3JDLE1BRGQ7a0JBRUtwUCxRQUZMO2dCQUdHc1A7T0FIVjs7O1dBT0ssS0FBS29DLFNBQUwsR0FDSkMsS0FESSxDQUNFSCxLQUFLbEksSUFBTCxFQUFXLENBQVgsRUFBYyxLQUFLNEgsUUFBTCxDQUFjNUIsTUFBNUIsQ0FERixFQUVKc0MsSUFGSSxDQUVDM1IsVUFBVWdFLFNBQVYsR0FBc0IsS0FBS2lOLFFBQUwsQ0FBY2pSLEtBQXBDLEdBQTRDQSxLQUY3QyxFQUdKMFIsS0FISSxDQUdFSCxLQUFLRCxFQUFMLEVBQVMsS0FBS0wsUUFBTCxDQUFjbFIsUUFBdkIsRUFBaUMsS0FBS2tSLFFBQUwsQ0FBYzVCLE1BQS9DLENBSEYsRUFJSnVDLFlBSkksRUFBUDtHQTFEZTs7Ozs7Ozs7Ozs7O1NBMkVWLGVBQVNDLFVBQVQsRUFBcUJ2UyxPQUFyQixFQUE4QjtRQUMvQm9TLFFBQVEsS0FBS1IsZUFBakI7O1FBRUlXLGNBQWN2UyxPQUFsQixFQUEyQjtjQUNqQmtTLEdBQVIsR0FBY0ssVUFBZDttQkFDYSxJQUFJYixPQUFPYyxVQUFYLENBQXNCeFMsT0FBdEIsQ0FBYjs7O1FBR0UsRUFBRXVTLHNCQUFzQmpOLFFBQXRCLElBQWtDaU4sc0JBQXNCYixPQUFPYyxVQUFqRSxDQUFKLEVBQWtGO1VBQzVFRCxXQUFXTCxHQUFmLEVBQW9CO3FCQUNMLElBQUlSLE9BQU9jLFVBQVgsQ0FBc0JELFVBQXRCLENBQWI7T0FERixNQUVPO3FCQUNRLElBQUliLE9BQU9jLFVBQVgsQ0FBc0I7ZUFDNUJEO1NBRE0sQ0FBYjs7OztRQU1BQSxzQkFBc0JqTixRQUExQixFQUFvQztZQUM1QjNQLElBQU4sQ0FBVzRjLFVBQVg7S0FERixNQUVPLElBQUlBLHNCQUFzQmIsT0FBT2MsVUFBakMsRUFBNkM7WUFDNUM3YyxJQUFOLENBQVc0YyxXQUFXRSxLQUFYLEVBQVg7S0FESyxNQUVBO1lBQ0MsSUFBSWhjLEtBQUosQ0FBVSxtQkFBVixDQUFOOzs7V0FHSyxJQUFQO0dBckdlOzs7Ozs7O1FBNkdYLGNBQVNpYyxPQUFULEVBQWtCO1FBQ2xCQSxVQUFVLENBQWQsRUFBaUI7V0FDVmQsZUFBTCxDQUFxQmpjLElBQXJCLENBQTBCLFVBQVNtYyxJQUFULEVBQWU7bUJBQzVCQSxJQUFYLEVBQWlCLE9BQU9ZLE9BQXhCO09BREY7OztXQUtLLElBQVA7R0FwSGU7O2FBdUhOLHFCQUFXOztTQUVmZCxlQUFMLENBQXFCamMsSUFBckIsQ0FBMEIsVUFBU21jLElBQVQsRUFBZTtXQUNsQ3RRLFFBQUwsQ0FBYzNNLE9BQWQsQ0FBc0IsVUFBU0gsT0FBVCxFQUFrQm9QLEtBQWxCLEVBQXlCO1lBQ3pDb08sTUFBTSxLQUFLTCxzQkFBTCxDQUE0Qi9OLEtBQTVCLElBQXFDLEVBQS9DOzthQUVLLElBQUl2TyxJQUFJLENBQWIsRUFBZ0JBLElBQUliLFFBQVFDLEtBQVIsQ0FBY2EsTUFBbEMsRUFBMENELEdBQTFDLEVBQStDO2NBQ3pDYixRQUFRQyxLQUFSLENBQWNZLENBQWQsQ0FBSixJQUF3QmIsUUFBUUMsS0FBUixDQUFjRCxRQUFRQyxLQUFSLENBQWNZLENBQWQsQ0FBZCxDQUF4Qjs7T0FKa0IsQ0FNcEIrRSxJQU5vQixDQU1mLElBTmUsQ0FBdEI7O0tBRHdCLENBU3hCQSxJQVR3QixDQVNuQixJQVRtQixDQUExQjs7V0FXTyxJQUFQO0dBcEllOzs7Ozs7Ozs7O2dCQStJSCxzQkFBUzBGLE9BQVQsRUFBa0I7Y0FDcEJBLFdBQVcsRUFBckI7UUFDSTJTLE9BQU8sSUFBWDs7UUFFSTNTLFFBQVF1UyxVQUFSLElBQXNCLENBQUN2UyxRQUFRUyxRQUFuQyxFQUE2QztZQUNyQyxJQUFJaEssS0FBSixDQUFVLHNFQUFWLENBQU47OztRQUdFbWMsaUJBQWlCcmUsT0FBS2tkLHNCQUExQjs7UUFFSXpSLFFBQVF1UyxVQUFSLElBQXVCdlMsUUFBUVMsUUFBUixJQUFvQlQsUUFBUVMsUUFBUixHQUFtQixDQUFsRSxFQUFzRTtVQUNoRW9TLGtCQUFrQjdTLFFBQVF1UyxVQUFSLElBQXVCLFNBQVN2UyxRQUFRUyxRQUFqQixHQUE0QixJQUE1QixJQUFvQ1QsUUFBUStQLE1BQVIsSUFBa0IsUUFBdEQsQ0FBN0M7O1dBRUs2QixlQUFMLENBQXFCamMsSUFBckIsQ0FBMEIsVUFBU21jLElBQVQsRUFBZTtZQUNuQ3RRLFdBQVcsS0FBS0EsUUFBcEI7WUFDSXNSLFNBQUo7O1lBRUlDLGtCQUFrQixTQUFsQkEsZUFBa0IsR0FBVzttQkFDdEJsZSxPQUFULENBQWlCLFVBQVNILE9BQVQsRUFBa0I7b0JBQ3pCQyxLQUFSLENBQWNpZSxjQUFkLElBQWdDLEVBQWhDO1dBREY7U0FERjs7O1lBT0l4QyxrQkFBa0I3YixPQUFLMmIsbUJBQUwsQ0FBeUIxTyxTQUFTLENBQVQsQ0FBekIsRUFBc0MsWUFBVzt1QkFDeERzUixTQUFiOzs7U0FEb0IsQ0FBdEI7OztvQkFPWUUsV0FBVyxZQUFXOzs7O1NBQXRCLEVBSVRoVCxRQUFRUyxRQUFSLEdBQW1CLElBQW5CLEdBQTBCZ1AsYUFKakIsQ0FBWjs7O2lCQU9TNWEsT0FBVCxDQUFpQixVQUFTSCxPQUFULEVBQWtCb1AsS0FBbEIsRUFBeUI7O2NBRXBDb08sTUFBTVMsS0FBS2Qsc0JBQUwsQ0FBNEIvTixLQUE1QixDQUFWOztjQUVJLENBQUNvTyxHQUFMLEVBQVU7a0JBQ0YsSUFBSXpiLEtBQUosQ0FBVSxvRUFBVixDQUFOOzs7ZUFHR29iLHNCQUFMLENBQTRCL04sS0FBNUIsSUFBcUNZLFNBQXJDOztjQUVJcFEsSUFBSjtlQUNLLElBQUlpQixJQUFJLENBQVIsRUFBVzBkLE1BQU12ZSxRQUFRQyxLQUFSLENBQWNhLE1BQXBDLEVBQTRDRCxJQUFJMGQsR0FBaEQsRUFBcUQxZCxHQUFyRCxFQUEwRDttQkFDakRiLFFBQVFDLEtBQVIsQ0FBY1ksQ0FBZCxDQUFQO2dCQUNJMmMsSUFBSTVkLElBQUosTUFBY29RLFNBQWxCLEVBQTZCO2tCQUN2QnBRLElBQUosSUFBWSxFQUFaOzs7O2tCQUlJSyxLQUFSLENBQWNpZSxjQUFkLElBQWdDQyxlQUFoQzs7aUJBRU9qZSxJQUFQLENBQVlzZCxHQUFaLEVBQWlCcmQsT0FBakIsQ0FBeUIsVUFBU0MsR0FBVCxFQUFjO2dCQUNqQ0EsUUFBUThkLGNBQVosRUFBNEI7c0JBQ2xCamUsS0FBUixDQUFjRyxHQUFkLElBQXFCb2QsSUFBSXBkLEdBQUosQ0FBckI7O1dBRko7O2tCQU1RSCxLQUFSLENBQWNpZSxjQUFkLElBQWdDQyxlQUFoQztTQTFCRjtPQXpCRjtLQUhGLE1BeURPO1dBQ0FqQixlQUFMLENBQXFCamMsSUFBckIsQ0FBMEIsVUFBU21jLElBQVQsRUFBZTs7O09BQXpDOzs7V0FNSyxJQUFQOzthQUVTb0IsS0FBVCxHQUFpQjs7V0FFVjFSLFFBQUwsQ0FBYzNNLE9BQWQsQ0FBc0IsVUFBU0gsT0FBVCxFQUFrQm9QLEtBQWxCLEVBQXlCO2dCQUNyQ25QLEtBQVIsQ0FBY2llLGNBQWQsSUFBZ0MsTUFBaEM7O1lBRUlWLE1BQU1TLEtBQUtkLHNCQUFMLENBQTRCL04sS0FBNUIsQ0FBVjs7WUFFSSxDQUFDb08sR0FBTCxFQUFVO2dCQUNGLElBQUl6YixLQUFKLENBQVUsb0VBQVYsQ0FBTjs7O2FBR0dvYixzQkFBTCxDQUE0Qi9OLEtBQTVCLElBQXFDWSxTQUFyQzs7YUFFSyxJQUFJblAsSUFBSSxDQUFSLEVBQVdqQixPQUFPLEVBQXZCLEVBQTJCaUIsSUFBSWIsUUFBUUMsS0FBUixDQUFjYSxNQUE3QyxFQUFxREQsR0FBckQsRUFBMEQ7aUJBQ2pEYixRQUFRQyxLQUFSLENBQWNZLENBQWQsQ0FBUDtjQUNJLE9BQU8yYyxJQUFJeGQsUUFBUUMsS0FBUixDQUFjWSxDQUFkLENBQUosQ0FBUCxLQUFpQyxXQUFyQyxFQUFrRDtnQkFDNUNiLFFBQVFDLEtBQVIsQ0FBY1ksQ0FBZCxDQUFKLElBQXdCLEVBQXhCOzs7O2VBSUdYLElBQVAsQ0FBWXNkLEdBQVosRUFBaUJyZCxPQUFqQixDQUF5QixVQUFTQyxHQUFULEVBQWM7a0JBQzdCSCxLQUFSLENBQWNHLEdBQWQsSUFBcUJvZCxJQUFJcGQsR0FBSixDQUFyQjtTQURGO09BbEJGOztHQTdOYTs7Ozs7a0JBMFBELDBCQUFXO1NBQ3BCcWUsa0JBQUw7O1dBRU8sSUFBUDtHQTdQZTs7c0JBZ1FHLDhCQUFXO1FBQ3pCWixhQUFhLEtBQUtYLGVBQUwsQ0FBcUJ6UyxLQUFyQixFQUFqQjtRQUNJLEtBQUtpVSxrQkFBVCxFQUE2QjtZQUNyQixJQUFJM2MsS0FBSixDQUFVLDRCQUFWLENBQU47O1NBRUcyYyxrQkFBTCxHQUEwQmIsVUFBMUI7UUFDSUksT0FBTyxJQUFYO1FBQ0lVLFNBQVMsS0FBYjs7UUFFSXZCLE9BQU8sU0FBUEEsSUFBTyxHQUFXO1VBQ2hCLENBQUN1QixNQUFMLEVBQWE7aUJBQ0YsSUFBVDthQUNLRCxrQkFBTCxHQUEwQjFPLFNBQTFCO2FBQ0t5TyxrQkFBTDtPQUhGLE1BSU87Y0FDQyxJQUFJMWMsS0FBSixDQUFVLCtDQUFWLENBQU47O0tBTko7O1FBVUk4YixVQUFKLEVBQWdCO2lCQUNIcmUsSUFBWCxDQUFnQixJQUFoQixFQUFzQjRkLElBQXRCOzs7O0NBcFJOOzs7OztBQTZSQUosT0FBTzRCLE1BQVAsR0FBZ0IsOEJBQTZCO09BQ3RDLElBQUkvZCxJQUFJLENBQWIsRUFBZ0JBLElBQUlnZSxVQUFVL2QsTUFBOUIsRUFBc0NELEdBQXRDLEVBQTJDO2NBQy9CQSxDQUFWLEVBQWFpZSxJQUFiOztDQUZKOzs7Ozs7OztBQWFBOUIsT0FBT2MsVUFBUCxHQUFvQixVQUFTeFMsT0FBVCxFQUFrQjtPQUMvQkEsT0FBTCxHQUFlQSxXQUFXLEVBQTFCO09BQ0tBLE9BQUwsQ0FBYVMsUUFBYixHQUF3QixLQUFLVCxPQUFMLENBQWFTLFFBQWIsSUFBeUIsQ0FBakQ7T0FDS1QsT0FBTCxDQUFhK1AsTUFBYixHQUFzQixLQUFLL1AsT0FBTCxDQUFhK1AsTUFBYixJQUF1QixRQUE3QztPQUNLL1AsT0FBTCxDQUFha1MsR0FBYixHQUFtQixLQUFLbFMsT0FBTCxDQUFha1MsR0FBYixJQUFvQixFQUF2QztPQUNLbFMsT0FBTCxDQUFhOFAsUUFBYixHQUF3QixLQUFLOVAsT0FBTCxDQUFhOFAsUUFBYixJQUF5QixLQUFqRDtDQUxGOztBQVFBNEIsT0FBT2MsVUFBUCxDQUFrQnhlLFNBQWxCLEdBQThCOzs7Ozs7U0FNckIsaUJBQVc7O1FBRVpxRSxPQUFPekQsSUFBUCxDQUFZLEtBQUtvTCxPQUFMLENBQWFrUyxHQUF6QixFQUE4QjFjLE1BQTlCLEtBQXlDLENBQTdDLEVBQWdEO1lBQ3hDLElBQUlpQixLQUFKLENBQVUsMEJBQVYsQ0FBTjs7O1FBR0V5YixNQUFNdUIscUJBQXFCLEtBQUt6VCxPQUFMLENBQWFrUyxHQUFsQyxDQUFWOztRQUVJLEtBQUtsUyxPQUFMLENBQWFTLFFBQWIsR0FBd0IsQ0FBNUIsRUFBK0I7VUFDekJvUyxrQkFBa0J0ZSxPQUFLcWIsb0JBQUwsQ0FBMEIsS0FBSzVQLE9BQS9CLENBQXRCO1VBQ0kyUyxPQUFPLElBQVg7O2FBRU8sVUFBU2hYLFFBQVQsRUFBbUI7WUFDcEI2RixXQUFXLEtBQUtBLFFBQXBCO1lBQ0lrUyxVQUFVZixLQUFLM1MsT0FBTCxDQUFhUyxRQUFiLEdBQXdCLElBQXhCLEdBQStCZ1AsYUFBN0M7WUFDSXFELFNBQUo7O1lBRUkxQyxrQkFBa0I3YixPQUFLMmIsbUJBQUwsQ0FBeUIxTyxTQUFTLENBQVQsQ0FBekIsRUFBc0MsWUFBVzt1QkFDeERzUixTQUFiOztTQURvQixDQUF0Qjs7b0JBS1lFLFdBQVcsWUFBVzs7O1NBQXRCLEVBR1RVLE9BSFMsQ0FBWjs7aUJBS1M3ZSxPQUFULENBQWlCLFVBQVNILE9BQVQsRUFBa0I7a0JBQ3pCQyxLQUFSLENBQWNKLE9BQUtrZCxzQkFBbkIsSUFBNkNvQixlQUE3Qzs7aUJBRU9qZSxJQUFQLENBQVlzZCxHQUFaLEVBQWlCcmQsT0FBakIsQ0FBeUIsVUFBU1AsSUFBVCxFQUFlO29CQUM5QkssS0FBUixDQUFjTCxJQUFkLElBQXNCNGQsSUFBSTVkLElBQUosQ0FBdEI7V0FERjtTQUhGO09BZkY7OztRQTBCRSxLQUFLMEwsT0FBTCxDQUFhUyxRQUFiLElBQXlCLENBQTdCLEVBQWdDO2FBQ3ZCLFVBQVM5RSxRQUFULEVBQW1CO1lBQ3BCNkYsV0FBVyxLQUFLQSxRQUFwQjs7aUJBRVMzTSxPQUFULENBQWlCLFVBQVNILE9BQVQsRUFBa0I7a0JBQ3pCQyxLQUFSLENBQWNKLE9BQUtrZCxzQkFBbkIsSUFBNkMsRUFBN0M7O2lCQUVPN2MsSUFBUCxDQUFZc2QsR0FBWixFQUFpQnJkLE9BQWpCLENBQXlCLFVBQVNQLElBQVQsRUFBZTtvQkFDOUJLLEtBQVIsQ0FBY0wsSUFBZCxJQUFzQjRkLElBQUk1ZCxJQUFKLENBQXRCO1dBREY7U0FIRjs7WUFRSWtOLFNBQVNoTSxNQUFULEdBQWtCLENBQXRCLEVBQXlCO2lCQUNsQnFiLGlCQUFMLENBQXVCclAsUUFBdkIsRUFBaUMsWUFBVzttQkFDckMwUCxtQkFBTCxDQUF5QnZWLFFBQXpCO1dBREY7U0FERixNQUlPO2lCQUNBdVYsbUJBQUwsQ0FBeUJ2VixRQUF6Qjs7T0FoQko7OzthQXFCTzhYLG9CQUFULENBQThCdkIsR0FBOUIsRUFBbUM7VUFDN0IzYixTQUFTLEVBQWI7O2FBRU8zQixJQUFQLENBQVlzZCxHQUFaLEVBQWlCcmQsT0FBakIsQ0FBeUIsVUFBU1AsSUFBVCxFQUFlO1lBQ2xDOEUsUUFBUThZLElBQUk1ZCxJQUFKLENBQVo7O1lBRUlDLE9BQUtvYyxjQUFMLENBQW9CcmMsSUFBcEIsQ0FBSixFQUErQjtpQkFDdEJBLElBQVAsSUFBZThFLEtBQWY7Ozs7WUFJRXVhLFdBQVdwZixPQUFLK2IsWUFBTCxHQUFvQi9iLE9BQUttYixVQUFMLENBQWdCcGIsSUFBaEIsQ0FBbkM7WUFDSUMsT0FBS29jLGNBQUwsQ0FBb0JnRCxRQUFwQixDQUFKLEVBQW1DO2lCQUMxQkEsUUFBUCxJQUFtQnZhLEtBQW5CO1NBREYsTUFFTztpQkFDRXVhLFFBQVAsSUFBbUJ2YSxLQUFuQjtpQkFDTzlFLElBQVAsSUFBZThFLEtBQWY7O09BYko7O2FBaUJPN0MsTUFBUDs7O0NBdEZOOztBQzFoQkE7Ozs7QUFJQSxBQUlBLElBQUlxZCxPQUFKO0lBQVdDLEtBQVg7SUFBa0JDLFNBQWxCO0lBQTZCQyxZQUE3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLElBQUlDLGtCQUFrQixTQUFTQSxlQUFULENBQXlCdGYsT0FBekIsRUFBa0NzTCxPQUFsQyxFQUEyQztTQUN4RCxJQUFJZ1UsZ0JBQWdCQyxRQUFwQixDQUE2QnZmLE9BQTdCLEVBQXNDc0wsV0FBVyxFQUFqRCxDQUFQO0NBREY7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkFnVSxnQkFBZ0JyQyxRQUFoQixHQUEyQjtZQUNmOztpQkFFSyxPQUZMO2tCQUdNLE1BSE47b0JBSVEsTUFKUjtjQUtFLE1BTEY7dUJBTVc7O0NBUHZCOzs7Ozs7OztBQWlCQXFDLGdCQUFnQkUsUUFBaEIsR0FBMkJyZ0IsUUFBM0I7Ozs7Ozs7QUFPQW1nQixnQkFBZ0JHLGlCQUFoQixHQUFvQ3JkLFVBQVVzZCxjQUFWLElBQTRCdGQsVUFBVXVkLGdCQUExRTs7Ozs7OztBQU9BTCxnQkFBZ0JNLGVBQWhCLEdBQW1DLGtCQUFrQjNnQixNQUFyRDs7Ozs7OztBQU9BcWdCLGdCQUFnQk8sU0FBaEIsR0FBNEIsNkNBQTZDMWQsSUFBN0MsQ0FBa0RDLFVBQVVDLFNBQTVELENBQTVCOzs7Ozs7O0FBT0FpZCxnQkFBZ0JRLGNBQWhCLEdBQWtDUixnQkFBZ0JNLGVBQWhCLElBQW1DTixnQkFBZ0JPLFNBQXBELElBQWtFUCxnQkFBZ0JHLGlCQUFuSDs7Ozs7Ozs7QUFRQUgsZ0JBQWdCUyxrQkFBaEIsR0FBcUMsRUFBckM7Ozs7Ozs7Ozs7QUFVQSxJQUFJQyxjQUFjLEVBQWxCOzs7Ozs7Ozs7QUFTQSxJQUFJQyxpQkFBaUJYLGdCQUFnQlcsY0FBaEIsR0FBaUMsTUFBdEQ7QUFDQSxJQUFJQyxpQkFBaUJaLGdCQUFnQlksY0FBaEIsR0FBaUMsTUFBdEQ7QUFDQSxJQUFJQyxlQUFlYixnQkFBZ0JhLFlBQWhCLEdBQStCLElBQWxEO0FBQ0EsSUFBSUMsa0JBQWtCZCxnQkFBZ0JjLGVBQWhCLEdBQWtDLE9BQXhEOzs7Ozs7Ozs7QUFTQSxJQUFJQyxnQkFBZ0JmLGdCQUFnQmUsYUFBaEIsR0FBZ0MsT0FBcEQ7QUFDQSxJQUFJQyxnQkFBZ0JoQixnQkFBZ0JnQixhQUFoQixHQUFnQyxPQUFwRDtBQUNBLElBQUlDLGNBQWNqQixnQkFBZ0JpQixXQUFoQixHQUE4QixLQUFoRDs7Ozs7Ozs7O0FBU0EsSUFBSUMsY0FBY2xCLGdCQUFnQmtCLFdBQWhCLEdBQThCLE9BQWhEO0FBQ0EsSUFBSUMsYUFBYW5CLGdCQUFnQm1CLFVBQWhCLEdBQTZCLE1BQTlDO0FBQ0EsSUFBSUMsWUFBWXBCLGdCQUFnQm9CLFNBQWhCLEdBQTRCLEtBQTVDO0FBQ0EsSUFBSUMsZ0JBQWdCckIsZ0JBQWdCcUIsYUFBaEIsR0FBZ0MsU0FBcEQ7QUFDQSxJQUFJQyxjQUFjdEIsZ0JBQWdCc0IsV0FBaEIsR0FBOEIsT0FBaEQ7Ozs7Ozs7OztBQVNBdEIsZ0JBQWdCdUIsS0FBaEIsR0FBd0IsS0FBeEI7Ozs7Ozs7QUFPQXZCLGdCQUFnQndCLE9BQWhCLEdBQTBCeEIsZ0JBQWdCd0IsT0FBaEIsSUFBMkIsRUFBckQ7Ozs7Ozs7O0FBUUF4QixnQkFBZ0J5QixRQUFoQixHQUEyQnpCLGdCQUFnQnlCLFFBQWhCLElBQTRCLEVBQXZEOzs7Ozs7O0FBT0EsU0FBU0MsS0FBVCxDQUFlclcsSUFBZixFQUFxQjtNQUNmMlUsZ0JBQWdCdUIsS0FBcEIsRUFBMkI7Ozs7O1VBS3JCSSxtQkFBTjs7O1FBR014SSxJQUFOLENBQVc2RyxnQkFBZ0J5QixRQUEzQixFQUFxQyxVQUFTdEcsT0FBVCxFQUFrQjtjQUMzQ3pTLFFBQVYsQ0FBbUJ5UyxPQUFuQjtHQURGOzs7VUFLTXlHLE9BQU4sQ0FBYzVCLGdCQUFnQkUsUUFBOUIsRUFBd0NpQixVQUF4QyxFQUFvRHJCLFVBQVUrQixNQUE5RCxFQUFzRXhXLElBQXRFO1VBQ011VyxPQUFOLENBQWM1QixnQkFBZ0JFLFFBQTlCLEVBQXdDa0IsU0FBeEMsRUFBbUR0QixVQUFVK0IsTUFBN0QsRUFBcUV4VyxJQUFyRTs7O2tCQUdnQmtXLEtBQWhCLEdBQXdCLElBQXhCOzs7Ozs7Ozs7QUFTRjFCLFFBQVFHLGdCQUFnQjhCLEtBQWhCLEdBQXdCOzs7Ozs7Ozs7VUFTdEIsU0FBU3hWLE1BQVQsQ0FBZ0J5VixJQUFoQixFQUFzQkMsR0FBdEIsRUFBMkJDLEtBQTNCLEVBQWtDO1NBQ25DLElBQUluaEIsR0FBVCxJQUFnQmtoQixHQUFoQixFQUFxQjtVQUNmQSxJQUFJemMsY0FBSixDQUFtQnpFLEdBQW5CLE1BQTRCaWhCLEtBQUtqaEIsR0FBTCxNQUFjNFAsU0FBZCxJQUEyQixDQUFDdVIsS0FBeEQsQ0FBSixFQUFvRTthQUM3RG5oQixHQUFMLElBQVlraEIsSUFBSWxoQixHQUFKLENBQVo7OztXQUdHaWhCLElBQVA7R0FmNEI7Ozs7Ozs7O01Bd0IxQixTQUFTakgsRUFBVCxDQUFZcGEsT0FBWixFQUFxQjBKLElBQXJCLEVBQTJCZ0csT0FBM0IsRUFBb0N5RSxHQUFwQyxFQUF5QztXQUN0Q25OLGdCQUFMLENBQXNCaEgsT0FBdEIsRUFBK0IwSixJQUEvQixFQUFxQ2dHLE9BQXJDLEVBQThDeUUsR0FBOUMsRUFBbUQsSUFBbkQ7R0F6QjRCOzs7Ozs7OztPQWtDekIsU0FBU2dHLEdBQVQsQ0FBYW5hLE9BQWIsRUFBc0IwSixJQUF0QixFQUE0QmdHLE9BQTVCLEVBQXFDeUUsR0FBckMsRUFBMEM7V0FDeENwTixtQkFBTCxDQUF5Qi9HLE9BQXpCLEVBQWtDMEosSUFBbEMsRUFBd0NnRyxPQUF4QyxFQUFpRHlFLEdBQWpELEVBQXNELElBQXREO0dBbkM0Qjs7Ozs7Ozs7Ozs7UUErQ3hCLFNBQVNzRSxJQUFULENBQWNDLEdBQWQsRUFBbUI4SSxRQUFuQixFQUE2QkMsT0FBN0IsRUFBc0M7UUFDdEM1Z0IsQ0FBSixFQUFPMGQsR0FBUDs7O1FBR0ksYUFBYTdGLEdBQWpCLEVBQXNCO1VBQ2hCdlksT0FBSixDQUFZcWhCLFFBQVosRUFBc0JDLE9BQXRCOztLQURGLE1BR08sSUFBSS9JLElBQUk1WCxNQUFKLEtBQWVrUCxTQUFuQixFQUE4QjtXQUM5Qm5QLElBQUksQ0FBSixFQUFPMGQsTUFBTTdGLElBQUk1WCxNQUF0QixFQUE4QkQsSUFBSTBkLEdBQWxDLEVBQXVDMWQsR0FBdkMsRUFBNEM7WUFDdEMyZ0IsU0FBU2hpQixJQUFULENBQWNpaUIsT0FBZCxFQUF1Qi9JLElBQUk3WCxDQUFKLENBQXZCLEVBQStCQSxDQUEvQixFQUFrQzZYLEdBQWxDLE1BQTJDLEtBQS9DLEVBQXNEOzs7OztLQUZuRCxNQU9BO1dBQ0E3WCxDQUFMLElBQVU2WCxHQUFWLEVBQWU7WUFDVEEsSUFBSTdULGNBQUosQ0FBbUJoRSxDQUFuQixLQUNGMmdCLFNBQVNoaUIsSUFBVCxDQUFjaWlCLE9BQWQsRUFBdUIvSSxJQUFJN1gsQ0FBSixDQUF2QixFQUErQkEsQ0FBL0IsRUFBa0M2WCxHQUFsQyxNQUEyQyxLQUQ3QyxFQUNvRDs7Ozs7R0FoRTVCOzs7Ozs7OztTQTZFdkIsU0FBU2dKLEtBQVQsQ0FBZUosR0FBZixFQUFvQjNQLElBQXBCLEVBQTBCO1dBQ3hCMlAsSUFBSXRnQixPQUFKLENBQVkyUSxJQUFaLElBQW9CLENBQUMsQ0FBNUI7R0E5RTRCOzs7Ozs7OztXQXVGckIsU0FBU2dRLE9BQVQsQ0FBaUJMLEdBQWpCLEVBQXNCM1AsSUFBdEIsRUFBNEJpUSxJQUE1QixFQUFrQztRQUNyQ0EsSUFBSixFQUFVO1dBQ0gsSUFBSS9nQixJQUFJLENBQVIsRUFBVzBkLE1BQU0rQyxJQUFJeGdCLE1BQTFCLEVBQWtDRCxJQUFJMGQsR0FBdEMsRUFBMkMxZCxHQUEzQyxFQUFnRDs7WUFDMUM4QyxPQUFPekQsSUFBUCxDQUFZeVIsSUFBWixFQUFrQmtRLEtBQWxCLENBQXdCLFVBQVN6aEIsR0FBVCxFQUFjO2lCQUFTa2hCLElBQUl6Z0IsQ0FBSixFQUFPVCxHQUFQLE1BQWdCdVIsS0FBS3ZSLEdBQUwsQ0FBdkI7U0FBeEMsQ0FBSixFQUFrRjtpQkFDekVTLENBQVA7OzthQUdHLENBQUMsQ0FBUjs7O1FBR0V5Z0IsSUFBSXRnQixPQUFSLEVBQWlCO2FBQ1JzZ0IsSUFBSXRnQixPQUFKLENBQVkyUSxJQUFaLENBQVA7S0FERixNQUVPO1dBQ0EsSUFBSTlRLElBQUksQ0FBUixFQUFXMGQsTUFBTStDLElBQUl4Z0IsTUFBMUIsRUFBa0NELElBQUkwZCxHQUF0QyxFQUEyQzFkLEdBQTNDLEVBQWdEO1lBQzFDeWdCLElBQUl6Z0IsQ0FBSixNQUFXOFEsSUFBZixFQUFxQjtpQkFDWjlRLENBQVA7OzthQUdHLENBQUMsQ0FBUjs7R0F6RzBCOzs7Ozs7O1dBa0hyQixTQUFTaWhCLE9BQVQsQ0FBaUJwSixHQUFqQixFQUFzQjtXQUN0QnJaLE1BQU1DLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQXNCQyxJQUF0QixDQUEyQmtaLEdBQTNCLEVBQWdDLENBQWhDLENBQVA7R0FuSDRCOzs7Ozs7OzthQTRIbkIsU0FBU3FKLFNBQVQsQ0FBbUJuUSxJQUFuQixFQUF5QjVDLE1BQXpCLEVBQWlDO1dBQ25DNEMsSUFBUCxFQUFhO1VBQ1BBLFFBQVE1QyxNQUFaLEVBQW9CO2VBQ1gsSUFBUDs7YUFFSzRDLEtBQUs1SCxVQUFaOztXQUVLLEtBQVA7R0FuSTRCOzs7Ozs7O2FBMkluQixTQUFTZ1ksU0FBVCxDQUFtQkMsT0FBbkIsRUFBNEI7UUFDakNDLFFBQVEsRUFBWjtRQUNJQyxRQUFRLEVBRFo7UUFFSUMsVUFBVSxFQUZkO1FBR0lDLFVBQVUsRUFIZDtRQUlJQyxNQUFNbEosS0FBS2tKLEdBSmY7UUFLSUMsTUFBTW5KLEtBQUttSixHQUxmOzs7UUFRSU4sUUFBUW5oQixNQUFSLEtBQW1CLENBQXZCLEVBQTBCO2FBQ2pCO2VBQ0VtaEIsUUFBUSxDQUFSLEVBQVdDLEtBRGI7ZUFFRUQsUUFBUSxDQUFSLEVBQVdFLEtBRmI7aUJBR0lGLFFBQVEsQ0FBUixFQUFXRyxPQUhmO2lCQUlJSCxRQUFRLENBQVIsRUFBV0k7T0FKdEI7OztVQVFJNUosSUFBTixDQUFXd0osT0FBWCxFQUFvQixVQUFTTyxLQUFULEVBQWdCO1lBQzVCdmhCLElBQU4sQ0FBV3VoQixNQUFNTixLQUFqQjtZQUNNamhCLElBQU4sQ0FBV3VoQixNQUFNTCxLQUFqQjtjQUNRbGhCLElBQVIsQ0FBYXVoQixNQUFNSixPQUFuQjtjQUNRbmhCLElBQVIsQ0FBYXVoQixNQUFNSCxPQUFuQjtLQUpGOztXQU9PO2FBQ0UsQ0FBQ0MsSUFBSW5SLEtBQUosQ0FBVWlJLElBQVYsRUFBZ0I4SSxLQUFoQixJQUF5QkssSUFBSXBSLEtBQUosQ0FBVWlJLElBQVYsRUFBZ0I4SSxLQUFoQixDQUExQixJQUFvRCxDQUR0RDthQUVFLENBQUNJLElBQUluUixLQUFKLENBQVVpSSxJQUFWLEVBQWdCK0ksS0FBaEIsSUFBeUJJLElBQUlwUixLQUFKLENBQVVpSSxJQUFWLEVBQWdCK0ksS0FBaEIsQ0FBMUIsSUFBb0QsQ0FGdEQ7ZUFHSSxDQUFDRyxJQUFJblIsS0FBSixDQUFVaUksSUFBVixFQUFnQmdKLE9BQWhCLElBQTJCRyxJQUFJcFIsS0FBSixDQUFVaUksSUFBVixFQUFnQmdKLE9BQWhCLENBQTVCLElBQXdELENBSDVEO2VBSUksQ0FBQ0UsSUFBSW5SLEtBQUosQ0FBVWlJLElBQVYsRUFBZ0JpSixPQUFoQixJQUEyQkUsSUFBSXBSLEtBQUosQ0FBVWlJLElBQVYsRUFBZ0JpSixPQUFoQixDQUE1QixJQUF3RDtLQUpuRTtHQXBLNEI7Ozs7Ozs7OztlQW1MakIsU0FBU0ksV0FBVCxDQUFxQjlILFNBQXJCLEVBQWdDK0gsTUFBaEMsRUFBd0NDLE1BQXhDLEVBQWdEO1dBQ3BEO1NBQ0Z2SixLQUFLd0osR0FBTCxDQUFTRixTQUFTL0gsU0FBbEIsS0FBZ0MsQ0FEOUI7U0FFRnZCLEtBQUt3SixHQUFMLENBQVNELFNBQVNoSSxTQUFsQixLQUFnQztLQUZyQztHQXBMNEI7Ozs7Ozs7O1lBZ01wQixTQUFTa0ksUUFBVCxDQUFrQkMsTUFBbEIsRUFBMEJDLE1BQTFCLEVBQWtDO1FBQ3RDQyxJQUFJRCxPQUFPWCxPQUFQLEdBQWlCVSxPQUFPVixPQUFoQztRQUNJYSxJQUFJRixPQUFPVixPQUFQLEdBQWlCUyxPQUFPVCxPQURoQzs7V0FHT2pKLEtBQUs4SixLQUFMLENBQVdELENBQVgsRUFBY0QsQ0FBZCxJQUFtQixHQUFuQixHQUF5QjVKLEtBQUsrSixFQUFyQztHQXBNNEI7Ozs7Ozs7O2dCQTZNaEIsU0FBU0MsWUFBVCxDQUFzQk4sTUFBdEIsRUFBOEJDLE1BQTlCLEVBQXNDO1FBQzlDQyxJQUFJNUosS0FBS3dKLEdBQUwsQ0FBU0UsT0FBT1YsT0FBUCxHQUFpQlcsT0FBT1gsT0FBakMsQ0FBUjtRQUNJYSxJQUFJN0osS0FBS3dKLEdBQUwsQ0FBU0UsT0FBT1QsT0FBUCxHQUFpQlUsT0FBT1YsT0FBakMsQ0FEUjs7UUFHSVcsS0FBS0MsQ0FBVCxFQUFZO2FBQ0hILE9BQU9WLE9BQVAsR0FBaUJXLE9BQU9YLE9BQXhCLEdBQWtDLENBQWxDLEdBQXNDbEMsY0FBdEMsR0FBdURFLGVBQTlEOztXQUVLMEMsT0FBT1QsT0FBUCxHQUFpQlUsT0FBT1YsT0FBeEIsR0FBa0MsQ0FBbEMsR0FBc0NsQyxZQUF0QyxHQUFxREYsY0FBNUQ7R0FwTjRCOzs7Ozs7OztlQTZOakIsU0FBU29ELFdBQVQsQ0FBcUJQLE1BQXJCLEVBQTZCQyxNQUE3QixFQUFxQztRQUM1Q0MsSUFBSUQsT0FBT1gsT0FBUCxHQUFpQlUsT0FBT1YsT0FBaEM7UUFDSWEsSUFBSUYsT0FBT1YsT0FBUCxHQUFpQlMsT0FBT1QsT0FEaEM7O1dBR09qSixLQUFLa0ssSUFBTCxDQUFXTixJQUFJQSxDQUFMLEdBQVdDLElBQUlBLENBQXpCLENBQVA7R0FqTzRCOzs7Ozs7Ozs7WUEyT3BCLFNBQVNNLFFBQVQsQ0FBa0JDLEtBQWxCLEVBQXlCQyxHQUF6QixFQUE4Qjs7UUFFbENELE1BQU0xaUIsTUFBTixJQUFnQixDQUFoQixJQUFxQjJpQixJQUFJM2lCLE1BQUosSUFBYyxDQUF2QyxFQUEwQzthQUNqQyxLQUFLdWlCLFdBQUwsQ0FBaUJJLElBQUksQ0FBSixDQUFqQixFQUF5QkEsSUFBSSxDQUFKLENBQXpCLElBQW1DLEtBQUtKLFdBQUwsQ0FBaUJHLE1BQU0sQ0FBTixDQUFqQixFQUEyQkEsTUFBTSxDQUFOLENBQTNCLENBQTFDOztXQUVLLENBQVA7R0FoUDRCOzs7Ozs7OztlQXlQakIsU0FBU0UsV0FBVCxDQUFxQkYsS0FBckIsRUFBNEJDLEdBQTVCLEVBQWlDOztRQUV4Q0QsTUFBTTFpQixNQUFOLElBQWdCLENBQWhCLElBQXFCMmlCLElBQUkzaUIsTUFBSixJQUFjLENBQXZDLEVBQTBDO2FBQ2pDLEtBQUsraEIsUUFBTCxDQUFjWSxJQUFJLENBQUosQ0FBZCxFQUFzQkEsSUFBSSxDQUFKLENBQXRCLElBQWdDLEtBQUtaLFFBQUwsQ0FBY1csTUFBTSxDQUFOLENBQWQsRUFBd0JBLE1BQU0sQ0FBTixDQUF4QixDQUF2Qzs7V0FFSyxDQUFQO0dBOVA0Qjs7Ozs7OztjQXNRbEIsU0FBU0csVUFBVCxDQUFvQkMsU0FBcEIsRUFBK0I7V0FDbENBLGFBQWF6RCxZQUFiLElBQTZCeUQsYUFBYTNELGNBQWpEO0dBdlE0Qjs7Ozs7Ozs7OztrQkFrUmQsU0FBUzRELGNBQVQsQ0FBd0I3akIsT0FBeEIsRUFBaUN1YixJQUFqQyxFQUF1QzdXLEtBQXZDLEVBQThDa1QsTUFBOUMsRUFBc0Q7UUFDaEVrTSxXQUFXLENBQUMsRUFBRCxFQUFLLFFBQUwsRUFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCLElBQTNCLENBQWY7V0FDTzNFLE1BQU00RSxXQUFOLENBQWtCeEksSUFBbEIsQ0FBUDs7U0FFSyxJQUFJMWEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaWpCLFNBQVNoakIsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO1VBQ3BDZ0QsSUFBSTBYLElBQVI7O1VBRUl1SSxTQUFTampCLENBQVQsQ0FBSixFQUFpQjtZQUNYaWpCLFNBQVNqakIsQ0FBVCxJQUFjZ0QsRUFBRXRFLEtBQUYsQ0FBUSxDQUFSLEVBQVcsQ0FBWCxFQUFjc1csV0FBZCxFQUFkLEdBQTRDaFMsRUFBRXRFLEtBQUYsQ0FBUSxDQUFSLENBQWhEOzs7O1VBSUVzRSxLQUFLN0QsUUFBUUMsS0FBakIsRUFBd0I7Z0JBQ2RBLEtBQVIsQ0FBYzRELENBQWQsSUFBbUIsQ0FBQytULFdBQVcsSUFBWCxJQUFtQkEsTUFBcEIsS0FBK0JsVCxLQUEvQixJQUF3QyxFQUEzRDs7OztHQS9Sd0I7Ozs7Ozs7Ozs7O2tCQThTZCxTQUFTc2YsY0FBVCxDQUF3QmhrQixPQUF4QixFQUFpQ3NiLEtBQWpDLEVBQXdDMUQsTUFBeEMsRUFBZ0Q7UUFDMUQsQ0FBQzBELEtBQUQsSUFBVSxDQUFDdGIsT0FBWCxJQUFzQixDQUFDQSxRQUFRQyxLQUFuQyxFQUEwQzs7Ozs7VUFLcEN3WSxJQUFOLENBQVc2QyxLQUFYLEVBQWtCLFVBQVM1VyxLQUFULEVBQWdCNlcsSUFBaEIsRUFBc0I7WUFDaENzSSxjQUFOLENBQXFCN2pCLE9BQXJCLEVBQThCdWIsSUFBOUIsRUFBb0M3VyxLQUFwQyxFQUEyQ2tULE1BQTNDO0tBREY7O1FBSUlxTSxVQUFVck0sVUFBVSxZQUFXO2FBQzFCLEtBQVA7S0FERjs7O1FBS0kwRCxNQUFNNEksVUFBTixJQUFvQixNQUF4QixFQUFnQztjQUN0QkMsYUFBUixHQUF3QkYsT0FBeEI7OztRQUdFM0ksTUFBTThJLFFBQU4sSUFBa0IsTUFBdEIsRUFBOEI7Y0FDcEJDLFdBQVIsR0FBc0JKLE9BQXRCOztHQWxVMEI7Ozs7Ozs7O2VBNFVqQixTQUFTRixXQUFULENBQXFCOUksR0FBckIsRUFBMEI7V0FDOUJBLElBQUlsWSxPQUFKLENBQVksY0FBWixFQUE0QixVQUFTcEMsQ0FBVCxFQUFZO2FBQ3RDQSxFQUFFLENBQUYsRUFBS2tWLFdBQUwsRUFBUDtLQURLLENBQVA7O0NBN1VKOzs7Ozs7Ozs7QUEyVkFxSixVQUFRSSxnQkFBZ0IvTyxLQUFoQixHQUF3Qjs7Ozs7Ozs7c0JBUVYsS0FSVTs7Ozs7Ozs7V0FnQnJCLEtBaEJxQjs7Ozs7Ozs7Z0JBd0JoQixLQXhCZ0I7Ozs7Ozs7Ozs7O01BbUMxQixTQUFTNkosRUFBVCxDQUFZcGEsT0FBWixFQUFxQjBKLElBQXJCLEVBQTJCZ0csT0FBM0IsRUFBb0N5RSxHQUFwQyxFQUF5Q21RLElBQXpDLEVBQStDO1FBQzdDQyxRQUFRN2EsS0FBS2xKLEtBQUwsQ0FBVyxHQUFYLENBQVo7VUFDTWlZLElBQU4sQ0FBVzhMLEtBQVgsRUFBa0IsVUFBUzdhLElBQVQsRUFBZTtZQUN6QjBRLEVBQU4sQ0FBU3BhLE9BQVQsRUFBa0IwSixJQUFsQixFQUF3QmdHLE9BQXhCLEVBQWlDeUUsR0FBakM7Y0FDUW1RLEtBQUs1YSxJQUFMLENBQVI7S0FGRjtHQXJDNEI7Ozs7Ozs7Ozs7O09Bb0R6QixTQUFTeVEsR0FBVCxDQUFhbmEsT0FBYixFQUFzQjBKLElBQXRCLEVBQTRCZ0csT0FBNUIsRUFBcUN5RSxHQUFyQyxFQUEwQ21RLElBQTFDLEVBQWdEO1FBQy9DQyxRQUFRN2EsS0FBS2xKLEtBQUwsQ0FBVyxHQUFYLENBQVo7VUFDTWlZLElBQU4sQ0FBVzhMLEtBQVgsRUFBa0IsVUFBUzdhLElBQVQsRUFBZTtZQUN6QnlRLEdBQU4sQ0FBVW5hLE9BQVYsRUFBbUIwSixJQUFuQixFQUF5QmdHLE9BQXpCLEVBQWtDeUUsR0FBbEM7Y0FDUW1RLEtBQUs1YSxJQUFMLENBQVI7S0FGRjtHQXRENEI7Ozs7Ozs7Ozs7V0FvRXJCLFNBQVN3WCxPQUFULENBQWlCbGhCLE9BQWpCLEVBQTBCd2tCLFNBQTFCLEVBQXFDOVUsT0FBckMsRUFBOEN5RSxHQUE5QyxFQUFtRDtRQUN0RDhKLE9BQU8sSUFBWDs7UUFFSXdHLGlCQUFpQixTQUFTQSxjQUFULENBQXdCQyxFQUF4QixFQUE0QjtVQUMzQ0MsVUFBVUQsR0FBR2hiLElBQUgsQ0FBUS9ILFdBQVIsRUFBZDtVQUNJaWpCLFlBQVl0RixnQkFBZ0JHLGlCQURoQztVQUVJb0YsVUFBVTFGLE1BQU11QyxLQUFOLENBQVlpRCxPQUFaLEVBQXFCLE9BQXJCLENBRmQ7VUFHSUcsV0FISjs7OztVQU9JRCxXQUFXNUcsS0FBSzhHLGtCQUFwQixFQUF3Qzs7OztPQUF4QyxNQUlPLElBQUlGLFdBQVdMLGFBQWFoRSxXQUF4QixJQUF1Q2tFLEdBQUdNLE1BQUgsS0FBYyxDQUF6RCxFQUE0RDthQUM1REQsa0JBQUwsR0FBMEIsS0FBMUI7YUFDS0UsWUFBTCxHQUFvQixJQUFwQjtPQUZLLE1BR0EsSUFBSUwsYUFBYUosYUFBYWhFLFdBQTlCLEVBQTJDO2FBQzNDeUUsWUFBTCxHQUFxQlAsR0FBR1EsT0FBSCxLQUFlLENBQWYsSUFBb0I3RixhQUFhOEYsU0FBYixDQUF1QjdFLGFBQXZCLEVBQXNDb0UsRUFBdEMsQ0FBekM7O09BREssTUFHQSxJQUFJLENBQUNHLE9BQUQsSUFBWUwsYUFBYWhFLFdBQTdCLEVBQTBDO2FBQzFDdUUsa0JBQUwsR0FBMEIsSUFBMUI7YUFDS0UsWUFBTCxHQUFvQixJQUFwQjs7OztVQUlFTCxhQUFhSixhQUFhOUQsU0FBOUIsRUFBeUM7cUJBQzFCMEUsYUFBYixDQUEyQlosU0FBM0IsRUFBc0NFLEVBQXRDOzs7O1VBSUV6RyxLQUFLZ0gsWUFBVCxFQUF1QjtzQkFDUGhILEtBQUtvSCxRQUFMLENBQWM3bEIsSUFBZCxDQUFtQnllLElBQW5CLEVBQXlCeUcsRUFBekIsRUFBNkJGLFNBQTdCLEVBQXdDeGtCLE9BQXhDLEVBQWlEMFAsT0FBakQsQ0FBZDs7Ozs7VUFLRW9WLGVBQWVwRSxTQUFuQixFQUE4QjthQUN2QnFFLGtCQUFMLEdBQTBCLEtBQTFCO2FBQ0tFLFlBQUwsR0FBb0IsS0FBcEI7cUJBQ2F6RyxLQUFiOzs7O1VBSUVvRyxhQUFhSixhQUFhOUQsU0FBOUIsRUFBeUM7cUJBQzFCMEUsYUFBYixDQUEyQlosU0FBM0IsRUFBc0NFLEVBQXRDOztLQTNDSjs7U0ErQ0t0SyxFQUFMLENBQVFwYSxPQUFSLEVBQWlCZ2dCLFlBQVl3RSxTQUFaLENBQWpCLEVBQXlDQyxjQUF6QyxFQUF5RHRRLEdBQXpEO1dBQ09zUSxjQUFQO0dBdkg0Qjs7Ozs7Ozs7Ozs7WUFtSXBCLFNBQVNZLFFBQVQsQ0FBa0JYLEVBQWxCLEVBQXNCRixTQUF0QixFQUFpQ3hrQixPQUFqQyxFQUEwQzBQLE9BQTFDLEVBQW1EO1FBQ3ZENFYsWUFBWSxLQUFLQyxZQUFMLENBQWtCYixFQUFsQixFQUFzQkYsU0FBdEIsQ0FBaEI7UUFDSWdCLGtCQUFrQkYsVUFBVXhrQixNQUFoQztRQUNJZ2tCLGNBQWNOLFNBQWxCO1FBQ0lpQixnQkFBZ0JILFVBQVVJLE9BQTlCLENBSjJEO1FBS3ZEQyxnQkFBZ0JILGVBQXBCOzs7UUFHSWhCLGFBQWFoRSxXQUFqQixFQUE4QjtzQkFDWkksV0FBaEI7O0tBREYsTUFHTyxJQUFJNEQsYUFBYTlELFNBQWpCLEVBQTRCO3NCQUNqQkMsYUFBaEI7OztzQkFHZ0IyRSxVQUFVeGtCLE1BQVYsSUFBcUI0akIsR0FBR2tCLGNBQUosR0FBc0JsQixHQUFHa0IsY0FBSCxDQUFrQjlrQixNQUF4QyxHQUFpRCxDQUFyRSxDQUFoQjs7Ozs7O1FBTUU2a0IsZ0JBQWdCLENBQWhCLElBQXFCLEtBQUtFLE9BQTlCLEVBQXVDO29CQUN2QnBGLFVBQWQ7Ozs7U0FJR29GLE9BQUwsR0FBZSxJQUFmOzs7UUFHSUMsU0FBUyxLQUFLQyxnQkFBTCxDQUFzQi9sQixPQUF0QixFQUErQjhrQixXQUEvQixFQUE0Q1EsU0FBNUMsRUFBdURaLEVBQXZELENBQWI7Ozs7UUFJSUYsYUFBYTlELFNBQWpCLEVBQTRCO2NBQ2xCbGhCLElBQVIsQ0FBYTRmLFNBQWIsRUFBd0IwRyxNQUF4Qjs7OztRQUlFTCxhQUFKLEVBQW1CO2FBQ1ZFLGFBQVAsR0FBdUJBLGFBQXZCO2FBQ09uQixTQUFQLEdBQW1CaUIsYUFBbkI7O2NBRVFqbUIsSUFBUixDQUFhNGYsU0FBYixFQUF3QjBHLE1BQXhCOzthQUVPdEIsU0FBUCxHQUFtQk0sV0FBbkI7YUFDT2dCLE9BQU9ILGFBQWQ7Ozs7UUFJRWIsZUFBZXBFLFNBQW5CLEVBQThCO2NBQ3BCbGhCLElBQVIsQ0FBYTRmLFNBQWIsRUFBd0IwRyxNQUF4Qjs7OztXQUlLRCxPQUFMLEdBQWUsS0FBZjs7O1dBR0tmLFdBQVA7R0E1TDRCOzs7Ozs7Ozt1QkFxTVQsU0FBUzdELG1CQUFULEdBQStCO1FBQzlDc0QsS0FBSjtRQUNJakYsZ0JBQWdCRyxpQkFBcEIsRUFBdUM7VUFDakN4Z0IsT0FBT29nQixZQUFYLEVBQXlCO2dCQUNmLENBQ04sYUFETSxFQUVOLGFBRk0sRUFHTiw0Q0FITSxDQUFSO09BREYsTUFNTztnQkFDRyxDQUNOLGVBRE0sRUFFTixlQUZNLEVBR04sa0RBSE0sQ0FBUjs7S0FSSixNQWNPLElBQUlDLGdCQUFnQlEsY0FBcEIsRUFBb0M7Y0FDakMsQ0FDTixZQURNLEVBRU4sV0FGTSxFQUdOLHNCQUhNLENBQVI7S0FESyxNQU1BO2NBQ0csQ0FDTixzQkFETSxFQUVOLHFCQUZNLEVBR04sOEJBSE0sQ0FBUjs7O2dCQU9VVSxXQUFaLElBQTJCK0QsTUFBTSxDQUFOLENBQTNCO2dCQUNZOUQsVUFBWixJQUEwQjhELE1BQU0sQ0FBTixDQUExQjtnQkFDWTdELFNBQVosSUFBeUI2RCxNQUFNLENBQU4sQ0FBekI7V0FDT3ZFLFdBQVA7R0F0TzRCOzs7Ozs7OztnQkErT2hCLFNBQVN1RixZQUFULENBQXNCYixFQUF0QixFQUEwQkYsU0FBMUIsRUFBcUM7O1FBRTdDbEYsZ0JBQWdCRyxpQkFBcEIsRUFBdUM7YUFDOUJKLGFBQWFrRyxZQUFiLEVBQVA7Ozs7UUFJRWIsR0FBR3pDLE9BQVAsRUFBZ0I7VUFDVnVDLGFBQWEvRCxVQUFqQixFQUE2QjtlQUNwQmlFLEdBQUd6QyxPQUFWOzs7VUFHRStELGNBQWMsRUFBbEI7VUFDSXBsQixTQUFTLEdBQUdBLE1BQUgsQ0FBVXVlLE1BQU0yQyxPQUFOLENBQWM0QyxHQUFHekMsT0FBakIsQ0FBVixFQUFxQzlDLE1BQU0yQyxPQUFOLENBQWM0QyxHQUFHa0IsY0FBakIsQ0FBckMsQ0FBYjtVQUNJTixZQUFZLEVBQWhCOztZQUVNN00sSUFBTixDQUFXN1gsTUFBWCxFQUFtQixVQUFTNGhCLEtBQVQsRUFBZ0I7WUFDN0JyRCxNQUFNd0MsT0FBTixDQUFjcUUsV0FBZCxFQUEyQnhELE1BQU15RCxVQUFqQyxNQUFpRCxDQUFDLENBQXRELEVBQXlEO29CQUM3Q2hsQixJQUFWLENBQWV1aEIsS0FBZjs7b0JBRVV2aEIsSUFBWixDQUFpQnVoQixNQUFNeUQsVUFBdkI7T0FKRjs7YUFPT1gsU0FBUDs7OztPQUlDVyxVQUFILEdBQWdCLENBQWhCO1dBQ08sQ0FBQ3ZCLEVBQUQsQ0FBUDtHQTNRNEI7Ozs7Ozs7Ozs7b0JBc1JaLFNBQVNxQixnQkFBVCxDQUEwQi9sQixPQUExQixFQUFtQ3drQixTQUFuQyxFQUE4Q3ZDLE9BQTlDLEVBQXVEeUMsRUFBdkQsRUFBMkQ7O1FBRXZFd0IsY0FBYzVGLGFBQWxCO1FBQ0luQixNQUFNdUMsS0FBTixDQUFZZ0QsR0FBR2hiLElBQWYsRUFBcUIsT0FBckIsS0FBaUMyVixhQUFhOEYsU0FBYixDQUF1QjlFLGFBQXZCLEVBQXNDcUUsRUFBdEMsQ0FBckMsRUFBZ0Y7b0JBQ2hFckUsYUFBZDtLQURGLE1BRU8sSUFBSWhCLGFBQWE4RixTQUFiLENBQXVCNUUsV0FBdkIsRUFBb0NtRSxFQUFwQyxDQUFKLEVBQTZDO29CQUNwQ25FLFdBQWQ7OztXQUdLO2NBQ0dwQixNQUFNNkMsU0FBTixDQUFnQkMsT0FBaEIsQ0FESDtpQkFFTWtFLEtBQUtDLEdBQUwsRUFGTjtjQUdHMUIsR0FBRzljLE1BSE47ZUFJSXFhLE9BSko7aUJBS011QyxTQUxOO21CQU1RMEIsV0FOUjtnQkFPS3hCLEVBUEw7Ozs7OztzQkFhVywwQkFBVztZQUNyQjJCLFdBQVcsS0FBS0EsUUFBcEI7aUJBQ1NDLG1CQUFULElBQWdDRCxTQUFTQyxtQkFBVCxFQUFoQztpQkFDU3RNLGNBQVQsSUFBMkJxTSxTQUFTck0sY0FBVCxFQUEzQjtPQWhCRzs7Ozs7dUJBc0JZLDJCQUFXO2FBQ3JCcU0sUUFBTCxDQUFjNUssZUFBZDtPQXZCRzs7Ozs7OztrQkErQk8sc0JBQVc7ZUFDZDJELFVBQVVtSCxVQUFWLEVBQVA7O0tBaENKOztDQS9SSjs7Ozs7Ozs7QUE0VUFsSCxlQUFlQyxnQkFBZ0JELFlBQWhCLEdBQStCOzs7Ozs7WUFNbEMsRUFOa0M7Ozs7OztnQkFZOUIsU0FBU2tHLFlBQVQsR0FBd0I7UUFDaENpQixZQUFZLEVBQWhCOztVQUVNL04sSUFBTixDQUFXLEtBQUtnTyxRQUFoQixFQUEwQixVQUFTQyxPQUFULEVBQWtCO2dCQUNoQ3psQixJQUFWLENBQWV5bEIsT0FBZjtLQURGO1dBR09GLFNBQVA7R0FsQjBDOzs7Ozs7O2lCQTBCN0IsU0FBU3BCLGFBQVQsQ0FBdUJaLFNBQXZCLEVBQWtDbUMsWUFBbEMsRUFBZ0Q7UUFDekRuQyxhQUFhOUQsU0FBYixJQUEyQjhELGFBQWE5RCxTQUFiLElBQTBCaUcsYUFBYXpCLE9BQWIsS0FBeUIsQ0FBbEYsRUFBc0Y7YUFDN0UsS0FBS3VCLFFBQUwsQ0FBY0UsYUFBYUMsU0FBM0IsQ0FBUDtLQURGLE1BRU87bUJBQ1FYLFVBQWIsR0FBMEJVLGFBQWFDLFNBQXZDO1dBQ0tILFFBQUwsQ0FBY0UsYUFBYUMsU0FBM0IsSUFBd0NELFlBQXhDOztHQS9Cd0M7Ozs7Ozs7YUF3Q2pDLFNBQVN4QixTQUFULENBQW1CZSxXQUFuQixFQUFnQ3hCLEVBQWhDLEVBQW9DO1FBQ3pDLENBQUNBLEdBQUd3QixXQUFSLEVBQXFCO2FBQ1osS0FBUDs7O1FBR0VXLEtBQUtuQyxHQUFHd0IsV0FBWjtRQUNJM0IsUUFBUSxFQURaOztVQUdNbEUsYUFBTixJQUF3QndHLFFBQVFuQyxHQUFHb0Msb0JBQUgsSUFBMkJ6RyxhQUFuQyxDQUF4QjtVQUNNQyxhQUFOLElBQXdCdUcsUUFBUW5DLEdBQUdxQyxvQkFBSCxJQUEyQnpHLGFBQW5DLENBQXhCO1VBQ01DLFdBQU4sSUFBc0JzRyxRQUFRbkMsR0FBR3NDLGtCQUFILElBQXlCekcsV0FBakMsQ0FBdEI7V0FDT2dFLE1BQU0yQixXQUFOLENBQVA7R0FuRDBDOzs7OztTQXlEckMsU0FBU2UsU0FBVCxHQUFxQjtTQUNyQlIsUUFBTCxHQUFnQixFQUFoQjs7Q0ExREo7Ozs7Ozs7O0FBcUVBckgsWUFBWUUsZ0JBQWdCNEgsU0FBaEIsR0FBNEI7O1lBRTVCLEVBRjRCOzs7V0FLN0IsSUFMNkI7Ozs7WUFTNUIsSUFUNEI7OztXQVk3QixLQVo2Qjs7Ozs7OztlQW1CekIsU0FBU0MsV0FBVCxDQUFxQkMsSUFBckIsRUFBMkJDLFNBQTNCLEVBQXNDOztRQUU3QyxLQUFLdFosT0FBVCxFQUFrQjs7OztTQUlidVosT0FBTCxHQUFlLEtBQWY7OztTQUdLdlosT0FBTCxHQUFlO1lBQ1BxWixJQURPO2tCQUVEakksTUFBTXZULE1BQU4sQ0FBYSxFQUFiLEVBQWlCeWIsU0FBakIsQ0FGQztpQkFHRixLQUhFO3FCQUlFLEtBSkY7dUJBS0ksS0FMSjtvQkFNQyxFQU5EO1lBT1AsRUFQTztLQUFmOztTQVVLbEcsTUFBTCxDQUFZa0csU0FBWjtHQXRDb0M7Ozs7Ozs7VUE4QzlCLFNBQVNsRyxNQUFULENBQWdCa0csU0FBaEIsRUFBMkI7UUFDN0IsQ0FBQyxLQUFLdFosT0FBTixJQUFpQixLQUFLdVosT0FBMUIsRUFBbUM7Ozs7O2dCQUt2QixLQUFLQyxlQUFMLENBQXFCRixTQUFyQixDQUFaOzs7UUFHSUQsT0FBTyxLQUFLclosT0FBTCxDQUFhcVosSUFBeEI7UUFDSUksY0FBY0osS0FBSzliLE9BRHZCOzs7VUFJTW1OLElBQU4sQ0FBVyxLQUFLc0ksUUFBaEIsRUFBMEIsU0FBUzBHLGNBQVQsQ0FBd0JoTixPQUF4QixFQUFpQzs7VUFFckQsQ0FBQyxLQUFLNk0sT0FBTixJQUFpQkYsS0FBS00sT0FBdEIsSUFBaUNGLFlBQVkvTSxRQUFRN2EsSUFBcEIsQ0FBckMsRUFBZ0U7Z0JBQ3REOFAsT0FBUixDQUFnQmxRLElBQWhCLENBQXFCaWIsT0FBckIsRUFBOEI0TSxTQUE5QixFQUF5Q0QsSUFBekM7O0tBSEosRUFLRyxJQUxIOzs7UUFRSSxLQUFLclosT0FBVCxFQUFrQjtXQUNYQSxPQUFMLENBQWE0WixTQUFiLEdBQXlCTixTQUF6Qjs7O1FBR0VBLFVBQVU3QyxTQUFWLElBQXVCOUQsU0FBM0IsRUFBc0M7V0FDL0I2RixVQUFMOzs7V0FHS2MsU0FBUCxDQTdCaUM7R0E5Q0c7Ozs7Ozs7Y0FtRjFCLFNBQVNkLFVBQVQsR0FBc0I7OztTQUczQnFCLFFBQUwsR0FBZ0J6SSxNQUFNdlQsTUFBTixDQUFhLEVBQWIsRUFBaUIsS0FBS21DLE9BQXRCLENBQWhCOzs7U0FHS0EsT0FBTCxHQUFlLElBQWY7U0FDS3VaLE9BQUwsR0FBZSxJQUFmO0dBMUZvQzs7Ozs7Ozs7OztxQkFxR25CLFNBQVNPLGlCQUFULENBQTJCbkQsRUFBM0IsRUFBK0JvRCxNQUEvQixFQUF1Q25OLFNBQXZDLEVBQWtEK0gsTUFBbEQsRUFBMERDLE1BQTFELEVBQWtFO1FBQy9Fb0YsTUFBTSxLQUFLaGEsT0FBZjtRQUNJaWEsU0FBUyxLQURiO1FBRUlDLFNBQVNGLElBQUlHLGFBRmpCO1FBR0lDLFdBQVdKLElBQUlLLFlBSG5COztRQUtJSCxVQUFVdkQsR0FBRzJELFNBQUgsR0FBZUosT0FBT0ksU0FBdEIsR0FBa0MvSSxnQkFBZ0JTLGtCQUFoRSxFQUFvRjtlQUN6RWtJLE9BQU9ILE1BQWhCO2tCQUNZcEQsR0FBRzJELFNBQUgsR0FBZUosT0FBT0ksU0FBbEM7ZUFDUzNELEdBQUdvRCxNQUFILENBQVUxRixPQUFWLEdBQW9CNkYsT0FBT0gsTUFBUCxDQUFjMUYsT0FBM0M7ZUFDU3NDLEdBQUdvRCxNQUFILENBQVV6RixPQUFWLEdBQW9CNEYsT0FBT0gsTUFBUCxDQUFjekYsT0FBM0M7ZUFDUyxJQUFUOzs7UUFHRXFDLEdBQUdGLFNBQUgsSUFBZ0I1RCxXQUFoQixJQUErQjhELEdBQUdGLFNBQUgsSUFBZ0I3RCxhQUFuRCxFQUFrRTtVQUM1RDJILGVBQUosR0FBc0I1RCxFQUF0Qjs7O1FBR0UsQ0FBQ3FELElBQUlHLGFBQUwsSUFBc0JGLE1BQTFCLEVBQWtDO2VBQ3ZCTyxRQUFULEdBQW9CcEosTUFBTXNELFdBQU4sQ0FBa0I5SCxTQUFsQixFQUE2QitILE1BQTdCLEVBQXFDQyxNQUFyQyxDQUFwQjtlQUNTNkYsS0FBVCxHQUFpQnJKLE1BQU0wRCxRQUFOLENBQWVpRixNQUFmLEVBQXVCcEQsR0FBR29ELE1BQTFCLENBQWpCO2VBQ1NsRSxTQUFULEdBQXFCekUsTUFBTWlFLFlBQU4sQ0FBbUIwRSxNQUFuQixFQUEyQnBELEdBQUdvRCxNQUE5QixDQUFyQjs7VUFFSUksYUFBSixHQUFvQkgsSUFBSU8sZUFBSixJQUF1QjVELEVBQTNDO1VBQ0k0RCxlQUFKLEdBQXNCNUQsRUFBdEI7OztPQUdDK0QsU0FBSCxHQUFlTixTQUFTSSxRQUFULENBQWtCdkYsQ0FBakM7T0FDRzBGLFNBQUgsR0FBZVAsU0FBU0ksUUFBVCxDQUFrQnRGLENBQWpDO09BQ0cwRixZQUFILEdBQWtCUixTQUFTSyxLQUEzQjtPQUNHSSxnQkFBSCxHQUFzQlQsU0FBU3ZFLFNBQS9CO0dBbklvQzs7Ozs7OzttQkEySXJCLFNBQVMyRCxlQUFULENBQXlCN0MsRUFBekIsRUFBNkI7UUFDeENxRCxNQUFNLEtBQUtoYSxPQUFmO1FBQ0k4YSxVQUFVZCxJQUFJZSxVQURsQjtRQUVJQyxTQUFTaEIsSUFBSUosU0FBSixJQUFpQmtCLE9BRjlCOzs7UUFLSW5FLEdBQUdGLFNBQUgsSUFBZ0I1RCxXQUFoQixJQUErQjhELEdBQUdGLFNBQUgsSUFBZ0I3RCxhQUFuRCxFQUFrRTtjQUN4RHNCLE9BQVIsR0FBa0IsRUFBbEI7WUFDTXhKLElBQU4sQ0FBV2lNLEdBQUd6QyxPQUFkLEVBQXVCLFVBQVNPLEtBQVQsRUFBZ0I7Z0JBQzdCUCxPQUFSLENBQWdCaGhCLElBQWhCLENBQXFCO21CQUNWdWhCLE1BQU1KLE9BREk7bUJBRVZJLE1BQU1IO1NBRmpCO09BREY7OztRQVFFMUgsWUFBWStKLEdBQUcyRCxTQUFILEdBQWVRLFFBQVFSLFNBQXZDO1FBQ0kzRixTQUFTZ0MsR0FBR29ELE1BQUgsQ0FBVTFGLE9BQVYsR0FBb0J5RyxRQUFRZixNQUFSLENBQWUxRixPQURoRDtRQUVJTyxTQUFTK0IsR0FBR29ELE1BQUgsQ0FBVXpGLE9BQVYsR0FBb0J3RyxRQUFRZixNQUFSLENBQWV6RixPQUZoRDs7U0FJS3dGLGlCQUFMLENBQXVCbkQsRUFBdkIsRUFBMkJxRSxPQUFPakIsTUFBbEMsRUFBMENuTixTQUExQyxFQUFxRCtILE1BQXJELEVBQTZEQyxNQUE3RDs7VUFFTS9XLE1BQU4sQ0FBYThZLEVBQWIsRUFBaUI7a0JBQ0htRSxPQURHOztpQkFHSmxPLFNBSEk7Y0FJUCtILE1BSk87Y0FLUEMsTUFMTzs7Z0JBT0x4RCxNQUFNa0UsV0FBTixDQUFrQndGLFFBQVFmLE1BQTFCLEVBQWtDcEQsR0FBR29ELE1BQXJDLENBUEs7YUFRUjNJLE1BQU0wRCxRQUFOLENBQWVnRyxRQUFRZixNQUF2QixFQUErQnBELEdBQUdvRCxNQUFsQyxDQVJRO2lCQVNKM0ksTUFBTWlFLFlBQU4sQ0FBbUJ5RixRQUFRZixNQUEzQixFQUFtQ3BELEdBQUdvRCxNQUF0QyxDQVRJO2FBVVIzSSxNQUFNb0UsUUFBTixDQUFlc0YsUUFBUTVHLE9BQXZCLEVBQWdDeUMsR0FBR3pDLE9BQW5DLENBVlE7Z0JBV0w5QyxNQUFNdUUsV0FBTixDQUFrQm1GLFFBQVE1RyxPQUExQixFQUFtQ3lDLEdBQUd6QyxPQUF0QztLQVhaOztXQWNPeUMsRUFBUDtHQS9Lb0M7Ozs7Ozs7WUF1TDVCLFNBQVMxYyxRQUFULENBQWtCeVMsT0FBbEIsRUFBMkI7O1FBRS9CblAsVUFBVW1QLFFBQVF3QyxRQUFSLElBQW9CLEVBQWxDO1FBQ0kzUixRQUFRbVAsUUFBUTdhLElBQWhCLE1BQTBCb1EsU0FBOUIsRUFBeUM7Y0FDL0J5SyxRQUFRN2EsSUFBaEIsSUFBd0IsSUFBeEI7Ozs7VUFJSWdNLE1BQU4sQ0FBYTBULGdCQUFnQnJDLFFBQTdCLEVBQXVDM1IsT0FBdkMsRUFBZ0QsSUFBaEQ7OztZQUdROEQsS0FBUixHQUFnQnFMLFFBQVFyTCxLQUFSLElBQWlCLElBQWpDOzs7U0FHSzJSLFFBQUwsQ0FBYzlmLElBQWQsQ0FBbUJ3WixPQUFuQjs7O1NBR0tzRyxRQUFMLENBQWNpSSxJQUFkLENBQW1CLFVBQVNsTixDQUFULEVBQVltTixDQUFaLEVBQWU7VUFDNUJuTixFQUFFMU0sS0FBRixHQUFVNlosRUFBRTdaLEtBQWhCLEVBQXVCO2VBQ2QsQ0FBQyxDQUFSOztVQUVFME0sRUFBRTFNLEtBQUYsR0FBVTZaLEVBQUU3WixLQUFoQixFQUF1QjtlQUNkLENBQVA7O2FBRUssQ0FBUDtLQVBGOztXQVVPLEtBQUsyUixRQUFaOztDQWxOSjs7Ozs7Ozs7Ozs7Ozs7OztBQXFPQXpCLGdCQUFnQkMsUUFBaEIsR0FBMkIsVUFBU3ZmLE9BQVQsRUFBa0JzTCxPQUFsQixFQUEyQjtNQUNoRDJTLE9BQU8sSUFBWDtNQUNJaUwsa0JBQW1CNWQsV0FBV0EsUUFBUTZkLE9BQXBCLEdBQStCLEVBQUVBLFNBQVMsSUFBWCxFQUEvQixHQUFtRG5aLFNBQXpFOzs7O1FBSU1rWixlQUFOOzs7Ozs7T0FNS2xwQixPQUFMLEdBQWVBLE9BQWY7Ozs7Ozs7T0FPSzBuQixPQUFMLEdBQWUsSUFBZjs7Ozs7Ozs7UUFRTWpQLElBQU4sQ0FBV25OLE9BQVgsRUFBb0IsVUFBUzVHLEtBQVQsRUFBZ0I5RSxJQUFoQixFQUFzQjtXQUNqQzBMLFFBQVExTCxJQUFSLENBQVA7WUFDUXVmLE1BQU00RSxXQUFOLENBQWtCbmtCLElBQWxCLENBQVIsSUFBbUM4RSxLQUFuQztHQUZGOztPQUtLNEcsT0FBTCxHQUFlNlQsTUFBTXZULE1BQU4sQ0FBYXVULE1BQU12VCxNQUFOLENBQWEsRUFBYixFQUFpQjBULGdCQUFnQnJDLFFBQWpDLENBQWIsRUFBeUQzUixXQUFXLEVBQXBFLENBQWY7T0FDS0EsT0FBTCxDQUFhNGQsZUFBYixHQUErQkEsZUFBL0I7OztNQUdJLEtBQUs1ZCxPQUFMLENBQWE4ZCxRQUFqQixFQUEyQjtVQUNuQnBGLGNBQU4sQ0FBcUIsS0FBS2hrQixPQUExQixFQUFtQyxLQUFLc0wsT0FBTCxDQUFhOGQsUUFBaEQsRUFBMEQsSUFBMUQ7Ozs7Ozs7O09BUUdDLGlCQUFMLEdBQXlCbkssUUFBTWdDLE9BQU4sQ0FBY2xoQixPQUFkLEVBQXVCd2dCLFdBQXZCLEVBQW9DLFVBQVNrRSxFQUFULEVBQWE7UUFDcEV6RyxLQUFLeUosT0FBTCxJQUFnQmhELEdBQUdGLFNBQUgsSUFBZ0JoRSxXQUFwQyxFQUFpRDtnQkFDckMyRyxXQUFWLENBQXNCbEosSUFBdEIsRUFBNEJ5RyxFQUE1QjtLQURGLE1BRU8sSUFBSUEsR0FBR0YsU0FBSCxJQUFnQjVELFdBQXBCLEVBQWlDO2dCQUM1Qk8sTUFBVixDQUFpQnVELEVBQWpCOztHQUpxQixFQU10QndFLGVBTnNCLENBQXpCOzs7Ozs7O09BYUtJLGFBQUwsR0FBcUIsRUFBckI7Q0ExREY7O0FBNkRBaEssZ0JBQWdCQyxRQUFoQixDQUF5QmpnQixTQUF6QixHQUFxQzs7Ozs7Ozs7Ozs7Ozs7TUFjL0IsU0FBU2lxQixPQUFULENBQWlCeEksUUFBakIsRUFBMkJyUixPQUEzQixFQUFvQ3lFLEdBQXBDLEVBQXlDO1FBQ3ZDOEosT0FBTyxJQUFYOztZQUVNN0QsRUFBTixDQUFTNkQsS0FBS2plLE9BQWQsRUFBdUIrZ0IsUUFBdkIsRUFBaUNyUixPQUFqQyxFQUEwQzdQLE9BQUsrTCxNQUFMLENBQVksRUFBWixFQUFnQnFTLEtBQUszUyxPQUFMLENBQWE0ZCxlQUE3QixFQUE4Qy9VLEdBQTlDLENBQTFDLEVBQThGLFVBQVN6SyxJQUFULEVBQWU7V0FDdEc0ZixhQUFMLENBQW1Ccm9CLElBQW5CLENBQXdCLEVBQUV3WixTQUFTL1EsSUFBWCxFQUFpQmdHLFNBQVNBLE9BQTFCLEVBQXhCO0tBREY7V0FHT3VPLElBQVA7R0FwQmlDOzs7Ozs7Ozs7Ozs7Ozs7T0FvQzlCLFNBQVN1TCxRQUFULENBQWtCekksUUFBbEIsRUFBNEJyUixPQUE1QixFQUFxQ3lFLEdBQXJDLEVBQTBDO1FBQ3pDOEosT0FBTyxJQUFYOztZQUVNOUQsR0FBTixDQUFVOEQsS0FBS2plLE9BQWYsRUFBd0IrZ0IsUUFBeEIsRUFBa0NyUixPQUFsQyxFQUEyQzdQLE9BQUsrTCxNQUFMLENBQVksRUFBWixFQUFnQnFTLEtBQUszUyxPQUFMLENBQWE0ZCxlQUE3QixFQUE4Qy9VLEdBQTlDLENBQTNDLEVBQStGLFVBQVN6SyxJQUFULEVBQWU7VUFDeEcwRixRQUFRK1AsTUFBTXdDLE9BQU4sQ0FBYzFELEtBQUtxTCxhQUFuQixFQUFrQyxFQUFFN08sU0FBUy9RLElBQVgsRUFBaUJnRyxTQUFTQSxPQUExQixFQUFsQyxFQUF1RSxJQUF2RSxDQUFaO1VBQ0lOLFNBQVMsQ0FBYixFQUFnQjthQUNUa2EsYUFBTCxDQUFtQmphLE1BQW5CLENBQTBCRCxLQUExQixFQUFpQyxDQUFqQzs7S0FISjtXQU1PNk8sSUFBUDtHQTdDaUM7Ozs7Ozs7OztXQXVEMUIsU0FBU3dMLFlBQVQsQ0FBc0JoUCxPQUF0QixFQUErQjRNLFNBQS9CLEVBQTBDOztRQUU3QyxDQUFDQSxTQUFMLEVBQWdCO2tCQUNGLEVBQVo7Ozs7UUFJRTlXLFFBQVErTyxnQkFBZ0JFLFFBQWhCLENBQXlCaFAsV0FBekIsQ0FBcUMsT0FBckMsQ0FBWjtVQUNNQyxTQUFOLENBQWdCZ0ssT0FBaEIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0I7VUFDTUEsT0FBTixHQUFnQjRNLFNBQWhCOzs7O1FBSUlybkIsVUFBVSxLQUFLQSxPQUFuQjtRQUNJbWYsTUFBTTRDLFNBQU4sQ0FBZ0JzRixVQUFVemYsTUFBMUIsRUFBa0M1SCxPQUFsQyxDQUFKLEVBQWdEO2dCQUNwQ3FuQixVQUFVemYsTUFBcEI7OztZQUdNOEksYUFBUixDQUFzQkgsS0FBdEI7V0FDTyxJQUFQO0dBMUVpQzs7Ozs7Ozs7Ozs7O1VBdUYzQixTQUFTTyxNQUFULENBQWdCNFksS0FBaEIsRUFBdUI7U0FDeEJoQyxPQUFMLEdBQWVnQyxLQUFmO1dBQ08sSUFBUDtHQXpGaUM7Ozs7Ozs7OztXQW1HMUIsU0FBU0MsT0FBVCxHQUFtQjtRQUN0QjlvQixDQUFKLEVBQU8rb0IsRUFBUDs7O1VBR001RixjQUFOLENBQXFCLEtBQUtoa0IsT0FBMUIsRUFBbUMsS0FBS3NMLE9BQUwsQ0FBYThkLFFBQWhELEVBQTBELEtBQTFEOzs7U0FHS3ZvQixJQUFJLENBQUMsQ0FBVixFQUFjK29CLEtBQUssS0FBS04sYUFBTCxDQUFtQixFQUFFem9CLENBQXJCLENBQW5CLEdBQThDOztZQUN0Q3NaLEdBQU4sQ0FBVSxLQUFLbmEsT0FBZixFQUF3QjRwQixHQUFHblAsT0FBM0IsRUFBb0NtUCxHQUFHbGEsT0FBdkM7OztTQUdHNFosYUFBTCxHQUFxQixFQUFyQjs7O1lBR01uUCxHQUFOLENBQVUsS0FBS25hLE9BQWYsRUFBd0JnZ0IsWUFBWVEsV0FBWixDQUF4QixFQUFrRCxLQUFLNkksaUJBQXZEOztXQUVPLElBQVA7O0NBbkhKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdLQSxDQUFDLFVBQVN6cEIsSUFBVCxFQUFlO01BQ1ZpcUIsWUFBWSxLQUFoQjs7V0FFU0MsV0FBVCxDQUFxQnBGLEVBQXJCLEVBQXlCMEMsSUFBekIsRUFBK0I7UUFDekJXLE1BQU0zSSxVQUFVclIsT0FBcEI7OztRQUdJcVosS0FBSzliLE9BQUwsQ0FBYXllLGNBQWIsR0FBOEIsQ0FBOUIsSUFDRnJGLEdBQUd6QyxPQUFILENBQVduaEIsTUFBWCxHQUFvQnNtQixLQUFLOWIsT0FBTCxDQUFheWUsY0FEbkMsRUFDbUQ7Ozs7WUFJM0NyRixHQUFHRixTQUFYO1dBQ0toRSxXQUFMO29CQUNjLEtBQVo7OztXQUdHQyxVQUFMOzs7WUFHTWlFLEdBQUdoSyxRQUFILEdBQWMwTSxLQUFLOWIsT0FBTCxDQUFhMGUsZUFBM0IsSUFDRmpDLElBQUlub0IsSUFBSixJQUFZQSxJQURkLEVBQ29COzs7O1lBSWhCcXFCLGNBQWNsQyxJQUFJZSxVQUFKLENBQWVoQixNQUFqQzs7O1lBR0lDLElBQUlub0IsSUFBSixJQUFZQSxJQUFoQixFQUFzQjtjQUNoQkEsSUFBSixHQUFXQSxJQUFYO2NBQ0l3bkIsS0FBSzliLE9BQUwsQ0FBYTRlLHNCQUFiLElBQXVDeEYsR0FBR2hLLFFBQUgsR0FBYyxDQUF6RCxFQUE0RDs7OztnQkFJdER5UCxTQUFTL1EsS0FBS3dKLEdBQUwsQ0FBU3dFLEtBQUs5YixPQUFMLENBQWEwZSxlQUFiLEdBQStCdEYsR0FBR2hLLFFBQTNDLENBQWI7d0JBQ1l3SCxLQUFaLElBQXFCd0MsR0FBR2hDLE1BQUgsR0FBWXlILE1BQWpDO3dCQUNZaEksS0FBWixJQUFxQnVDLEdBQUcvQixNQUFILEdBQVl3SCxNQUFqQzt3QkFDWS9ILE9BQVosSUFBdUJzQyxHQUFHaEMsTUFBSCxHQUFZeUgsTUFBbkM7d0JBQ1k5SCxPQUFaLElBQXVCcUMsR0FBRy9CLE1BQUgsR0FBWXdILE1BQW5DOzs7aUJBR0svSyxVQUFVbUksZUFBVixDQUEwQjdDLEVBQTFCLENBQUw7Ozs7O1lBS0FxRCxJQUFJSixTQUFKLENBQWN5QyxjQUFkLElBQ0FoRCxLQUFLOWIsT0FBTCxDQUFhOGUsY0FBYixJQUNBaEQsS0FBSzliLE9BQUwsQ0FBYStlLG1CQUFiLElBQW9DM0YsR0FBR2hLLFFBRjNDLEVBR0s7YUFDRTBQLGNBQUgsR0FBb0IsSUFBcEI7Ozs7WUFJRUUsZ0JBQWdCdkMsSUFBSUosU0FBSixDQUFjL0QsU0FBbEM7WUFDSWMsR0FBRzBGLGNBQUgsSUFBcUJFLGtCQUFrQjVGLEdBQUdkLFNBQTlDLEVBQXlEO2NBQ25EekUsTUFBTXdFLFVBQU4sQ0FBaUIyRyxhQUFqQixDQUFKLEVBQXFDO2VBQ2hDMUcsU0FBSCxHQUFnQmMsR0FBRy9CLE1BQUgsR0FBWSxDQUFiLEdBQWtCeEMsWUFBbEIsR0FBaUNGLGNBQWhEO1dBREYsTUFFTztlQUNGMkQsU0FBSCxHQUFnQmMsR0FBR2hDLE1BQUgsR0FBWSxDQUFiLEdBQWtCeEMsY0FBbEIsR0FBbUNFLGVBQWxEOzs7OztZQUtBLENBQUN5SixTQUFMLEVBQWdCO2VBQ1RuRSxPQUFMLENBQWE5bEIsT0FBTyxPQUFwQixFQUE2QjhrQixFQUE3QjtzQkFDWSxJQUFaOzs7O2FBSUdnQixPQUFMLENBQWE5bEIsSUFBYixFQUFtQjhrQixFQUFuQjthQUNLZ0IsT0FBTCxDQUFhOWxCLE9BQU84a0IsR0FBR2QsU0FBdkIsRUFBa0NjLEVBQWxDOztZQUVJZixhQUFheEUsTUFBTXdFLFVBQU4sQ0FBaUJlLEdBQUdkLFNBQXBCLENBQWpCOzs7WUFHS3dELEtBQUs5YixPQUFMLENBQWFpZixpQkFBYixJQUFrQzVHLFVBQW5DLElBQ0R5RCxLQUFLOWIsT0FBTCxDQUFha2YsbUJBQWIsSUFBb0MsQ0FBQzdHLFVBRHhDLEVBQ3FEO2FBQ2hEM0osY0FBSDs7OztXQUlDMkcsYUFBTDtZQUNNa0osYUFBYW5GLEdBQUdpQixhQUFILElBQW9CeUIsS0FBSzliLE9BQUwsQ0FBYXllLGNBQWxELEVBQWtFO2VBQzNEckUsT0FBTCxDQUFhOWxCLE9BQU8sS0FBcEIsRUFBMkI4a0IsRUFBM0I7c0JBQ1ksS0FBWjs7OztXQUlDaEUsU0FBTDtvQkFDYyxLQUFaOzs7OztrQkFLWUssUUFBaEIsQ0FBeUIwSixJQUF6QixHQUFnQztVQUN4QjdxQixJQUR3QjtXQUV2QixFQUZ1QjthQUdyQmtxQixXQUhxQjtjQUlwQjs7Ozs7Ozt1QkFPUyxFQVBUOzs7Ozs7Ozs7Ozs4QkFrQmdCLElBbEJoQjs7Ozs7Ozs7c0JBMEJRLENBMUJSOzs7Ozs7Ozs7OzJCQW9DYSxLQXBDYjs7Ozs7Ozs7eUJBNENXLEtBNUNYOzs7Ozs7Ozs7c0JBcURRLEtBckRSOzs7Ozs7Ozs7MkJBOERhOztHQWxFekI7Q0EvRkosRUFvS0ssTUFwS0w7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvTEV4SyxnQkFBZ0J5QixRQUFoQixDQUF5QjJKLE9BQXpCLEdBQW1DO1FBQzNCLFNBRDJCO1NBRTFCLElBRjBCO1dBR3hCLFNBQVNDLGNBQVQsQ0FBd0JqRyxFQUF4QixFQUE0QjBDLElBQTVCLEVBQWtDO1NBQ3BDMUIsT0FBTCxDQUFhLEtBQUs5bEIsSUFBbEIsRUFBd0I4a0IsRUFBeEI7O0NBSko7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsQ0FBQyxVQUFTOWtCLElBQVQsRUFBZTtNQUNWZ3JCLEtBQUo7O1dBRVNDLFdBQVQsQ0FBcUJuRyxFQUFyQixFQUF5QjBDLElBQXpCLEVBQStCO1FBQ3pCOWIsVUFBVThiLEtBQUs5YixPQUFuQjtRQUNJeUMsVUFBVXFSLFVBQVVyUixPQUR4Qjs7WUFHUTJXLEdBQUdGLFNBQVg7V0FDS2hFLFdBQUw7cUJBQ2VvSyxLQUFiOzs7Z0JBR1FockIsSUFBUixHQUFlQSxJQUFmOzs7O2dCQUlRMGUsV0FBVyxZQUFXO2NBQ3hCdlEsV0FBV0EsUUFBUW5PLElBQVIsSUFBZ0JBLElBQS9CLEVBQXFDO2lCQUM5QjhsQixPQUFMLENBQWE5bEIsSUFBYixFQUFtQjhrQixFQUFuQjs7U0FGSSxFQUlMcFosUUFBUXdmLFdBSkgsQ0FBUjs7O1dBT0dySyxVQUFMO1lBQ01pRSxHQUFHaEssUUFBSCxHQUFjcFAsUUFBUXlmLGFBQTFCLEVBQXlDO3VCQUMxQkgsS0FBYjs7OztXQUlDakssYUFBTDtxQkFDZWlLLEtBQWI7Ozs7O2tCQUtZN0osUUFBaEIsQ0FBeUJpSyxJQUF6QixHQUFnQztVQUN4QnByQixJQUR3QjtXQUV2QixFQUZ1QjtjQUdwQjs7Ozs7O21CQU1LLEdBTkw7Ozs7Ozs7O3FCQWNPO0tBakJhO2FBbUJyQmlyQjtHQW5CWDtDQW5DRixFQXdERyxNQXhESDs7Ozs7Ozs7Ozs7Ozs7O0FBdUVBdkwsZ0JBQWdCeUIsUUFBaEIsQ0FBeUJrSyxPQUF6QixHQUFtQztRQUMzQixTQUQyQjtTQUUxQkMsUUFGMEI7V0FHeEIsU0FBU1AsY0FBVCxDQUF3QmpHLEVBQXhCLEVBQTRCMEMsSUFBNUIsRUFBa0M7UUFDckMxQyxHQUFHRixTQUFILElBQWdCN0QsYUFBcEIsRUFBbUM7V0FDNUIrRSxPQUFMLENBQWEsS0FBSzlsQixJQUFsQixFQUF3QjhrQixFQUF4Qjs7O0NBTE47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOENBcEYsZ0JBQWdCeUIsUUFBaEIsQ0FBeUJvSyxLQUF6QixHQUFpQztRQUN6QixPQUR5QjtTQUV4QixFQUZ3QjtZQUdyQjs7Ozs7O3FCQU1TLENBTlQ7Ozs7Ozs7cUJBYVMsQ0FiVDs7Ozs7Ozs7b0JBcUJRLEdBckJSOzs7Ozs7OztvQkE2QlE7R0FoQ2E7O1dBbUN0QixTQUFTQyxZQUFULENBQXNCMUcsRUFBdEIsRUFBMEIwQyxJQUExQixFQUFnQztRQUNuQzFDLEdBQUdGLFNBQUgsSUFBZ0I3RCxhQUFwQixFQUFtQztVQUM3QnNCLFVBQVV5QyxHQUFHekMsT0FBSCxDQUFXbmhCLE1BQXpCO1VBQ0l3SyxVQUFVOGIsS0FBSzliLE9BRG5COzs7VUFJSTJXLFVBQVUzVyxRQUFRK2YsZUFBbEIsSUFDRnBKLFVBQVUzVyxRQUFRZ2dCLGVBRHBCLEVBQ3FDOzs7Ozs7VUFNakM1RyxHQUFHK0QsU0FBSCxHQUFlbmQsUUFBUWlnQixjQUF2QixJQUNGN0csR0FBR2dFLFNBQUgsR0FBZXBkLFFBQVFrZ0IsY0FEekIsRUFDeUM7O2FBRWxDOUYsT0FBTCxDQUFhLEtBQUs5bEIsSUFBbEIsRUFBd0I4a0IsRUFBeEI7YUFDS2dCLE9BQUwsQ0FBYSxLQUFLOWxCLElBQUwsR0FBWThrQixHQUFHZCxTQUE1QixFQUF1Q2MsRUFBdkM7Ozs7Q0FwRFI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0VBLENBQUMsVUFBUzlrQixJQUFULEVBQWU7TUFDVjZyQixXQUFXLEtBQWY7O1dBRVNDLFVBQVQsQ0FBb0JoSCxFQUFwQixFQUF3QjBDLElBQXhCLEVBQThCO1FBQ3hCOWIsVUFBVThiLEtBQUs5YixPQUFuQjtRQUNJeUMsVUFBVXFSLFVBQVVyUixPQUR4QjtRQUVJNGQsT0FBT3ZNLFVBQVV3SSxRQUZyQjtRQUdJZ0UsU0FISjtRQUlJQyxZQUpKOztZQU1RbkgsR0FBR0YsU0FBWDtXQUNLaEUsV0FBTDttQkFDYSxLQUFYOzs7V0FHR0MsVUFBTDttQkFDYWdMLFlBQWEvRyxHQUFHaEssUUFBSCxHQUFjcFAsUUFBUXdnQixjQUE5Qzs7O1dBR0dwTCxTQUFMO1lBQ00sQ0FBQ3ZCLE1BQU11QyxLQUFOLENBQVlnRCxHQUFHMkIsUUFBSCxDQUFZM2MsSUFBeEIsRUFBOEIsUUFBOUIsQ0FBRCxJQUE0Q2diLEdBQUcvSixTQUFILEdBQWVyUCxRQUFReWdCLFVBQW5FLElBQWlGLENBQUNOLFFBQXRGLEVBQWdHOztzQkFFbEZFLFFBQVFBLEtBQUtoRSxTQUFiLElBQTBCakQsR0FBRzJELFNBQUgsR0FBZXNELEtBQUtoRSxTQUFMLENBQWVVLFNBQXBFO3lCQUNlLEtBQWY7OztjQUdJc0QsUUFBUUEsS0FBSy9yQixJQUFMLElBQWFBLElBQXJCLElBQ0Rnc0IsYUFBYUEsWUFBWXRnQixRQUFRMGdCLGlCQURoQyxJQUVGdEgsR0FBR2hLLFFBQUgsR0FBY3BQLFFBQVEyZ0IsaUJBRnhCLEVBRTJDO2lCQUNwQ3ZHLE9BQUwsQ0FBYSxXQUFiLEVBQTBCaEIsRUFBMUI7MkJBQ2UsSUFBZjs7OztjQUlFLENBQUNtSCxZQUFELElBQWlCdmdCLFFBQVE0Z0IsU0FBN0IsRUFBd0M7b0JBQzlCdHNCLElBQVIsR0FBZUEsSUFBZjtpQkFDSzhsQixPQUFMLENBQWEzWCxRQUFRbk8sSUFBckIsRUFBMkI4a0IsRUFBM0I7Ozs7Ozs7a0JBT1EzRCxRQUFoQixDQUF5Qm9MLEdBQXpCLEdBQStCO1VBQ3ZCdnNCLElBRHVCO1dBRXRCLEdBRnNCO2FBR3BCOHJCLFVBSG9CO2NBSW5COzs7Ozs7O2tCQU9JLEdBUEo7Ozs7Ozs7O3NCQWVRLEVBZlI7Ozs7Ozs7O2lCQXVCRyxJQXZCSDs7Ozs7Ozs7eUJBK0JXLEVBL0JYOzs7Ozs7Ozt5QkF1Q1c7O0dBM0N2QjtDQTNDRixFQXlGRyxLQXpGSDs7Ozs7Ozs7Ozs7Ozs7O0FBd0dBcE0sZ0JBQWdCeUIsUUFBaEIsQ0FBeUJxTCxLQUF6QixHQUFpQztRQUN6QixPQUR5QjtTQUV4QixDQUFDbEIsUUFGdUI7WUFHckI7Ozs7Ozs7OztvQkFTUSxLQVRSOzs7Ozs7OztrQkFpQk07R0FwQmU7V0FzQnRCLFNBQVNtQixZQUFULENBQXNCM0gsRUFBdEIsRUFBMEIwQyxJQUExQixFQUFnQztRQUNuQ0EsS0FBSzliLE9BQUwsQ0FBYWdoQixZQUFiLElBQTZCNUgsR0FBR3dCLFdBQUgsSUFBa0I3RixhQUFuRCxFQUFrRTtTQUM3RGtHLFVBQUg7Ozs7UUFJRWEsS0FBSzliLE9BQUwsQ0FBYTBPLGNBQWpCLEVBQWlDO1NBQzVCQSxjQUFIOzs7UUFHRTBLLEdBQUdGLFNBQUgsSUFBZ0I1RCxXQUFwQixFQUFpQztXQUMxQjhFLE9BQUwsQ0FBYSxPQUFiLEVBQXNCaEIsRUFBdEI7OztDQWpDTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2RUEsQ0FBQyxVQUFTOWtCLElBQVQsRUFBZTtNQUNWaXFCLFlBQVksS0FBaEI7O1dBRVMwQyxnQkFBVCxDQUEwQjdILEVBQTFCLEVBQThCMEMsSUFBOUIsRUFBb0M7WUFDMUIxQyxHQUFHRixTQUFYO1dBQ0toRSxXQUFMO29CQUNjLEtBQVo7OztXQUdHQyxVQUFMOztZQUVNaUUsR0FBR3pDLE9BQUgsQ0FBV25oQixNQUFYLEdBQW9CLENBQXhCLEVBQTJCOzs7O1lBSXZCMHJCLGlCQUFpQnBULEtBQUt3SixHQUFMLENBQVMsSUFBSThCLEdBQUcrSCxLQUFoQixDQUFyQjtZQUNJQyxvQkFBb0J0VCxLQUFLd0osR0FBTCxDQUFTOEIsR0FBR2lJLFFBQVosQ0FBeEI7Ozs7WUFJSUgsaUJBQWlCcEYsS0FBSzliLE9BQUwsQ0FBYXNoQixpQkFBOUIsSUFDRkYsb0JBQW9CdEYsS0FBSzliLE9BQUwsQ0FBYXVoQixvQkFEbkMsRUFDeUQ7Ozs7O2tCQUsvQzllLE9BQVYsQ0FBa0JuTyxJQUFsQixHQUF5QkEsSUFBekI7OztZQUdJLENBQUNpcUIsU0FBTCxFQUFnQjtlQUNUbkUsT0FBTCxDQUFhOWxCLE9BQU8sT0FBcEIsRUFBNkI4a0IsRUFBN0I7c0JBQ1ksSUFBWjs7O2FBR0dnQixPQUFMLENBQWE5bEIsSUFBYixFQUFtQjhrQixFQUFuQixFQXpCRjs7O1lBNEJNZ0ksb0JBQW9CdEYsS0FBSzliLE9BQUwsQ0FBYXVoQixvQkFBckMsRUFBMkQ7ZUFDcERuSCxPQUFMLENBQWEsUUFBYixFQUF1QmhCLEVBQXZCOzs7O1lBSUU4SCxpQkFBaUJwRixLQUFLOWIsT0FBTCxDQUFhc2hCLGlCQUFsQyxFQUFxRDtlQUM5Q2xILE9BQUwsQ0FBYSxPQUFiLEVBQXNCaEIsRUFBdEI7ZUFDS2dCLE9BQUwsQ0FBYSxXQUFXaEIsR0FBRytILEtBQUgsR0FBVyxDQUFYLEdBQWUsSUFBZixHQUFzQixLQUFqQyxDQUFiLEVBQXNEL0gsRUFBdEQ7Ozs7V0FJQy9ELGFBQUw7WUFDTWtKLGFBQWFuRixHQUFHaUIsYUFBSCxHQUFtQixDQUFwQyxFQUF1QztlQUNoQ0QsT0FBTCxDQUFhOWxCLE9BQU8sS0FBcEIsRUFBMkI4a0IsRUFBM0I7c0JBQ1ksS0FBWjs7Ozs7O2tCQU1VM0QsUUFBaEIsQ0FBeUIrTCxTQUF6QixHQUFxQztVQUM3Qmx0QixJQUQ2QjtXQUU1QixFQUY0QjtjQUd6Qjs7Ozs7Ozt5QkFPVyxJQVBYOzs7Ozs7Ozs0QkFlYztLQWxCVzs7YUFxQjFCMnNCO0dBckJYO0NBekRGLEVBZ0ZHLFdBaEZIOztBQzU4REY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBQUlRLGlCQUFKO0lBQWNDLGlCQUFkOztBQUVBLFNBQVNDLGNBQVQsQ0FBd0JqdEIsT0FBeEIsRUFBaUM7TUFDM0JBLFFBQVE0VSxVQUFSLENBQW1COVQsTUFBbkIsR0FBNEIsQ0FBaEMsRUFBbUM7b0JBQ2pCZCxPQUFoQjs7U0FFSytzQixTQUFTdGIsR0FBVCxDQUFhelIsT0FBYixDQUFQOzs7QUFHRixTQUFTa3RCLGVBQVQsQ0FBeUJsdEIsT0FBekIsRUFBa0M7V0FDdkI4SCxHQUFULENBQWE5SCxPQUFiLEVBQXNCLElBQXRCOzs7QUFHRixTQUFTbXRCLFdBQVQsQ0FBcUJudEIsT0FBckIsRUFBOEI0QixFQUE5QixFQUFrQztNQUM1QixDQUFDb3JCLFNBQVN2YixHQUFULENBQWF6UixPQUFiLENBQUwsRUFBNEI7YUFDakI4SCxHQUFULENBQWE5SCxPQUFiLEVBQXNCLEVBQXRCOztXQUVPNEksR0FBVCxDQUFhNUksT0FBYixFQUFzQmlCLElBQXRCLENBQTJCVyxFQUEzQjs7O0FBR0YsU0FBU3dyQixZQUFULENBQXNCcHRCLE9BQXRCLEVBQStCO01BQ3ZCc2MsWUFBWTBRLFNBQVNwa0IsR0FBVCxDQUFhNUksT0FBYixFQUFzQixFQUF0QixLQUE2QixFQUEvQztXQUNTcXRCLE1BQVQsQ0FBZ0JydEIsT0FBaEI7WUFDVUcsT0FBVixDQUFrQjtXQUFZOEcsVUFBWjtHQUFsQjs7O0FBR0YsQUFBZSxTQUFTcW1CLFlBQVQsQ0FBc0J0dEIsT0FBdEIsRUFBOEM7TUFBZjRCLEVBQWUsdUVBQVYsWUFBTSxFQUFJOztNQUN2RG1yQixhQUFhL2MsU0FBakIsRUFBNEI7ZUFDZixJQUFJdWQsT0FBSixFQUFYO2VBQ1csSUFBSUEsT0FBSixFQUFYOzs7Y0FHVXZ0QixPQUFaLEVBQXFCNEIsRUFBckI7O01BRUlxckIsZUFBZWp0QixPQUFmLENBQUosRUFBNkI7aUJBQ2RBLE9BQWI7Ozs7TUFJSXd0QixXQUFXLElBQUlDLGdCQUFKLENBQXFCLG1CQUFXO29CQUMvQnp0QixPQUFoQjtpQkFDYUEsT0FBYjtHQUZlLENBQWpCO1dBSVMwdEIsT0FBVCxDQUFpQjF0QixPQUFqQixFQUEwQixFQUFDMnRCLFdBQVcsSUFBWixFQUFrQkMsZUFBZSxJQUFqQyxFQUExQjs7O2VBR2EsWUFBTTtvQkFDRDV0QixPQUFoQjtpQkFDYUEsT0FBYjtHQUZGOzs7QUMvREY7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUJNNnRCO3dCQUNVOzs7U0FDUG5RLEtBQUwsR0FBYSxFQUFiOzs7Ozt3QkFHRTliLElBQUk0WCxTQUFTOzs7V0FDVmtFLEtBQUwsQ0FBV3pjLElBQVgsQ0FBZ0JXLEVBQWhCOztVQUVJLEtBQUs4YixLQUFMLENBQVc1YyxNQUFYLEtBQXNCLENBQTFCLEVBQTZCO3FCQUNkLEtBQUs0YyxLQUFMLENBQVcsQ0FBWCxDQUFiOzs7Y0FHTW9RLElBQVIsQ0FBYSxZQUFNO2NBQ1pwUSxLQUFMLENBQVdqVCxLQUFYOztZQUVJLE1BQUtpVCxLQUFMLENBQVc1YyxNQUFYLEdBQW9CLENBQXhCLEVBQTJCO3FCQUNkLE1BQUs0YyxLQUFMLENBQVcsQ0FBWCxDQUFYLEVBQTBCLE9BQUssRUFBL0IsRUFEeUI7O09BSDdCOzs7Ozs7QUFVSixtQkFBZSxJQUFJbVEsVUFBSixFQUFmOztBQ3ZDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFJQSxJQUFNRSxpQkFBaUIsU0FBakJBLGNBQWlCLENBQUMvdEIsT0FBRCxFQUFVc0wsT0FBVixFQUFzQjtHQUMxQyxJQUFELEVBQU8sT0FBUCxFQUFnQixXQUFoQixFQUNHbkwsT0FESCxDQUNXO1dBQUttTCxRQUFRekcsY0FBUixDQUF1QmlYLENBQXZCLEtBQTZCOWIsUUFBUTZNLFlBQVIsQ0FBcUJpUCxDQUFyQixFQUF3QnhRLFFBQVF3USxDQUFSLENBQXhCLENBQWxDO0dBRFg7O01BR0l4USxRQUFRb0MsUUFBWixFQUFzQjtXQUNmUixXQUFMLENBQWlCbE4sT0FBakIsRUFBMEJzTCxRQUFRb0MsUUFBbEM7O0NBTEo7O0FBU0EsSUFBTXNnQixzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFDeHBCLE9BQUQsRUFBMEM7TUFBaEM4RyxPQUFnQyx1RUFBdEIsRUFBc0I7TUFBbEIyUixXQUFrQix1RUFBUCxFQUFPOzt5QkFDckQzUixPQUFmO1NBQ085RyxPQUFQLEtBQW1CLFFBQW5CLEdBQStCOEcsUUFBUTlHLE9BQVIsR0FBa0JBLE9BQWpELEdBQTZEOEcsVUFBVTlHLE9BQXZFO01BQ0ksQ0FBQzhHLE9BQUQsSUFBWSxDQUFDQSxRQUFROUcsT0FBVCxJQUFvQixDQUFDOEcsUUFBUTJpQixXQUE3QyxFQUEwRDtXQUNuRDFwQixLQUFMLENBQVcsc0NBQVg7OztNQUdFK0csUUFBUXpHLGNBQVIsQ0FBdUIsY0FBdkIsS0FBMEN5RyxRQUFRekcsY0FBUixDQUF1QixhQUF2QixDQUE5QyxFQUFxRjtZQUMzRXFwQixZQUFSLEdBQXVCNWlCLFFBQVE0aUIsWUFBUixJQUF3QjVpQixRQUFRNmlCLFdBQXZEO1FBQ0ksQ0FBQzl1QixNQUFNK3VCLE9BQU4sQ0FBYzlpQixRQUFRNGlCLFlBQXRCLENBQUwsRUFBMEM7Y0FDaENBLFlBQVIsR0FBdUIsQ0FBQzVpQixRQUFRNGlCLFlBQVIsSUFBd0IsRUFBekIsQ0FBdkI7Ozs7U0FJR3J1QixPQUFLK0wsTUFBTCxDQUFZO2FBQ047YUFBU3lpQixLQUFUO0tBRE07Y0FFTDthQUFTQSxLQUFUO0tBRks7ZUFHSixTQUhJO2dCQUlILEtBSkc7d0JBS0ssQ0FBQy9pQixRQUFRNGlCLFlBQVIsSUFBd0JqUixZQUFTaVIsWUFBakMsSUFBaUQsRUFBbEQsRUFBc0RwdEIsTUFBdEQsR0FBK0Q7R0FMaEYsRUFNRm1jLFdBTkUsRUFNUTNSLE9BTlIsQ0FBUDtDQWRGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMERBLElBQU1nakIsZUFBZSxFQUFyQjs7QUFFQUEsYUFBYUMsa0JBQWIsR0FBa0M7b0NBQUlwVCxNQUFKO1VBQUE7OztTQUFlLElBQUkzUyxPQUFKLENBQVksbUJBQVc7UUFDaEU4QyxVQUFVMGlCLHFDQUF1QjdTLE1BQXZCLENBQWhCO1dBQ0tQLGtCQUFMLENBQXdCLGFBQXhCLEVBQXVDLG1CQUF2Qzs7O1FBR0k0VCxjQUFjLEVBQWxCO1FBQ0lsakIsUUFBUW1qQixRQUFaLEVBQXNCO3lHQUlSbmpCLFFBQVFvakIsU0FBUixJQUFxQixNQUhqQyxrQ0FJbUJwakIsUUFBUXFqQixXQUFSLElBQXVCLEVBSjFDLDRCQUthcmpCLFFBQVFzakIsWUFBUixJQUF3QixFQUxyQzs7OztRQVlFMUosVUFBVSxFQUFkO1lBQ1FnSixZQUFSLENBQXFCL3RCLE9BQXJCLENBQTZCLFVBQUMwdUIsS0FBRCxFQUFRemYsS0FBUixFQUFrQjtvRkFJckNBLFVBQVU5RCxRQUFRd2pCLGtCQUFsQixHQUF1Qyw4QkFBdkMsR0FBd0UsRUFIaEYsc0JBSVF4akIsUUFBUTRpQixZQUFSLENBQXFCcHRCLE1BQXJCLElBQStCLENBQS9CLEdBQW1DLGlDQUFuQyxHQUF1RSxFQUovRSxvRUFPTSt0QixLQVBOO0tBREY7OztRQWNJbGxCLEtBQUssRUFBVDtRQUNNb2xCLGlCQUFpQixTQUFqQkEsY0FBaUIsR0FBTTtVQUN2QnBsQixHQUFHcWxCLE1BQUgsQ0FBVUMsY0FBZCxFQUE4QjtXQUN6QkQsTUFBSCxDQUFVam9CLG1CQUFWLENBQThCLGVBQTlCLEVBQStDNEMsR0FBR3FsQixNQUFILENBQVVDLGNBQXpEOzs7YUFHSy91QixJQUFQLENBQVl5SixFQUFaLEVBQWdCeEosT0FBaEIsQ0FBd0I7ZUFBTyxPQUFPd0osR0FBR3ZKLEdBQUgsQ0FBZDtPQUF4QjtXQUNLLElBQUw7O1VBRUlrTCxRQUFRNGpCLE9BQVIsWUFBMkJ0ZSxRQUEvQixFQUF5QztnQkFDL0JzZSxPQUFSOztLQVRKOztPQWFHRixNQUFILEdBQVk3dkIsU0FBU3FILGFBQVQsQ0FBdUIsa0JBQXZCLENBQVo7T0FDR3dvQixNQUFILENBQVVqbEIsU0FBVixzRUFHUXVCLFFBQVE2akIsU0FBUixHQUFvQix1QkFBdUI3akIsUUFBUTZqQixTQUFuRCxHQUErRCxFQUh2RSw0SkFRVTdqQixRQUFROGpCLEtBQVIsSUFBaUIsRUFSM0Isa0ZBV1U5akIsUUFBUTlHLE9BQVIsSUFBbUI4RyxRQUFRMmlCLFdBWHJDLHFCQVlVTyxXQVpWLDBGQWdCVWxqQixRQUFRNGlCLFlBQVIsQ0FBcUJwdEIsTUFBckIsSUFBK0IsQ0FBL0IsR0FBbUMsaUNBQW5DLEdBQXVFLEVBaEJqRixpQ0FrQlVva0IsT0FsQlY7aUJBdUJhdmIsR0FBR3FsQixNQUFoQjs7O21CQUdlcmxCLEdBQUdxbEIsTUFBbEIsRUFBMEIxakIsT0FBMUI7OztRQUdJQSxRQUFRbWpCLFFBQVIsSUFBb0JuakIsUUFBUStqQixhQUFoQyxFQUErQztTQUMxQ0MsS0FBSCxHQUFXM2xCLEdBQUdxbEIsTUFBSCxDQUFVem5CLGFBQVYsQ0FBd0IsYUFBeEIsQ0FBWDtTQUNHK25CLEtBQUgsQ0FBU0MsVUFBVCxHQUFzQixpQkFBUztZQUN6QmhmLE1BQU1pZixPQUFOLEtBQWtCLEVBQXRCLEVBQTBCO2FBQ3JCUixNQUFILENBQVVTLElBQVYsR0FDRzNCLElBREgsQ0FDUSxZQUFNO2dCQUNObmtCLEVBQUosRUFBUTtrQkFDQStsQixlQUFlL2xCLEdBQUcybEIsS0FBSCxDQUFTNXFCLEtBQTlCOztzQkFFUXVDLFFBQVIsQ0FBaUJ5b0IsWUFBakI7c0JBQ1FBLFlBQVI7O1dBTk47O09BRko7Ozs7T0FnQkNDLE1BQUgsR0FBWWhtQixHQUFHcWxCLE1BQUgsQ0FBVXpuQixhQUFWLENBQXdCLHNCQUF4QixDQUFaO1dBQ0tpQyxTQUFMLENBQWVHLEdBQUdxbEIsTUFBSCxDQUFVN21CLGdCQUFWLENBQTJCLHNCQUEzQixDQUFmLEVBQW1FaEksT0FBbkUsQ0FBMkUsVUFBQ3l2QixhQUFELEVBQWdCeGdCLEtBQWhCLEVBQTBCO29CQUNyRnlnQixPQUFkLEdBQXdCLFlBQU07V0FDdkJiLE1BQUgsQ0FBVVMsSUFBVixHQUNHM0IsSUFESCxDQUNRLFlBQU07Y0FDTm5rQixFQUFKLEVBQVE7Z0JBQ0YrbEIsZUFBZXRnQixLQUFuQjtnQkFDSTlELFFBQVFtakIsUUFBWixFQUFzQjs2QkFDTHJmLFVBQVU5RCxRQUFRd2pCLGtCQUFsQixHQUF1Q25sQixHQUFHMmxCLEtBQUgsQ0FBUzVxQixLQUFoRCxHQUF3RCxJQUF2RTs7ZUFFQ3NxQixNQUFILENBQVV2Z0IsTUFBVjs7b0JBRVF4SCxRQUFSLENBQWlCeW9CLFlBQWpCO29CQUNRQSxZQUFSOztTQVZOO09BREo7O1NBZ0JHQyxNQUFILENBQVUvbEIsV0FBVixDQUFzQmdtQixhQUF0QjtLQWpCRjs7O1FBcUJJdGtCLFFBQVF5TyxVQUFaLEVBQXdCO1NBQ25CaVYsTUFBSCxDQUFValYsVUFBVixHQUF1QixJQUF2QjtTQUNHaVYsTUFBSCxDQUFVQyxjQUFWLEdBQTJCLFlBQU07cUJBQ2xCLFlBQU07YUFDZEQsTUFBSCxDQUFVdmdCLE1BQVY7O1NBREY7WUFJTWloQixlQUFlcGtCLFFBQVFtakIsUUFBUixHQUFtQixJQUFuQixHQUEwQixDQUFDLENBQWhEO2dCQUNReG5CLFFBQVIsQ0FBaUJ5b0IsWUFBakI7Z0JBQ1FBLFlBQVI7T0FQRjtTQVNHVixNQUFILENBQVVob0IsZ0JBQVYsQ0FBMkIsZUFBM0IsRUFBNEMyQyxHQUFHcWxCLE1BQUgsQ0FBVUMsY0FBdEQsRUFBc0UsS0FBdEU7Ozs7YUFJTzNuQixJQUFULENBQWNzQyxXQUFkLENBQTBCRCxHQUFHcWxCLE1BQTdCO1lBQ1FjLE9BQVIsQ0FBZ0JubUIsR0FBR3FsQixNQUFuQjtpQkFDYSxZQUFNO1NBQ2RBLE1BQUgsQ0FBVWUsSUFBVixHQUNHakMsSUFESCxDQUNRLFlBQU07WUFDTm5rQixHQUFHMmxCLEtBQUgsSUFBWWhrQixRQUFRbWpCLFFBQXBCLElBQWdDbmpCLFFBQVEwa0IsU0FBNUMsRUFBdUQ7Y0FDL0NDLFlBQVl0bUIsR0FBRzJsQixLQUFILENBQVM1cUIsS0FBVCxDQUFlNUQsTUFBakM7YUFDR3d1QixLQUFILENBQVNZLEtBQVQ7YUFDR1osS0FBSCxDQUFTYSxpQkFBVCxDQUEyQkYsU0FBM0IsRUFBc0NBLFNBQXRDOztPQUxOO0tBREY7R0F2SStDLENBQWY7Q0FBbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd05BM0IsYUFBYThCLEtBQWIsR0FBcUIsVUFBQzVyQixPQUFELEVBQVU4RyxPQUFWO1NBQ25CZ2pCLGFBQWFDLGtCQUFiLENBQWdDL3BCLE9BQWhDLEVBQXlDOEcsT0FBekMsRUFBa0Q7a0JBQ2xDLENBQUMsSUFBRCxDQURrQztXQUV6QztHQUZULENBRG1CO0NBQXJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQ0FnakIsYUFBYStCLE9BQWIsR0FBdUIsVUFBQzdyQixPQUFELEVBQVU4RyxPQUFWO1NBQ3JCZ2pCLGFBQWFDLGtCQUFiLENBQWdDL3BCLE9BQWhDLEVBQXlDOEcsT0FBekMsRUFBa0Q7a0JBQ2xDLENBQUMsUUFBRCxFQUFXLElBQVgsQ0FEa0M7V0FFekM7R0FGVCxDQURxQjtDQUF2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5REFnakIsYUFBYWdDLE1BQWIsR0FBc0IsVUFBQzlyQixPQUFELEVBQVU4RyxPQUFWO1NBQ3BCZ2pCLGFBQWFDLGtCQUFiLENBQWdDL3BCLE9BQWhDLEVBQXlDOEcsT0FBekMsRUFBa0Q7a0JBQ2xDLENBQUMsSUFBRCxDQURrQztXQUV6QyxPQUZ5QztjQUd0QyxJQUhzQztlQUlyQyxJQUpxQzttQkFLakM7R0FMakIsQ0FEb0I7Q0FBdEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZEQWdqQixhQUFhaUMsS0FBYixHQUFxQixVQUFDL3JCLE9BQUQsRUFBVThHLE9BQVYsRUFBc0I7TUFDbkNrTyxVQUFVLElBQUloUixPQUFKLENBQVksbUJBQVc7V0FDaENvUyxrQkFBTCxDQUF3QixPQUF4QixFQURxQzs7Y0FHM0JvVCxvQkFBb0J4cEIsT0FBcEIsRUFBNkI4RyxPQUE3QixFQUFzQztlQUNyQyxDQURxQzthQUV2QztLQUZDLENBQVY7O1FBS0lpbEIsUUFBUTF3QixPQUFLMkcsYUFBTCxtQ0FFTjhFLFFBQVE5RyxPQUZGLG1CQUdOOEcsUUFBUTRpQixZQUFSLGdCQUFrQzVpQixRQUFRNGlCLFlBQVIsQ0FBcUIsQ0FBckIsQ0FBbEMsaUJBQXVFLEVBSGpFLGlDQUFaOzttQkFPZXFDLEtBQWYsRUFBc0JqbEIsT0FBdEI7O1FBRU1rbEIsU0FBUyxTQUFUQSxNQUFTLFFBQVM7VUFDbEJELEtBQUosRUFBVztjQUVSZCxJQURELEdBRUMzQixJQUZELENBRU0sWUFBTTtjQUNOeUMsS0FBSixFQUFXO2tCQUNIOWhCLE1BQU47b0JBQ1EsSUFBUjtvQkFDUXhILFFBQVIsQ0FBaUJ2QyxLQUFqQjtvQkFDUUEsS0FBUjs7U0FQSjs7S0FGSjs7UUFlSTRHLFFBQVE0aUIsWUFBWixFQUEwQjthQUNuQnZaLFNBQUwsQ0FBZTRiLE1BQU1FLE1BQXJCLEVBQTZCLFFBQTdCLEVBQXVDWixPQUF2QyxHQUFpRDtlQUFNVyxPQUFPLENBQVAsQ0FBTjtPQUFqRDs7O2FBR09scEIsSUFBVCxDQUFjc0MsV0FBZCxDQUEwQjJtQixLQUExQjtZQUNRVCxPQUFSLENBQWdCUyxLQUFoQjs7UUFFTVIsT0FBTyxTQUFQQSxJQUFPLEdBQU07WUFDWDdYLGFBQU4sSUFBdUJxWSxNQUFNUixJQUFOLENBQVd6a0IsT0FBWCxFQUFvQndpQixJQUFwQixDQUF5QixZQUFNO1lBQ2hEeGlCLFFBQVEwVCxPQUFaLEVBQXFCO3FCQUNSO21CQUFNd1IsT0FBTyxDQUFDLENBQVIsQ0FBTjtXQUFYLEVBQTZCbGxCLFFBQVEwVCxPQUFyQzs7T0FGbUIsQ0FBdkI7S0FERjs7aUJBUWE7YUFBTTFULFFBQVErQixLQUFSLEdBQWdCMGlCLE1BQWhCLEdBQXlCbEMsYUFBV3RmLEdBQVgsQ0FBZXdoQixJQUFmLEVBQXFCdlcsT0FBckIsQ0FBL0I7S0FBYjtHQS9DYyxDQUFoQjs7U0FrRE9BLE9BQVA7Q0FuREY7O0FDbmRBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUVBO0FBQ0EsSUFBTWtYLGVBQWUsU0FBZkEsWUFBZSxVQUFXO01BQ3hCQyxNQUFNLFNBQU5BLEdBQU0sQ0FBQ3BWLElBQUQ7UUFBTzdSLElBQVAsdUVBQWMsVUFBZDtXQUE2QjdKLE9BQUswRSxLQUFMLGVBQXVCZ1gsSUFBdkIsaUNBQXVEN1IsSUFBdkQsQ0FBN0I7R0FBWjtNQUNNN0UsaUJBQWlCLFNBQWpCQSxjQUFpQjtXQUFRbEIsT0FBT2tCLGNBQVAsQ0FBc0JyRixJQUF0QixDQUEyQjhMLE9BQTNCLEVBQW9DaVEsSUFBcEMsQ0FBUjtHQUF2QjtNQUNNcVYsYUFBYSxTQUFiQSxVQUFhLENBQUNyVixJQUFEO1FBQU83UixJQUFQLHVFQUFja0gsUUFBZDtXQUEyQnRGLFFBQVFpUSxJQUFSLGFBQXlCN1IsSUFBcEQ7R0FBbkI7O01BRU11ZixJQUFJLFNBQVY7TUFBcUI0SCxLQUFLLFVBQTFCO01BQXNDOXJCLElBQUksU0FBMUM7TUFBcUQrckIsSUFBSSxTQUF6RDtHQUNDLENBQUNqc0IsZUFBZW9rQixDQUFmLENBQUQsSUFBc0IsQ0FBQzJILFdBQVczSCxDQUFYLEVBQWM1cEIsS0FBZCxDQUF4QixLQUFpRHN4QixJQUFJMUgsQ0FBSixFQUFPLE9BQVAsQ0FBakQ7aUJBQ2dCNEgsRUFBZixLQUFzQixDQUFDRCxXQUFXQyxFQUFYLENBQXhCLElBQTJDRixJQUFJRSxFQUFKLENBQTNDO2lCQUNnQjlyQixDQUFmLEtBQXFCLENBQUM2ckIsV0FBVzdyQixDQUFYLENBQXZCLElBQXlDNHJCLElBQUk1ckIsQ0FBSixDQUF6QztpQkFDZ0IrckIsQ0FBZixLQUFxQixDQUFDRixXQUFXRSxDQUFYLENBQXZCLElBQXlDSCxJQUFJRyxDQUFKLENBQXpDO0NBVEY7OztBQWFBLG1CQUFlO01BQUN4bEIsT0FBRCx1RUFBVyxFQUFYO1NBQWtCLElBQUk5QyxPQUFKLENBQVksbUJBQVc7V0FDakRvUyxrQkFBTCxDQUF3QixhQUF4QjtpQkFDYXRQLE9BQWI7OztRQUdJeWxCLGNBQWNseEIsT0FBSzJHLGFBQUwsc0NBRVo4RSxRQUFROGpCLEtBQVIsZUFBMEI5akIsUUFBUThqQixLQUFsQyxTQUE2QyxFQUZqQyxrQkFHWjlqQixRQUFReU8sVUFBUixHQUFxQixZQUFyQixHQUFvQyxFQUh4QixrQkFJWnpPLFFBQVFvQyxRQUFSLGtCQUFnQ3BDLFFBQVFvQyxRQUF4QyxTQUFzRCxFQUoxQyxrQkFLWnBDLFFBQVE2akIsU0FBUixvQkFBbUM3akIsUUFBUTZqQixTQUEzQyxTQUEwRCxFQUw5QyxrQkFNWjdqQixRQUFRdUUsRUFBUixZQUFvQnZFLFFBQVF1RSxFQUE1QixTQUFvQyxFQU54QixrQkFPWnZFLFFBQVEwbEIsS0FBUixlQUEwQjFsQixRQUFRMGxCLEtBQWxDLFNBQTZDLEVBUGpDLG1GQUFsQjs7O1FBY01SLFNBQVMsU0FBVEEsTUFBUyxDQUFDamdCLEtBQUQsRUFBdUI7VUFBZm5CLEtBQWUsdUVBQVAsQ0FBQyxDQUFNOztVQUNoQzJoQixXQUFKLEVBQWlCO2dCQUNQN0IsT0FBUixJQUFtQjVqQixRQUFRNGpCLE9BQVIsQ0FBZ0I2QixXQUFoQixDQUFuQjs7b0JBRVlocUIsbUJBQVosQ0FBZ0MsZUFBaEMsRUFBaUR5cEIsTUFBakQsRUFBeUQsS0FBekQ7b0JBQ1kvaEIsTUFBWjtzQkFDYyxJQUFkOztnQkFFUXhILFFBQVIsSUFBb0JxRSxRQUFRckUsUUFBUixDQUFpQm1JLEtBQWpCLENBQXBCO2dCQUNRQSxLQUFSOztLQVRKOzs7Z0JBY1lwSSxnQkFBWixDQUE2QixlQUE3QixFQUE4Q3dwQixNQUE5QyxFQUFzRCxLQUF0RDs7O1FBR010TCxVQUFVL2xCLFNBQVM4eEIsc0JBQVQsRUFBaEI7WUFDUS9MLE9BQVIsQ0FBZ0Iva0IsT0FBaEIsQ0FBd0IsVUFBQyt3QixJQUFELEVBQU85aEIsS0FBUCxFQUFpQjtVQUNqQytoQixnQkFBaUIsT0FBT0QsSUFBUCxLQUFnQixRQUFqQixHQUE2QixFQUFFckMsT0FBT3FDLElBQVQsRUFBN0IsZ0JBQW9EQSxJQUFwRCxDQUF0QjtVQUNJNWxCLFFBQVE4bEIsV0FBUixLQUF3QmhpQixLQUE1QixFQUFtQztzQkFDbkIxQixRQUFkLEdBQXlCLENBQUN5akIsY0FBY3pqQixRQUFkLElBQTBCLEVBQTNCLElBQWlDLGNBQTFEOzs7VUFHSXNYLFNBQVNubEIsT0FBSzJHLGFBQUwsaURBRVQycUIsY0FBY0UsSUFBZCxjQUE4QkYsY0FBY0UsSUFBNUMsU0FBc0QsRUFGN0Msb0JBR1RGLGNBQWN6akIsUUFBZCxrQkFBc0N5akIsY0FBY3pqQixRQUFwRCxTQUFrRSxFQUh6RCw0QkFLVHlqQixjQUFjdEMsS0FMTCw4Q0FBZjs7YUFTT2dCLE9BQVAsR0FBaUI7ZUFBU2tCLFlBQVl0QixJQUFaLEdBQW1CM0IsSUFBbkIsQ0FBd0I7aUJBQU0wQyxPQUFPamdCLEtBQVAsRUFBY25CLEtBQWQsQ0FBTjtTQUF4QixDQUFUO09BQWpCO2NBQ1F4RixXQUFSLENBQW9Cb2IsTUFBcEI7S0FoQkY7OztXQW9CS3JRLFNBQUwsQ0FBZW9jLFdBQWYsRUFBNEIsZUFBNUIsRUFBNkNubkIsV0FBN0MsQ0FBeURzYixPQUF6RDthQUNTNWQsSUFBVCxDQUFjc0MsV0FBZCxDQUEwQm1uQixXQUExQjtZQUNRakIsT0FBUixJQUFtQnhrQixRQUFRd2tCLE9BQVIsQ0FBZ0JubUIsR0FBR3FsQixNQUFuQixDQUFuQjs7O2lCQUdhO2FBQU0rQixZQUFZaEIsSUFBWixDQUFpQjttQkFDdkJ6a0IsUUFBUUcsU0FEZTswQkFFaEJILFFBQVFPO09BRlQsQ0FBTjtLQUFiO0dBOUQrQixDQUFsQjtDQUFmOztBQ2pDQTs7Ozs7Ozs7Ozs7OztBQWFBLElBQU15bEIsYUFBYyxTQUFkQSxVQUFjLEdBQVUsRUFBOUI7QUFDQUEsV0FBV2h5QixTQUFYLEdBQXdCO01BQ2xCLFlBQVNpUixLQUFULEVBQWdCZ2hCLEdBQWhCLEVBQW9CO1NBQ2pCQyxPQUFMLEdBQWUsS0FBS0EsT0FBTCxJQUFnQixFQUEvQjtTQUNLQSxPQUFMLENBQWFqaEIsS0FBYixJQUFzQixLQUFLaWhCLE9BQUwsQ0FBYWpoQixLQUFiLEtBQXVCLEVBQTdDO1NBQ0tpaEIsT0FBTCxDQUFhamhCLEtBQWIsRUFBb0J0UCxJQUFwQixDQUF5QnN3QixHQUF6QjtHQUpvQjtRQU1oQixjQUFTaGhCLEtBQVQsRUFBZ0JnaEIsR0FBaEIsRUFBb0I7UUFDcEJ0VCxPQUFPLElBQVg7UUFDSWpJLFVBQVUsU0FBVkEsT0FBVSxHQUFXO1dBQ2xCbUUsR0FBTCxDQUFTNUosS0FBVCxFQUFnQnlGLE9BQWhCO2FBQ091YixJQUFJcGdCLEtBQUosQ0FBVSxJQUFWLEVBQWdCME4sU0FBaEIsQ0FBUDtLQUZGO1NBSUt6RSxFQUFMLENBQVE3SixLQUFSLEVBQWV5RixPQUFmO0dBWm9CO09BY2pCLGFBQVN6RixLQUFULEVBQWdCZ2hCLEdBQWhCLEVBQW9CO1NBQ2xCQyxPQUFMLEdBQWUsS0FBS0EsT0FBTCxJQUFnQixFQUEvQjtRQUNJamhCLFNBQVMsS0FBS2loQixPQUFkLEtBQTBCLEtBQTlCLEVBQXFDOzs7O1NBSWhDQSxPQUFMLENBQWFqaEIsS0FBYixJQUFzQixLQUFLaWhCLE9BQUwsQ0FBYWpoQixLQUFiLEVBQ25CMUIsTUFEbUIsQ0FDWixVQUFTNGlCLElBQVQsRUFBZTtVQUNqQkYsR0FBSixFQUFTO2VBQ0NBLFFBQVFFLElBQWY7T0FESCxNQUdLO2VBQ0ksS0FBUDs7S0FOZ0IsQ0FBdEI7R0FwQm9CO1FBOEJoQixjQUFTbGhCLEtBQVQsa0JBQStCO1NBQzlCaWhCLE9BQUwsR0FBZSxLQUFLQSxPQUFMLElBQWdCLEVBQS9CO1FBQ0lqaEIsU0FBUyxLQUFLaWhCLE9BQWQsS0FBMEIsS0FBOUIsRUFBcUM7OztTQUdoQyxJQUFJM3dCLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLMndCLE9BQUwsQ0FBYWpoQixLQUFiLEVBQW9CelAsTUFBeEMsRUFBZ0RELEdBQWhELEVBQW9EO1dBQzdDMndCLE9BQUwsQ0FBYWpoQixLQUFiLEVBQW9CMVAsQ0FBcEIsRUFBdUJzUSxLQUF2QixDQUE2QixJQUE3QixFQUFtQzlSLE1BQU1DLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQXNCQyxJQUF0QixDQUEyQnFmLFNBQTNCLEVBQXNDLENBQXRDLENBQW5DOzs7Q0FwQ047Ozs7Ozs7OztBQWdEQXlTLFdBQVdJLEtBQVgsR0FBb0IsVUFBU0MsVUFBVCxFQUFvQjtNQUNsQ3JXLFFBQVEsQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLEtBQWYsRUFBc0IsTUFBdEIsQ0FBWjtPQUNLLElBQUl6YSxJQUFJLENBQWIsRUFBZ0JBLElBQUl5YSxNQUFNeGEsTUFBMUIsRUFBa0NELEdBQWxDLEVBQXVDO1FBQ2pDLE9BQU84d0IsVUFBUCxLQUFzQixVQUExQixFQUFzQztpQkFDekJyeUIsU0FBWCxDQUFxQmdjLE1BQU16YSxDQUFOLENBQXJCLElBQWtDeXdCLFdBQVdoeUIsU0FBWCxDQUFxQmdjLE1BQU16YSxDQUFOLENBQXJCLENBQWxDO0tBREYsTUFFTztpQkFDTXlhLE1BQU16YSxDQUFOLENBQVgsSUFBdUJ5d0IsV0FBV2h5QixTQUFYLENBQXFCZ2MsTUFBTXphLENBQU4sQ0FBckIsQ0FBdkI7OztDQU5OOztBQVdBNUIsT0FBT3F5QixVQUFQLEdBQW9CQSxVQUFwQjs7QUN6RUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBRUEsSUFBTXhiLFNBQVMsU0FBVEEsTUFBUyxHQUFNOzs7Ozs7Ozs7TUFTYjRDLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkF5REcsS0F6REg7Ozs7Ozs7Ozs7OztnQkFxRUUsc0JBQVc7YUFDZCxLQUFLa1osV0FBTCxFQUFQO0tBdEVROzs7Ozs7Ozs7Ozs7aUJBbUZHLHVCQUFXO2FBQ2YsQ0FBQyxLQUFLQyxVQUFMLEVBQVI7S0FwRlE7O1dBdUZILGlCQUFXO2VBQ1A3cUIsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQThDLEtBQUt3SSxtQkFBTCxDQUF5QjVKLElBQXpCLENBQThCLElBQTlCLENBQTlDLEVBQW1GLEtBQW5GOztVQUVJLGlCQUFpQjNHLE1BQXJCLEVBQTZCO2VBQ3BCK0gsZ0JBQVAsQ0FBd0IsbUJBQXhCLEVBQTZDLEtBQUs4cUIsb0JBQUwsQ0FBMEJsc0IsSUFBMUIsQ0FBK0IsSUFBL0IsQ0FBN0MsRUFBbUYsS0FBbkY7T0FERixNQUVPO2VBQ0VvQixnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLK3FCLFNBQUwsQ0FBZW5zQixJQUFmLENBQW9CLElBQXBCLENBQWxDLEVBQTZELEtBQTdEOzs7V0FHR2dzQixXQUFMLEdBQW1CLFlBQVc7ZUFDckIzeUIsT0FBTyt5QixXQUFQLEdBQXFCL3lCLE9BQU9nekIsVUFBbkM7T0FERjs7YUFJTyxJQUFQO0tBcEdROzt5QkF1R1csK0JBQVc7V0FDekJDLGdDQUFMO1dBQ0tDLElBQUwsQ0FBVSxRQUFWLEVBQW9CLEVBQUNOLFlBQVksS0FBS0EsVUFBTCxFQUFiLEVBQXBCO0tBekdROztzQ0E0R3dCLDRDQUFXO1VBQ3JDQSxhQUFhNXlCLE9BQU9nekIsVUFBUCxHQUFvQmh6QixPQUFPK3lCLFdBQTlDOztVQUVJLEVBQUUsaUJBQWlCL3lCLE1BQW5CLENBQUosRUFBZ0M7YUFDekIyeUIsV0FBTCxHQUFtQixZQUFXO2lCQUNyQjN5QixPQUFPK3lCLFdBQVAsR0FBcUIveUIsT0FBT2d6QixVQUFuQztTQURGO09BREYsTUFJTyxJQUFJaHpCLE9BQU9tekIsV0FBUCxHQUFxQixHQUFyQixLQUE2QixDQUFqQyxFQUFvQzthQUNwQ1IsV0FBTCxHQUFtQixZQUFXO2lCQUNyQnhZLEtBQUt3SixHQUFMLENBQVMzakIsT0FBT216QixXQUFQLEdBQXFCLEdBQTlCLE1BQXVDLENBQXZDLEdBQTJDUCxVQUEzQyxHQUF3RCxDQUFDQSxVQUFoRTtTQURGO09BREssTUFJQTthQUNBRCxXQUFMLEdBQW1CLFlBQVc7aUJBQ3JCeFksS0FBS3dKLEdBQUwsQ0FBUzNqQixPQUFPbXpCLFdBQVAsR0FBcUIsR0FBOUIsTUFBdUMsRUFBdkMsR0FBNENQLFVBQTVDLEdBQXlELENBQUNBLFVBQWpFO1NBREY7O0tBeEhNOzswQkE4SFksZ0NBQVc7OztVQUN6QkEsYUFBYSxLQUFLRCxXQUFMLEVBQW5COzs7O1VBSUlTLFFBQVEsQ0FBWjtVQUNNQyxXQUFXQyxZQUFZLFlBQU07OztZQUczQkMsSUFBSXZ6QixPQUFPZ3pCLFVBQWpCO1lBQ01RLElBQUl4ekIsT0FBTyt5QixXQUFqQjs7WUFFS0gsY0FBY1csS0FBS0MsQ0FBcEIsSUFDQSxDQUFDWixVQUFELElBQWVXLEtBQUtDLENBRHhCLEVBQzRCO2dCQUNyQk4sSUFBTCxDQUFVLFFBQVYsRUFBb0IsRUFBQ04sWUFBWUEsVUFBYixFQUFwQjt3QkFDY1MsUUFBZDtTQUhGLE1BSU8sSUFBSUQsVUFBVSxFQUFkLEVBQWtCO2dCQUNsQkYsSUFBTCxDQUFVLFFBQVYsRUFBb0IsRUFBQ04sWUFBWUEsVUFBYixFQUFwQjt3QkFDY1MsUUFBZDs7T0FaYSxFQWNkLEVBZGMsQ0FBakI7S0FwSVE7OztlQXNKQyxxQkFBVztXQUNmSCxJQUFMLENBQVUsUUFBVixFQUFvQixFQUFDTixZQUFZLEtBQUtBLFVBQUwsRUFBYixFQUFwQjs7R0F2Sko7O2FBMkpXSCxLQUFYLENBQWlCaFosR0FBakI7O1NBRU9BLEdBQVA7Q0F0S0Y7O0FBeUtBLGtCQUFlNUMsU0FBUzRjLEtBQVQsRUFBZjs7QUM1TEE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQSxlQUFlOzs7Ozs7Ozs7Ozs7OztPQWNSLGFBQUMxeUIsT0FBRDtzQ0FBYTJ5QixTQUFiO2VBQUE7OztXQUEyQkEsVUFBVXh5QixPQUFWLENBQWtCO2FBQVlOLE9BQUtxTixXQUFMLENBQWlCbE4sT0FBakIsRUFBMEIwTixRQUExQixDQUFaO0tBQWxCLENBQTNCO0dBZFE7Ozs7Ozs7Ozs7Ozs7O1VBNEJMLGdCQUFDMU4sT0FBRDt1Q0FBYTJ5QixTQUFiO2VBQUE7OztXQUEyQkEsVUFBVXh5QixPQUFWLENBQWtCO2FBQVlOLE9BQUtvTixjQUFMLENBQW9Cak4sT0FBcEIsRUFBNkIwTixRQUE3QixDQUFaO0tBQWxCLENBQTNCO0dBNUJLOzs7Ozs7Ozs7Ozs7Ozs7OztZQTZDSDdOLE9BQUs0TSxXQTdDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7VUE4REw1TSxPQUFLOFg7Q0E5RGY7O0FDaENBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUdBLElBQU1pYixtQkFBbUIsSUFBSXRCLFVBQUosRUFBekI7QUFDQXNCLGlCQUFpQkMsUUFBakIsR0FBNEIsS0FBNUI7O0FBRUEsSUFBTUMsU0FBUyxTQUFUQSxNQUFTLEdBQU07bUJBQ0ZELFFBQWpCLEdBQTRCLElBQTVCO21CQUNpQlYsSUFBakIsQ0FBc0IsTUFBdEI7Q0FGRjs7QUFLQSxJQUFNWSxTQUFTLFNBQVRBLE1BQVMsR0FBTTttQkFDRkYsUUFBakIsR0FBNEIsS0FBNUI7bUJBQ2lCVixJQUFqQixDQUFzQixNQUF0QjtDQUZGOztBQUtBLElBQU1hLGFBQWEsU0FBYkEsVUFBYSxHQUFNO01BQ25CLE9BQU9DLFFBQVAsS0FBb0IsV0FBeEIsRUFBcUM7O2FBRTFCQyxNQUFULEdBQWtCSixNQUFsQjthQUNTSyxNQUFULEdBQWtCSixNQUFsQjtxQkFDaUJaLElBQWpCLENBQXNCLE1BQXRCLEVBQThCLEVBQUNpQixTQUFTSCxTQUFTSSxTQUFuQixFQUE5Qjs7V0FFTyxJQUFQO0dBTkYsTUFPTyxJQUFJLE9BQU9yeEIsUUFBUThlLE9BQWYsS0FBMkIsV0FBM0IsSUFBMEMsT0FBTzllLFFBQVE4ZSxPQUFSLENBQWdCbVMsUUFBdkIsS0FBb0MsV0FBbEYsRUFBK0Y7O1dBRTdGanNCLGdCQUFQLENBQXdCLHFCQUF4QixFQUErQzhyQixNQUEvQztXQUNPOXJCLGdCQUFQLENBQXdCLHFCQUF4QixFQUErQytyQixNQUEvQztxQkFDaUJaLElBQWpCLENBQXNCLE1BQXRCLEVBQThCLEVBQUNpQixTQUFTcHhCLFFBQVE4ZSxPQUFSLENBQWdCbVMsUUFBaEIsQ0FBeUJJLFNBQW5DLEVBQTlCOztXQUVPLElBQVA7OztTQUdLLEtBQVA7Q0FqQkY7O0FBb0JBLElBQU1DLGdCQUFnQixTQUFoQkEsYUFBZ0IsR0FBTTtTQUNyQmp6QixJQUFMLENBQVUsdURBQVY7Q0FERjs7QUFJQWxCLFNBQVM2SCxnQkFBVCxDQUEwQixhQUExQixFQUF5QyxZQUFNO01BQ3pDLENBQUNnc0IsWUFBTCxFQUFtQjtRQUNiN3pCLFNBQVNvSSxhQUFULENBQXVCLHVCQUF2QixLQUNGcEksU0FBU29JLGFBQVQsQ0FBdUIseUJBQXZCLENBREYsRUFDcUQ7Ozs7cUJBSXBDNlMsRUFBakIsR0FBc0JrWixhQUF0Qjs7Q0FQSjs7QUN6REE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBQU1DLGFBQWMsWUFBVztNQUN6QjF5QixJQUFJLENBQVI7U0FDTyxZQUFXO1dBQ1RBLEdBQVA7R0FERjtDQUZpQixFQUFuQjs7Ozs7Ozs7O0lBYXFCMnlCO3NCQUVPO1FBQWRsb0IsT0FBYyx1RUFBSixFQUFJOzs7U0FDbkJtb0IsU0FBTCxHQUFpQixFQUFqQjtTQUNLQyxTQUFMLEdBQWlCLEVBQWpCO1NBQ0tDLElBQUwsR0FBWXJvQixRQUFRc29CLEdBQVIsSUFBZSxZQUFXLEVBQXRDOzs7Ozs7Ozs7Ozs7MkJBUUs7OztVQUNDQyxTQUFTLFNBQVRBLE1BQVMsR0FBTTtjQUNkQyxPQUFMLENBQWFELE1BQWI7T0FERjthQUdPaGtCLEVBQVAsR0FBWTBqQixZQUFaO1dBQ0tFLFNBQUwsQ0FBZXh5QixJQUFmLENBQW9CNHlCLE1BQXBCO1dBQ0tGLElBQUwsQ0FBVSxXQUFZRSxPQUFPaGtCLEVBQTdCOzthQUVPZ2tCLE1BQVA7Ozs7NEJBR01qeUIsSUFBSTtVQUNKd04sUUFBUSxLQUFLcWtCLFNBQUwsQ0FBZXp5QixPQUFmLENBQXVCWSxFQUF2QixDQUFkO1VBQ0l3TixVQUFVLENBQUMsQ0FBZixFQUFrQjtjQUNWLElBQUlyTixLQUFKLENBQVUsbURBQVYsQ0FBTjs7O1dBR0cweEIsU0FBTCxDQUFlcGtCLE1BQWYsQ0FBc0JELEtBQXRCLEVBQTZCLENBQTdCO1dBQ0t1a0IsSUFBTCxDQUFVLGFBQWEveEIsR0FBR2lPLEVBQTFCOztXQUVLa2tCLGtCQUFMOzs7O3lDQUdtQjthQUNaLENBQUMsS0FBS0MsUUFBTCxFQUFELElBQW9CLEtBQUtOLFNBQUwsQ0FBZTV5QixNQUFmLEdBQXdCLENBQW5ELEVBQXNEO2FBQy9DNHlCLFNBQUwsQ0FBZWpwQixLQUFmOzs7Ozs7Ozs7Ozs7K0JBU094RCxVQUFVO1VBQ2YsRUFBRUEsb0JBQW9CMkosUUFBdEIsQ0FBSixFQUFxQztjQUM3QixJQUFJN08sS0FBSixDQUFVLHdDQUFWLENBQU47OztVQUdFLEtBQUtpeUIsUUFBTCxFQUFKLEVBQXFCO2FBQ2ROLFNBQUwsQ0FBZXp5QixJQUFmLENBQW9CZ0csUUFBcEI7T0FERixNQUVPOzs7Ozs7Ozs7OzsrQkFRRTthQUNGLEtBQUt3c0IsU0FBTCxDQUFlM3lCLE1BQWYsR0FBd0IsQ0FBL0I7Ozs7OztBQzdGSjs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxBQUdBO0FBQ0EsU0FBU216QixRQUFULE9BQStDN1csSUFBL0MsRUFBcUQ7TUFBbEM3VSxJQUFrQyxRQUFsQ0EsSUFBa0M7TUFBNUJ5RyxNQUE0QixRQUE1QkEsTUFBNEI7eUJBQXBCbU0sTUFBb0I7O2FBQzFDL1EsZ0JBQVQsQ0FBMEI3QixJQUExQixFQUFnQ3VsQixJQUFoQyxDQUFxQyxnQkFBUTtRQUNyQ29HLGNBQWNyMEIsT0FBSzJHLGFBQUwsQ0FBbUJJLElBQW5CLENBQXBCO1dBQ09nRCxXQUFQLENBQW1Cc3FCLFdBQW5COztTQUVLQSxXQUFMO0dBSkY7OztBQVFGLFNBQVNDLFVBQVQsQ0FBb0JuMEIsT0FBcEIsRUFBNkI7TUFDdkJBLFFBQVFvMEIsUUFBUixZQUE0QnhqQixRQUFoQyxFQUEwQztZQUNoQ3dqQixRQUFSO0dBREYsTUFFTztZQUNHM2xCLE1BQVI7Ozs7QUFJSixJQUFhNGxCLFVBQWI7Ozs7c0JBSWNDLE1BQVosRUFBb0JDLFFBQXBCLEVBQThCOzs7U0FDdkJDLE9BQUwsR0FBZUYsa0JBQWtCMWpCLFFBQWxCLEdBQTZCMGpCLE1BQTdCLEdBQXNDTCxRQUFyRDtTQUNLUSxTQUFMLEdBQWlCRixvQkFBb0IzakIsUUFBcEIsR0FBK0IyakIsUUFBL0IsR0FBMENKLFVBQTNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBdUJnQy9XLElBN0JwQyxFQTZCMEM7VUFBbEM3VSxJQUFrQyxTQUFsQ0EsSUFBa0M7VUFBNUJ5RyxNQUE0QixTQUE1QkEsTUFBNEI7K0JBQXBCbU0sTUFBb0I7VUFBcEJBLE1BQW9CLGdDQUFYLEVBQVc7O1dBQ2pDcVosT0FBTCxDQUFhLEVBQUNqc0IsVUFBRCxFQUFPeUcsY0FBUCxFQUFlbU0sY0FBZixFQUFiLEVBQXFDLHVCQUFlO1lBQzlDLEVBQUUrWSx1QkFBdUJRLE9BQXpCLENBQUosRUFBdUM7Z0JBQy9CM3lCLE1BQU0sNkNBQU4sQ0FBTjs7O2FBR0dteUIsV0FBTDtPQUxGOzs7OzJCQVNLQSxXQXZDVCxFQXVDc0I7VUFDZCxFQUFFQSx1QkFBdUJRLE9BQXpCLENBQUosRUFBdUM7Y0FDL0IzeUIsTUFBTSw2Q0FBTixDQUFOOzs7V0FHRzB5QixTQUFMLENBQWVQLFdBQWY7Ozs7eUJBaENpQnR5QixFQVpyQixFQVl5QjtVQUNqQixFQUFFQSxjQUFjZ1AsUUFBaEIsQ0FBSixFQUErQjtjQUN2QjdPLE1BQU0saURBQU4sQ0FBTjs7V0FFR3l5QixPQUFMLEdBQWU1eUIsRUFBZjtLQWhCSjsyQkFtQnVCO2FBQ1osS0FBSzR5QixPQUFaOzs7Ozs7QUE0QkosQUFBTyxJQUFNRyxvQkFBb0IsSUFBSU4sVUFBSixFQUExQjs7QUFFUCxBQUFPLElBQU1PLG9CQUFvQixJQUFJUCxVQUFKLENBQy9CLGlCQUFzQ2pYLElBQXRDLEVBQTRDO01BQWxDN1UsSUFBa0MsU0FBbENBLElBQWtDO01BQTVCeUcsTUFBNEIsU0FBNUJBLE1BQTRCOzJCQUFwQm1NLE1BQW9COztNQUNwQ25iLFVBQVVILE9BQUsyRyxhQUFMLENBQW1CK0IsS0FBSzdHLElBQUwsRUFBbkIsQ0FBaEI7U0FDT2tJLFdBQVAsQ0FBbUI1SixPQUFuQjs7T0FFS0EsT0FBTDtDQUw2QixFQU8vQm0wQixVQVArQixDQUExQjs7QUN2RlA7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBZ0JBOzs7Ozs7O0FBT0EsSUFBTVUsUUFBTTtnQkFBQTtzQ0FBQTt1QkFBQTtrQ0FBQTtvQkFBQTs0QkFBQTswQkFBQTtrREFBQTt3QkFBQTtvQkFBQTtvQ0FBQTtjQVlFcmQsU0FaRjthQWFDblIsVUFiRDtjQWNFLElBQUltdEIsUUFBSixFQWRGO1NBZUgzekI7Q0FmVDs7QUFrQkFnMUIsTUFBSXB6QixRQUFKLENBQWFxekIsTUFBYixDQUFvQixDQUFDNzFCLE9BQU84MUIsUUFBUCxDQUFnQkMsTUFBaEIsQ0FBdUJ0MUIsS0FBdkIsQ0FBNkIsbUJBQTdCLEtBQXFELEVBQXRELEVBQTBELENBQTFELENBQXBCOztBQUVBdTFCOztBQUVBLElBQU1DLGFBQWEsU0FBYkEsVUFBYTtTQUFTcjFCLE9BQUswRSxLQUFMLGtDQUF5QzR3QixRQUFRLE9BQVIsR0FBa0IsUUFBM0QsNkJBQVQ7Q0FBbkI7Ozs7Ozs7Ozs7OztBQVlBTixNQUFJTyxPQUFKLEdBQWMsWUFBTTtTQUNYLENBQUNQLE1BQUlRLFVBQUosQ0FBZXJCLFFBQWYsRUFBUjtDQURGOzs7Ozs7Ozs7Ozs7QUFjQWEsTUFBSXp1QixTQUFKLEdBQWdCeXVCLE1BQUlwekIsUUFBSixDQUFhMkUsU0FBN0I7Ozs7Ozs7Ozs7OztBQVlBeXVCLE1BQUlTLEtBQUosR0FBWSxvQkFBWTtNQUNsQlQsTUFBSU8sT0FBSixFQUFKLEVBQW1COztHQUFuQixNQUVPO1VBQ0RDLFVBQUosQ0FBZUUsVUFBZixDQUEwQnR1QixRQUExQjs7Q0FKSjs7Ozs7Ozs7Ozs7O0FBa0JBNHRCLE1BQUlXLGtDQUFKLEdBQXlDLFVBQVNDLFFBQVQsRUFBbUI7TUFDdEQsQ0FBQ1osTUFBSU8sT0FBSixFQUFMLEVBQW9CO2VBQ1AsSUFBWDs7UUFFRU0sK0JBQUosQ0FBb0NDLFdBQXBDLENBQWdERixRQUFoRDtDQUpGOzs7Ozs7Ozs7QUFjQVosTUFBSWUsOEJBQUosR0FBcUMsWUFBVztNQUMxQyxDQUFDZixNQUFJTyxPQUFKLEVBQUwsRUFBb0I7ZUFDUCxJQUFYOzthQUVPaGpCLGFBQVQsQ0FBdUJ5akIsT0FBdkI7Q0FKRjs7Ozs7Ozs7O0FBY0FoQixNQUFJaUIsNkJBQUosR0FBb0MsWUFBVztNQUN6QyxDQUFDakIsTUFBSU8sT0FBSixFQUFMLEVBQW9CO2VBQ1AsSUFBWDs7YUFFT2hqQixhQUFULENBQXVCdEIsTUFBdkI7Q0FKRjs7QUFPQStqQixNQUFJa0IseUJBQUosR0FBZ0MsWUFBVzthQUNoQzNqQixhQUFULENBQXVCMmpCLHlCQUF2QjtDQURGOzs7Ozs7Ozs7QUFXQWxCLE1BQUltQix1QkFBSixHQUE4QixZQUFNO01BQzlCbkIsTUFBSU8sT0FBSixFQUFKLEVBQW1CO2VBQ04sS0FBWDs7YUFFTzl1QixNQUFULENBQWdCSSxpQkFBaEIsR0FBb0MsSUFBcEM7Q0FKRjs7Ozs7Ozs7O0FBY0FtdUIsTUFBSW9CLHdCQUFKLEdBQStCLFlBQU07TUFDL0JwQixNQUFJTyxPQUFKLEVBQUosRUFBbUI7ZUFDTixLQUFYOzthQUVPOXVCLE1BQVQsQ0FBZ0JJLGlCQUFoQixHQUFvQyxLQUFwQztDQUpGOzs7Ozs7Ozs7QUFjQW11QixNQUFJcUIsYUFBSixHQUFvQixZQUFNO01BQ3BCckIsTUFBSU8sT0FBSixFQUFKLEVBQW1CO2VBQ04sS0FBWDs7O01BR0llLE9BQU8sU0FBUEEsSUFBTyxHQUFNO1FBQ2IsQ0FBQ2gzQixTQUFTbUksSUFBVCxDQUFjK0osUUFBZCxDQUF1QixDQUF2QixDQUFELElBQThCLENBQUNsUyxTQUFTbUksSUFBVCxDQUFjK0osUUFBZCxDQUF1QixDQUF2QixFQUEwQmhELFNBQTFCLENBQW9DNkcsUUFBcEMsQ0FBNkMscUJBQTdDLENBQW5DLEVBQXdHO1VBQ2hHNUksVUFBVTdLLFNBQVN5QyxTQUFULEVBQWhCO1VBQXNDckQsSUFBSTs4QkFBa0JBLEdBQUVMLEtBQUYsQ0FBUSxHQUFSLEVBQWEsQ0FBYixDQUFsQixTQUFxQ0ssRUFBckM7T0FBMUM7VUFDTWlSLE9BQU94RixVQUFhekwsRUFBRSxjQUFGLENBQWIsU0FBa0NBLEVBQUUsa0JBQUYsQ0FBbEMsZUFBc0VBLEVBQUUsU0FBRixDQUFuRjtVQUNFaW5CLFNBQVN4YixVQUFVLEVBQVYsR0FBZSxVQUQxQjtVQUVFeUYsUUFBUXpGLFVBQWF6TCxFQUFFLGNBQUYsQ0FBYixTQUFrQ0EsRUFBRSxXQUFGLENBQWxDLFNBQW9EQSxFQUFFLGNBQUYsQ0FBcEQsMEJBQTBGQSxFQUFFLDJCQUFGLENBRnBHOztlQUlTeUcsSUFBVCxDQUFjMFIsWUFBZCxDQUEyQm5aLE9BQUsyRyxhQUFMLENBQ3pCLHNDQUFtQzhGLFVBQVUsU0FBVixHQUFzQixLQUF6RCxzQkFDVXdGLElBRFYsbUJBQzRCZ1csTUFENUIsbUJBQ2dEL1YsS0FEaEQsdUJBRHlCLENBQTNCLEVBSUc1UyxTQUFTbUksSUFBVCxDQUFjMlIsVUFKakI7O0dBUEo7O1dBZVMzUixJQUFULEdBQ0k2dUIsTUFESixHQUVJOXZCLFdBQVNRLG9CQUFULENBQThCc3ZCLElBQTlCLENBRko7Q0FwQkY7Ozs7Ozs7OztBQWdDQXRCLE1BQUl1QixpQkFBSixHQUF3QixZQUFNO2FBQ25COXZCLE1BQVQsQ0FBZ0J3RixrQkFBaEIsR0FBcUMsSUFBckM7Q0FERjs7Ozs7Ozs7O0FBV0Erb0IsTUFBSXdCLGdCQUFKLEdBQXVCLFlBQU07YUFDbEIvdkIsTUFBVCxDQUFnQndGLGtCQUFoQixHQUFxQyxLQUFyQztDQURGOztBQUlBK29CLE1BQUl5QixnQkFBSixHQUF1QixZQUFNO2FBQ2xCaHdCLE1BQVQsQ0FBZ0JtVCxnQkFBaEIsR0FBbUMsSUFBbkM7Q0FERjs7QUFJQW9iLE1BQUkwQixlQUFKLEdBQXNCLFlBQU07YUFDakJqd0IsTUFBVCxDQUFnQm1ULGdCQUFoQixHQUFtQyxLQUFuQztDQURGOzs7Ozs7Ozs7QUFXQW9iLE1BQUkyQixrQkFBSixHQUF5QmhmLFVBQVVxZSxPQUFuQzs7Ozs7Ozs7O0FBU0FoQixNQUFJNEIsaUJBQUosR0FBd0JqZixVQUFVMUcsTUFBbEM7Ozs7Ozs7OztBQVNBK2pCLE1BQUk2QixxQkFBSixHQUE0QixZQUFNO1NBQzNCOWIsa0JBQUwsQ0FBd0IsTUFBeEI7Y0FDUytiLElBQVQsQ0FBY0MsYUFBZCxDQUE0QixLQUE1QjtDQUZGOzs7Ozs7Ozs7O0FBYUEvQixNQUFJdmEsdUJBQUosR0FBOEIsWUFBa0I7TUFBakJqTixLQUFpQix1RUFBVCxJQUFTOzthQUNyQy9HLE1BQVQsQ0FBZ0JnVSx1QkFBaEIsR0FBMENqTixLQUExQztDQURGOzs7Ozs7Ozs7O0FBWUF3bkIsTUFBSWdDLG9CQUFKLEdBQTJCLHVCQUFlO1FBQ3BDSixpQkFBSjtRQUNJaDFCLFFBQUosQ0FBYXF6QixNQUFiLENBQW9CZ0MsZUFBZSxLQUFuQzs7UUFFSUMsS0FBSixDQUFVdnRCLFNBQVYsQ0FBb0JySyxTQUFTZ0osZ0JBQVQsQ0FBMEIsR0FBMUIsQ0FBcEIsRUFDR2hJLE9BREgsQ0FDVyxVQUFTSCxPQUFULEVBQWtCO1FBQ3JCQSxRQUFRd00sT0FBUixDQUFnQjdLLFdBQWhCLE9BQWtDLFFBQXRDLEVBQWdEO2NBQ3RDcTFCLGVBQVI7S0FERixNQUVPLElBQUloM0IsUUFBUXdNLE9BQVIsQ0FBZ0I5TSxLQUFoQixDQUFzQixRQUF0QixDQUFKLEVBQXFDO2dCQUNoQzhOLE9BQVYsQ0FBa0J4TixPQUFsQixFQUEyQixJQUEzQjtVQUNJQSxRQUFRd00sT0FBUixDQUFnQjdLLFdBQWhCLE9BQWtDLFlBQXRDLEVBQW9EO2dCQUMxQ3MxQixlQUFSOzs7R0FQUjtDQUpGOzs7Ozs7Ozs7Ozs7Ozs7QUE4QkFwQyxNQUFJcUMsT0FBSixHQUFjLFlBQXlCO01BQWhCaHZCLFNBQWdCLHVFQUFKLEVBQUk7O1NBQzlCTSxRQUFRMnVCLEdBQVIsQ0FBWSxDQUFDanZCLHFCQUFxQjdJLEtBQXJCLEdBQTZCNkksU0FBN0IsR0FBeUMsQ0FBQ0EsU0FBRCxDQUExQyxFQUF1RHhDLEdBQXZELENBQTJELG9CQUFZO1FBQ3BGLE9BQU9nQyxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO2FBQzNCbkQsS0FBTCxDQUFXLCtDQUE4Q21ELFFBQTlDLHlDQUE4Q0EsUUFBOUMsRUFBWDs7V0FFS3JCLFdBQVNpQyxvQkFBVCxDQUE4QlosUUFBOUIsQ0FBUDtHQUppQixDQUFaLENBQVA7Q0FERjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JBbXRCLE1BQUlydUIsYUFBSixHQUFvQixVQUFDa0IsUUFBRCxFQUE0QjtNQUFqQjRELE9BQWlCLHVFQUFQLEVBQU87O2FBQ25DNUQsU0FBU2hHLElBQVQsRUFBWDs7TUFFTW9VLFNBQVMsU0FBVEEsTUFBUyxPQUFRO1FBQ2Y5VixVQUFVNjBCLE1BQUlrQyxLQUFKLENBQVV2d0IsYUFBVixDQUF3QkksSUFBeEIsQ0FBaEI7WUFDUTZILE1BQVI7O1FBRUluRCxRQUFROHJCLE1BQVosRUFBb0I7VUFDWnh2QixTQUFTMEQsUUFBUThyQixNQUFSLFlBQTBCLzFCLFdBQTFCLEdBQXdDaUssUUFBUThyQixNQUFoRCxHQUF5RGo0QixTQUFTbUksSUFBakY7YUFDTzBSLFlBQVAsQ0FBb0JoWixPQUFwQixFQUE2QnNMLFFBQVEwTixZQUFSLElBQXdCLElBQXJEO2NBQ1FxZSxJQUFSLFlBQXdCem1CLFFBQXhCLElBQW9DdEYsUUFBUStyQixJQUFSLENBQWFyM0IsT0FBYixDQUFwQzs7O1dBR0tBLE9BQVA7R0FWRjs7U0FhTzBILFNBQVN2QyxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQXZCLEdBQTZCMlEsT0FBT3BPLFFBQVAsQ0FBN0IsR0FBZ0RyQixXQUFTK0QsZ0JBQVQsQ0FBMEIxQyxRQUExQixFQUFvQ29tQixJQUFwQyxDQUF5Q2hZLE1BQXpDLENBQXZEO0NBaEJGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNFQStlLE1BQUl5QyxhQUFKLEdBQW9CekMsTUFBSTBDLFlBQUosR0FBbUIxQyxNQUFJMkMsaUJBQUosR0FBd0IsVUFBQzl2QixRQUFEO01BQVc0RCxPQUFYLHVFQUFxQixFQUFyQjtTQUE0QnVwQixNQUFJcnVCLGFBQUosQ0FBa0JrQixRQUFsQixhQUE4QjB2QixRQUFRLElBQXRDLElBQStDOXJCLE9BQS9DLEVBQTVCO0NBQS9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0F1cEIsTUFBSTRDLGVBQUosR0FBc0IxRyxXQUF0Qjs7Ozs7Ozs7Ozs7O0FBWUE4RCxNQUFJNkMseUJBQUosR0FBZ0MsVUFBQ252QixJQUFELEVBQU84dUIsSUFBUCxFQUFnQjtNQUN4Q3ZxQixXQUFXK25CLE1BQUlrQyxLQUFKLENBQVV2dEIsU0FBVixDQUFvQnZLLE9BQU9FLFFBQVAsQ0FBZ0JnSixnQkFBaEIsQ0FBaUMsMkJBQWpDLENBQXBCLENBQWpCO01BQ0kyRSxTQUFTaE0sTUFBVCxLQUFvQixDQUF4QixFQUEyQjtXQUNwQnlELEtBQUwsQ0FBVyxtQ0FBWDs7O1dBSUNzSyxNQURILENBQ1U7V0FBVyxDQUFDN08sUUFBUWtCLFlBQVIsQ0FBcUIsTUFBckIsQ0FBWjtHQURWLEVBRUdmLE9BRkgsQ0FFVyxtQkFBVztZQUNWME0sWUFBUixDQUFxQix5QkFBckIsRUFBZ0R0RSxJQUFoRDtVQUNJb3ZCLDBCQUFKLENBQStCMzNCLE9BQS9CLEVBQXdDdUksSUFBeEMsRUFBOEM4dUIsSUFBOUM7R0FKSjtDQU5GOztBQWVBeEMsTUFBSStDLHlCQUFKLEdBQWdDLFlBQVc7UUFDckN0QyxLQUFKLENBQVUsWUFBTTtRQUNSeG9CLFdBQVcrbkIsTUFBSWtDLEtBQUosQ0FBVXZ0QixTQUFWLENBQW9CdkssT0FBT0UsUUFBUCxDQUFnQmdKLGdCQUFoQixDQUFpQywyQkFBakMsQ0FBcEIsQ0FBakI7O2FBRVNoSSxPQUFULENBQWlCLG1CQUFXO1VBQ3BCb0ksT0FBT3ZJLFFBQVFrQixZQUFSLENBQXFCLHlCQUFyQixDQUFiO1VBQ0ksT0FBT3FILElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7Y0FDeEJvdkIsMEJBQUosQ0FBK0IzM0IsT0FBL0IsRUFBd0N1SSxJQUF4Qzs7S0FISjtHQUhGO0NBREY7O0FBYUFzc0IsTUFBSThDLDBCQUFKLEdBQWlDLFVBQVMzb0IsTUFBVCxFQUFpQnpHLElBQWpCLEVBQXNEO01BQS9COHVCLElBQStCLHVFQUF2QixVQUFDMXRCLEVBQUQsRUFBS3lULElBQUw7V0FBY0EsTUFBZDtHQUF1Qjs7VUFDN0V5WCxNQUFJcnVCLGFBQUosQ0FBa0IrQixJQUFsQixFQUNMdWxCLElBREssQ0FDQSxtQkFBVztZQUNQN3RCLEtBQVIsQ0FBY3NSLE9BQWQsR0FBd0IsTUFBeEI7V0FDTzNILFdBQVAsQ0FBbUI1SixPQUFuQjtTQUNLQSxPQUFMLEVBQWMsWUFBTTthQUNYZ1AsT0FBT2lLLFVBQVAsSUFBcUJqSyxPQUFPaUssVUFBUCxLQUFzQmpaLE9BQWxELEVBQTJEO2VBQ2xENjNCLFdBQVAsQ0FBbUI3b0IsT0FBT2lLLFVBQTFCOztjQUVNaFosS0FBUixDQUFjc1IsT0FBZCxHQUF3QixFQUF4QjtLQUpGO0dBSkksRUFXTC9HLEtBWEssQ0FXQztXQUFTaEMsUUFBUUUsTUFBUixDQUFlLHFDQUFxQ3BFLEtBQXBELENBQVQ7R0FYRCxDQUFSO0NBREY7O0FBZUEsU0FBUzJ3QixlQUFULEdBQTJCO01BQ25CNkMsb0JBQW9CakQsTUFBSVEsVUFBSixDQUFlMEMsSUFBZixFQUExQjtTQUNPL3dCLGdCQUFQLENBQXdCLGtCQUF4QixFQUE0QyxZQUFNO1FBQzVDNnRCLE1BQUl6dUIsU0FBSixFQUFKLEVBQXFCO2FBQ1pqSCxRQUFQLENBQWdCNkgsZ0JBQWhCLENBQWlDLGFBQWpDLEVBQWdEOHdCLGlCQUFoRCxFQUFtRSxLQUFuRTtLQURGLE1BRU87OztHQUhULEVBTUcsS0FOSDs7Ozs7Ozs7Ozs7OztBQW1CRixJQUFNRSxRQUFRLG1CQUFtQjc0QixRQUFuQixHQUE4QjtTQUFNQSxTQUFTODRCLGFBQWY7Q0FBOUIsR0FBNkQ7U0FBTTk0QixTQUFTKzRCLE9BQVQsQ0FBaUIvNEIsU0FBUys0QixPQUFULENBQWlCcDNCLE1BQWpCLEdBQTBCLENBQTNDLENBQU47Q0FBM0U7QUFDQSt6QixNQUFJc0QsYUFBSixHQUFvQjtTQUFNSCxXQUFXLFlBQVk3MUIsSUFBWixDQUFpQjYxQixRQUFROWYsYUFBUixDQUFzQjFMLE9BQXZDLENBQVgsSUFBOER3ckIsUUFBUTlmLGFBQXRFLElBQXVGLElBQTdGO0NBQXBCOzs7Ozs7O0NDaGlCRSxhQUFZO1dBc0JKa2dCLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCL3NCLE9BQTFCLEVBQW1DO09BQzlCZ3RCLFVBQUo7O2FBRVVodEIsV0FBVyxFQUFyQjs7Ozs7OztRQU9LaXRCLGFBQUwsR0FBcUIsS0FBckI7Ozs7Ozs7UUFRS0Msa0JBQUwsR0FBMEIsQ0FBMUI7Ozs7Ozs7UUFRS3pwQixhQUFMLEdBQXFCLElBQXJCOzs7Ozs7O1FBUUswcEIsV0FBTCxHQUFtQixDQUFuQjs7Ozs7OztRQVFLQyxXQUFMLEdBQW1CLENBQW5COzs7Ozs7O1FBUUtDLG1CQUFMLEdBQTJCLENBQTNCOzs7Ozs7O1FBUUtDLGFBQUwsR0FBcUJ0dEIsUUFBUXN0QixhQUFSLElBQXlCLEVBQTlDOzs7Ozs7O1FBUUtQLEtBQUwsR0FBYUEsS0FBYjs7Ozs7OztRQU9LUSxRQUFMLEdBQWdCdnRCLFFBQVF1dEIsUUFBUixJQUFvQixHQUFwQzs7Ozs7OztRQU9LQyxVQUFMLEdBQWtCeHRCLFFBQVF3dEIsVUFBUixJQUFzQixHQUF4Qzs7T0FFSVYsVUFBVVcsU0FBVixDQUFvQlYsS0FBcEIsQ0FBSixFQUFnQzs7Ozs7WUFLdkJ6eUIsSUFBVCxDQUFjb3pCLE1BQWQsRUFBc0J2WCxPQUF0QixFQUErQjtXQUN2QixZQUFXO1lBQVN1WCxPQUFPN25CLEtBQVAsQ0FBYXNRLE9BQWIsRUFBc0I1QyxTQUF0QixDQUFQO0tBQXBCOzs7T0FJR29hLFVBQVUsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixjQUF2QixFQUF1QyxhQUF2QyxFQUFzRCxZQUF0RCxFQUFvRSxlQUFwRSxDQUFkO09BQ0l4WCxVQUFVLElBQWQ7UUFDSyxJQUFJNWdCLElBQUksQ0FBUixFQUFXK1UsSUFBSXFqQixRQUFRbjRCLE1BQTVCLEVBQW9DRCxJQUFJK1UsQ0FBeEMsRUFBMkMvVSxHQUEzQyxFQUFnRDtZQUN2Q280QixRQUFRcDRCLENBQVIsQ0FBUixJQUFzQitFLEtBQUs2YixRQUFRd1gsUUFBUXA0QixDQUFSLENBQVIsQ0FBTCxFQUEwQjRnQixPQUExQixDQUF0Qjs7OztPQUlHeVgsZUFBSixFQUFxQjtVQUNkbHlCLGdCQUFOLENBQXVCLFdBQXZCLEVBQW9DLEtBQUtteUIsT0FBekMsRUFBa0QsSUFBbEQ7VUFDTW55QixnQkFBTixDQUF1QixXQUF2QixFQUFvQyxLQUFLbXlCLE9BQXpDLEVBQWtELElBQWxEO1VBQ01ueUIsZ0JBQU4sQ0FBdUIsU0FBdkIsRUFBa0MsS0FBS215QixPQUF2QyxFQUFnRCxJQUFoRDs7O1NBR0tueUIsZ0JBQU4sQ0FBdUIsT0FBdkIsRUFBZ0MsS0FBS295QixPQUFyQyxFQUE4QyxJQUE5QztTQUNNcHlCLGdCQUFOLENBQXVCLFlBQXZCLEVBQXFDLEtBQUtxeUIsWUFBMUMsRUFBd0QsS0FBeEQ7U0FDTXJ5QixnQkFBTixDQUF1QixXQUF2QixFQUFvQyxLQUFLc3lCLFdBQXpDLEVBQXNELEtBQXREO1NBQ010eUIsZ0JBQU4sQ0FBdUIsVUFBdkIsRUFBbUMsS0FBS3V5QixVQUF4QyxFQUFvRCxLQUFwRDtTQUNNdnlCLGdCQUFOLENBQXVCLGFBQXZCLEVBQXNDLEtBQUt3eUIsYUFBM0MsRUFBMEQsS0FBMUQ7Ozs7O09BS0ksQ0FBQ3RhLE1BQU01ZixTQUFOLENBQWdCbTZCLHdCQUFyQixFQUErQztVQUN4QzF5QixtQkFBTixHQUE0QixVQUFTMkMsSUFBVCxFQUFlekMsUUFBZixFQUF5Qm9OLE9BQXpCLEVBQWtDO1NBQ3pEcWxCLE1BQU01a0IsS0FBS3hWLFNBQUwsQ0FBZXlILG1CQUF6QjtTQUNJMkMsU0FBUyxPQUFiLEVBQXNCO1VBQ2pCbEssSUFBSixDQUFTNjRCLEtBQVQsRUFBZ0IzdUIsSUFBaEIsRUFBc0J6QyxTQUFTMHlCLFFBQVQsSUFBcUIxeUIsUUFBM0MsRUFBcURvTixPQUFyRDtNQURELE1BRU87VUFDRjdVLElBQUosQ0FBUzY0QixLQUFULEVBQWdCM3VCLElBQWhCLEVBQXNCekMsUUFBdEIsRUFBZ0NvTixPQUFoQzs7S0FMRjs7VUFTTXJOLGdCQUFOLEdBQXlCLFVBQVMwQyxJQUFULEVBQWV6QyxRQUFmLEVBQXlCb04sT0FBekIsRUFBa0M7U0FDdER1bEIsTUFBTTlrQixLQUFLeFYsU0FBTCxDQUFlMEgsZ0JBQXpCO1NBQ0kwQyxTQUFTLE9BQWIsRUFBc0I7VUFDakJsSyxJQUFKLENBQVM2NEIsS0FBVCxFQUFnQjN1QixJQUFoQixFQUFzQnpDLFNBQVMweUIsUUFBVCxLQUFzQjF5QixTQUFTMHlCLFFBQVQsR0FBb0IsVUFBU3BwQixLQUFULEVBQWdCO1dBQzNFLENBQUNBLE1BQU1zcEIsa0JBQVgsRUFBK0I7aUJBQ3JCdHBCLEtBQVQ7O09BRm9CLENBQXRCLEVBSUk4RCxPQUpKO01BREQsTUFNTztVQUNGN1UsSUFBSixDQUFTNjRCLEtBQVQsRUFBZ0IzdUIsSUFBaEIsRUFBc0J6QyxRQUF0QixFQUFnQ29OLE9BQWhDOztLQVRGOzs7Ozs7T0FpQkcsT0FBT2drQixNQUFNeEksT0FBYixLQUF5QixVQUE3QixFQUF5Qzs7OztpQkFJM0J3SSxNQUFNeEksT0FBbkI7VUFDTTdvQixnQkFBTixDQUF1QixPQUF2QixFQUFnQyxVQUFTdUosS0FBVCxFQUFnQjtnQkFDcENBLEtBQVg7S0FERCxFQUVHLEtBRkg7VUFHTXNmLE9BQU4sR0FBZ0IsSUFBaEI7Ozs7Ozs7OztNQVNFaUssdUJBQXVCMTNCLFVBQVVDLFNBQVYsQ0FBb0JyQixPQUFwQixDQUE0QixlQUE1QixLQUFnRCxDQUEzRTs7Ozs7OztNQU9JazRCLGtCQUFrQjkyQixVQUFVQyxTQUFWLENBQW9CckIsT0FBcEIsQ0FBNEIsU0FBNUIsSUFBeUMsQ0FBekMsSUFBOEMsQ0FBQzg0QixvQkFBckU7Ozs7Ozs7TUFRSUMsY0FBYyxpQkFBaUI1M0IsSUFBakIsQ0FBc0JDLFVBQVVDLFNBQWhDLEtBQThDLENBQUN5M0Isb0JBQWpFOzs7Ozs7O01BUUlFLGVBQWVELGVBQWdCLGVBQUQsQ0FBa0I1M0IsSUFBbEIsQ0FBdUJDLFVBQVVDLFNBQWpDLENBQWxDOzs7Ozs7O01BUUk0M0IsMkJBQTJCRixlQUFnQixhQUFELENBQWdCNTNCLElBQWhCLENBQXFCQyxVQUFVQyxTQUEvQixDQUE5Qzs7Ozs7OztNQU9JNjNCLHVCQUF1QjkzQixVQUFVQyxTQUFWLENBQW9CckIsT0FBcEIsQ0FBNEIsTUFBNUIsSUFBc0MsQ0FBakU7Ozs7Ozs7TUFPSW01QixhQUFhLENBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsVUFBcEIsRUFBZ0MsUUFBaEMsRUFBMEMsS0FBMUMsRUFBaUQsTUFBakQsRUFBeUQsS0FBekQsQ0FBakI7Ozs7Ozs7O1lBUVU3NkIsU0FBVixDQUFvQjg2QixVQUFwQixHQUFpQyxVQUFTeHlCLE1BQVQsRUFBaUI7V0FDekNBLE9BQU9DLFFBQVAsQ0FBZ0JsRyxXQUFoQixFQUFSOzs7U0FHSyxRQUFMO1NBQ0ssUUFBTDtTQUNLLFVBQUw7U0FDS2lHLE9BQU95eUIsUUFBWCxFQUFxQjthQUNiLElBQVA7Ozs7U0FJRyxPQUFMOzs7U0FHTU4sZUFBZW55QixPQUFPOEIsSUFBUCxLQUFnQixNQUFoQyxJQUEyQzlCLE9BQU95eUIsUUFBdEQsRUFBZ0U7YUFDeEQsSUFBUDs7OztTQUlHLE9BQUw7U0FDSyxRQUFMLENBcEJBO1NBcUJLLE9BQUw7WUFDUSxJQUFQOzs7MkJBR00sQ0FBbUJsNEIsSUFBbkIsQ0FBd0J5RixPQUFPbU8sU0FBL0I7O0dBMUJSOzs7Ozs7OztZQW9DVXpXLFNBQVYsQ0FBb0JnN0IsVUFBcEIsR0FBaUMsVUFBUzF5QixNQUFULEVBQWlCO1dBQ3pDQSxPQUFPQyxRQUFQLENBQWdCbEcsV0FBaEIsRUFBUjtTQUNLLFVBQUw7WUFDUSxJQUFQO1NBQ0ksUUFBTDtZQUNRLENBQUN1M0IsZUFBUjtTQUNJLE9BQUw7YUFDU3R4QixPQUFPOEIsSUFBZjtXQUNLLFFBQUw7V0FDSyxVQUFMO1dBQ0ssTUFBTDtXQUNLLE9BQUw7V0FDSyxPQUFMO1dBQ0ssUUFBTDtjQUNRLEtBQVA7Ozs7WUFJTSxDQUFDOUIsT0FBT3l5QixRQUFSLElBQW9CLENBQUN6eUIsT0FBTzJ5QixRQUFuQzs7NkJBRU8sQ0FBbUJwNEIsSUFBbkIsQ0FBd0J5RixPQUFPbU8sU0FBL0I7OztHQXBCVDs7Ozs7Ozs7WUErQlV6VyxTQUFWLENBQW9CazdCLFNBQXBCLEdBQWdDLFVBQVN6ckIsYUFBVCxFQUF3QndCLEtBQXhCLEVBQStCO09BQzFEa3FCLFVBQUosRUFBZ0JqWSxLQUFoQjs7O09BR0lyakIsU0FBU3U3QixhQUFULElBQTBCdjdCLFNBQVN1N0IsYUFBVCxLQUEyQjNyQixhQUF6RCxFQUF3RTthQUM5RDJyQixhQUFULENBQXVCQyxJQUF2Qjs7O1dBR09wcUIsTUFBTXFWLGNBQU4sQ0FBcUIsQ0FBckIsQ0FBUjs7O2dCQUdhem1CLFNBQVNxUixXQUFULENBQXFCLGFBQXJCLENBQWI7Y0FDV29xQixjQUFYLENBQTBCLEtBQUtDLGtCQUFMLENBQXdCOXJCLGFBQXhCLENBQTFCLEVBQWtFLElBQWxFLEVBQXdFLElBQXhFLEVBQThFOVAsTUFBOUUsRUFBc0YsQ0FBdEYsRUFBeUZ1akIsTUFBTXNZLE9BQS9GLEVBQXdHdFksTUFBTXVZLE9BQTlHLEVBQXVIdlksTUFBTUosT0FBN0gsRUFBc0lJLE1BQU1ILE9BQTVJLEVBQXFKLEtBQXJKLEVBQTRKLEtBQTVKLEVBQW1LLEtBQW5LLEVBQTBLLEtBQTFLLEVBQWlMLENBQWpMLEVBQW9MLElBQXBMO2NBQ1cyWSxtQkFBWCxHQUFpQyxJQUFqQztpQkFDY3RxQixhQUFkLENBQTRCK3BCLFVBQTVCO0dBZEQ7O1lBaUJVbjdCLFNBQVYsQ0FBb0J1N0Isa0JBQXBCLEdBQXlDLFVBQVM5ckIsYUFBVCxFQUF3Qjs7O09BRzVEbXFCLG1CQUFtQm5xQixjQUFjdkMsT0FBZCxDQUFzQjdLLFdBQXRCLE9BQXdDLFFBQS9ELEVBQXlFO1dBQ2pFLFdBQVA7OztVQUdNLE9BQVA7R0FQRDs7Ozs7WUFjVXJDLFNBQVYsQ0FBb0I0d0IsS0FBcEIsR0FBNEIsVUFBU25oQixhQUFULEVBQXdCO09BQy9Dak8sTUFBSjs7O09BR0lpNUIsZUFBZWhyQixjQUFjb2hCLGlCQUE3QixJQUFrRHBoQixjQUFjckYsSUFBZCxDQUFtQjFJLE9BQW5CLENBQTJCLE1BQTNCLE1BQXVDLENBQXpGLElBQThGK04sY0FBY3JGLElBQWQsS0FBdUIsTUFBckgsSUFBK0hxRixjQUFjckYsSUFBZCxLQUF1QixPQUF0SixJQUFpS3FGLGNBQWNyRixJQUFkLEtBQXVCLE9BQXhMLElBQW1NcUYsY0FBY3JGLElBQWQsS0FBdUIsUUFBOU4sRUFBd087YUFDOU5xRixjQUFjckssS0FBZCxDQUFvQjVELE1BQTdCO2tCQUNjcXZCLGlCQUFkLENBQWdDcnZCLE1BQWhDLEVBQXdDQSxNQUF4QztJQUZELE1BR087a0JBQ1FvdkIsS0FBZDs7R0FSRjs7Ozs7OztZQWtCVTV3QixTQUFWLENBQW9CMjdCLGtCQUFwQixHQUF5QyxVQUFTbHNCLGFBQVQsRUFBd0I7T0FDNURtc0IsWUFBSixFQUFrQmhqQixhQUFsQjs7a0JBRWVuSixjQUFjb3NCLHFCQUE3Qjs7OztPQUlJLENBQUNELFlBQUQsSUFBaUIsQ0FBQ0EsYUFBYWhtQixRQUFiLENBQXNCbkcsYUFBdEIsQ0FBdEIsRUFBNEQ7b0JBQzNDQSxhQUFoQjtPQUNHO1NBQ0VtSixjQUFja2pCLFlBQWQsR0FBNkJsakIsY0FBY21FLFlBQS9DLEVBQTZEO3FCQUM3Q25FLGFBQWY7b0JBQ2NpakIscUJBQWQsR0FBc0NqakIsYUFBdEM7Ozs7cUJBSWVBLGNBQWNBLGFBQTlCO0tBUEQsUUFRU0EsYUFSVDs7OztPQVlHZ2pCLFlBQUosRUFBa0I7aUJBQ0pHLHNCQUFiLEdBQXNDSCxhQUFhSSxTQUFuRDs7R0F0QkY7Ozs7OztZQStCVWg4QixTQUFWLENBQW9CaThCLCtCQUFwQixHQUFzRCxVQUFTQyxXQUFULEVBQXNCOzs7T0FHdkVBLFlBQVkzbUIsUUFBWixLQUF5QkMsS0FBSzJtQixTQUFsQyxFQUE2QztXQUNyQ0QsWUFBWXh4QixVQUFuQjs7O1VBR013eEIsV0FBUDtHQVBEOzs7Ozs7WUFlVWw4QixTQUFWLENBQW9CbzhCLFdBQXBCLEdBQWtDLFVBQVMzc0IsYUFBVCxFQUF3QjtVQUV4REEsY0FBY3ZDLE9BQWQsQ0FBc0I3SyxXQUF0QixPQUF3QyxVQUF4QyxJQUNHdzRCLFdBQVduNUIsT0FBWCxDQUFtQitOLGNBQWNyRixJQUFqQyxNQUEyQyxDQUFDLENBRmhEO0dBREQ7Ozs7Ozs7O1lBYVVwSyxTQUFWLENBQW9CKzVCLFlBQXBCLEdBQW1DLFVBQVM5b0IsS0FBVCxFQUFnQjtPQUM5Q3hCLGFBQUosRUFBbUJ5VCxLQUFuQjs7O09BR0lqUyxNQUFNb3JCLGFBQU4sQ0FBb0I3NkIsTUFBcEIsR0FBNkIsQ0FBakMsRUFBb0M7V0FDNUIsSUFBUDs7O21CQUdlLEtBQUt5NkIsK0JBQUwsQ0FBcUNockIsTUFBTTNJLE1BQTNDLENBQWhCO1dBQ1EySSxNQUFNb3JCLGFBQU4sQ0FBb0IsQ0FBcEIsQ0FBUjs7OztPQUlJNXNCLGNBQWM2c0IsaUJBQWxCLEVBQXFDO1dBQzdCLElBQVA7OztPQUdHN0IsV0FBSixFQUFpQjs7OztRQUlaaHJCLGtCQUFrQjVQLFNBQVN1N0IsYUFBM0IsSUFBNEMsS0FBS2dCLFdBQUwsQ0FBaUIzc0IsYUFBakIsQ0FBaEQsRUFBaUY7WUFDeEUsSUFBUDs7O1FBR0UsQ0FBQ2lyQixZQUFMLEVBQW1COzs7Ozs7Ozs7O1NBVWR4WCxNQUFNeUQsVUFBTixJQUFvQnpELE1BQU15RCxVQUFOLEtBQXFCLEtBQUswUyxtQkFBbEQsRUFBdUU7WUFDaEUzZSxjQUFOO2FBQ08sS0FBUDs7O1VBR0kyZSxtQkFBTCxHQUEyQm5XLE1BQU15RCxVQUFqQzs7Ozs7Ozs7VUFRS2dWLGtCQUFMLENBQXdCbHNCLGFBQXhCOzs7O1FBSUd3cEIsYUFBTCxHQUFxQixJQUFyQjtRQUNLQyxrQkFBTCxHQUEwQmpvQixNQUFNOFgsU0FBaEM7UUFDS3RaLGFBQUwsR0FBcUJBLGFBQXJCOztRQUVLMHBCLFdBQUwsR0FBbUJqVyxNQUFNTixLQUF6QjtRQUNLd1csV0FBTCxHQUFtQmxXLE1BQU1MLEtBQXpCOzs7T0FHSzVSLE1BQU04WCxTQUFOLEdBQWtCLEtBQUt3VCxhQUF4QixHQUF5QyxLQUFLaEQsUUFBOUMsSUFBMkR0b0IsTUFBTThYLFNBQU4sR0FBa0IsS0FBS3dULGFBQXhCLEdBQXlDLENBQUMsQ0FBeEcsRUFBMkc7VUFDcEc3aEIsY0FBTjs7O1VBR00sSUFBUDtHQWhFRDs7Ozs7Ozs7WUEwRVUxYSxTQUFWLENBQW9CdzhCLGFBQXBCLEdBQW9DLFVBQVN2ckIsS0FBVCxFQUFnQjtPQUMvQ2lTLFFBQVFqUyxNQUFNcVYsY0FBTixDQUFxQixDQUFyQixDQUFaO09BQXFDbVcsV0FBVyxLQUFLbkQsYUFBckQ7O09BRUl4ZixLQUFLd0osR0FBTCxDQUFTSixNQUFNTixLQUFOLEdBQWMsS0FBS3VXLFdBQTVCLElBQTJDc0QsUUFBM0MsSUFBdUQzaUIsS0FBS3dKLEdBQUwsQ0FBU0osTUFBTUwsS0FBTixHQUFjLEtBQUt1VyxXQUE1QixJQUEyQ3FELFFBQXRHLEVBQWdIO1dBQ3hHLElBQVA7OztVQUdNLEtBQVA7R0FQRDs7Ozs7Ozs7WUFpQlV6OEIsU0FBVixDQUFvQmc2QixXQUFwQixHQUFrQyxVQUFTL29CLEtBQVQsRUFBZ0I7T0FDN0MsQ0FBQyxLQUFLZ29CLGFBQVYsRUFBeUI7V0FDakIsSUFBUDs7OztPQUlHLEtBQUt4cEIsYUFBTCxLQUF1QixLQUFLd3NCLCtCQUFMLENBQXFDaHJCLE1BQU0zSSxNQUEzQyxDQUF2QixJQUE2RSxLQUFLazBCLGFBQUwsQ0FBbUJ2ckIsS0FBbkIsQ0FBakYsRUFBNEc7U0FDdEdnb0IsYUFBTCxHQUFxQixLQUFyQjtTQUNLeHBCLGFBQUwsR0FBcUIsSUFBckI7OztVQUdNLElBQVA7R0FYRDs7Ozs7Ozs7WUFxQlV6UCxTQUFWLENBQW9CMDhCLFdBQXBCLEdBQWtDLFVBQVNDLFlBQVQsRUFBdUI7OztPQUdwREEsYUFBYUMsT0FBYixLQUF5QmxzQixTQUE3QixFQUF3QztXQUNoQ2lzQixhQUFhQyxPQUFwQjs7OztPQUlHRCxhQUFhRSxPQUFqQixFQUEwQjtXQUNsQmg5QixTQUFTNEosY0FBVCxDQUF3Qmt6QixhQUFhRSxPQUFyQyxDQUFQOzs7OztVQUtNRixhQUFhMTBCLGFBQWIsQ0FBMkIscUZBQTNCLENBQVA7R0FkRDs7Ozs7Ozs7WUF3QlVqSSxTQUFWLENBQW9CaTZCLFVBQXBCLEdBQWlDLFVBQVNocEIsS0FBVCxFQUFnQjtPQUM1QzZyQixVQUFKO09BQWdCNUQsa0JBQWhCO09BQW9DNkQsYUFBcEM7T0FBbURuQixZQUFuRDtPQUFpRTFZLEtBQWpFO09BQXdFelQsZ0JBQWdCLEtBQUtBLGFBQTdGOztPQUVJLENBQUMsS0FBS3dwQixhQUFWLEVBQXlCO1dBQ2pCLElBQVA7Ozs7T0FJSWhvQixNQUFNOFgsU0FBTixHQUFrQixLQUFLd1QsYUFBeEIsR0FBeUMsS0FBS2hELFFBQTlDLElBQTJEdG9CLE1BQU04WCxTQUFOLEdBQWtCLEtBQUt3VCxhQUF4QixHQUF5QyxDQUFDLENBQXhHLEVBQTJHO1NBQ3JHUyxlQUFMLEdBQXVCLElBQXZCO1dBQ08sSUFBUDs7O09BR0kvckIsTUFBTThYLFNBQU4sR0FBa0IsS0FBS21RLGtCQUF4QixHQUE4QyxLQUFLTSxVQUF2RCxFQUFtRTtXQUMzRCxJQUFQOzs7O1FBSUl3RCxlQUFMLEdBQXVCLEtBQXZCOztRQUVLVCxhQUFMLEdBQXFCdHJCLE1BQU04WCxTQUEzQjs7d0JBRXFCLEtBQUttUSxrQkFBMUI7UUFDS0QsYUFBTCxHQUFxQixLQUFyQjtRQUNLQyxrQkFBTCxHQUEwQixDQUExQjs7Ozs7O09BTUl5Qix3QkFBSixFQUE4QjtZQUNyQjFwQixNQUFNcVYsY0FBTixDQUFxQixDQUFyQixDQUFSOzs7b0JBR2dCem1CLFNBQVNvOUIsZ0JBQVQsQ0FBMEIvWixNQUFNTixLQUFOLEdBQWNqakIsT0FBT3U5QixXQUEvQyxFQUE0RGhhLE1BQU1MLEtBQU4sR0FBY2xqQixPQUFPdzlCLFdBQWpGLEtBQWlHMXRCLGFBQWpIO2tCQUNjb3NCLHFCQUFkLEdBQXNDLEtBQUtwc0IsYUFBTCxDQUFtQm9zQixxQkFBekQ7OzttQkFHZXBzQixjQUFjdkMsT0FBZCxDQUFzQjdLLFdBQXRCLEVBQWhCO09BQ0kwNkIsa0JBQWtCLE9BQXRCLEVBQStCO2lCQUNqQixLQUFLTCxXQUFMLENBQWlCanRCLGFBQWpCLENBQWI7UUFDSXF0QixVQUFKLEVBQWdCO1VBQ1ZsTSxLQUFMLENBQVduaEIsYUFBWDtTQUNJbXFCLGVBQUosRUFBcUI7YUFDYixLQUFQOzs7cUJBR2VrRCxVQUFoQjs7SUFSRixNQVVPLElBQUksS0FBSzlCLFVBQUwsQ0FBZ0J2ckIsYUFBaEIsQ0FBSixFQUFvQzs7OztRQUlyQ3dCLE1BQU04WCxTQUFOLEdBQWtCbVEsa0JBQW5CLEdBQXlDLEdBQXpDLElBQWlEdUIsZUFBZTk2QixPQUFPeTlCLEdBQVAsS0FBZXo5QixNQUE5QixJQUF3Q285QixrQkFBa0IsT0FBL0csRUFBeUg7VUFDbkh0dEIsYUFBTCxHQUFxQixJQUFyQjtZQUNPLEtBQVA7OztTQUdJbWhCLEtBQUwsQ0FBV25oQixhQUFYO1NBQ0t5ckIsU0FBTCxDQUFlenJCLGFBQWYsRUFBOEJ3QixLQUE5Qjs7OztRQUlJLENBQUN5cEIsWUFBRCxJQUFpQnFDLGtCQUFrQixRQUF2QyxFQUFpRDtVQUMzQ3R0QixhQUFMLEdBQXFCLElBQXJCO1dBQ01pTCxjQUFOOzs7V0FHTSxLQUFQOzs7T0FHRytmLGVBQWUsQ0FBQ0MsWUFBcEIsRUFBa0M7Ozs7bUJBSWxCanJCLGNBQWNvc0IscUJBQTdCO1FBQ0lELGdCQUFnQkEsYUFBYUcsc0JBQWIsS0FBd0NILGFBQWFJLFNBQXpFLEVBQW9GO1lBQzVFLElBQVA7Ozs7OztPQU1FLENBQUMsS0FBS2xCLFVBQUwsQ0FBZ0JyckIsYUFBaEIsQ0FBTCxFQUFxQztVQUM5QmlMLGNBQU47U0FDS3dnQixTQUFMLENBQWV6ckIsYUFBZixFQUE4QndCLEtBQTlCOzs7VUFHTSxLQUFQO0dBeEZEOzs7Ozs7O1lBaUdValIsU0FBVixDQUFvQms2QixhQUFwQixHQUFvQyxZQUFXO1FBQ3pDakIsYUFBTCxHQUFxQixLQUFyQjtRQUNLeHBCLGFBQUwsR0FBcUIsSUFBckI7R0FGRDs7Ozs7Ozs7WUFZVXpQLFNBQVYsQ0FBb0I2NUIsT0FBcEIsR0FBOEIsVUFBUzVvQixLQUFULEVBQWdCOzs7T0FHekMsQ0FBQyxLQUFLeEIsYUFBVixFQUF5QjtXQUNqQixJQUFQOzs7T0FHR3dCLE1BQU15cUIsbUJBQVYsRUFBK0I7V0FDdkIsSUFBUDs7OztPQUlHLENBQUN6cUIsTUFBTXdKLFVBQVgsRUFBdUI7V0FDZixJQUFQOzs7Ozs7T0FNRyxDQUFDLEtBQUtxZ0IsVUFBTCxDQUFnQixLQUFLcnJCLGFBQXJCLENBQUQsSUFBd0MsS0FBS3V0QixlQUFqRCxFQUFrRTs7O1FBRzdEL3JCLE1BQU1rcEIsd0JBQVYsRUFBb0M7V0FDN0JBLHdCQUFOO0tBREQsTUFFTzs7O1dBR0FJLGtCQUFOLEdBQTJCLElBQTNCOzs7O1VBSUtwZSxlQUFOO1VBQ016QixjQUFOOztXQUVPLEtBQVA7Ozs7VUFJTSxJQUFQO0dBdENEOzs7Ozs7Ozs7O1lBa0RVMWEsU0FBVixDQUFvQjg1QixPQUFwQixHQUE4QixVQUFTN29CLEtBQVQsRUFBZ0I7T0FDekNvc0IsU0FBSjs7O09BR0ksS0FBS3BFLGFBQVQsRUFBd0I7U0FDbEJ4cEIsYUFBTCxHQUFxQixJQUFyQjtTQUNLd3BCLGFBQUwsR0FBcUIsS0FBckI7V0FDTyxJQUFQOzs7O09BSUdob0IsTUFBTTNJLE1BQU4sQ0FBYThCLElBQWIsS0FBc0IsUUFBdEIsSUFBa0M2RyxNQUFNNkcsTUFBTixLQUFpQixDQUF2RCxFQUEwRDtXQUNsRCxJQUFQOzs7ZUFHVyxLQUFLK2hCLE9BQUwsQ0FBYTVvQixLQUFiLENBQVo7OztPQUdJLENBQUNvc0IsU0FBTCxFQUFnQjtTQUNWNXRCLGFBQUwsR0FBcUIsSUFBckI7Ozs7VUFJTTR0QixTQUFQO0dBdkJEOzs7Ozs7O1lBZ0NVcjlCLFNBQVYsQ0FBb0I0dkIsT0FBcEIsR0FBOEIsWUFBVztPQUNwQ21KLFFBQVEsS0FBS0EsS0FBakI7O09BRUlhLGVBQUosRUFBcUI7VUFDZG55QixtQkFBTixDQUEwQixXQUExQixFQUF1QyxLQUFLb3lCLE9BQTVDLEVBQXFELElBQXJEO1VBQ01weUIsbUJBQU4sQ0FBMEIsV0FBMUIsRUFBdUMsS0FBS295QixPQUE1QyxFQUFxRCxJQUFyRDtVQUNNcHlCLG1CQUFOLENBQTBCLFNBQTFCLEVBQXFDLEtBQUtveUIsT0FBMUMsRUFBbUQsSUFBbkQ7OztTQUdLcHlCLG1CQUFOLENBQTBCLE9BQTFCLEVBQW1DLEtBQUtxeUIsT0FBeEMsRUFBaUQsSUFBakQ7U0FDTXJ5QixtQkFBTixDQUEwQixZQUExQixFQUF3QyxLQUFLc3lCLFlBQTdDLEVBQTJELEtBQTNEO1NBQ010eUIsbUJBQU4sQ0FBMEIsV0FBMUIsRUFBdUMsS0FBS3V5QixXQUE1QyxFQUF5RCxLQUF6RDtTQUNNdnlCLG1CQUFOLENBQTBCLFVBQTFCLEVBQXNDLEtBQUt3eUIsVUFBM0MsRUFBdUQsS0FBdkQ7U0FDTXh5QixtQkFBTixDQUEwQixhQUExQixFQUF5QyxLQUFLeXlCLGFBQTlDLEVBQTZELEtBQTdEO0dBYkQ7Ozs7Ozs7WUFzQlVULFNBQVYsR0FBc0IsVUFBU1YsS0FBVCxFQUFnQjtPQUNqQ3VFLFlBQUo7T0FDSUMsYUFBSjtPQUNJQyxpQkFBSjtPQUNJQyxjQUFKOzs7T0FHSSxPQUFPOTlCLE9BQU8rOUIsWUFBZCxLQUErQixXQUFuQyxFQUFnRDtXQUN4QyxJQUFQOzs7O21CQUllLENBQUMsQ0FBQyxtQkFBbUJDLElBQW5CLENBQXdCNzZCLFVBQVVDLFNBQWxDLEtBQWdELEdBQUUsQ0FBRixDQUFqRCxFQUF1RCxDQUF2RCxDQUFqQjs7T0FFSXc2QixhQUFKLEVBQW1COztRQUVkM0QsZUFBSixFQUFxQjtvQkFDTC81QixTQUFTb0ksYUFBVCxDQUF1QixxQkFBdkIsQ0FBZjs7U0FFSXExQixZQUFKLEVBQWtCOztVQUViQSxhQUFhdjBCLE9BQWIsQ0FBcUJySCxPQUFyQixDQUE2QixrQkFBN0IsTUFBcUQsQ0FBQyxDQUExRCxFQUE2RDtjQUNyRCxJQUFQOzs7VUFHRzY3QixnQkFBZ0IsRUFBaEIsSUFBc0IxOUIsU0FBU0MsZUFBVCxDQUF5Qjg5QixXQUF6QixJQUF3Q2orQixPQUFPaytCLFVBQXpFLEVBQXFGO2NBQzdFLElBQVA7Ozs7O0tBVkgsTUFlTztZQUNDLElBQVA7Ozs7T0FJRWpELG9CQUFKLEVBQTBCO3dCQUNMOTNCLFVBQVVDLFNBQVYsQ0FBb0IzQyxLQUFwQixDQUEwQiw2QkFBMUIsQ0FBcEI7Ozs7UUFJSW85QixrQkFBa0IsQ0FBbEIsS0FBd0IsRUFBeEIsSUFBOEJBLGtCQUFrQixDQUFsQixLQUF3QixDQUExRCxFQUE2RDtvQkFDN0MzOUIsU0FBU29JLGFBQVQsQ0FBdUIscUJBQXZCLENBQWY7O1NBRUlxMUIsWUFBSixFQUFrQjs7VUFFYkEsYUFBYXYwQixPQUFiLENBQXFCckgsT0FBckIsQ0FBNkIsa0JBQTdCLE1BQXFELENBQUMsQ0FBMUQsRUFBNkQ7Y0FDckQsSUFBUDs7O1VBR0c3QixTQUFTQyxlQUFULENBQXlCODlCLFdBQXpCLElBQXdDaitCLE9BQU9rK0IsVUFBbkQsRUFBK0Q7Y0FDdkQsSUFBUDs7Ozs7OztPQU9BOUUsTUFBTXA0QixLQUFOLENBQVltOUIsYUFBWixLQUE4QixNQUE5QixJQUF3Qy9FLE1BQU1wNEIsS0FBTixDQUFZbzlCLFdBQVosS0FBNEIsY0FBeEUsRUFBd0Y7V0FDaEYsSUFBUDs7OztvQkFJZ0IsQ0FBQyxDQUFDLG9CQUFvQkosSUFBcEIsQ0FBeUI3NkIsVUFBVUMsU0FBbkMsS0FBaUQsR0FBRSxDQUFGLENBQWxELEVBQXdELENBQXhELENBQWxCOztPQUVJMDZCLGtCQUFrQixFQUF0QixFQUEwQjs7O21CQUdWNTlCLFNBQVNvSSxhQUFULENBQXVCLHFCQUF2QixDQUFmO1FBQ0lxMUIsaUJBQWlCQSxhQUFhdjBCLE9BQWIsQ0FBcUJySCxPQUFyQixDQUE2QixrQkFBN0IsTUFBcUQsQ0FBQyxDQUF0RCxJQUEyRDdCLFNBQVNDLGVBQVQsQ0FBeUI4OUIsV0FBekIsSUFBd0NqK0IsT0FBT2srQixVQUEzSCxDQUFKLEVBQTRJO1lBQ3BJLElBQVA7Ozs7OztPQU1FOUUsTUFBTXA0QixLQUFOLENBQVlvOUIsV0FBWixLQUE0QixNQUE1QixJQUFzQ2hGLE1BQU1wNEIsS0FBTixDQUFZbzlCLFdBQVosS0FBNEIsY0FBdEUsRUFBc0Y7V0FDOUUsSUFBUDs7O1VBR00sS0FBUDtHQWhGRDs7Ozs7Ozs7WUEwRlVDLE1BQVYsR0FBbUIsVUFBU2pGLEtBQVQsRUFBZ0Ivc0IsT0FBaEIsRUFBeUI7VUFDcEMsSUFBSThzQixTQUFKLENBQWNDLEtBQWQsRUFBcUIvc0IsT0FBckIsQ0FBUDtHQUREOztNQUtJLE9BQU9peUIsU0FBUCxLQUFrQixVQUFsQixJQUFnQ0MsUUFBT0QsVUFBT0UsR0FBZCxNQUFzQixRQUF0RCxJQUFrRUYsVUFBT0UsR0FBN0UsRUFBa0Y7OzthQUcxRSxZQUFXO1dBQ1ZyRixTQUFQO0lBRERtRjtHQUhELE1BTU8sSUFBSSxhQUFrQixXQUFsQixJQUFpQ0csT0FBT0MsT0FBNUMsRUFBcUQ7aUJBQzNELEdBQWlCdkYsVUFBVWtGLE1BQTNCO2lCQUNBLFVBQUEsR0FBMkJsRixTQUEzQjtHQUZNLE1BR0E7VUFDQ0EsU0FBUCxHQUFtQkEsU0FBbkI7O0VBOTFCQSxHQUFEOzs7OztBQ0FEO0FBQ0EsSUFBSW41QixPQUFPMitCLGNBQVgsRUFBMkI7O1dBQ2hCQSxjQUFQLENBQXNCQyxhQUF0QixHQUFzQyxJQUF0Qzs7Ozs7TUNEQUMsU0FBU0osY0FBQSxHQUFpQixPQUFPeitCLE1BQVAsSUFBaUIsV0FBakIsSUFBZ0NBLE9BQU9tYSxJQUFQLElBQWVBLElBQS9DLEdBQzFCbmEsTUFEMEIsR0FDakIsT0FBT2dmLElBQVAsSUFBZSxXQUFmLElBQThCQSxLQUFLN0UsSUFBTCxJQUFhQSxJQUEzQyxHQUFrRDZFOztJQUUzRHJOLFNBQVMsYUFBVCxHQUhKO01BSUksT0FBT210QixHQUFQLElBQWMsUUFBbEIsRUFBNEJBLE1BQU1ELE1BQU47Ozs7TUNMeEJFLE9BQU9OLGNBQUEsR0FBaUIsRUFBRTc2QixTQUFTLE9BQVgsRUFBNUI7TUFDSSxPQUFPbzdCLEdBQVAsSUFBYyxRQUFsQixFQUE0QkEsTUFBTUQsSUFBTjs7Ozs7QUNENUIsZ0JBQWlCLGtCQUFBLENBQVVFLEVBQVYsRUFBYztTQUN0QixRQUFPQSxFQUFQLHlDQUFPQSxFQUFQLE9BQWMsUUFBZCxHQUF5QkEsT0FBTyxJQUFoQyxHQUF1QyxPQUFPQSxFQUFQLEtBQWMsVUFBNUQ7Q0FERjs7QUNDQSxnQkFBaUIsa0JBQUEsQ0FBVUEsRUFBVixFQUFjO01BQ3pCLENBQUNDLFVBQVNELEVBQVQsQ0FBTCxFQUFtQixNQUFNRSxVQUFVRixLQUFLLG9CQUFmLENBQU47U0FDWkEsRUFBUDtDQUZGOztBQ0RBLGFBQWlCLGVBQUEsQ0FBVWpCLElBQVYsRUFBZ0I7TUFDM0I7V0FDSyxDQUFDLENBQUNBLE1BQVQ7R0FERixDQUVFLE9BQU90MUIsQ0FBUCxFQUFVO1dBQ0gsSUFBUDs7Q0FKSjs7QUNBQTtBQUNBLG1CQUFpQixDQUFDMDJCLE9BQW9CLFlBQVk7U0FDekMxNkIsT0FBT3NRLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsR0FBMUIsRUFBK0IsRUFBRXJMLEtBQUssZUFBWTthQUFTLENBQVA7S0FBckIsRUFBL0IsRUFBbUVrVCxDQUFuRSxJQUF3RSxDQUEvRTtDQURnQixDQUFsQjs7QUNBQSxJQUFJM2MsYUFBV2svQixRQUFxQmwvQixRQUFwQzs7QUFFQSxJQUFJbS9CLEtBQUtILFVBQVNoL0IsVUFBVCxLQUFzQmcvQixVQUFTaC9CLFdBQVNxSCxhQUFsQixDQUEvQjtBQUNBLGlCQUFpQixtQkFBQSxDQUFVMDNCLEVBQVYsRUFBYztTQUN0QkksS0FBS24vQixXQUFTcUgsYUFBVCxDQUF1QjAzQixFQUF2QixDQUFMLEdBQWtDLEVBQXpDO0NBREY7O0FDSkEsb0JBQWlCLENBQUNHLFlBQUQsSUFBOEIsQ0FBQ0UsT0FBb0IsWUFBWTtTQUN2RTU2QixPQUFPc1EsY0FBUCxDQUFzQnVxQixXQUF5QixLQUF6QixDQUF0QixFQUF1RCxHQUF2RCxFQUE0RCxFQUFFNTFCLEtBQUssZUFBWTthQUFTLENBQVA7S0FBckIsRUFBNUQsRUFBZ0drVCxDQUFoRyxJQUFxRyxDQUE1RztDQUQ4QyxDQUFoRDs7QUNBQTs7OztBQUlBLG1CQUFpQixxQkFBQSxDQUFVb2lCLEVBQVYsRUFBY08sQ0FBZCxFQUFpQjtNQUM1QixDQUFDTixVQUFTRCxFQUFULENBQUwsRUFBbUIsT0FBT0EsRUFBUDtNQUNmdDhCLEVBQUosRUFBUTg4QixHQUFSO01BQ0lELEtBQUssUUFBUTc4QixLQUFLczhCLEdBQUd0NkIsUUFBaEIsS0FBNkIsVUFBbEMsSUFBZ0QsQ0FBQ3U2QixVQUFTTyxNQUFNOThCLEdBQUdwQyxJQUFILENBQVEwK0IsRUFBUixDQUFmLENBQXJELEVBQWtGLE9BQU9RLEdBQVA7TUFDOUUsUUFBUTk4QixLQUFLczhCLEdBQUdTLE9BQWhCLEtBQTRCLFVBQTVCLElBQTBDLENBQUNSLFVBQVNPLE1BQU05OEIsR0FBR3BDLElBQUgsQ0FBUTArQixFQUFSLENBQWYsQ0FBL0MsRUFBNEUsT0FBT1EsR0FBUDtNQUN4RSxDQUFDRCxDQUFELElBQU0sUUFBUTc4QixLQUFLczhCLEdBQUd0NkIsUUFBaEIsS0FBNkIsVUFBbkMsSUFBaUQsQ0FBQ3U2QixVQUFTTyxNQUFNOThCLEdBQUdwQyxJQUFILENBQVEwK0IsRUFBUixDQUFmLENBQXRELEVBQW1GLE9BQU9RLEdBQVA7UUFDN0VOLFVBQVUseUNBQVYsQ0FBTjtDQU5GOztBQ0RBLElBQUlRLEtBQUtqN0IsT0FBT3NRLGNBQWhCOztBQUVBLFFBQVlvcUIsZUFBNEIxNkIsT0FBT3NRLGNBQW5DLEdBQW9ELFNBQVNBLGNBQVQsQ0FBd0I0cUIsQ0FBeEIsRUFBMkJDLENBQTNCLEVBQThCQyxVQUE5QixFQUEwQztZQUMvRkYsQ0FBVDtNQUNJRyxhQUFZRixDQUFaLEVBQWUsSUFBZixDQUFKO1lBQ1NDLFVBQVQ7TUFDSUUsYUFBSixFQUFvQixJQUFJO1dBQ2ZMLEdBQUdDLENBQUgsRUFBTUMsQ0FBTixFQUFTQyxVQUFULENBQVA7R0FEa0IsQ0FFbEIsT0FBT3AzQixDQUFQLEVBQVU7TUFDUixTQUFTbzNCLFVBQVQsSUFBdUIsU0FBU0EsVUFBcEMsRUFBZ0QsTUFBTVgsVUFBVSwwQkFBVixDQUFOO01BQzVDLFdBQVdXLFVBQWYsRUFBMkJGLEVBQUVDLENBQUYsSUFBT0MsV0FBV3I2QixLQUFsQjtTQUNwQm02QixDQUFQO0NBVEY7Ozs7OztBQ0xBLG9CQUFpQixzQkFBQSxDQUFVSyxNQUFWLEVBQWtCeDZCLEtBQWxCLEVBQXlCO1NBQ2pDO2dCQUNPLEVBQUV3NkIsU0FBUyxDQUFYLENBRFA7a0JBRVMsRUFBRUEsU0FBUyxDQUFYLENBRlQ7Y0FHSyxFQUFFQSxTQUFTLENBQVgsQ0FITDtXQUlFeDZCO0dBSlQ7Q0FERjs7QUNFQSxZQUFpQjI1QixlQUE0QixVQUFVOXFCLE1BQVYsRUFBa0JuVCxHQUFsQixFQUF1QnNFLEtBQXZCLEVBQThCO1NBQ2xFazZCLFVBQUdqbUIsQ0FBSCxDQUFLcEYsTUFBTCxFQUFhblQsR0FBYixFQUFrQisrQixjQUFXLENBQVgsRUFBY3o2QixLQUFkLENBQWxCLENBQVA7Q0FEZSxHQUViLFVBQVU2TyxNQUFWLEVBQWtCblQsR0FBbEIsRUFBdUJzRSxLQUF2QixFQUE4QjtTQUN6QnRFLEdBQVAsSUFBY3NFLEtBQWQ7U0FDTzZPLE1BQVA7Q0FKRjs7QUNGQSxJQUFJMU8saUJBQWlCLEdBQUdBLGNBQXhCO0FBQ0EsV0FBaUIsYUFBQSxDQUFVcTVCLEVBQVYsRUFBYzk5QixHQUFkLEVBQW1CO1NBQzNCeUUsZUFBZXJGLElBQWYsQ0FBb0IwK0IsRUFBcEIsRUFBd0I5OUIsR0FBeEIsQ0FBUDtDQURGOztBQ0RBLElBQUl5UCxLQUFLLENBQVQ7QUFDQSxJQUFJdXZCLEtBQUtobUIsS0FBS2ltQixNQUFMLEVBQVQ7QUFDQSxXQUFpQixhQUFBLENBQVVqL0IsR0FBVixFQUFlO1NBQ3ZCLFVBQVVRLE1BQVYsQ0FBaUJSLFFBQVE0UCxTQUFSLEdBQW9CLEVBQXBCLEdBQXlCNVAsR0FBMUMsRUFBK0MsSUFBL0MsRUFBcUQsQ0FBQyxFQUFFeVAsRUFBRixHQUFPdXZCLEVBQVIsRUFBWXg3QixRQUFaLENBQXFCLEVBQXJCLENBQXJELENBQVA7Q0FERjs7O01DQ0kwN0IsTUFBTWpCLEtBQWtCLEtBQWxCLENBQVY7TUFDSWtCLFlBQVksVUFBaEI7TUFDSUMsWUFBWTV1QixTQUFTMnVCLFNBQVQsQ0FBaEI7TUFDSUUsTUFBTSxDQUFDLEtBQUtELFNBQU4sRUFBaUJoL0IsS0FBakIsQ0FBdUIrK0IsU0FBdkIsQ0FBVjs7UUFFbUJHLGFBQW5CLEdBQW1DLFVBQVV4QixFQUFWLEVBQWM7V0FDeENzQixVQUFVaGdDLElBQVYsQ0FBZTArQixFQUFmLENBQVA7R0FERjs7R0FJQ1IsY0FBQSxHQUFpQixVQUFVbUIsQ0FBVixFQUFheitCLEdBQWIsRUFBa0JzK0IsR0FBbEIsRUFBdUJpQixJQUF2QixFQUE2QjtRQUN6Q0MsYUFBYSxPQUFPbEIsR0FBUCxJQUFjLFVBQS9CO1FBQ0lrQixVQUFKLEVBQWdCbnVCLEtBQUlpdEIsR0FBSixFQUFTLE1BQVQsS0FBb0JqUCxNQUFLaVAsR0FBTCxFQUFVLE1BQVYsRUFBa0J0K0IsR0FBbEIsQ0FBcEI7UUFDWnkrQixFQUFFeitCLEdBQUYsTUFBV3MrQixHQUFmLEVBQW9CO1FBQ2hCa0IsVUFBSixFQUFnQm51QixLQUFJaXRCLEdBQUosRUFBU1ksR0FBVCxLQUFpQjdQLE1BQUtpUCxHQUFMLEVBQVVZLEdBQVYsRUFBZVQsRUFBRXorQixHQUFGLElBQVMsS0FBS3krQixFQUFFeitCLEdBQUYsQ0FBZCxHQUF1QnEvQixJQUFJaGdDLElBQUosQ0FBU29nQyxPQUFPei9CLEdBQVAsQ0FBVCxDQUF0QyxDQUFqQjtRQUNaeStCLE1BQU1mLE9BQVYsRUFBa0I7UUFDZDE5QixHQUFGLElBQVNzK0IsR0FBVDtLQURGLE1BRU8sSUFBSSxDQUFDaUIsSUFBTCxFQUFXO2FBQ1RkLEVBQUV6K0IsR0FBRixDQUFQO1lBQ0t5K0IsQ0FBTCxFQUFReitCLEdBQVIsRUFBYXMrQixHQUFiO0tBRkssTUFHQSxJQUFJRyxFQUFFeitCLEdBQUYsQ0FBSixFQUFZO1FBQ2ZBLEdBQUYsSUFBU3MrQixHQUFUO0tBREssTUFFQTtZQUNBRyxDQUFMLEVBQVF6K0IsR0FBUixFQUFhcytCLEdBQWI7OztHQWJKLEVBZ0JHOXRCLFNBQVN0UixTQWhCWixFQWdCdUJpZ0MsU0FoQnZCLEVBZ0JrQyxTQUFTMzdCLFFBQVQsR0FBb0I7V0FDN0MsT0FBTyxJQUFQLElBQWUsVUFBZixJQUE2QixLQUFLMDdCLEdBQUwsQ0FBN0IsSUFBMENFLFVBQVVoZ0MsSUFBVixDQUFlLElBQWYsQ0FBakQ7R0FqQkY7OztBQ1pBLGlCQUFpQixtQkFBQSxDQUFVMCtCLEVBQVYsRUFBYztNQUN6QixPQUFPQSxFQUFQLElBQWEsVUFBakIsRUFBNkIsTUFBTUUsVUFBVUYsS0FBSyxxQkFBZixDQUFOO1NBQ3RCQSxFQUFQO0NBRkY7O0FDQUE7O0FBRUEsV0FBaUIsYUFBQSxDQUFVdDhCLEVBQVYsRUFBY2srQixJQUFkLEVBQW9CaC9CLE1BQXBCLEVBQTRCO2FBQ2pDYyxFQUFWO01BQ0lrK0IsU0FBUzl2QixTQUFiLEVBQXdCLE9BQU9wTyxFQUFQO1VBQ2hCZCxNQUFSO1NBQ08sQ0FBTDthQUFlLFVBQVVnYixDQUFWLEVBQWE7ZUFDbkJsYSxHQUFHcEMsSUFBSCxDQUFRc2dDLElBQVIsRUFBY2hrQixDQUFkLENBQVA7T0FETTtTQUdILENBQUw7YUFBZSxVQUFVQSxDQUFWLEVBQWFtTixDQUFiLEVBQWdCO2VBQ3RCcm5CLEdBQUdwQyxJQUFILENBQVFzZ0MsSUFBUixFQUFjaGtCLENBQWQsRUFBaUJtTixDQUFqQixDQUFQO09BRE07U0FHSCxDQUFMO2FBQWUsVUFBVW5OLENBQVYsRUFBYW1OLENBQWIsRUFBZ0Jsa0IsQ0FBaEIsRUFBbUI7ZUFDekJuRCxHQUFHcEMsSUFBSCxDQUFRc2dDLElBQVIsRUFBY2hrQixDQUFkLEVBQWlCbU4sQ0FBakIsRUFBb0Jsa0IsQ0FBcEIsQ0FBUDtPQURNOztTQUlILHlCQUF5QjtXQUN2Qm5ELEdBQUd1UCxLQUFILENBQVMydUIsSUFBVCxFQUFlamhCLFNBQWYsQ0FBUDtHQURGO0NBZEY7O0FDR0EsSUFBSWtoQixZQUFZLFdBQWhCOztBQUVBLElBQUlDLFVBQVUsU0FBVkEsT0FBVSxDQUFVdDJCLElBQVYsRUFBZ0I5SixJQUFoQixFQUFzQnFnQyxNQUF0QixFQUE4QjtNQUN0Q0MsWUFBWXgyQixPQUFPczJCLFFBQVFHLENBQS9CO01BQ0lDLFlBQVkxMkIsT0FBT3MyQixRQUFRSyxDQUEvQjtNQUNJQyxZQUFZNTJCLE9BQU9zMkIsUUFBUXZCLENBQS9CO01BQ0k4QixXQUFXNzJCLE9BQU9zMkIsUUFBUWxCLENBQTlCO01BQ0kwQixVQUFVOTJCLE9BQU9zMkIsUUFBUVMsQ0FBN0I7TUFDSTc0QixTQUFTdzRCLFlBQVl0QyxPQUFaLEdBQXFCd0MsWUFBWXhDLFFBQU9sK0IsSUFBUCxNQUFpQmsrQixRQUFPbCtCLElBQVAsSUFBZSxFQUFoQyxDQUFaLEdBQWtELENBQUNrK0IsUUFBT2wrQixJQUFQLEtBQWdCLEVBQWpCLEVBQXFCbWdDLFNBQXJCLENBQXBGO01BQ0lwQyxVQUFVeUMsWUFBWXBDLEtBQVosR0FBbUJBLE1BQUtwK0IsSUFBTCxNQUFlbytCLE1BQUtwK0IsSUFBTCxJQUFhLEVBQTVCLENBQWpDO01BQ0k4Z0MsV0FBVy9DLFFBQVFvQyxTQUFSLE1BQXVCcEMsUUFBUW9DLFNBQVIsSUFBcUIsRUFBNUMsQ0FBZjtNQUNJMy9CLEdBQUosRUFBU3VnQyxHQUFULEVBQWNDLEdBQWQsRUFBbUJDLEdBQW5CO01BQ0lULFNBQUosRUFBZUgsU0FBU3JnQyxJQUFUO09BQ1ZRLEdBQUwsSUFBWTYvQixNQUFaLEVBQW9COztVQUVaLENBQUNDLFNBQUQsSUFBY3Q0QixNQUFkLElBQXdCQSxPQUFPeEgsR0FBUCxNQUFnQjRQLFNBQTlDOztVQUVNLENBQUMyd0IsTUFBTS80QixNQUFOLEdBQWVxNEIsTUFBaEIsRUFBd0I3L0IsR0FBeEIsQ0FBTjs7VUFFTW9nQyxXQUFXRyxHQUFYLEdBQWlCRyxLQUFJRixHQUFKLEVBQVM5QyxPQUFULENBQWpCLEdBQW9DeUMsWUFBWSxPQUFPSyxHQUFQLElBQWMsVUFBMUIsR0FBdUNFLEtBQUlsd0IsU0FBU3BSLElBQWIsRUFBbUJvaEMsR0FBbkIsQ0FBdkMsR0FBaUVBLEdBQTNHOztRQUVJaDVCLE1BQUosRUFBWW01QixVQUFTbjVCLE1BQVQsRUFBaUJ4SCxHQUFqQixFQUFzQndnQyxHQUF0QixFQUEyQmwzQixPQUFPczJCLFFBQVFnQixDQUExQzs7UUFFUnJELFFBQVF2OUIsR0FBUixLQUFnQndnQyxHQUFwQixFQUF5Qm5SLE1BQUtrTyxPQUFMLEVBQWN2OUIsR0FBZCxFQUFtQnlnQyxHQUFuQjtRQUNyQk4sWUFBWUcsU0FBU3RnQyxHQUFULEtBQWlCd2dDLEdBQWpDLEVBQXNDRixTQUFTdGdDLEdBQVQsSUFBZ0J3Z0MsR0FBaEI7O0NBdEIxQztBQXlCQTlDLFFBQU9FLElBQVAsR0FBY0EsS0FBZDs7QUFFQWdDLFFBQVFHLENBQVIsR0FBWSxDQUFaO0FBQ0FILFFBQVFLLENBQVIsR0FBWSxDQUFaO0FBQ0FMLFFBQVF2QixDQUFSLEdBQVksQ0FBWjtBQUNBdUIsUUFBUWxCLENBQVIsR0FBWSxDQUFaO0FBQ0FrQixRQUFRUyxDQUFSLEdBQVksRUFBWjtBQUNBVCxRQUFRaUIsQ0FBUixHQUFZLEVBQVo7QUFDQWpCLFFBQVFnQixDQUFSLEdBQVksRUFBWjtBQUNBaEIsUUFBUWtCLENBQVIsR0FBWSxHQUFaO0FBQ0EsY0FBaUJsQixPQUFqQjs7QUMxQ0EsVUFBWSxHQUFHbUIsb0JBQWY7Ozs7OztBQ0FBLElBQUl2OUIsV0FBVyxHQUFHQSxRQUFsQjs7QUFFQSxXQUFpQixhQUFBLENBQVVzNkIsRUFBVixFQUFjO1NBQ3RCdDZCLFNBQVNwRSxJQUFULENBQWMwK0IsRUFBZCxFQUFrQjMrQixLQUFsQixDQUF3QixDQUF4QixFQUEyQixDQUFDLENBQTVCLENBQVA7Q0FERjs7QUNGQTs7O0FBR0EsZUFBaUJvRSxPQUFPLEdBQVAsRUFBWXc5QixvQkFBWixDQUFpQyxDQUFqQyxJQUFzQ3g5QixNQUF0QyxHQUErQyxVQUFVdTZCLEVBQVYsRUFBYztTQUNyRWtELEtBQUlsRCxFQUFKLEtBQVcsUUFBWCxHQUFzQkEsR0FBRzE5QixLQUFILENBQVMsRUFBVCxDQUF0QixHQUFxQ21ELE9BQU91NkIsRUFBUCxDQUE1QztDQURGOztBQ0hBO0FBQ0EsZUFBaUIsaUJBQUEsQ0FBVUEsRUFBVixFQUFjO01BQ3pCQSxNQUFNbHVCLFNBQVYsRUFBcUIsTUFBTW91QixVQUFVLDJCQUEyQkYsRUFBckMsQ0FBTjtTQUNkQSxFQUFQO0NBRkY7O0FDREE7OztBQUdBLGlCQUFpQixtQkFBQSxDQUFVQSxFQUFWLEVBQWM7U0FDdEJtRCxTQUFRQyxTQUFRcEQsRUFBUixDQUFSLENBQVA7Q0FERjs7QUNHQSxJQUFJcUQsT0FBTzU5QixPQUFPNjlCLHdCQUFsQjs7QUFFQSxVQUFZbkQsZUFBNEJrRCxJQUE1QixHQUFtQyxTQUFTQyx3QkFBVCxDQUFrQzNDLENBQWxDLEVBQXFDQyxDQUFyQyxFQUF3QztNQUNqRjJDLFdBQVU1QyxDQUFWLENBQUo7TUFDSUcsYUFBWUYsQ0FBWixFQUFlLElBQWYsQ0FBSjtNQUNJRyxhQUFKLEVBQW9CLElBQUk7V0FDZnNDLEtBQUsxQyxDQUFMLEVBQVFDLENBQVIsQ0FBUDtHQURrQixDQUVsQixPQUFPbjNCLENBQVAsRUFBVTtNQUNSOEosS0FBSW90QixDQUFKLEVBQU9DLENBQVAsQ0FBSixFQUFlLE9BQU9LLGNBQVcsQ0FBQ3VDLFdBQUkvb0IsQ0FBSixDQUFNblosSUFBTixDQUFXcS9CLENBQVgsRUFBY0MsQ0FBZCxDQUFaLEVBQThCRCxFQUFFQyxDQUFGLENBQTlCLENBQVA7Q0FOakI7Ozs7OztBQ1JBOzs7QUFJQSxJQUFJNkMsUUFBUSxTQUFSQSxLQUFRLENBQVU5QyxDQUFWLEVBQWErQyxLQUFiLEVBQW9CO1lBQ3JCL0MsQ0FBVDtNQUNJLENBQUNWLFVBQVN5RCxLQUFULENBQUQsSUFBb0JBLFVBQVUsSUFBbEMsRUFBd0MsTUFBTXhELFVBQVV3RCxRQUFRLDJCQUFsQixDQUFOO0NBRjFDO0FBSUEsZ0JBQWlCO09BQ1ZqK0IsT0FBT2srQixjQUFQLEtBQTBCLGVBQWUsRUFBZjtZQUNuQjEvQixJQUFWLEVBQWdCMi9CLEtBQWhCLEVBQXVCaDZCLEdBQXZCLEVBQTRCO1FBQ3RCO1lBQ0l1MkIsS0FBa0J6dEIsU0FBU3BSLElBQTNCLEVBQWlDKytCLFlBQTBCNWxCLENBQTFCLENBQTRCaFYsT0FBT3JFLFNBQW5DLEVBQThDLFdBQTlDLEVBQTJEd0ksR0FBNUYsRUFBaUcsQ0FBakcsQ0FBTjtVQUNJM0YsSUFBSixFQUFVLEVBQVY7Y0FDUSxFQUFFQSxnQkFBZ0I5QyxLQUFsQixDQUFSO0tBSEYsQ0FJRSxPQUFPc0ksQ0FBUCxFQUFVO2NBQVUsSUFBUjs7V0FDUCxTQUFTazZCLGNBQVQsQ0FBd0JoRCxDQUF4QixFQUEyQitDLEtBQTNCLEVBQWtDO1lBQ2pDL0MsQ0FBTixFQUFTK0MsS0FBVDtVQUNJRSxLQUFKLEVBQVdqRCxFQUFFa0QsU0FBRixHQUFjSCxLQUFkLENBQVgsS0FDSzk1QixJQUFJKzJCLENBQUosRUFBTytDLEtBQVA7YUFDRS9DLENBQVA7S0FKRjtHQU5GLENBWUUsRUFaRixFQVlNLEtBWk4sQ0FENkIsR0FhZDd1QixTQWJaLENBRFU7U0FlUjJ4QjtDQWZUOztBQ1JBOztBQUVBM0IsUUFBUUEsUUFBUXZCLENBQWhCLEVBQW1CLFFBQW5CLEVBQTZCLEVBQUVvRCxnQkFBZ0J4RCxVQUF3QnYyQixHQUExQyxFQUE3Qjs7QUNEQSxxQkFBaUJ5MkIsTUFBK0I1NkIsTUFBL0IsQ0FBc0NrK0IsY0FBdkQ7O0FDQUEsSUFBSUcsU0FBUyxvQkFBYjtBQUNBLElBQUlDLFFBQVFuRSxRQUFPa0UsTUFBUCxNQUFtQmxFLFFBQU9rRSxNQUFQLElBQWlCLEVBQXBDLENBQVo7QUFDQSxjQUFpQixnQkFBQSxDQUFVNWhDLEdBQVYsRUFBZTtTQUN2QjZoQyxNQUFNN2hDLEdBQU4sTUFBZTZoQyxNQUFNN2hDLEdBQU4sSUFBYSxFQUE1QixDQUFQO0NBREY7OztNQ0hJNmhDLFFBQVE1RCxRQUFxQixLQUFyQixDQUFaOztNQUVJNkQsVUFBUzNELFFBQXFCMkQsTUFBbEM7TUFDSUMsYUFBYSxPQUFPRCxPQUFQLElBQWlCLFVBQWxDOztNQUVJRSxXQUFXMUUsY0FBQSxHQUFpQixVQUFVOTlCLElBQVYsRUFBZ0I7V0FDdkNxaUMsTUFBTXJpQyxJQUFOLE1BQWdCcWlDLE1BQU1yaUMsSUFBTixJQUNyQnVpQyxjQUFjRCxRQUFPdGlDLElBQVAsQ0FBZCxJQUE4QixDQUFDdWlDLGFBQWFELE9BQWIsR0FBc0JHLElBQXZCLEVBQTRCLFlBQVl6aUMsSUFBeEMsQ0FEekIsQ0FBUDtHQURGOztXQUtTcWlDLEtBQVQsR0FBaUJBLEtBQWpCOzs7QUNWQTs7QUFFQSxJQUFJSyxNQUFNakUsS0FBa0IsYUFBbEIsQ0FBVjs7QUFFQSxJQUFJa0UsTUFBTW5CLEtBQUksWUFBWTtTQUFTdmlCLFNBQVA7Q0FBZCxFQUFKLEtBQTRDLFdBQXREOzs7QUFHQSxJQUFJMmpCLFNBQVMsU0FBVEEsTUFBUyxDQUFVdEUsRUFBVixFQUFjOTlCLEdBQWQsRUFBbUI7TUFDMUI7V0FDSzg5QixHQUFHOTlCLEdBQUgsQ0FBUDtHQURGLENBRUUsT0FBT3VILENBQVAsRUFBVTtDQUhkOztBQU1BLGVBQWlCLGlCQUFBLENBQVV1MkIsRUFBVixFQUFjO01BQ3pCVyxDQUFKLEVBQU80RCxDQUFQLEVBQVVoQyxDQUFWO1NBQ092QyxPQUFPbHVCLFNBQVAsR0FBbUIsV0FBbkIsR0FBaUNrdUIsT0FBTyxJQUFQLEdBQWM7O0lBRWxELFFBQVF1RSxJQUFJRCxPQUFPM0QsSUFBSWw3QixPQUFPdTZCLEVBQVAsQ0FBWCxFQUF1Qm9FLEdBQXZCLENBQVosS0FBNEMsUUFBNUMsR0FBdURHOztJQUV2REYsTUFBTW5CLEtBQUl2QyxDQUFKOztJQUVOLENBQUM0QixJQUFJVyxLQUFJdkMsQ0FBSixDQUFMLEtBQWdCLFFBQWhCLElBQTRCLE9BQU9BLEVBQUU2RCxNQUFULElBQW1CLFVBQS9DLEdBQTRELFdBQTVELEdBQTBFakMsQ0FOOUU7Q0FGRjs7OztBQ1ZBLElBQUl0K0IsT0FBTyxFQUFYO0FBQ0FBLEtBQUtrOEIsS0FBa0IsYUFBbEIsQ0FBTCxJQUF5QyxHQUF6QztBQUNBLElBQUlsOEIsT0FBTyxFQUFQLElBQWEsWUFBakIsRUFBK0I7WUFDTndCLE9BQU9yRSxTQUE5QixFQUF5QyxVQUF6QyxFQUFxRCxTQUFTc0UsUUFBVCxHQUFvQjtXQUNoRSxhQUFhKytCLFNBQVEsSUFBUixDQUFiLEdBQTZCLEdBQXBDO0dBREYsRUFFRyxJQUZIOzs7QUNORjtBQUNBLElBQUlDLE9BQU94cEIsS0FBS3dwQixJQUFoQjtBQUNBLElBQUl2cEIsUUFBUUQsS0FBS0MsS0FBakI7QUFDQSxpQkFBaUIsbUJBQUEsQ0FBVTZrQixFQUFWLEVBQWM7U0FDdEIvckIsTUFBTStyQixLQUFLLENBQUNBLEVBQVosSUFBa0IsQ0FBbEIsR0FBc0IsQ0FBQ0EsS0FBSyxDQUFMLEdBQVM3a0IsS0FBVCxHQUFpQnVwQixJQUFsQixFQUF3QjFFLEVBQXhCLENBQTdCO0NBREY7O0FDREE7O0FBRUEsZ0JBQWlCLGtCQUFBLENBQVVxQixTQUFWLEVBQXFCO1NBQzdCLFVBQVVPLElBQVYsRUFBZ0IrQyxHQUFoQixFQUFxQjtRQUN0QmxpQyxJQUFJay9CLE9BQU95QixTQUFReEIsSUFBUixDQUFQLENBQVI7UUFDSWovQixJQUFJaWlDLFdBQVVELEdBQVYsQ0FBUjtRQUNJanRCLElBQUlqVixFQUFFRyxNQUFWO1FBQ0lnYixDQUFKLEVBQU9tTixDQUFQO1FBQ0lwb0IsSUFBSSxDQUFKLElBQVNBLEtBQUsrVSxDQUFsQixFQUFxQixPQUFPMnBCLFlBQVksRUFBWixHQUFpQnZ2QixTQUF4QjtRQUNqQnJQLEVBQUV5UyxVQUFGLENBQWF2UyxDQUFiLENBQUo7V0FDT2liLElBQUksTUFBSixJQUFjQSxJQUFJLE1BQWxCLElBQTRCamIsSUFBSSxDQUFKLEtBQVUrVSxDQUF0QyxJQUEyQyxDQUFDcVQsSUFBSXRvQixFQUFFeVMsVUFBRixDQUFhdlMsSUFBSSxDQUFqQixDQUFMLElBQTRCLE1BQXZFLElBQWlGb29CLElBQUksTUFBckYsR0FDSHNXLFlBQVk1K0IsRUFBRXdFLE1BQUYsQ0FBU3RFLENBQVQsQ0FBWixHQUEwQmliLENBRHZCLEdBRUh5akIsWUFBWTUrQixFQUFFcEIsS0FBRixDQUFRc0IsQ0FBUixFQUFXQSxJQUFJLENBQWYsQ0FBWixHQUFnQyxDQUFDaWIsSUFBSSxNQUFKLElBQWMsRUFBZixLQUFzQm1OLElBQUksTUFBMUIsSUFBb0MsT0FGeEU7R0FQRjtDQURGOztBQ0pBLGVBQWlCLEtBQWpCOztBQ0FBLGlCQUFpQixFQUFqQjs7QUNBQTs7QUFFQSxJQUFJM0csTUFBTWxKLEtBQUtrSixHQUFmO0FBQ0EsZ0JBQWlCLGtCQUFBLENBQVU0YixFQUFWLEVBQWM7U0FDdEJBLEtBQUssQ0FBTCxHQUFTNWIsSUFBSXdnQixXQUFVNUUsRUFBVixDQUFKLEVBQW1CLGdCQUFuQixDQUFULEdBQWdELENBQXZELENBRDZCO0NBQS9COztBQ0ZBLElBQUkzYixNQUFNbkosS0FBS21KLEdBQWY7QUFDQSxJQUFJRCxRQUFNbEosS0FBS2tKLEdBQWY7QUFDQSx1QkFBaUIseUJBQUEsQ0FBVWxULEtBQVYsRUFBaUJ0TyxNQUFqQixFQUF5QjtVQUNoQ2dpQyxXQUFVMXpCLEtBQVYsQ0FBUjtTQUNPQSxRQUFRLENBQVIsR0FBWW1ULElBQUluVCxRQUFRdE8sTUFBWixFQUFvQixDQUFwQixDQUFaLEdBQXFDd2hCLE1BQUlsVCxLQUFKLEVBQVd0TyxNQUFYLENBQTVDO0NBRkY7O0FDSEE7Ozs7QUFLQSxxQkFBaUIsdUJBQUEsQ0FBVWlpQyxXQUFWLEVBQXVCO1NBQy9CLFVBQVVDLEtBQVYsRUFBaUJyNUIsRUFBakIsRUFBcUJzNUIsU0FBckIsRUFBZ0M7UUFDakNwRSxJQUFJNEMsV0FBVXVCLEtBQVYsQ0FBUjtRQUNJbGlDLFNBQVNvaUMsVUFBU3JFLEVBQUUvOUIsTUFBWCxDQUFiO1FBQ0lzTyxRQUFRK3pCLGlCQUFnQkYsU0FBaEIsRUFBMkJuaUMsTUFBM0IsQ0FBWjtRQUNJNEQsS0FBSjs7O1FBR0lxK0IsZUFBZXA1QixNQUFNQSxFQUF6QixFQUE2QixPQUFPN0ksU0FBU3NPLEtBQWhCLEVBQXVCO2NBQzFDeXZCLEVBQUV6dkIsT0FBRixDQUFSOztVQUVJMUssU0FBU0EsS0FBYixFQUFvQixPQUFPLElBQVA7O0tBSHRCLE1BS08sT0FBTTVELFNBQVNzTyxLQUFmLEVBQXNCQSxPQUF0QjtVQUFtQzJ6QixlQUFlM3pCLFNBQVN5dkIsQ0FBNUIsRUFBK0I7WUFDL0RBLEVBQUV6dkIsS0FBRixNQUFhekYsRUFBakIsRUFBcUIsT0FBT281QixlQUFlM3pCLEtBQWYsSUFBd0IsQ0FBL0I7O0tBQ3JCLE9BQU8sQ0FBQzJ6QixXQUFELElBQWdCLENBQUMsQ0FBeEI7R0FkSjtDQURGOztBQ0xBLElBQUlLLFNBQVMvRSxRQUFxQixNQUFyQixDQUFiOztBQUVBLGlCQUFpQixtQkFBQSxDQUFVaitCLEdBQVYsRUFBZTtTQUN2QmdqQyxPQUFPaGpDLEdBQVAsTUFBZ0JnakMsT0FBT2hqQyxHQUFQLElBQWNpaUMsS0FBSWppQyxHQUFKLENBQTlCLENBQVA7Q0FERjs7QUNBQSxJQUFJaWpDLGVBQWVoRixlQUE2QixLQUE3QixDQUFuQjtBQUNBLElBQUlpRixhQUFXL0UsV0FBeUIsVUFBekIsQ0FBZjs7QUFFQSwwQkFBaUIsNEJBQUEsQ0FBVWhyQixNQUFWLEVBQWtCZ3dCLEtBQWxCLEVBQXlCO01BQ3BDMUUsSUFBSTRDLFdBQVVsdUIsTUFBVixDQUFSO01BQ0kxUyxJQUFJLENBQVI7TUFDSWdCLFNBQVMsRUFBYjtNQUNJekIsR0FBSjtPQUNLQSxHQUFMLElBQVl5K0IsQ0FBWjtRQUFtQnorQixPQUFPa2pDLFVBQVgsRUFBcUI3eEIsS0FBSW90QixDQUFKLEVBQU96K0IsR0FBUCxLQUFleUIsT0FBT1osSUFBUCxDQUFZYixHQUFaLENBQWY7R0FMSTtTQU9qQ21qQyxNQUFNemlDLE1BQU4sR0FBZUQsQ0FBdEI7UUFBNkI0USxLQUFJb3RCLENBQUosRUFBT3orQixNQUFNbWpDLE1BQU0xaUMsR0FBTixDQUFiLENBQUosRUFBOEI7T0FDcER3aUMsYUFBYXhoQyxNQUFiLEVBQXFCekIsR0FBckIsQ0FBRCxJQUE4QnlCLE9BQU9aLElBQVAsQ0FBWWIsR0FBWixDQUE5Qjs7R0FFRixPQUFPeUIsTUFBUDtDQVZGOztBQ0xBO0FBQ0EsbUJBQ0UsK0ZBRGUsQ0FFZnJCLEtBRmUsQ0FFVCxHQUZTLENBQWpCOztBQ0RBOzs7QUFJQSxrQkFBaUJtRCxPQUFPekQsSUFBUCxJQUFlLFNBQVNBLElBQVQsQ0FBYzIrQixDQUFkLEVBQWlCO1NBQ3hDMkUsb0JBQU0zRSxDQUFOLEVBQVM0RSxZQUFULENBQVA7Q0FERjs7QUNBQSxpQkFBaUJwRixlQUE0QjE2QixPQUFPKy9CLGdCQUFuQyxHQUFzRCxTQUFTQSxnQkFBVCxDQUEwQjdFLENBQTFCLEVBQTZCOEUsVUFBN0IsRUFBeUM7WUFDckc5RSxDQUFUO01BQ0kzK0IsT0FBTzBqQyxZQUFRRCxVQUFSLENBQVg7TUFDSTdpQyxTQUFTWixLQUFLWSxNQUFsQjtNQUNJRCxJQUFJLENBQVI7TUFDSWkrQixDQUFKO1NBQ09oK0IsU0FBU0QsQ0FBaEI7Y0FBc0I4WCxDQUFILENBQUtrbUIsQ0FBTCxFQUFRQyxJQUFJNStCLEtBQUtXLEdBQUwsQ0FBWixFQUF1QjhpQyxXQUFXN0UsQ0FBWCxDQUF2QjtHQUNuQixPQUFPRCxDQUFQO0NBUEY7O0FDSkEsSUFBSTEvQixhQUFXay9CLFFBQXFCbC9CLFFBQXBDO0FBQ0EsWUFBaUJBLGNBQVlBLFdBQVNDLGVBQXRDOztBQ0RBOzs7QUFJQSxJQUFJa2tDLFdBQVdqRixXQUF5QixVQUF6QixDQUFmO0FBQ0EsSUFBSXdGLFFBQVEsU0FBUkEsS0FBUSxHQUFZLGFBQXhCO0FBQ0EsSUFBSTlELGNBQVksV0FBaEI7OztBQUdBLElBQUkrRCxjQUFhLHNCQUFZOztNQUV2QkMsU0FBU3hGLFdBQXlCLFFBQXpCLENBQWI7TUFDSTE5QixJQUFJNGlDLGFBQVkzaUMsTUFBcEI7TUFDSWtqQyxLQUFLLEdBQVQ7TUFDSUMsS0FBSyxHQUFUO01BQ0lDLGNBQUo7U0FDT2prQyxLQUFQLENBQWFzUixPQUFiLEdBQXVCLE1BQXZCO1FBQ21CM0gsV0FBbkIsQ0FBK0JtNkIsTUFBL0I7U0FDT3ppQixHQUFQLEdBQWEsYUFBYixDQVQyQjs7O21CQVlWeWlCLE9BQU9JLGFBQVAsQ0FBcUJobEMsUUFBdEM7aUJBQ2UrSixJQUFmO2lCQUNlazdCLEtBQWYsQ0FBcUJKLEtBQUssUUFBTCxHQUFnQkMsRUFBaEIsR0FBcUIsbUJBQXJCLEdBQTJDRCxFQUEzQyxHQUFnRCxTQUFoRCxHQUE0REMsRUFBakY7aUJBQ2VJLEtBQWY7Z0JBQ2FILGVBQWUvRCxDQUE1QjtTQUNPdC9CLEdBQVA7V0FBbUJpakMsWUFBVy9ELFdBQVgsRUFBc0IwRCxhQUFZNWlDLENBQVosQ0FBdEIsQ0FBUDtHQUNaLE9BQU9pakMsYUFBUDtDQWxCRjs7QUFxQkEsb0JBQWlCbmdDLE9BQU9tUyxNQUFQLElBQWlCLFNBQVNBLE1BQVQsQ0FBZ0Irb0IsQ0FBaEIsRUFBbUI4RSxVQUFuQixFQUErQjtNQUMzRDloQyxNQUFKO01BQ0lnOUIsTUFBTSxJQUFWLEVBQWdCO1VBQ1JrQixXQUFOLElBQW1CdUUsVUFBU3pGLENBQVQsQ0FBbkI7YUFDUyxJQUFJZ0YsS0FBSixFQUFUO1VBQ005RCxXQUFOLElBQW1CLElBQW5COztXQUVPdUQsUUFBUCxJQUFtQnpFLENBQW5CO0dBTEYsTUFNT2g5QixTQUFTaWlDLGFBQVQ7U0FDQUgsZUFBZTN6QixTQUFmLEdBQTJCbk8sTUFBM0IsR0FBb0MwaUMsV0FBSTFpQyxNQUFKLEVBQVk4aEMsVUFBWixDQUEzQztDQVRGOztBQzlCQSxJQUFJYSxNQUFNbkcsVUFBd0IxbEIsQ0FBbEM7O0FBRUEsSUFBSTJwQixRQUFNL0QsS0FBa0IsYUFBbEIsQ0FBVjs7QUFFQSxzQkFBaUIsd0JBQUEsQ0FBVUwsRUFBVixFQUFjdUcsR0FBZCxFQUFtQkMsSUFBbkIsRUFBeUI7TUFDcEN4RyxNQUFNLENBQUN6c0IsS0FBSXlzQixLQUFLd0csT0FBT3hHLEVBQVAsR0FBWUEsR0FBRzUrQixTQUF4QixFQUFtQ2dqQyxLQUFuQyxDQUFYLEVBQW9Ea0MsSUFBSXRHLEVBQUosRUFBUW9FLEtBQVIsRUFBYSxFQUFFcUMsY0FBYyxJQUFoQixFQUFzQmpnQyxPQUFPKy9CLEdBQTdCLEVBQWI7Q0FEdEQ7O0FDQUEsSUFBSUcsb0JBQW9CLEVBQXhCOzs7QUFHQXZHLE1BQW1CdUcsaUJBQW5CLEVBQXNDckcsS0FBa0IsVUFBbEIsQ0FBdEMsRUFBcUUsWUFBWTtTQUFTLElBQVA7Q0FBbkY7O0FBRUEsa0JBQWlCLG9CQUFBLENBQVVzRyxXQUFWLEVBQXVCQyxJQUF2QixFQUE2QkMsSUFBN0IsRUFBbUM7Y0FDdEN6bEMsU0FBWixHQUF3QndXLGNBQU84dUIsaUJBQVAsRUFBMEIsRUFBRUcsTUFBTUMsY0FBVyxDQUFYLEVBQWNELElBQWQsQ0FBUixFQUExQixDQUF4QjtrQkFDZUYsV0FBZixFQUE0QkMsT0FBTyxXQUFuQztDQUZGOztBQ1RBOztBQUVBLGdCQUFpQixrQkFBQSxDQUFVNUcsRUFBVixFQUFjO1NBQ3RCdjZCLE9BQU8yOUIsU0FBUXBELEVBQVIsQ0FBUCxDQUFQO0NBREY7O0FDRkE7OztBQUdBLElBQUlvRixhQUFXakYsV0FBeUIsVUFBekIsQ0FBZjtBQUNBLElBQUk0RyxjQUFjdGhDLE9BQU9yRSxTQUF6Qjs7QUFFQSxpQkFBaUJxRSxPQUFPdWhDLGNBQVAsSUFBeUIsVUFBVXJHLENBQVYsRUFBYTtNQUNqRHNHLFVBQVN0RyxDQUFULENBQUo7TUFDSXB0QixLQUFJb3RCLENBQUosRUFBT3lFLFVBQVAsQ0FBSixFQUFzQixPQUFPekUsRUFBRXlFLFVBQUYsQ0FBUDtNQUNsQixPQUFPekUsRUFBRXVHLFdBQVQsSUFBd0IsVUFBeEIsSUFBc0N2RyxhQUFhQSxFQUFFdUcsV0FBekQsRUFBc0U7V0FDN0R2RyxFQUFFdUcsV0FBRixDQUFjOWxDLFNBQXJCO0dBQ0EsT0FBT3UvQixhQUFhbDdCLE1BQWIsR0FBc0JzaEMsV0FBdEIsR0FBb0MsSUFBM0M7Q0FMSjs7QUNJQSxJQUFJSSxXQUFXaEgsS0FBa0IsVUFBbEIsQ0FBZjtBQUNBLElBQUlpSCxRQUFRLEVBQUUsR0FBR3BsQyxJQUFILElBQVcsVUFBVSxHQUFHQSxJQUFILEVBQXZCLENBQVo7QUFDQSxJQUFJcWxDLGNBQWMsWUFBbEI7QUFDQSxJQUFJQyxPQUFPLE1BQVg7QUFDQSxJQUFJQyxTQUFTLFFBQWI7O0FBRUEsSUFBSUMsYUFBYSxTQUFiQSxVQUFhLEdBQVk7U0FBUyxJQUFQO0NBQS9COztBQUVBLGtCQUFpQixvQkFBQSxDQUFVQyxJQUFWLEVBQWdCYixJQUFoQixFQUFzQkQsV0FBdEIsRUFBbUNFLElBQW5DLEVBQXlDYSxPQUF6QyxFQUFrREMsTUFBbEQsRUFBMERDLE1BQTFELEVBQWtFO2NBQ3JFakIsV0FBWixFQUF5QkMsSUFBekIsRUFBK0JDLElBQS9CO01BQ0lnQixZQUFZLFNBQVpBLFNBQVksQ0FBVUMsSUFBVixFQUFnQjtRQUMxQixDQUFDVixLQUFELElBQVVVLFFBQVFwRSxLQUF0QixFQUE2QixPQUFPQSxNQUFNb0UsSUFBTixDQUFQO1lBQ3JCQSxJQUFSO1dBQ09SLElBQUw7ZUFBa0IsU0FBU3RsQyxJQUFULEdBQWdCO2lCQUFTLElBQUkya0MsV0FBSixDQUFnQixJQUFoQixFQUFzQm1CLElBQXRCLENBQVA7U0FBekI7V0FDTlAsTUFBTDtlQUFvQixTQUFTUSxNQUFULEdBQWtCO2lCQUFTLElBQUlwQixXQUFKLENBQWdCLElBQWhCLEVBQXNCbUIsSUFBdEIsQ0FBUDtTQUEzQjtLQUNiLE9BQU8sU0FBU0UsT0FBVCxHQUFtQjthQUFTLElBQUlyQixXQUFKLENBQWdCLElBQWhCLEVBQXNCbUIsSUFBdEIsQ0FBUDtLQUE1QjtHQUxKO01BT0kxRCxNQUFNd0MsT0FBTyxXQUFqQjtNQUNJcUIsYUFBYVAsV0FBV0gsTUFBNUI7TUFDSVcsYUFBYSxLQUFqQjtNQUNJeEUsUUFBUStELEtBQUtybUMsU0FBakI7TUFDSSttQyxVQUFVekUsTUFBTXlELFFBQU4sS0FBbUJ6RCxNQUFNMkQsV0FBTixDQUFuQixJQUF5Q0ssV0FBV2hFLE1BQU1nRSxPQUFOLENBQWxFO01BQ0lVLFdBQVdELFdBQVdOLFVBQVVILE9BQVYsQ0FBMUI7TUFDSVcsV0FBV1gsVUFBVSxDQUFDTyxVQUFELEdBQWNHLFFBQWQsR0FBeUJQLFVBQVUsU0FBVixDQUFuQyxHQUEwRC8xQixTQUF6RTtNQUNJdzJCLGFBQWExQixRQUFRLE9BQVIsR0FBa0JsRCxNQUFNc0UsT0FBTixJQUFpQkcsT0FBbkMsR0FBNkNBLE9BQTlEO01BQ0lwTixPQUFKLEVBQWE3NEIsR0FBYixFQUFrQndrQyxpQkFBbEI7O01BRUk0QixVQUFKLEVBQWdCO3dCQUNNdEIsV0FBZXNCLFdBQVdobkMsSUFBWCxDQUFnQixJQUFJbW1DLElBQUosRUFBaEIsQ0FBZixDQUFwQjtRQUNJZixzQkFBc0JqaEMsT0FBT3JFLFNBQTdCLElBQTBDc2xDLGtCQUFrQkcsSUFBaEUsRUFBc0U7O3NCQUVyREgsaUJBQWYsRUFBa0N0QyxHQUFsQyxFQUF1QyxJQUF2Qzs7VUFFSSxDQUFDbUUsUUFBRCxJQUFZLENBQUNoMUIsS0FBSW16QixpQkFBSixFQUF1QlMsUUFBdkIsQ0FBakIsRUFBbUQ1VixNQUFLbVYsaUJBQUwsRUFBd0JTLFFBQXhCLEVBQWtDSyxVQUFsQzs7OztNQUluRFMsY0FBY0UsT0FBZCxJQUF5QkEsUUFBUXptQyxJQUFSLEtBQWlCNmxDLE1BQTlDLEVBQXNEO2lCQUN2QyxJQUFiO2VBQ1csU0FBU1EsTUFBVCxHQUFrQjthQUFTSSxRQUFRN21DLElBQVIsQ0FBYSxJQUFiLENBQVA7S0FBL0I7OztNQUdFLENBQUMsQ0FBQ2luQyxRQUFELElBQVlYLE1BQWIsTUFBeUJSLFNBQVNjLFVBQVQsSUFBdUIsQ0FBQ3hFLE1BQU15RCxRQUFOLENBQWpELENBQUosRUFBdUU7VUFDaEV6RCxLQUFMLEVBQVl5RCxRQUFaLEVBQXNCaUIsUUFBdEI7OzthQUdReEIsSUFBVixJQUFrQndCLFFBQWxCO2FBQ1VoRSxHQUFWLElBQWlCb0QsVUFBakI7TUFDSUUsT0FBSixFQUFhO2NBQ0Q7Y0FDQU8sYUFBYUcsUUFBYixHQUF3QlAsVUFBVU4sTUFBVixDQUR4QjtZQUVGSSxTQUFTUyxRQUFULEdBQW9CUCxVQUFVUCxJQUFWLENBRmxCO2VBR0NlO0tBSFg7UUFLSVQsTUFBSixFQUFZLEtBQUsxbEMsR0FBTCxJQUFZNjRCLE9BQVosRUFBcUI7VUFDM0IsRUFBRTc0QixPQUFPd2hDLEtBQVQsQ0FBSixFQUFxQmIsVUFBU2EsS0FBVCxFQUFnQnhoQyxHQUFoQixFQUFxQjY0QixRQUFRNzRCLEdBQVIsQ0FBckI7S0FEdkIsTUFFTzQvQixRQUFRQSxRQUFRbEIsQ0FBUixHQUFZa0IsUUFBUUcsQ0FBUixJQUFhbUYsU0FBU2MsVUFBdEIsQ0FBcEIsRUFBdUR0QixJQUF2RCxFQUE2RDdMLE9BQTdEOztTQUVGQSxPQUFQO0NBbERGOztBQ2pCQSxJQUFJeU4sTUFBTXJJLFVBQXdCLElBQXhCLENBQVY7OztBQUdBRSxZQUEwQnNCLE1BQTFCLEVBQWtDLFFBQWxDLEVBQTRDLFVBQVU4RyxRQUFWLEVBQW9CO09BQ3pEQyxFQUFMLEdBQVUvRyxPQUFPOEcsUUFBUCxDQUFWLENBRDhEO09BRXpERSxFQUFMLEdBQVUsQ0FBVixDQUY4RDs7Q0FBaEUsRUFJRyxZQUFZO01BQ1RoSSxJQUFJLEtBQUsrSCxFQUFiO01BQ0l4M0IsUUFBUSxLQUFLeTNCLEVBQWpCO01BQ0lDLEtBQUo7TUFDSTEzQixTQUFTeXZCLEVBQUUvOUIsTUFBZixFQUF1QixPQUFPLEVBQUU0RCxPQUFPc0wsU0FBVCxFQUFvQm9OLE1BQU0sSUFBMUIsRUFBUDtVQUNmc3BCLElBQUk3SCxDQUFKLEVBQU96dkIsS0FBUCxDQUFSO09BQ0t5M0IsRUFBTCxJQUFXQyxNQUFNaG1DLE1BQWpCO1NBQ08sRUFBRTRELE9BQU9vaUMsS0FBVCxFQUFnQjFwQixNQUFNLEtBQXRCLEVBQVA7Q0FYRjs7QUNKQTtBQUNBLElBQUkycEIsY0FBYzFJLEtBQWtCLGFBQWxCLENBQWxCO0FBQ0EsSUFBSTJJLGFBQWEzbkMsTUFBTUMsU0FBdkI7QUFDQSxJQUFJMG5DLFdBQVdELFdBQVgsS0FBMkIvMkIsU0FBL0IsRUFBMEN1dUIsTUFBbUJ5SSxVQUFuQixFQUErQkQsV0FBL0IsRUFBNEMsRUFBNUM7QUFDMUMsd0JBQWlCLDBCQUFBLENBQVUzbUMsR0FBVixFQUFlO2FBQ25CMm1DLFdBQVgsRUFBd0IzbUMsR0FBeEIsSUFBK0IsSUFBL0I7Q0FERjs7QUNKQSxnQkFBaUIsa0JBQUEsQ0FBVWdkLElBQVYsRUFBZ0IxWSxLQUFoQixFQUF1QjtTQUMvQixFQUFFQSxPQUFPQSxLQUFULEVBQWdCMFksTUFBTSxDQUFDLENBQUNBLElBQXhCLEVBQVA7Q0FERjs7Ozs7O0FDVUEseUJBQWlCaWhCLFlBQTBCaC9CLEtBQTFCLEVBQWlDLE9BQWpDLEVBQTBDLFVBQVVzbkMsUUFBVixFQUFvQlgsSUFBcEIsRUFBMEI7T0FDOUVZLEVBQUwsR0FBVW5GLFdBQVVrRixRQUFWLENBQVYsQ0FEbUY7T0FFOUVFLEVBQUwsR0FBVSxDQUFWLENBRm1GO09BRzlFSSxFQUFMLEdBQVVqQixJQUFWLENBSG1GOztDQUFwRSxFQUtkLFlBQVk7TUFDVG5ILElBQUksS0FBSytILEVBQWI7TUFDSVosT0FBTyxLQUFLaUIsRUFBaEI7TUFDSTczQixRQUFRLEtBQUt5M0IsRUFBTCxFQUFaO01BQ0ksQ0FBQ2hJLENBQUQsSUFBTXp2QixTQUFTeXZCLEVBQUUvOUIsTUFBckIsRUFBNkI7U0FDdEI4bEMsRUFBTCxHQUFVNTJCLFNBQVY7V0FDT3VOLFVBQUssQ0FBTCxDQUFQOztNQUVFeW9CLFFBQVEsTUFBWixFQUFvQixPQUFPem9CLFVBQUssQ0FBTCxFQUFRbk8sS0FBUixDQUFQO01BQ2hCNDJCLFFBQVEsUUFBWixFQUFzQixPQUFPem9CLFVBQUssQ0FBTCxFQUFRc2hCLEVBQUV6dkIsS0FBRixDQUFSLENBQVA7U0FDZm1PLFVBQUssQ0FBTCxFQUFRLENBQUNuTyxLQUFELEVBQVF5dkIsRUFBRXp2QixLQUFGLENBQVIsQ0FBUixDQUFQO0NBZmUsRUFnQmQsUUFoQmMsQ0FBakI7OztBQW1CQTgzQixXQUFVQyxTQUFWLEdBQXNCRCxXQUFVN25DLEtBQWhDOztBQUVBK25DLGtCQUFpQixNQUFqQjtBQUNBQSxrQkFBaUIsUUFBakI7QUFDQUEsa0JBQWlCLFNBQWpCOztBQzFCQSxJQUFJL0IsYUFBV2dDLEtBQUksVUFBSixDQUFmO0FBQ0EsSUFBSUMsZ0JBQWdCRCxLQUFJLGFBQUosQ0FBcEI7QUFDQSxJQUFJRSxjQUFjTCxXQUFVN25DLEtBQTVCOztBQUVBLElBQUltb0MsZUFBZTtlQUNKLElBREk7dUJBRUksS0FGSjtnQkFHSCxLQUhHO2tCQUlELEtBSkM7ZUFLSixLQUxJO2lCQU1GLEtBTkU7Z0JBT0gsSUFQRzt3QkFRSyxLQVJMO1lBU1AsS0FUTztxQkFVRSxLQVZGO2tCQVdELEtBWEM7bUJBWUEsS0FaQTtxQkFhRSxLQWJGO2FBY04sSUFkTTtpQkFlRixLQWZFO2dCQWdCSCxLQWhCRztZQWlCUCxJQWpCTztvQkFrQkMsS0FsQkQ7VUFtQlQsS0FuQlM7ZUFvQkosS0FwQkk7aUJBcUJGLEtBckJFO2lCQXNCRixLQXRCRTtrQkF1QkQsS0F2QkM7Z0JBd0JILEtBeEJHO2lCQXlCRixLQXpCRTtvQkEwQkMsS0ExQkQ7b0JBMkJDLEtBM0JEO2tCQTRCRCxJQTVCQztvQkE2QkMsS0E3QkQ7aUJBOEJGLEtBOUJFO2FBK0JOO0NBL0JiOztBQWtDQSxLQUFLLElBQUlDLGNBQWM3RCxZQUFRNEQsWUFBUixDQUFsQixFQUF5QzNtQyxJQUFJLENBQWxELEVBQXFEQSxJQUFJNG1DLFlBQVkzbUMsTUFBckUsRUFBNkVELEdBQTdFLEVBQWtGO01BQzVFaWtDLE9BQU8yQyxZQUFZNW1DLENBQVosQ0FBWDtNQUNJNm1DLFdBQVdGLGFBQWExQyxJQUFiLENBQWY7TUFDSTZDLGFBQWE3SixRQUFPZ0gsSUFBUCxDQUFqQjtNQUNJbEQsUUFBUStGLGNBQWNBLFdBQVdyb0MsU0FBckM7TUFDSWMsR0FBSjtNQUNJd2hDLEtBQUosRUFBVztRQUNMLENBQUNBLE1BQU15RCxVQUFOLENBQUwsRUFBc0I1VixNQUFLbVMsS0FBTCxFQUFZeUQsVUFBWixFQUFzQmtDLFdBQXRCO1FBQ2xCLENBQUMzRixNQUFNMEYsYUFBTixDQUFMLEVBQTJCN1gsTUFBS21TLEtBQUwsRUFBWTBGLGFBQVosRUFBMkJ4QyxJQUEzQjtlQUNqQkEsSUFBVixJQUFrQnlDLFdBQWxCO1FBQ0lHLFFBQUosRUFBYyxLQUFLdG5DLEdBQUwsSUFBWXduQyxrQkFBWjtVQUE0QixDQUFDaEcsTUFBTXhoQyxHQUFOLENBQUwsRUFBaUIyZ0MsVUFBU2EsS0FBVCxFQUFnQnhoQyxHQUFoQixFQUFxQnduQyxtQkFBV3huQyxHQUFYLENBQXJCLEVBQXNDLElBQXRDOzs7OztBQ3REM0QsbUJBQWlCLHFCQUFBLENBQVV3SCxNQUFWLEVBQWtCMFosR0FBbEIsRUFBdUJxZSxJQUF2QixFQUE2QjtPQUN2QyxJQUFJdi9CLEdBQVQsSUFBZ0JraEIsR0FBaEI7Y0FBOEIxWixNQUFULEVBQWlCeEgsR0FBakIsRUFBc0JraEIsSUFBSWxoQixHQUFKLENBQXRCLEVBQWdDdS9CLElBQWhDO0dBQ3JCLE9BQU8vM0IsTUFBUDtDQUZGOztBQ0RBLGtCQUFpQixvQkFBQSxDQUFVczJCLEVBQVYsRUFBYzJHLFdBQWQsRUFBMkJqbEMsSUFBM0IsRUFBaUNpb0MsY0FBakMsRUFBaUQ7TUFDNUQsRUFBRTNKLGNBQWMyRyxXQUFoQixLQUFpQ2dELG1CQUFtQjczQixTQUFuQixJQUFnQzYzQixrQkFBa0IzSixFQUF2RixFQUE0RjtVQUNwRkUsVUFBVXgrQixPQUFPLHlCQUFqQixDQUFOO0dBQ0EsT0FBT3MrQixFQUFQO0NBSEo7O0FDQUE7O0FBRUEsZ0JBQWlCLGtCQUFBLENBQVUxYyxRQUFWLEVBQW9CNWYsRUFBcEIsRUFBd0I4QyxLQUF4QixFQUErQndoQyxPQUEvQixFQUF3QztNQUNuRDtXQUNLQSxVQUFVdGtDLEdBQUcwaUMsVUFBUzUvQixLQUFULEVBQWdCLENBQWhCLENBQUgsRUFBdUJBLE1BQU0sQ0FBTixDQUF2QixDQUFWLEdBQTZDOUMsR0FBRzhDLEtBQUgsQ0FBcEQ7O0dBREYsQ0FHRSxPQUFPaUQsQ0FBUCxFQUFVO1FBQ05tZ0MsTUFBTXRtQixTQUFTLFFBQVQsQ0FBVjtRQUNJc21CLFFBQVE5M0IsU0FBWixFQUF1QnMwQixVQUFTd0QsSUFBSXRvQyxJQUFKLENBQVNnaUIsUUFBVCxDQUFUO1VBQ2pCN1osQ0FBTjs7Q0FQSjs7QUNGQTs7QUFFQSxJQUFJMDlCLGFBQVdoSCxLQUFrQixVQUFsQixDQUFmO0FBQ0EsSUFBSTJJLGVBQWEzbkMsTUFBTUMsU0FBdkI7O0FBRUEsbUJBQWlCLHFCQUFBLENBQVU0K0IsRUFBVixFQUFjO1NBQ3RCQSxPQUFPbHVCLFNBQVAsS0FBcUJrM0IsV0FBVTduQyxLQUFWLEtBQW9CNitCLEVBQXBCLElBQTBCOEksYUFBVzNCLFVBQVgsTUFBeUJuSCxFQUF4RSxDQUFQO0NBREY7O0FDSkEsSUFBSW1ILGFBQVdoSCxLQUFrQixVQUFsQixDQUFmOztBQUVBLDZCQUFpQkUsTUFBbUJ3SixpQkFBbkIsR0FBdUMsVUFBVTdKLEVBQVYsRUFBYztNQUNoRUEsTUFBTWx1QixTQUFWLEVBQXFCLE9BQU9rdUIsR0FBR21ILFVBQUgsS0FDdkJuSCxHQUFHLFlBQUgsQ0FEdUIsSUFFdkJnSixXQUFVdkUsU0FBUXpFLEVBQVIsQ0FBVixDQUZnQjtDQUR2Qjs7O01DR0k4SixRQUFRLEVBQVo7TUFDSUMsU0FBUyxFQUFiO01BQ0l0SyxVQUFVRCxjQUFBLEdBQWlCLFVBQVV3SyxRQUFWLEVBQW9CaEMsT0FBcEIsRUFBNkJ0a0MsRUFBN0IsRUFBaUNrK0IsSUFBakMsRUFBdUN1RixRQUF2QyxFQUFpRDtRQUMxRThDLFNBQVM5QyxXQUFXLFlBQVk7YUFBUzZDLFFBQVA7S0FBekIsR0FBOENFLHVCQUFVRixRQUFWLENBQTNEO1FBQ0l2dkIsSUFBSW1vQixLQUFJbC9CLEVBQUosRUFBUWsrQixJQUFSLEVBQWNvRyxVQUFVLENBQVYsR0FBYyxDQUE1QixDQUFSO1FBQ0k5MkIsUUFBUSxDQUFaO1FBQ0l0TyxNQUFKLEVBQVl5YyxJQUFaLEVBQWtCaUUsUUFBbEIsRUFBNEIzZixNQUE1QjtRQUNJLE9BQU9zbUMsTUFBUCxJQUFpQixVQUFyQixFQUFpQyxNQUFNL0osVUFBVThKLFdBQVcsbUJBQXJCLENBQU47O1FBRTdCRyxhQUFZRixNQUFaLENBQUosRUFBeUIsS0FBS3JuQyxTQUFTb2lDLFVBQVNnRixTQUFTcG5DLE1BQWxCLENBQWQsRUFBeUNBLFNBQVNzTyxLQUFsRCxFQUF5REEsT0FBekQsRUFBa0U7ZUFDaEY4MkIsVUFBVXZ0QixFQUFFMnJCLFVBQVMvbUIsT0FBTzJxQixTQUFTOTRCLEtBQVQsQ0FBaEIsRUFBaUMsQ0FBakMsQ0FBRixFQUF1Q21PLEtBQUssQ0FBTCxDQUF2QyxDQUFWLEdBQTRENUUsRUFBRXV2QixTQUFTOTRCLEtBQVQsQ0FBRixDQUFyRTtVQUNJdk4sV0FBV21tQyxLQUFYLElBQW9Cbm1DLFdBQVdvbUMsTUFBbkMsRUFBMkMsT0FBT3BtQyxNQUFQO0tBRjdDLE1BR08sS0FBSzJmLFdBQVcybUIsT0FBTzNvQyxJQUFQLENBQVkwb0MsUUFBWixDQUFoQixFQUF1QyxDQUFDLENBQUMzcUIsT0FBT2lFLFNBQVN1akIsSUFBVCxFQUFSLEVBQXlCM25CLElBQWpFLEdBQXdFO2VBQ3BFNWQsVUFBS2dpQixRQUFMLEVBQWU3SSxDQUFmLEVBQWtCNEUsS0FBSzdZLEtBQXZCLEVBQThCd2hDLE9BQTlCLENBQVQ7VUFDSXJrQyxXQUFXbW1DLEtBQVgsSUFBb0JubUMsV0FBV29tQyxNQUFuQyxFQUEyQyxPQUFPcG1DLE1BQVA7O0dBWi9DO1VBZVFtbUMsS0FBUixHQUFnQkEsS0FBaEI7VUFDUUMsTUFBUixHQUFpQkEsTUFBakI7OztBQ3BCQSxJQUFJSyxVQUFVakssS0FBa0IsU0FBbEIsQ0FBZDs7QUFFQSxrQkFBaUIsb0JBQUEsQ0FBVWtLLEdBQVYsRUFBZTtNQUMxQkMsSUFBSTFLLFFBQU95SyxHQUFQLENBQVI7TUFDSUUsZ0JBQWVELENBQWYsSUFBb0IsQ0FBQ0EsRUFBRUYsT0FBRixDQUF6QixFQUFxQzFKLFVBQUdqbUIsQ0FBSCxDQUFLNnZCLENBQUwsRUFBUUYsT0FBUixFQUFpQjtrQkFDdEMsSUFEc0M7U0FFL0MsZUFBWTthQUFTLElBQVA7O0dBRmdCO0NBRnZDOzs7TUNOSUksT0FBT3JLLEtBQWtCLE1BQWxCLENBQVg7O01BR0lzSyxVQUFVcEssVUFBd0I1bEIsQ0FBdEM7TUFDSTlJLEtBQUssQ0FBVDtNQUNJKzRCLGVBQWVqbEMsT0FBT2lsQyxZQUFQLElBQXVCLFlBQVk7V0FDN0MsSUFBUDtHQURGO01BR0lDLFNBQVMsQ0FBQ3JLLE9BQW9CLFlBQVk7V0FDckNvSyxhQUFhamxDLE9BQU9tbEMsaUJBQVAsQ0FBeUIsRUFBekIsQ0FBYixDQUFQO0dBRFksQ0FBZDtNQUdJQyxVQUFVLFNBQVZBLE9BQVUsQ0FBVTdLLEVBQVYsRUFBYztZQUNsQkEsRUFBUixFQUFZd0ssSUFBWixFQUFrQixFQUFFaGtDLE9BQU87V0FDdEIsTUFBTSxFQUFFbUwsRUFEYztXQUV0QixFQUZzQjtPQUFULEVBQWxCO0dBREY7TUFNSW01QixVQUFVLFNBQVZBLE9BQVUsQ0FBVTlLLEVBQVYsRUFBY3BvQixNQUFkLEVBQXNCOztRQUU5QixDQUFDcW9CLFVBQVNELEVBQVQsQ0FBTCxFQUFtQixPQUFPLFFBQU9BLEVBQVAseUNBQU9BLEVBQVAsTUFBYSxRQUFiLEdBQXdCQSxFQUF4QixHQUE2QixDQUFDLE9BQU9BLEVBQVAsSUFBYSxRQUFiLEdBQXdCLEdBQXhCLEdBQThCLEdBQS9CLElBQXNDQSxFQUExRTtRQUNmLENBQUN6c0IsS0FBSXlzQixFQUFKLEVBQVF3SyxJQUFSLENBQUwsRUFBb0I7O1VBRWQsQ0FBQ0UsYUFBYTFLLEVBQWIsQ0FBTCxFQUF1QixPQUFPLEdBQVA7O1VBRW5CLENBQUNwb0IsTUFBTCxFQUFhLE9BQU8sR0FBUDs7Y0FFTG9vQixFQUFSOztLQUVBLE9BQU9BLEdBQUd3SyxJQUFILEVBQVM3bkMsQ0FBaEI7R0FYSjtNQWFJb29DLFVBQVUsU0FBVkEsT0FBVSxDQUFVL0ssRUFBVixFQUFjcG9CLE1BQWQsRUFBc0I7UUFDOUIsQ0FBQ3JFLEtBQUl5c0IsRUFBSixFQUFRd0ssSUFBUixDQUFMLEVBQW9COztVQUVkLENBQUNFLGFBQWExSyxFQUFiLENBQUwsRUFBdUIsT0FBTyxJQUFQOztVQUVuQixDQUFDcG9CLE1BQUwsRUFBYSxPQUFPLEtBQVA7O2NBRUxvb0IsRUFBUjs7S0FFQSxPQUFPQSxHQUFHd0ssSUFBSCxFQUFTbFcsQ0FBaEI7R0FUSjs7TUFZSTBXLFdBQVcsU0FBWEEsUUFBVyxDQUFVaEwsRUFBVixFQUFjO1FBQ3ZCMkssVUFBVU0sS0FBS0MsSUFBZixJQUF1QlIsYUFBYTFLLEVBQWIsQ0FBdkIsSUFBMkMsQ0FBQ3pzQixLQUFJeXNCLEVBQUosRUFBUXdLLElBQVIsQ0FBaEQsRUFBK0RLLFFBQVE3SyxFQUFSO1dBQ3hEQSxFQUFQO0dBRkY7TUFJSWlMLE9BQU96TCxjQUFBLEdBQWlCO1NBQ3JCZ0wsSUFEcUI7VUFFcEIsS0FGb0I7YUFHakJNLE9BSGlCO2FBSWpCQyxPQUppQjtjQUtoQkM7R0FMWjs7Ozs7Ozs7O0FDN0NBLDBCQUFpQiw0QkFBQSxDQUFVaEwsRUFBVixFQUFjbUwsSUFBZCxFQUFvQjtNQUMvQixDQUFDbEwsVUFBU0QsRUFBVCxDQUFELElBQWlCQSxHQUFHMEksRUFBSCxLQUFVeUMsSUFBL0IsRUFBcUMsTUFBTWpMLFVBQVUsNEJBQTRCaUwsSUFBNUIsR0FBbUMsWUFBN0MsQ0FBTjtTQUM5Qm5MLEVBQVA7Q0FGRjs7QUNBQSxJQUFJVSxPQUFLUCxVQUF3QjFsQixDQUFqQzs7QUFVQSxJQUFJcXdCLFVBQVV6SyxNQUFtQnlLLE9BQWpDOztBQUVBLElBQUlNLE9BQU9iLGVBQWMsSUFBZCxHQUFxQixNQUFoQzs7QUFFQSxJQUFJYyxXQUFXLFNBQVhBLFFBQVcsQ0FBVXpKLElBQVYsRUFBZ0IxL0IsR0FBaEIsRUFBcUI7O01BRTlCZ1AsUUFBUTQ1QixRQUFRNW9DLEdBQVIsQ0FBWjtNQUNJb3BDLEtBQUo7TUFDSXA2QixVQUFVLEdBQWQsRUFBbUIsT0FBTzB3QixLQUFLK0csRUFBTCxDQUFRejNCLEtBQVIsQ0FBUDs7T0FFZG82QixRQUFRMUosS0FBSzJKLEVBQWxCLEVBQXNCRCxLQUF0QixFQUE2QkEsUUFBUUEsTUFBTUUsQ0FBM0MsRUFBOEM7UUFDeENGLE1BQU1oN0IsQ0FBTixJQUFXcE8sR0FBZixFQUFvQixPQUFPb3BDLEtBQVA7O0NBUHhCOztBQVdBLHdCQUFpQjtrQkFDQyx3QkFBVXh6QixPQUFWLEVBQW1COHVCLElBQW5CLEVBQXlCNkUsTUFBekIsRUFBaUNDLEtBQWpDLEVBQXdDO1FBQ2xEcEIsSUFBSXh5QixRQUFRLFVBQVU4cEIsSUFBVixFQUFnQm9JLFFBQWhCLEVBQTBCO2tCQUM3QnBJLElBQVgsRUFBaUIwSSxDQUFqQixFQUFvQjFELElBQXBCLEVBQTBCLElBQTFCO1dBQ0s4QixFQUFMLEdBQVU5QixJQUFWLENBRndDO1dBR25DK0IsRUFBTCxHQUFVL3dCLGNBQU8sSUFBUCxDQUFWLENBSHdDO1dBSW5DMnpCLEVBQUwsR0FBVXo1QixTQUFWLENBSndDO1dBS25DNjVCLEVBQUwsR0FBVTc1QixTQUFWLENBTHdDO1dBTW5DczVCLElBQUwsSUFBYSxDQUFiLENBTndDO1VBT3BDcEIsWUFBWWw0QixTQUFoQixFQUEyQjg1QixPQUFNNUIsUUFBTixFQUFnQnlCLE1BQWhCLEVBQXdCN0osS0FBSzhKLEtBQUwsQ0FBeEIsRUFBcUM5SixJQUFyQztLQVByQixDQUFSO2lCQVNZMEksRUFBRWxwQyxTQUFkLEVBQXlCOzs7YUFHaEIsU0FBU2dCLEtBQVQsR0FBaUI7YUFDakIsSUFBSXcvQixPQUFPaUssb0JBQVMsSUFBVCxFQUFlakYsSUFBZixDQUFYLEVBQWlDa0YsT0FBT2xLLEtBQUsrRyxFQUE3QyxFQUFpRDJDLFFBQVExSixLQUFLMkosRUFBbkUsRUFBdUVELEtBQXZFLEVBQThFQSxRQUFRQSxNQUFNRSxDQUE1RixFQUErRjtnQkFDdkZocEMsQ0FBTixHQUFVLElBQVY7Y0FDSThvQyxNQUFNM2xDLENBQVYsRUFBYTJsQyxNQUFNM2xDLENBQU4sR0FBVTJsQyxNQUFNM2xDLENBQU4sQ0FBUTZsQyxDQUFSLEdBQVkxNUIsU0FBdEI7aUJBQ05nNkIsS0FBS1IsTUFBTTNvQyxDQUFYLENBQVA7O2FBRUc0b0MsRUFBTCxHQUFVM0osS0FBSytKLEVBQUwsR0FBVTc1QixTQUFwQjthQUNLczVCLElBQUwsSUFBYSxDQUFiO09BVnFCOzs7Z0JBY2IsaUJBQVVscEMsR0FBVixFQUFlO1lBQ25CMC9CLE9BQU9pSyxvQkFBUyxJQUFULEVBQWVqRixJQUFmLENBQVg7WUFDSTBFLFFBQVFELFNBQVN6SixJQUFULEVBQWUxL0IsR0FBZixDQUFaO1lBQ0lvcEMsS0FBSixFQUFXO2NBQ0x6RSxPQUFPeUUsTUFBTUUsQ0FBakI7Y0FDSS9kLE9BQU82ZCxNQUFNM2xDLENBQWpCO2lCQUNPaThCLEtBQUsrRyxFQUFMLENBQVEyQyxNQUFNM29DLENBQWQsQ0FBUDtnQkFDTUgsQ0FBTixHQUFVLElBQVY7Y0FDSWlyQixJQUFKLEVBQVVBLEtBQUsrZCxDQUFMLEdBQVMzRSxJQUFUO2NBQ05BLElBQUosRUFBVUEsS0FBS2xoQyxDQUFMLEdBQVM4bkIsSUFBVDtjQUNObVUsS0FBSzJKLEVBQUwsSUFBV0QsS0FBZixFQUFzQjFKLEtBQUsySixFQUFMLEdBQVUxRSxJQUFWO2NBQ2xCakYsS0FBSytKLEVBQUwsSUFBV0wsS0FBZixFQUFzQjFKLEtBQUsrSixFQUFMLEdBQVVsZSxJQUFWO2VBQ2pCMmQsSUFBTDtTQUNBLE9BQU8sQ0FBQyxDQUFDRSxLQUFUO09BM0JtQjs7O2VBK0JkLFNBQVNycEMsT0FBVCxDQUFpQjhwQyxVQUFqQiwyQkFBc0Q7NEJBQ3BELElBQVQsRUFBZW5GLElBQWY7WUFDSW5zQixJQUFJbW9CLEtBQUltSixVQUFKLEVBQWdCcHJCLFVBQVUvZCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK2QsVUFBVSxDQUFWLENBQXZCLEdBQXNDN08sU0FBdEQsRUFBaUUsQ0FBakUsQ0FBUjtZQUNJdzVCLEtBQUo7ZUFDT0EsUUFBUUEsUUFBUUEsTUFBTUUsQ0FBZCxHQUFrQixLQUFLRCxFQUF0QyxFQUEwQztZQUN0Q0QsTUFBTVUsQ0FBUixFQUFXVixNQUFNaDdCLENBQWpCLEVBQW9CLElBQXBCOztpQkFFT2c3QixTQUFTQSxNQUFNOW9DLENBQXRCO29CQUFpQzhvQyxNQUFNM2xDLENBQWQ7OztPQXRDTjs7O1dBMkNsQixTQUFTNE4sR0FBVCxDQUFhclIsR0FBYixFQUFrQjtlQUNkLENBQUMsQ0FBQ21wQyxTQUFTUSxvQkFBUyxJQUFULEVBQWVqRixJQUFmLENBQVQsRUFBK0Ixa0MsR0FBL0IsQ0FBVDs7S0E1Q0o7UUErQ0lxb0MsWUFBSixFQUFpQjdKLEtBQUc0SixFQUFFbHBDLFNBQUwsRUFBZ0IsTUFBaEIsRUFBd0I7V0FDbEMsZUFBWTtlQUNSeXFDLG9CQUFTLElBQVQsRUFBZWpGLElBQWYsRUFBcUJ3RSxJQUFyQixDQUFQOztLQUZhO1dBS1ZkLENBQVA7R0EvRGE7T0FpRVYsYUFBVTFJLElBQVYsRUFBZ0IxL0IsR0FBaEIsRUFBcUJzRSxLQUFyQixFQUE0QjtRQUMzQjhrQyxRQUFRRCxTQUFTekosSUFBVCxFQUFlMS9CLEdBQWYsQ0FBWjtRQUNJdXJCLElBQUosRUFBVXZjLEtBQVY7O1FBRUlvNkIsS0FBSixFQUFXO1lBQ0hVLENBQU4sR0FBVXhsQyxLQUFWOztLQURGLE1BR087V0FDQW1sQyxFQUFMLEdBQVVMLFFBQVE7V0FDYnA2QixRQUFRNDVCLFFBQVE1b0MsR0FBUixFQUFhLElBQWIsQ0FESztXQUViQSxHQUZhO1dBR2JzRSxLQUhhO1dBSWJpbkIsT0FBT21VLEtBQUsrSixFQUpDO1dBS2I3NUIsU0FMYTtXQU1iLEtBTmE7T0FBbEI7VUFRSSxDQUFDOHZCLEtBQUsySixFQUFWLEVBQWMzSixLQUFLMkosRUFBTCxHQUFVRCxLQUFWO1VBQ1Y3ZCxJQUFKLEVBQVVBLEtBQUsrZCxDQUFMLEdBQVNGLEtBQVQ7V0FDTEYsSUFBTDs7VUFFSWw2QixVQUFVLEdBQWQsRUFBbUIwd0IsS0FBSytHLEVBQUwsQ0FBUXozQixLQUFSLElBQWlCbzZCLEtBQWpCO0tBQ25CLE9BQU8xSixJQUFQO0dBdEZXO1lBd0ZMeUosUUF4Rks7YUF5RkosbUJBQVVmLENBQVYsRUFBYTFELElBQWIsRUFBbUI2RSxNQUFuQixFQUEyQjs7O2dCQUd4Qm5CLENBQVosRUFBZTFELElBQWYsRUFBcUIsVUFBVTZCLFFBQVYsRUFBb0JYLElBQXBCLEVBQTBCO1dBQ3hDWSxFQUFMLEdBQVVtRCxvQkFBU3BELFFBQVQsRUFBbUI3QixJQUFuQixDQUFWLENBRDZDO1dBRXhDbUMsRUFBTCxHQUFVakIsSUFBVixDQUY2QztXQUd4QzZELEVBQUwsR0FBVTc1QixTQUFWLENBSDZDO0tBQS9DLEVBSUcsWUFBWTtVQUNUOHZCLE9BQU8sSUFBWDtVQUNJa0csT0FBT2xHLEtBQUttSCxFQUFoQjtVQUNJdUMsUUFBUTFKLEtBQUsrSixFQUFqQjs7YUFFT0wsU0FBU0EsTUFBTTlvQyxDQUF0QjtnQkFBaUM4b0MsTUFBTTNsQyxDQUFkO09BTFo7VUFPVCxDQUFDaThCLEtBQUs4RyxFQUFOLElBQVksRUFBRTlHLEtBQUsrSixFQUFMLEdBQVVMLFFBQVFBLFFBQVFBLE1BQU1FLENBQWQsR0FBa0I1SixLQUFLOEcsRUFBTCxDQUFRNkMsRUFBOUMsQ0FBaEIsRUFBbUU7O2FBRTVEN0MsRUFBTCxHQUFVNTJCLFNBQVY7ZUFDT3VOLFVBQUssQ0FBTCxDQUFQOzs7VUFHRXlvQixRQUFRLE1BQVosRUFBb0IsT0FBT3pvQixVQUFLLENBQUwsRUFBUWlzQixNQUFNaDdCLENBQWQsQ0FBUDtVQUNoQnczQixRQUFRLFFBQVosRUFBc0IsT0FBT3pvQixVQUFLLENBQUwsRUFBUWlzQixNQUFNVSxDQUFkLENBQVA7YUFDZjNzQixVQUFLLENBQUwsRUFBUSxDQUFDaXNCLE1BQU1oN0IsQ0FBUCxFQUFVZzdCLE1BQU1VLENBQWhCLENBQVIsQ0FBUDtLQW5CRixFQW9CR1AsU0FBUyxTQUFULEdBQXFCLFFBcEJ4QixFQW9Ca0MsQ0FBQ0EsTUFwQm5DLEVBb0IyQyxJQXBCM0M7OztnQkF1Qlc3RSxJQUFYOztDQW5ISjs7QUMxQkEsSUFBSU8sYUFBV2hILEtBQWtCLFVBQWxCLENBQWY7QUFDQSxJQUFJOEwsZUFBZSxLQUFuQjs7QUFFQSxJQUFJO01BQ0VDLFFBQVEsQ0FBQyxDQUFELEVBQUkvRSxVQUFKLEdBQVo7UUFDTSxRQUFOLElBQWtCLFlBQVk7bUJBQWlCLElBQWY7R0FBaEM7OztDQUZGLENBS0UsT0FBTzE5QixDQUFQLEVBQVU7O0FBRVosa0JBQWlCLG9CQUFBLENBQVVzMUIsSUFBVixFQUFnQm9OLFdBQWhCLEVBQTZCO01BQ3hDLENBQUNBLFdBQUQsSUFBZ0IsQ0FBQ0YsWUFBckIsRUFBbUMsT0FBTyxLQUFQO01BQy9CeEssT0FBTyxLQUFYO01BQ0k7UUFDRTJLLE1BQU0sQ0FBQyxDQUFELENBQVY7UUFDSUMsT0FBT0QsSUFBSWpGLFVBQUosR0FBWDtTQUNLTixJQUFMLEdBQVksWUFBWTthQUFTLEVBQUUzbkIsTUFBTXVpQixPQUFPLElBQWYsRUFBUDtLQUExQjtRQUNJMEYsVUFBSixJQUFnQixZQUFZO2FBQVNrRixJQUFQO0tBQTlCO1NBQ0tELEdBQUw7R0FMRixDQU1FLE9BQU8zaUMsQ0FBUCxFQUFVO1NBQ0xnNEIsSUFBUDtDQVZGOztBQ1RBLElBQUlrQyxtQkFBaUJ4RCxVQUF3QnYyQixHQUE3QztBQUNBLHlCQUFpQiwyQkFBQSxDQUFVZzRCLElBQVYsRUFBZ0JsNEIsTUFBaEIsRUFBd0I0Z0MsQ0FBeEIsRUFBMkI7TUFDdEMvSixJQUFJNzJCLE9BQU93OUIsV0FBZjtNQUNJdEcsQ0FBSjtNQUNJTCxNQUFNK0osQ0FBTixJQUFXLE9BQU8vSixDQUFQLElBQVksVUFBdkIsSUFBcUMsQ0FBQ0ssSUFBSUwsRUFBRW4vQixTQUFQLE1BQXNCa3BDLEVBQUVscEMsU0FBN0QsSUFBMEU2K0IsVUFBU1csQ0FBVCxDQUExRSxJQUF5RitDLGdCQUE3RixFQUE2RztxQkFDNUYvQixJQUFmLEVBQXFCaEIsQ0FBckI7R0FDQSxPQUFPZ0IsSUFBUDtDQUxKOztBQ1lBLGtCQUFpQixvQkFBQSxDQUFVZ0YsSUFBVixFQUFnQjl1QixPQUFoQixFQUF5QmlqQixPQUF6QixFQUFrQ3VSLE1BQWxDLEVBQTBDYixNQUExQyxFQUFrRGMsT0FBbEQsRUFBMkQ7TUFDdEU5RSxPQUFPN0gsUUFBT2dILElBQVAsQ0FBWDtNQUNJMEQsSUFBSTdDLElBQVI7TUFDSWlFLFFBQVFELFNBQVMsS0FBVCxHQUFpQixLQUE3QjtNQUNJL0gsUUFBUTRHLEtBQUtBLEVBQUVscEMsU0FBbkI7TUFDSXUvQixJQUFJLEVBQVI7TUFDSTZMLFlBQVksU0FBWkEsU0FBWSxDQUFVbkMsR0FBVixFQUFlO1FBQ3pCM21DLEtBQUtnZ0MsTUFBTTJHLEdBQU4sQ0FBVDtjQUNTM0csS0FBVCxFQUFnQjJHLEdBQWhCLEVBQ0VBLE9BQU8sUUFBUCxHQUFrQixVQUFVenNCLENBQVYsRUFBYTthQUN0QjJ1QixXQUFXLENBQUN0TSxVQUFTcmlCLENBQVQsQ0FBWixHQUEwQixLQUExQixHQUFrQ2xhLEdBQUdwQyxJQUFILENBQVEsSUFBUixFQUFjc2MsTUFBTSxDQUFOLEdBQVUsQ0FBVixHQUFjQSxDQUE1QixDQUF6QztLQURGLEdBRUl5c0IsT0FBTyxLQUFQLEdBQWUsU0FBUzkyQixHQUFULENBQWFxSyxDQUFiLEVBQWdCO2FBQzFCMnVCLFdBQVcsQ0FBQ3RNLFVBQVNyaUIsQ0FBVCxDQUFaLEdBQTBCLEtBQTFCLEdBQWtDbGEsR0FBR3BDLElBQUgsQ0FBUSxJQUFSLEVBQWNzYyxNQUFNLENBQU4sR0FBVSxDQUFWLEdBQWNBLENBQTVCLENBQXpDO0tBREUsR0FFQXlzQixPQUFPLEtBQVAsR0FBZSxTQUFTMy9CLEdBQVQsQ0FBYWtULENBQWIsRUFBZ0I7YUFDMUIydUIsV0FBVyxDQUFDdE0sVUFBU3JpQixDQUFULENBQVosR0FBMEI5TCxTQUExQixHQUFzQ3BPLEdBQUdwQyxJQUFILENBQVEsSUFBUixFQUFjc2MsTUFBTSxDQUFOLEdBQVUsQ0FBVixHQUFjQSxDQUE1QixDQUE3QztLQURFLEdBRUF5c0IsT0FBTyxLQUFQLEdBQWUsU0FBU2g2QixHQUFULENBQWF1TixDQUFiLEVBQWdCO1NBQUt0YyxJQUFILENBQVEsSUFBUixFQUFjc2MsTUFBTSxDQUFOLEdBQVUsQ0FBVixHQUFjQSxDQUE1QixFQUFnQyxPQUFPLElBQVA7S0FBakUsR0FDQSxTQUFTaFUsR0FBVCxDQUFhZ1UsQ0FBYixFQUFnQm1OLENBQWhCLEVBQW1CO1NBQUt6cEIsSUFBSCxDQUFRLElBQVIsRUFBY3NjLE1BQU0sQ0FBTixHQUFVLENBQVYsR0FBY0EsQ0FBNUIsRUFBK0JtTixDQUEvQixFQUFtQyxPQUFPLElBQVA7S0FSOUQ7R0FGRjtNQWFJLE9BQU91ZixDQUFQLElBQVksVUFBWixJQUEwQixFQUFFaUMsV0FBVzdJLE1BQU16aEMsT0FBTixJQUFpQixDQUFDd3FDLE9BQU0sWUFBWTtRQUN6RW5DLENBQUosR0FBUXRDLE9BQVIsR0FBa0JuQixJQUFsQjtHQUQyRCxDQUEvQixDQUE5QixFQUVLOztRQUVDeUYsT0FBT0ksY0FBUCxDQUFzQjUwQixPQUF0QixFQUErQjh1QixJQUEvQixFQUFxQzZFLE1BQXJDLEVBQTZDQyxLQUE3QyxDQUFKO2lCQUNZcEIsRUFBRWxwQyxTQUFkLEVBQXlCMjVCLE9BQXpCO1VBQ0ttUSxJQUFMLEdBQVksSUFBWjtHQU5GLE1BT087UUFDRHlCLFdBQVcsSUFBSXJDLENBQUosRUFBZjs7UUFFSXNDLGlCQUFpQkQsU0FBU2pCLEtBQVQsRUFBZ0JhLFVBQVUsRUFBVixHQUFlLENBQUMsQ0FBaEMsRUFBbUMsQ0FBbkMsS0FBeUNJLFFBQTlEOztRQUVJRSx1QkFBdUJKLE9BQU0sWUFBWTtlQUFXbDVCLEdBQVQsQ0FBYSxDQUFiO0tBQXBCLENBQTNCOztRQUVJdTVCLG1CQUFtQkMsWUFBWSxVQUFVVixJQUFWLEVBQWdCO1VBQU0vQixDQUFKLENBQU0rQixJQUFOO0tBQTlCLENBQXZCLENBUEs7O1FBU0RXLGFBQWEsQ0FBQ1QsT0FBRCxJQUFZRSxPQUFNLFlBQVk7O1VBRXpDUSxZQUFZLElBQUkzQyxDQUFKLEVBQWhCO1VBQ0lwNUIsUUFBUSxDQUFaO2FBQ09BLE9BQVA7a0JBQTBCdzZCLEtBQVYsRUFBaUJ4NkIsS0FBakIsRUFBd0JBLEtBQXhCO09BQ2hCLE9BQU8sQ0FBQys3QixVQUFVMTVCLEdBQVYsQ0FBYyxDQUFDLENBQWYsQ0FBUjtLQUwyQixDQUE3QjtRQU9JLENBQUN1NUIsZ0JBQUwsRUFBdUI7VUFDakJoMUIsUUFBUSxVQUFVcE8sTUFBVixFQUFrQnNnQyxRQUFsQixFQUE0QjtvQkFDM0J0Z0MsTUFBWCxFQUFtQjRnQyxDQUFuQixFQUFzQjFELElBQXRCO1lBQ0loRixPQUFPc0wsbUJBQWtCLElBQUl6RixJQUFKLEVBQWxCLEVBQThCLzlCLE1BQTlCLEVBQXNDNGdDLENBQXRDLENBQVg7WUFDSU4sWUFBWWw0QixTQUFoQixFQUEyQjg1QixPQUFNNUIsUUFBTixFQUFnQnlCLE1BQWhCLEVBQXdCN0osS0FBSzhKLEtBQUwsQ0FBeEIsRUFBcUM5SixJQUFyQztlQUNwQkEsSUFBUDtPQUpFLENBQUo7UUFNRXhnQyxTQUFGLEdBQWNzaUMsS0FBZDtZQUNNd0QsV0FBTixHQUFvQm9ELENBQXBCOztRQUVFdUMsd0JBQXdCRyxVQUE1QixFQUF3QztnQkFDNUIsUUFBVjtnQkFDVSxLQUFWO2dCQUNVUixVQUFVLEtBQVYsQ0FBVjs7UUFFRVEsY0FBY0osY0FBbEIsRUFBa0NKLFVBQVVkLEtBQVY7O1FBRTlCYSxXQUFXN0ksTUFBTXRoQyxLQUFyQixFQUE0QixPQUFPc2hDLE1BQU10aEMsS0FBYjs7O2tCQUdma29DLENBQWYsRUFBa0IxRCxJQUFsQjs7SUFFRUEsSUFBRixJQUFVMEQsQ0FBVjtVQUNReEksUUFBUUssQ0FBUixHQUFZTCxRQUFRaUIsQ0FBcEIsR0FBd0JqQixRQUFRRyxDQUFSLElBQWFxSSxLQUFLN0MsSUFBbEIsQ0FBaEMsRUFBeUQ5RyxDQUF6RDs7TUFFSSxDQUFDNEwsT0FBTCxFQUFjRCxPQUFPYSxTQUFQLENBQWlCN0MsQ0FBakIsRUFBb0IxRCxJQUFwQixFQUEwQjZFLE1BQTFCOztTQUVQbkIsQ0FBUDtDQXJFRjs7QUNYQSxJQUFJOEMsTUFBTSxLQUFWOzs7QUFHQSxjQUFpQmpOLFlBQXlCaU4sR0FBekIsRUFBOEIsVUFBVTFpQyxHQUFWLEVBQWU7U0FDckQsU0FBUzJpQyxHQUFULEdBQWU7V0FBUzNpQyxJQUFJLElBQUosRUFBVWlXLFVBQVUvZCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK2QsVUFBVSxDQUFWLENBQXZCLEdBQXNDN08sU0FBaEQsQ0FBUDtHQUF4QjtDQURlLEVBRWQ7O09BRUksU0FBU3pCLEdBQVQsQ0FBYTdKLEtBQWIsRUFBb0I7V0FDaEI4bUMsa0JBQU9oSCxHQUFQLENBQVd1RixvQkFBUyxJQUFULEVBQWV1QixHQUFmLENBQVgsRUFBZ0M1bUMsUUFBUUEsVUFBVSxDQUFWLEdBQWMsQ0FBZCxHQUFrQkEsS0FBMUQsRUFBaUVBLEtBQWpFLENBQVA7O0NBTGEsRUFPZDhtQyxpQkFQYyxDQUFqQjs7QUNKQSx5QkFBaUIsMkJBQUEsQ0FBVWpCLElBQVYsRUFBZ0JsRixRQUFoQixFQUEwQjtNQUNyQ3hqQyxTQUFTLEVBQWI7U0FDTTBvQyxJQUFOLEVBQVksS0FBWixFQUFtQjFvQyxPQUFPWixJQUExQixFQUFnQ1ksTUFBaEMsRUFBd0N3akMsUUFBeEM7U0FDT3hqQyxNQUFQO0NBSEY7O0FDRkE7OztBQUdBLHdCQUFpQiwwQkFBQSxDQUFVaWpDLElBQVYsRUFBZ0I7U0FDeEIsU0FBUzJHLE1BQVQsR0FBa0I7UUFDbkI5SSxTQUFRLElBQVIsS0FBaUJtQyxJQUFyQixFQUEyQixNQUFNMUcsVUFBVTBHLE9BQU8sdUJBQWpCLENBQU47V0FDcEJ6dkIsbUJBQUssSUFBTCxDQUFQO0dBRkY7Q0FERjs7QUNIQTs7O0FBR0EycUIsUUFBUUEsUUFBUWxCLENBQVIsR0FBWWtCLFFBQVFrQixDQUE1QixFQUErQixLQUEvQixFQUFzQyxFQUFFdUssUUFBUXBOLGtCQUFpQyxLQUFqQyxDQUFWLEVBQXRDOzs7OztBQ0NBLHVCQUFpQix5QkFBQSxDQUFVcU4sVUFBVixFQUFzQjtVQUM3QjFMLFFBQVF2QixDQUFoQixFQUFtQmlOLFVBQW5CLEVBQStCLEVBQUVDLElBQUksU0FBU0EsRUFBVCxHQUFjO1VBQzdDN3FDLFNBQVMrZCxVQUFVL2QsTUFBdkI7VUFDSThxQyxJQUFJdnNDLE1BQU15QixNQUFOLENBQVI7YUFDT0EsUUFBUDtVQUFtQkEsTUFBRixJQUFZK2QsVUFBVS9kLE1BQVYsQ0FBWjtPQUNqQixPQUFPLElBQUksSUFBSixDQUFTOHFDLENBQVQsQ0FBUDtLQUo2QixFQUEvQjtDQURGOztBQ0pBO0FBQ0F2TixpQkFBZ0MsS0FBaEM7Ozs7O0FDTUEseUJBQWlCLDJCQUFBLENBQVVxTixVQUFWLEVBQXNCO1VBQzdCMUwsUUFBUXZCLENBQWhCLEVBQW1CaU4sVUFBbkIsRUFBK0IsRUFBRXIyQixNQUFNLFNBQVNBLElBQVQsQ0FBYzRxQixNQUFkLHlCQUE2QztVQUM5RTRMLFFBQVFodEIsVUFBVSxDQUFWLENBQVo7VUFDSWl0QixPQUFKLEVBQWFGLENBQWIsRUFBZ0JsQyxDQUFoQixFQUFtQjdZLEVBQW5CO2lCQUNVLElBQVY7Z0JBQ1VnYixVQUFVNzdCLFNBQXBCO1VBQ0k4N0IsT0FBSixFQUFhQyxXQUFVRixLQUFWO1VBQ1Q1TCxVQUFVandCLFNBQWQsRUFBeUIsT0FBTyxJQUFJLElBQUosRUFBUDtVQUNyQixFQUFKO1VBQ0k4N0IsT0FBSixFQUFhO1lBQ1AsQ0FBSjthQUNLaEwsS0FBSStLLEtBQUosRUFBV2h0QixVQUFVLENBQVYsQ0FBWCxFQUF5QixDQUF6QixDQUFMO2VBQ01vaEIsTUFBTixFQUFjLEtBQWQsRUFBcUIsVUFBVStMLFFBQVYsRUFBb0I7WUFDckMvcUMsSUFBRixDQUFPNHZCLEdBQUdtYixRQUFILEVBQWF0QyxHQUFiLENBQVA7U0FERjtPQUhGLE1BTU87ZUFDQ3pKLE1BQU4sRUFBYyxLQUFkLEVBQXFCMkwsRUFBRTNxQyxJQUF2QixFQUE2QjJxQyxDQUE3Qjs7YUFFSyxJQUFJLElBQUosQ0FBU0EsQ0FBVCxDQUFQO0tBakI2QixFQUEvQjtDQURGOztBQ1BBO0FBQ0F2TixtQkFBa0MsS0FBbEM7O0FDTUEsWUFBaUI0TixNQUE0QlYsR0FBN0M7O0FDSkEsSUFBSVcsTUFBTSxLQUFWOzs7QUFHQSxjQUFpQjdOLFlBQXlCNk4sR0FBekIsRUFBOEIsVUFBVXRqQyxHQUFWLEVBQWU7U0FDckQsU0FBU3VqQyxHQUFULEdBQWU7V0FBU3ZqQyxJQUFJLElBQUosRUFBVWlXLFVBQVUvZCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK2QsVUFBVSxDQUFWLENBQXZCLEdBQXNDN08sU0FBaEQsQ0FBUDtHQUF4QjtDQURlLEVBRWQ7O09BRUksU0FBU3BILEdBQVQsQ0FBYXhJLEdBQWIsRUFBa0I7UUFDakJvcEMsUUFBUWdDLGtCQUFPakMsUUFBUCxDQUFnQlEsb0JBQVMsSUFBVCxFQUFlbUMsR0FBZixDQUFoQixFQUFxQzlyQyxHQUFyQyxDQUFaO1dBQ09vcEMsU0FBU0EsTUFBTVUsQ0FBdEI7R0FKRDs7T0FPSSxTQUFTcGlDLEdBQVQsQ0FBYTFILEdBQWIsRUFBa0JzRSxLQUFsQixFQUF5QjtXQUNyQjhtQyxrQkFBT2hILEdBQVAsQ0FBV3VGLG9CQUFTLElBQVQsRUFBZW1DLEdBQWYsQ0FBWCxFQUFnQzlyQyxRQUFRLENBQVIsR0FBWSxDQUFaLEdBQWdCQSxHQUFoRCxFQUFxRHNFLEtBQXJELENBQVA7O0NBVmEsRUFZZDhtQyxpQkFaYyxFQVlOLElBWk0sQ0FBakI7O0FDTkE7OztBQUdBeEwsUUFBUUEsUUFBUWxCLENBQVIsR0FBWWtCLFFBQVFrQixDQUE1QixFQUErQixLQUEvQixFQUFzQyxFQUFFdUssUUFBUXBOLGtCQUFpQyxLQUFqQyxDQUFWLEVBQXRDOztBQ0hBO0FBQ0FBLGlCQUFnQyxLQUFoQzs7QUNEQTtBQUNBQSxtQkFBa0MsS0FBbEM7O0FDTUEsVUFBaUI0TixNQUE0QkUsR0FBN0M7O0FDUEE7O0FBRUEsZUFBaUI5c0MsTUFBTSt1QixPQUFOLElBQWlCLFNBQVNBLE9BQVQsQ0FBaUJnZSxHQUFqQixFQUFzQjtTQUMvQ2hMLEtBQUlnTCxHQUFKLEtBQVksT0FBbkI7Q0FERjs7QUNBQSxJQUFJOUQsWUFBVWpLLEtBQWtCLFNBQWxCLENBQWQ7O0FBRUEsK0JBQWlCLGlDQUFBLENBQVVnTyxRQUFWLEVBQW9CO01BQy9CN0QsQ0FBSjtNQUNJcGEsU0FBUWllLFFBQVIsQ0FBSixFQUF1QjtRQUNqQkEsU0FBU2pILFdBQWI7O1FBRUksT0FBT29ELENBQVAsSUFBWSxVQUFaLEtBQTJCQSxNQUFNbnBDLEtBQU4sSUFBZSt1QixTQUFRb2EsRUFBRWxwQyxTQUFWLENBQTFDLENBQUosRUFBcUVrcEMsSUFBSXg0QixTQUFKO1FBQ2pFbXVCLFVBQVNxSyxDQUFULENBQUosRUFBaUI7VUFDWEEsRUFBRUYsU0FBRixDQUFKO1VBQ0lFLE1BQU0sSUFBVixFQUFnQkEsSUFBSXg0QixTQUFKOztHQUVsQixPQUFPdzRCLE1BQU14NEIsU0FBTixHQUFrQjNRLEtBQWxCLEdBQTBCbXBDLENBQWpDO0NBVko7O0FDSkE7OztBQUdBLDBCQUFpQiw0QkFBQSxDQUFVNkQsUUFBVixFQUFvQnZyQyxNQUFwQixFQUE0QjtTQUNwQyxLQUFLd3JDLHlCQUFtQkQsUUFBbkIsQ0FBTCxFQUFtQ3ZyQyxNQUFuQyxDQUFQO0NBREY7O0FDSEE7Ozs7Ozs7OztBQVlBLG9CQUFpQixzQkFBQSxDQUFVdW9DLElBQVYsRUFBZ0JrRCxPQUFoQixFQUF5QjtNQUNwQzVDLFNBQVNOLFFBQVEsQ0FBckI7TUFDSW1ELFlBQVluRCxRQUFRLENBQXhCO01BQ0lvRCxVQUFVcEQsUUFBUSxDQUF0QjtNQUNJcUQsV0FBV3JELFFBQVEsQ0FBdkI7TUFDSXNELGdCQUFnQnRELFFBQVEsQ0FBNUI7TUFDSXVELFdBQVd2RCxRQUFRLENBQVIsSUFBYXNELGFBQTVCO01BQ0k3MkIsU0FBU3kyQixXQUFXTSxtQkFBeEI7U0FDTyxVQUFVN0osS0FBVixFQUFpQmlILFVBQWpCLEVBQTZCbkssSUFBN0IsRUFBbUM7UUFDcENqQixJQUFJc0csVUFBU25DLEtBQVQsQ0FBUjtRQUNJL2tCLE9BQU9vakIsU0FBUXhDLENBQVIsQ0FBWDtRQUNJbG1CLElBQUltb0IsS0FBSW1KLFVBQUosRUFBZ0JuSyxJQUFoQixFQUFzQixDQUF0QixDQUFSO1FBQ0loL0IsU0FBU29pQyxVQUFTamxCLEtBQUtuZCxNQUFkLENBQWI7UUFDSXNPLFFBQVEsQ0FBWjtRQUNJdk4sU0FBUzhuQyxTQUFTN3pCLE9BQU9rdEIsS0FBUCxFQUFjbGlDLE1BQWQsQ0FBVCxHQUFpQzByQyxZQUFZMTJCLE9BQU9rdEIsS0FBUCxFQUFjLENBQWQsQ0FBWixHQUErQmh6QixTQUE3RTtRQUNJMHVCLEdBQUosRUFBU29PLEdBQVQ7V0FDTWhzQyxTQUFTc08sS0FBZixFQUFzQkEsT0FBdEI7VUFBbUN3OUIsWUFBWXg5QixTQUFTNk8sSUFBekIsRUFBK0I7Y0FDdERBLEtBQUs3TyxLQUFMLENBQU47Y0FDTXVKLEVBQUUrbEIsR0FBRixFQUFPdHZCLEtBQVAsRUFBY3l2QixDQUFkLENBQU47WUFDSXdLLElBQUosRUFBVTtjQUNKTSxNQUFKLEVBQVk5bkMsT0FBT3VOLEtBQVAsSUFBZ0IwOUIsR0FBaEIsQ0FBWjtlQUNLLElBQUlBLEdBQUosRUFBUyxRQUFRekQsSUFBUjttQkFDUCxDQUFMO3VCQUFlLElBQVAsQ0FESTttQkFFUCxDQUFMO3VCQUFlM0ssR0FBUCxDQUZJO21CQUdQLENBQUw7dUJBQWV0dkIsS0FBUCxDQUhJO21CQUlQLENBQUw7dUJBQWVuTyxJQUFQLENBQVl5OUIsR0FBWixFQUpJO2FBQVQsTUFLRSxJQUFJZ08sUUFBSixFQUFjLE9BQU8sS0FBUCxDQVBiOzs7S0FVWixPQUFPQyxnQkFBZ0IsQ0FBQyxDQUFqQixHQUFxQkYsV0FBV0MsUUFBWCxHQUFzQkEsUUFBdEIsR0FBaUM3cUMsTUFBN0Q7R0FyQkY7Q0FSRjs7QUNaQSxVQUFZOEIsT0FBT29wQyxxQkFBbkI7Ozs7Ozs7OztBQ09BLElBQUlDLFVBQVVycEMsT0FBT3NwQyxNQUFyQjs7O0FBR0Esb0JBQWlCLENBQUNELE9BQUQsSUFBWTNPLE9BQW9CLFlBQVk7TUFDdkR1TixJQUFJLEVBQVI7TUFDSW5MLElBQUksRUFBUjs7TUFFSWhDLElBQUl5RCxRQUFSO01BQ0lnTCxJQUFJLHNCQUFSO0lBQ0V6TyxDQUFGLElBQU8sQ0FBUDtJQUNFaitCLEtBQUYsQ0FBUSxFQUFSLEVBQVlMLE9BQVosQ0FBb0IsVUFBVXFPLENBQVYsRUFBYTtNQUFJQSxDQUFGLElBQU9BLENBQVA7R0FBbkM7U0FDT3crQixRQUFRLEVBQVIsRUFBWXBCLENBQVosRUFBZW5OLENBQWYsS0FBcUIsQ0FBckIsSUFBMEI5NkIsT0FBT3pELElBQVAsQ0FBWThzQyxRQUFRLEVBQVIsRUFBWXZNLENBQVosQ0FBWixFQUE0QmhoQyxJQUE1QixDQUFpQyxFQUFqQyxLQUF3Q3l0QyxDQUF6RTtDQVIyQixDQUFaLEdBU1osU0FBU0QsTUFBVCxDQUFnQnJsQyxNQUFoQixFQUF3QnE0QixNQUF4QixFQUFnQzs7TUFDL0J3QyxJQUFJMEMsVUFBU3Y5QixNQUFULENBQVI7TUFDSXVsQyxPQUFPdHVCLFVBQVUvZCxNQUFyQjtNQUNJc08sUUFBUSxDQUFaO01BQ0lnK0IsYUFBYUMsWUFBSzEwQixDQUF0QjtNQUNJMjBCLFNBQVM1TCxXQUFJL29CLENBQWpCO1NBQ093MEIsT0FBTy85QixLQUFkLEVBQXFCO1FBQ2ZxdkIsSUFBSTRDLFNBQVF4aUIsVUFBVXpQLE9BQVYsQ0FBUixDQUFSO1FBQ0lsUCxPQUFPa3RDLGFBQWF4SixZQUFRbkYsQ0FBUixFQUFXNzlCLE1BQVgsQ0FBa0J3c0MsV0FBVzNPLENBQVgsQ0FBbEIsQ0FBYixHQUFnRG1GLFlBQVFuRixDQUFSLENBQTNEO1FBQ0kzOUIsU0FBU1osS0FBS1ksTUFBbEI7UUFDSXNWLElBQUksQ0FBUjtRQUNJaFcsR0FBSjtXQUNPVSxTQUFTc1YsQ0FBaEI7VUFBdUJrM0IsT0FBTzl0QyxJQUFQLENBQVlpL0IsQ0FBWixFQUFlcitCLE1BQU1GLEtBQUtrVyxHQUFMLENBQXJCLENBQUosRUFBcUNxc0IsRUFBRXJpQyxHQUFGLElBQVNxK0IsRUFBRXIrQixHQUFGLENBQVQ7O0dBQ3hELE9BQU9xaUMsQ0FBUDtDQXRCYSxHQXVCYnVLLE9BdkJKOztBQ1JBLElBQUkvRCxVQUFVNUssTUFBbUI0SyxPQUFqQzs7QUFRQSxJQUFJc0UsWUFBWUMsY0FBa0IsQ0FBbEIsQ0FBaEI7QUFDQSxJQUFJQyxpQkFBaUJELGNBQWtCLENBQWxCLENBQXJCO0FBQ0EsSUFBSTM5QixPQUFLLENBQVQ7OztBQUdBLElBQUk2OUIsc0JBQXNCLFNBQXRCQSxtQkFBc0IsQ0FBVTVOLElBQVYsRUFBZ0I7U0FDakNBLEtBQUsrSixFQUFMLEtBQVkvSixLQUFLK0osRUFBTCxHQUFVLElBQUk4RCxtQkFBSixFQUF0QixDQUFQO0NBREY7QUFHQSxJQUFJQSxzQkFBc0IsU0FBdEJBLG1CQUFzQixHQUFZO09BQy9CN3hCLENBQUwsR0FBUyxFQUFUO0NBREY7QUFHQSxJQUFJOHhCLHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQVUzTCxLQUFWLEVBQWlCN2hDLEdBQWpCLEVBQXNCO1NBQ3RDbXRDLFVBQVV0TCxNQUFNbm1CLENBQWhCLEVBQW1CLFVBQVVvaUIsRUFBVixFQUFjO1dBQy9CQSxHQUFHLENBQUgsTUFBVTk5QixHQUFqQjtHQURLLENBQVA7Q0FERjtBQUtBdXRDLG9CQUFvQnJ1QyxTQUFwQixHQUFnQztPQUN6QixhQUFVYyxHQUFWLEVBQWU7UUFDZG9wQyxRQUFRb0UsbUJBQW1CLElBQW5CLEVBQXlCeHRDLEdBQXpCLENBQVo7UUFDSW9wQyxLQUFKLEVBQVcsT0FBT0EsTUFBTSxDQUFOLENBQVA7R0FIaUI7T0FLekIsYUFBVXBwQyxHQUFWLEVBQWU7V0FDWCxDQUFDLENBQUN3dEMsbUJBQW1CLElBQW5CLEVBQXlCeHRDLEdBQXpCLENBQVQ7R0FONEI7T0FRekIsYUFBVUEsR0FBVixFQUFlc0UsS0FBZixFQUFzQjtRQUNyQjhrQyxRQUFRb0UsbUJBQW1CLElBQW5CLEVBQXlCeHRDLEdBQXpCLENBQVo7UUFDSW9wQyxLQUFKLEVBQVdBLE1BQU0sQ0FBTixJQUFXOWtDLEtBQVgsQ0FBWCxLQUNLLEtBQUtvWCxDQUFMLENBQU83YSxJQUFQLENBQVksQ0FBQ2IsR0FBRCxFQUFNc0UsS0FBTixDQUFaO0dBWHVCO1lBYXBCLGlCQUFVdEUsR0FBVixFQUFlO1FBQ25CZ1AsUUFBUXErQixlQUFlLEtBQUszeEIsQ0FBcEIsRUFBdUIsVUFBVW9pQixFQUFWLEVBQWM7YUFDeENBLEdBQUcsQ0FBSCxNQUFVOTlCLEdBQWpCO0tBRFUsQ0FBWjtRQUdJLENBQUNnUCxLQUFMLEVBQVksS0FBSzBNLENBQUwsQ0FBT3pNLE1BQVAsQ0FBY0QsS0FBZCxFQUFxQixDQUFyQjtXQUNMLENBQUMsQ0FBQyxDQUFDQSxLQUFWOztDQWxCSjs7QUFzQkEsc0JBQWlCO2tCQUNDLHdCQUFVNEcsT0FBVixFQUFtQjh1QixJQUFuQixFQUF5QjZFLE1BQXpCLEVBQWlDQyxLQUFqQyxFQUF3QztRQUNsRHBCLElBQUl4eUIsUUFBUSxVQUFVOHBCLElBQVYsRUFBZ0JvSSxRQUFoQixFQUEwQjtrQkFDN0JwSSxJQUFYLEVBQWlCMEksQ0FBakIsRUFBb0IxRCxJQUFwQixFQUEwQixJQUExQjtXQUNLOEIsRUFBTCxHQUFVOUIsSUFBVixDQUZ3QztXQUduQytCLEVBQUwsR0FBVWgzQixNQUFWLENBSHdDO1dBSW5DZzZCLEVBQUwsR0FBVTc1QixTQUFWLENBSndDO1VBS3BDazRCLFlBQVlsNEIsU0FBaEIsRUFBMkI4NUIsT0FBTTVCLFFBQU4sRUFBZ0J5QixNQUFoQixFQUF3QjdKLEtBQUs4SixLQUFMLENBQXhCLEVBQXFDOUosSUFBckM7S0FMckIsQ0FBUjtpQkFPWTBJLEVBQUVscEMsU0FBZCxFQUF5Qjs7O2dCQUdiLGlCQUFVYyxHQUFWLEVBQWU7WUFDbkIsQ0FBQys5QixVQUFTLzlCLEdBQVQsQ0FBTCxFQUFvQixPQUFPLEtBQVA7WUFDaEI0cEMsT0FBT2YsUUFBUTdvQyxHQUFSLENBQVg7WUFDSTRwQyxTQUFTLElBQWIsRUFBbUIsT0FBTzBELG9CQUFvQjNELG9CQUFTLElBQVQsRUFBZWpGLElBQWYsQ0FBcEIsRUFBMEMsUUFBMUMsRUFBb0Qxa0MsR0FBcEQsQ0FBUDtlQUNaNHBDLFFBQVE2RCxLQUFLN0QsSUFBTCxFQUFXLEtBQUtuRCxFQUFoQixDQUFSLElBQStCLE9BQU9tRCxLQUFLLEtBQUtuRCxFQUFWLENBQTdDO09BUHFCOzs7V0FXbEIsU0FBU3AxQixHQUFULENBQWFyUixHQUFiLEVBQWtCO1lBQ2pCLENBQUMrOUIsVUFBUy85QixHQUFULENBQUwsRUFBb0IsT0FBTyxLQUFQO1lBQ2hCNHBDLE9BQU9mLFFBQVE3b0MsR0FBUixDQUFYO1lBQ0k0cEMsU0FBUyxJQUFiLEVBQW1CLE9BQU8wRCxvQkFBb0IzRCxvQkFBUyxJQUFULEVBQWVqRixJQUFmLENBQXBCLEVBQTBDcnpCLEdBQTFDLENBQThDclIsR0FBOUMsQ0FBUDtlQUNaNHBDLFFBQVE2RCxLQUFLN0QsSUFBTCxFQUFXLEtBQUtuRCxFQUFoQixDQUFmOztLQWZKO1dBa0JPMkIsQ0FBUDtHQTNCYTtPQTZCVixhQUFVMUksSUFBVixFQUFnQjEvQixHQUFoQixFQUFxQnNFLEtBQXJCLEVBQTRCO1FBQzNCc2xDLE9BQU9mLFFBQVEzRSxVQUFTbGtDLEdBQVQsQ0FBUixFQUF1QixJQUF2QixDQUFYO1FBQ0k0cEMsU0FBUyxJQUFiLEVBQW1CMEQsb0JBQW9CNU4sSUFBcEIsRUFBMEJoNEIsR0FBMUIsQ0FBOEIxSCxHQUE5QixFQUFtQ3NFLEtBQW5DLEVBQW5CLEtBQ0tzbEMsS0FBS2xLLEtBQUsrRyxFQUFWLElBQWdCbmlDLEtBQWhCO1dBQ0VvN0IsSUFBUDtHQWpDYTtXQW1DTjROO0NBbkNYOzs7TUMvQ0lqMUIsT0FBTzRsQixjQUE0QixDQUE1QixDQUFYOztNQVFJeVAsV0FBVyxTQUFmO01BQ0k3RSxVQUFVRSxNQUFLRixPQUFuQjtNQUNJTCxlQUFlamxDLE9BQU9pbEMsWUFBMUI7TUFDSThFLHNCQUFzQkssZ0JBQUtDLE9BQS9CO01BQ0lDLE1BQU0sRUFBVjtNQUNJQyxXQUFKOztNQUVJbDRCLFVBQVUsU0FBVkEsT0FBVSxDQUFVcE4sR0FBVixFQUFlO1dBQ3BCLFNBQVMya0IsT0FBVCxHQUFtQjthQUNqQjNrQixJQUFJLElBQUosRUFBVWlXLFVBQVUvZCxNQUFWLEdBQW1CLENBQW5CLEdBQXVCK2QsVUFBVSxDQUFWLENBQXZCLEdBQXNDN08sU0FBaEQsQ0FBUDtLQURGO0dBREY7O01BTUlpcEIsVUFBVTs7U0FFUCxTQUFTcndCLEdBQVQsQ0FBYXhJLEdBQWIsRUFBa0I7VUFDakIrOUIsVUFBUy85QixHQUFULENBQUosRUFBbUI7WUFDYjRwQyxPQUFPZixRQUFRN29DLEdBQVIsQ0FBWDtZQUNJNHBDLFNBQVMsSUFBYixFQUFtQixPQUFPMEQsb0JBQW9CM0Qsb0JBQVMsSUFBVCxFQUFlK0QsUUFBZixDQUFwQixFQUE4Q2xsQyxHQUE5QyxDQUFrRHhJLEdBQWxELENBQVA7ZUFDWjRwQyxPQUFPQSxLQUFLLEtBQUtuRCxFQUFWLENBQVAsR0FBdUI3MkIsU0FBOUI7O0tBTlE7O1NBVVAsU0FBU2xJLEdBQVQsQ0FBYTFILEdBQWIsRUFBa0JzRSxLQUFsQixFQUF5QjthQUNyQnFwQyxnQkFBS3ZKLEdBQUwsQ0FBU3VGLG9CQUFTLElBQVQsRUFBZStELFFBQWYsQ0FBVCxFQUFtQzF0QyxHQUFuQyxFQUF3Q3NFLEtBQXhDLENBQVA7O0dBWEo7OztNQWdCSXlwQyxXQUFXelEsY0FBQSxHQUFpQmEsWUFBeUJ1UCxRQUF6QixFQUFtQzkzQixPQUFuQyxFQUE0Q2lqQixPQUE1QyxFQUFxRDhVLGVBQXJELEVBQTJELElBQTNELEVBQWlFLElBQWpFLENBQWhDOzs7TUFHSXBELE9BQU0sWUFBWTtXQUFTLElBQUl3RCxRQUFKLEdBQWVybUMsR0FBZixDQUFtQixDQUFDbkUsT0FBT3lxQyxNQUFQLElBQWlCenFDLE1BQWxCLEVBQTBCc3FDLEdBQTFCLENBQW5CLEVBQW1ELENBQW5ELEVBQXNEcmxDLEdBQXRELENBQTBEcWxDLEdBQTFELEtBQWtFLENBQXpFO0dBQXBCLENBQUosRUFBd0c7a0JBQ3hGRixnQkFBS25ELGNBQUwsQ0FBb0I1MEIsT0FBcEIsRUFBNkI4M0IsUUFBN0IsQ0FBZDtrQkFDT0ksWUFBWTV1QyxTQUFuQixFQUE4QjI1QixPQUE5QjtVQUNLbVEsSUFBTCxHQUFZLElBQVo7U0FDSyxDQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCLEtBQWxCLEVBQXlCLEtBQXpCLENBQUwsRUFBc0MsVUFBVWhwQyxHQUFWLEVBQWU7VUFDL0N3aEMsUUFBUXVNLFNBQVM3dUMsU0FBckI7VUFDSTA1QixTQUFTNEksTUFBTXhoQyxHQUFOLENBQWI7Z0JBQ1N3aEMsS0FBVCxFQUFnQnhoQyxHQUFoQixFQUFxQixVQUFVMGIsQ0FBVixFQUFhbU4sQ0FBYixFQUFnQjs7WUFFL0JrVixVQUFTcmlCLENBQVQsS0FBZSxDQUFDOHNCLGFBQWE5c0IsQ0FBYixDQUFwQixFQUFxQztjQUMvQixDQUFDLEtBQUsydEIsRUFBVixFQUFjLEtBQUtBLEVBQUwsR0FBVSxJQUFJeUUsV0FBSixFQUFWO2NBQ1Zyc0MsU0FBUyxLQUFLNG5DLEVBQUwsQ0FBUXJwQyxHQUFSLEVBQWEwYixDQUFiLEVBQWdCbU4sQ0FBaEIsQ0FBYjtpQkFDTzdvQixPQUFPLEtBQVAsR0FBZSxJQUFmLEdBQXNCeUIsTUFBN0I7O1NBRUEsT0FBT20zQixPQUFPeDVCLElBQVAsQ0FBWSxJQUFaLEVBQWtCc2MsQ0FBbEIsRUFBcUJtTixDQUFyQixDQUFQO09BUEo7S0FIRjs7OztBQzdDRjtBQUNBb1YsaUJBQWdDLFNBQWhDOztBQ0RBO0FBQ0FBLG1CQUFrQyxTQUFsQzs7QUNJQSxjQUFpQmdRLE1BQTRCOWdCLE9BQTdDOztBQ0RBLHNCQUFpQix3QkFBQSxDQUFVaGEsTUFBVixFQUFrQm5FLEtBQWxCLEVBQXlCMUssS0FBekIsRUFBZ0M7TUFDM0MwSyxTQUFTbUUsTUFBYixFQUFxQis2QixVQUFnQjMxQixDQUFoQixDQUFrQnBGLE1BQWxCLEVBQTBCbkUsS0FBMUIsRUFBaUMrdkIsY0FBVyxDQUFYLEVBQWN6NkIsS0FBZCxDQUFqQyxFQUFyQixLQUNLNk8sT0FBT25FLEtBQVAsSUFBZ0IxSyxLQUFoQjtDQUZQOztBQ01BczdCLFFBQVFBLFFBQVF2QixDQUFSLEdBQVl1QixRQUFRRyxDQUFSLEdBQVksQ0FBQzlCLFlBQTBCLFVBQVVrTSxJQUFWLEVBQWdCOztDQUExQyxDQUFqQyxFQUFtRyxPQUFuRyxFQUE0Rzs7UUFFcEcsU0FBU2wxQixJQUFULENBQWNnQixTQUFkLGlEQUF3RTtRQUN4RXdvQixJQUFJc0csVUFBUzl1QixTQUFULENBQVI7UUFDSW15QixJQUFJLE9BQU8sSUFBUCxJQUFlLFVBQWYsR0FBNEIsSUFBNUIsR0FBbUNucEMsS0FBM0M7UUFDSTh0QyxPQUFPdHVCLFVBQVUvZCxNQUFyQjtRQUNJeXRDLFFBQVFwQixPQUFPLENBQVAsR0FBV3R1QixVQUFVLENBQVYsQ0FBWCxHQUEwQjdPLFNBQXRDO1FBQ0k4N0IsVUFBVXlDLFVBQVV2K0IsU0FBeEI7UUFDSVosUUFBUSxDQUFaO1FBQ0krNEIsU0FBU0MsdUJBQVV2SixDQUFWLENBQWI7UUFDSS85QixNQUFKLEVBQVllLE1BQVosRUFBb0IwYixJQUFwQixFQUEwQmlFLFFBQTFCO1FBQ0lzcUIsT0FBSixFQUFheUMsUUFBUXpOLEtBQUl5TixLQUFKLEVBQVdwQixPQUFPLENBQVAsR0FBV3R1QixVQUFVLENBQVYsQ0FBWCxHQUEwQjdPLFNBQXJDLEVBQWdELENBQWhELENBQVI7O1FBRVRtNEIsVUFBVW40QixTQUFWLElBQXVCLEVBQUV3NEIsS0FBS25wQyxLQUFMLElBQWNncEMsYUFBWUYsTUFBWixDQUFoQixDQUEzQixFQUFpRTtXQUMxRDNtQixXQUFXMm1CLE9BQU8zb0MsSUFBUCxDQUFZcS9CLENBQVosQ0FBWCxFQUEyQmg5QixTQUFTLElBQUkybUMsQ0FBSixFQUF6QyxFQUFrRCxDQUFDLENBQUNqckIsT0FBT2lFLFNBQVN1akIsSUFBVCxFQUFSLEVBQXlCM25CLElBQTVFLEVBQWtGaE8sT0FBbEYsRUFBMkY7d0JBQzFFdk4sTUFBZixFQUF1QnVOLEtBQXZCLEVBQThCMDhCLFVBQVV0c0MsVUFBS2dpQixRQUFMLEVBQWUrc0IsS0FBZixFQUFzQixDQUFDaHhCLEtBQUs3WSxLQUFOLEVBQWEwSyxLQUFiLENBQXRCLEVBQTJDLElBQTNDLENBQVYsR0FBNkRtTyxLQUFLN1ksS0FBaEc7O0tBRkosTUFJTztlQUNJdytCLFVBQVNyRSxFQUFFLzlCLE1BQVgsQ0FBVDtXQUNLZSxTQUFTLElBQUkybUMsQ0FBSixDQUFNMW5DLE1BQU4sQ0FBZCxFQUE2QkEsU0FBU3NPLEtBQXRDLEVBQTZDQSxPQUE3QyxFQUFzRDt3QkFDckN2TixNQUFmLEVBQXVCdU4sS0FBdkIsRUFBOEIwOEIsVUFBVXlDLE1BQU0xUCxFQUFFenZCLEtBQUYsQ0FBTixFQUFnQkEsS0FBaEIsQ0FBVixHQUFtQ3l2QixFQUFFenZCLEtBQUYsQ0FBakU7OztXQUdHdE8sTUFBUCxHQUFnQnNPLEtBQWhCO1dBQ092TixNQUFQOztDQXhCSjs7QUNSQSxhQUFpQjI4QixNQUErQm4vQixLQUEvQixDQUFxQ2dXLElBQXREOztBQ0ZBLElBQU1tNUIsa0JBQWtCLElBQUlqRCxHQUFKLENBQVEsQ0FDOUIsZ0JBRDhCLEVBRTlCLGVBRjhCLEVBRzlCLFdBSDhCLEVBSTlCLGVBSjhCLEVBSzlCLGVBTDhCLEVBTTlCLGtCQU44QixFQU85QixnQkFQOEIsRUFROUIsZUFSOEIsQ0FBUixDQUF4Qjs7Ozs7O0FBZUEsQUFBTyxTQUFTa0Qsd0JBQVQsQ0FBa0NDLFNBQWxDLEVBQTZDO01BQzVDQyxXQUFXSCxnQkFBZ0IvOEIsR0FBaEIsQ0FBb0JpOUIsU0FBcEIsQ0FBakI7TUFDTUUsWUFBWSxtQ0FBbUN6c0MsSUFBbkMsQ0FBd0N1c0MsU0FBeEMsQ0FBbEI7U0FDTyxDQUFDQyxRQUFELElBQWFDLFNBQXBCOzs7Ozs7OztBQVFGLEFBQU8sU0FBU0MsV0FBVCxDQUFxQmo5QixJQUFyQixFQUEyQjs7TUFFMUJrOUIsY0FBY2w5QixLQUFLaTlCLFdBQXpCO01BQ0lDLGdCQUFnQjkrQixTQUFwQixFQUErQjtXQUN0QjgrQixXQUFQOzs7O01BSUUvZ0MsVUFBVTZELElBQWQ7U0FDTzdELFdBQVcsRUFBRUEsUUFBUWdoQyxxQkFBUixJQUFpQ2hoQyxtQkFBbUJpaEMsUUFBdEQsQ0FBbEIsRUFBbUY7Y0FDdkVqaEMsUUFBUS9ELFVBQVIsS0FBdUIvSyxPQUFPZ3dDLFVBQVAsSUFBcUJsaEMsbUJBQW1Ca2hDLFVBQXhDLEdBQXFEbGhDLFFBQVFtaEMsSUFBN0QsR0FBb0VsL0IsU0FBM0YsQ0FBVjs7U0FFSyxDQUFDLEVBQUVqQyxZQUFZQSxRQUFRZ2hDLHFCQUFSLElBQWlDaGhDLG1CQUFtQmloQyxRQUFoRSxDQUFGLENBQVI7Ozs7Ozs7O0FBUUYsU0FBU0csNEJBQVQsQ0FBc0NDLElBQXRDLEVBQTRDNXJCLEtBQTVDLEVBQW1EO01BQzdDNVIsT0FBTzRSLEtBQVg7U0FDTzVSLFFBQVFBLFNBQVN3OUIsSUFBakIsSUFBeUIsQ0FBQ3g5QixLQUFLeTlCLFdBQXRDLEVBQW1EO1dBQzFDejlCLEtBQUs1SCxVQUFaOztTQUVNLENBQUM0SCxJQUFELElBQVNBLFNBQVN3OUIsSUFBbkIsR0FBMkIsSUFBM0IsR0FBa0N4OUIsS0FBS3k5QixXQUE5Qzs7Ozs7Ozs7QUFRRixTQUFTQyxRQUFULENBQWtCRixJQUFsQixFQUF3QjVyQixLQUF4QixFQUErQjtTQUN0QkEsTUFBTXZLLFVBQU4sR0FBbUJ1SyxNQUFNdkssVUFBekIsR0FBc0NrMkIsNkJBQTZCQyxJQUE3QixFQUFtQzVyQixLQUFuQyxDQUE3Qzs7Ozs7Ozs7QUFRRixBQUFPLFNBQVMrckIsMEJBQVQsQ0FBb0NILElBQXBDLEVBQTBDbm9DLFFBQTFDLEVBQWdGO01BQTVCdW9DLGNBQTRCLHVFQUFYLElBQUlqRSxHQUFKLEVBQVc7O01BQ2pGMzVCLE9BQU93OUIsSUFBWDtTQUNPeDlCLElBQVAsRUFBYTtRQUNQQSxLQUFLaUQsUUFBTCxLQUFrQkMsS0FBS0MsWUFBM0IsRUFBeUM7VUFDakMvVSxpQ0FBa0M0UixJQUF4Qzs7ZUFFUzVSLE9BQVQ7O1VBRU0wdUMsWUFBWTF1QyxRQUFRMHVDLFNBQTFCO1VBQ0lBLGNBQWMsTUFBZCxJQUF3QjF1QyxRQUFRa0IsWUFBUixDQUFxQixLQUFyQixNQUFnQyxRQUE1RCxFQUFzRTs7O1lBRzlEK1UsaUNBQW1DalcsUUFBUXl2QyxNQUFqRDtZQUNJeDVCLHNCQUFzQm5CLElBQXRCLElBQThCLENBQUMwNkIsZUFBZS85QixHQUFmLENBQW1Cd0UsVUFBbkIsQ0FBbkMsRUFBbUU7O3lCQUVsRDFILEdBQWYsQ0FBbUIwSCxVQUFuQjs7ZUFFSyxJQUFJUCxRQUFRTyxXQUFXZ0QsVUFBNUIsRUFBd0N2RCxLQUF4QyxFQUErQ0EsUUFBUUEsTUFBTTI1QixXQUE3RCxFQUEwRTt1Q0FDN0MzNUIsS0FBM0IsRUFBa0N6TyxRQUFsQyxFQUE0Q3VvQyxjQUE1Qzs7Ozs7OztlQU9HTCw2QkFBNkJDLElBQTdCLEVBQW1DcHZDLE9BQW5DLENBQVA7O09BaEJGLE1Ba0JPLElBQUkwdUMsY0FBYyxVQUFsQixFQUE4Qjs7Ozs7ZUFLNUJTLDZCQUE2QkMsSUFBN0IsRUFBbUNwdkMsT0FBbkMsQ0FBUDs7Ozs7VUFLSTB2QyxhQUFhMXZDLFFBQVEydkMsZUFBM0I7VUFDSUQsVUFBSixFQUFnQjthQUNULElBQUloNkIsU0FBUWc2QixXQUFXejJCLFVBQTVCLEVBQXdDdkQsTUFBeEMsRUFBK0NBLFNBQVFBLE9BQU0yNUIsV0FBN0QsRUFBMEU7cUNBQzdDMzVCLE1BQTNCLEVBQWtDek8sUUFBbEMsRUFBNEN1b0MsY0FBNUM7Ozs7O1dBS0NGLFNBQVNGLElBQVQsRUFBZXg5QixJQUFmLENBQVA7Ozs7Ozs7Ozs7Ozs7QUFhSixBQUFPLFNBQVNnK0Isb0JBQVQsQ0FBOEJDLFdBQTlCLEVBQTJDandDLElBQTNDLEVBQWlEOEUsS0FBakQsRUFBd0Q7Y0FDakQ5RSxJQUFaLElBQW9COEUsS0FBcEI7OztBQy9IRjs7O0FBR0EsSUFBTW9yQyxxQkFBcUI7VUFDakIsQ0FEaUI7VUFFakI7Q0FGVjs7SUNBcUJDO29DQUNMOzs7O1NBRVBDLHNCQUFMLEdBQThCLElBQUk3RCxHQUFKLEVBQTlCOzs7U0FHSzhELHdCQUFMLEdBQWdDLElBQUk5RCxHQUFKLEVBQWhDOzs7U0FHSytELFFBQUwsR0FBZ0IsRUFBaEI7OztTQUdLQyxXQUFMLEdBQW1CLEtBQW5COzs7Ozs7Ozs7OztrQ0FPWXpCLFdBQVcwQixZQUFZO1dBQzlCSixzQkFBTCxDQUE0QmxvQyxHQUE1QixDQUFnQzRtQyxTQUFoQyxFQUEyQzBCLFVBQTNDO1dBQ0tILHdCQUFMLENBQThCbm9DLEdBQTlCLENBQWtDc29DLFdBQVdoTCxXQUE3QyxFQUEwRGdMLFVBQTFEOzs7Ozs7Ozs7OzBDQU9vQjFCLFdBQVc7YUFDeEIsS0FBS3NCLHNCQUFMLENBQTRCcG5DLEdBQTVCLENBQWdDOGxDLFNBQWhDLENBQVA7Ozs7Ozs7Ozs7NENBT3NCdEosYUFBYTthQUM1QixLQUFLNkssd0JBQUwsQ0FBOEJybkMsR0FBOUIsQ0FBa0N3OEIsV0FBbEMsQ0FBUDs7Ozs7Ozs7OzZCQU1PM1AsVUFBVTtXQUNaMGEsV0FBTCxHQUFtQixJQUFuQjtXQUNLRCxRQUFMLENBQWNqdkMsSUFBZCxDQUFtQncwQixRQUFuQjs7Ozs7Ozs7OzhCQU1RN2pCLE1BQU07OztVQUNWLENBQUMsS0FBS3UrQixXQUFWLEVBQXVCOztnQ0FFdkIsQ0FBcUN2K0IsSUFBckMsRUFBMkM7ZUFBVyxNQUFLeStCLEtBQUwsQ0FBV3J3QyxPQUFYLENBQVg7T0FBM0M7Ozs7Ozs7OzswQkFNSTRSLE1BQU07VUFDTixDQUFDLEtBQUt1K0IsV0FBVixFQUF1Qjs7VUFFbkJ2K0IsS0FBSzArQixZQUFULEVBQXVCO1dBQ2xCQSxZQUFMLEdBQW9CLElBQXBCOztXQUVLLElBQUl6dkMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUtxdkMsUUFBTCxDQUFjcHZDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQzthQUN4Q3F2QyxRQUFMLENBQWNydkMsQ0FBZCxFQUFpQitRLElBQWpCOzs7Ozs7Ozs7O2dDQU9RdzlCLE1BQU07VUFDVnRpQyxXQUFXLEVBQWpCOztnQ0FFQSxDQUFxQ3NpQyxJQUFyQyxFQUEyQztlQUFXdGlDLFNBQVM3TCxJQUFULENBQWNqQixPQUFkLENBQVg7T0FBM0M7O1dBRUssSUFBSWEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaU0sU0FBU2hNLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztZQUNsQ2IsVUFBVThNLFNBQVNqTSxDQUFULENBQWhCO1lBQ0liLFFBQVF1d0MsVUFBUixLQUF1QkMsbUJBQVFDLE1BQW5DLEVBQTJDO2NBQ3JDQyxXQUFBLENBQXNCMXdDLE9BQXRCLENBQUosRUFBb0M7aUJBQzdCMndDLGlCQUFMLENBQXVCM3dDLE9BQXZCOztTQUZKLE1BSU87ZUFDQTR3QyxjQUFMLENBQW9CNXdDLE9BQXBCOzs7Ozs7Ozs7OzttQ0FRU292QyxNQUFNO1VBQ2J0aUMsV0FBVyxFQUFqQjs7Z0NBRUEsQ0FBcUNzaUMsSUFBckMsRUFBMkM7ZUFBV3RpQyxTQUFTN0wsSUFBVCxDQUFjakIsT0FBZCxDQUFYO09BQTNDOztXQUVLLElBQUlhLElBQUksQ0FBYixFQUFnQkEsSUFBSWlNLFNBQVNoTSxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7WUFDbENiLFVBQVU4TSxTQUFTak0sQ0FBVCxDQUFoQjtZQUNJYixRQUFRdXdDLFVBQVIsS0FBdUJDLG1CQUFRQyxNQUFuQyxFQUEyQztlQUNwQ0ksb0JBQUwsQ0FBMEI3d0MsT0FBMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQW9FY292QyxNQUFrQzs7O1VBQTVCSSxjQUE0Qix1RUFBWCxJQUFJakUsR0FBSixFQUFXOztVQUM5Q3orQixXQUFXLEVBQWpCOztVQUVNZ2tDLGlCQUFpQixTQUFqQkEsY0FBaUIsVUFBVztZQUM1Qjl3QyxRQUFRMHVDLFNBQVIsS0FBc0IsTUFBdEIsSUFBZ0MxdUMsUUFBUWtCLFlBQVIsQ0FBcUIsS0FBckIsTUFBZ0MsUUFBcEUsRUFBOEU7OztjQUd0RStVLGlDQUFtQ2pXLFFBQVF5dkMsTUFBakQ7O2NBRUl4NUIsc0JBQXNCbkIsSUFBdEIsSUFBOEJtQixXQUFXblUsVUFBWCxLQUEwQixVQUE1RCxFQUF3RTt1QkFDM0RpdEMscUJBQVgsR0FBbUMsSUFBbkM7Ozt1QkFHV2dDLGdCQUFYLEdBQThCLElBQTlCO1dBSkYsTUFLTzs7O29CQUdHL3BDLGdCQUFSLENBQXlCLE1BQXpCLEVBQWlDLFlBQU07a0JBQy9CaVAsaUNBQW1DalcsUUFBUXl2QyxNQUFqRDs7a0JBRUl4NUIsV0FBVys2Qix3QkFBZixFQUF5Qzt5QkFDOUJBLHdCQUFYLEdBQXNDLElBQXRDOzt5QkFFV2pDLHFCQUFYLEdBQW1DLElBQW5DOzs7eUJBR1dnQyxnQkFBWCxHQUE4QixJQUE5Qjs7Ozs7Ozs2QkFRZTFqQixNQUFmLENBQXNCcFgsVUFBdEI7O3FCQUVLZzdCLG1CQUFMLENBQXlCaDdCLFVBQXpCLEVBQXFDdTVCLGNBQXJDO2FBbkJGOztTQWJKLE1BbUNPO21CQUNJdnVDLElBQVQsQ0FBY2pCLE9BQWQ7O09BckNKOzs7O2dDQTJDQSxDQUFxQ292QyxJQUFyQyxFQUEyQzBCLGNBQTNDLEVBQTJEdEIsY0FBM0Q7O1VBRUksS0FBS1csV0FBVCxFQUFzQjthQUNmLElBQUl0dkMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaU0sU0FBU2hNLE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztlQUNuQ3d2QyxLQUFMLENBQVd2akMsU0FBU2pNLENBQVQsQ0FBWDs7OztXQUlDLElBQUlBLEtBQUksQ0FBYixFQUFnQkEsS0FBSWlNLFNBQVNoTSxNQUE3QixFQUFxQ0QsSUFBckMsRUFBMEM7YUFDbkMrdkMsY0FBTCxDQUFvQjlqQyxTQUFTak0sRUFBVCxDQUFwQjs7Ozs7Ozs7OzttQ0FPV2IsU0FBUztVQUNoQmt4QyxlQUFlbHhDLFFBQVF1d0MsVUFBN0I7VUFDSVcsaUJBQWlCbGhDLFNBQXJCLEVBQWdDOztVQUUxQm9nQyxhQUFhLEtBQUtlLHFCQUFMLENBQTJCbnhDLFFBQVEwdUMsU0FBbkMsQ0FBbkI7VUFDSSxDQUFDMEIsVUFBTCxFQUFpQjs7aUJBRU5nQixpQkFBWCxDQUE2Qm53QyxJQUE3QixDQUFrQ2pCLE9BQWxDOztVQUVNb2xDLGNBQWNnTCxXQUFXaEwsV0FBL0I7VUFDSTtZQUNFO2NBQ0V2akMsU0FBUyxJQUFLdWpDLFdBQUwsRUFBYjtjQUNJdmpDLFdBQVc3QixPQUFmLEVBQXdCO2tCQUNoQixJQUFJK0IsS0FBSixDQUFVLDRFQUFWLENBQU47O1NBSEosU0FLVTtxQkFDR3F2QyxpQkFBWCxDQUE2QkMsR0FBN0I7O09BUEosQ0FTRSxPQUFPMXBDLENBQVAsRUFBVTtnQkFDRjRvQyxVQUFSLEdBQXFCQyxtQkFBUWMsTUFBN0I7Y0FDTTNwQyxDQUFOOzs7Y0FHTTRvQyxVQUFSLEdBQXFCQyxtQkFBUUMsTUFBN0I7Y0FDUWMsZUFBUixHQUEwQm5CLFVBQTFCOztVQUVJQSxXQUFXb0Isd0JBQWYsRUFBeUM7WUFDakNDLHFCQUFxQnJCLFdBQVdxQixrQkFBdEM7YUFDSyxJQUFJNXdDLElBQUksQ0FBYixFQUFnQkEsSUFBSTR3QyxtQkFBbUIzd0MsTUFBdkMsRUFBK0NELEdBQS9DLEVBQW9EO2NBQzVDakIsT0FBTzZ4QyxtQkFBbUI1d0MsQ0FBbkIsQ0FBYjtjQUNNNkQsUUFBUTFFLFFBQVFrQixZQUFSLENBQXFCdEIsSUFBckIsQ0FBZDtjQUNJOEUsVUFBVSxJQUFkLEVBQW9CO2lCQUNiOHNDLHdCQUFMLENBQThCeHhDLE9BQTlCLEVBQXVDSixJQUF2QyxFQUE2QyxJQUE3QyxFQUFtRDhFLEtBQW5ELEVBQTBELElBQTFEOzs7OztVQUtGZ3NDLFdBQUEsQ0FBc0Ixd0MsT0FBdEIsQ0FBSixFQUFvQzthQUM3QjJ3QyxpQkFBTCxDQUF1QjN3QyxPQUF2Qjs7Ozs7Ozs7OztzQ0FPY0EsU0FBUztVQUNuQm93QyxhQUFhcHdDLFFBQVF1eEMsZUFBM0I7VUFDSW5CLFdBQVdPLGlCQUFmLEVBQWtDO21CQUNyQkEsaUJBQVgsQ0FBNkJueEMsSUFBN0IsQ0FBa0NRLE9BQWxDOzs7Y0FHTTB4Qyw4QkFBUixHQUF5QyxJQUF6Qzs7Ozs7Ozs7O3lDQU1tQjF4QyxTQUFTO1VBQ3hCLENBQUNBLFFBQVEweEMsOEJBQWIsRUFBNkM7YUFDdENmLGlCQUFMLENBQXVCM3dDLE9BQXZCOzs7VUFHSW93QyxhQUFhcHdDLFFBQVF1eEMsZUFBM0I7VUFDSW5CLFdBQVdTLG9CQUFmLEVBQXFDO21CQUN4QkEsb0JBQVgsQ0FBZ0NyeEMsSUFBaEMsQ0FBcUNRLE9BQXJDOzs7Y0FHTTB4Qyw4QkFBUixHQUF5QzFoQyxTQUF6Qzs7Ozs7Ozs7Ozs7Ozs2Q0FVdUJoUSxTQUFTSixNQUFNK3hDLFVBQVVDLFVBQVVDLFdBQVc7VUFDL0R6QixhQUFhcHdDLFFBQVF1eEMsZUFBM0I7VUFFRW5CLFdBQVdvQix3QkFBWCxJQUNBcEIsV0FBV3FCLGtCQUFYLENBQThCendDLE9BQTlCLENBQXNDcEIsSUFBdEMsSUFBOEMsQ0FBQyxDQUZqRCxFQUdFO21CQUNXNHhDLHdCQUFYLENBQW9DaHlDLElBQXBDLENBQXlDUSxPQUF6QyxFQUFrREosSUFBbEQsRUFBd0QreEMsUUFBeEQsRUFBa0VDLFFBQWxFLEVBQTRFQyxTQUE1RTs7Ozs7OztJQzdUZUM7d0NBQ1BDLFNBQVosRUFBdUJDLEdBQXZCLEVBQTRCOzs7Ozs7U0FJckJDLFVBQUwsR0FBa0JGLFNBQWxCOzs7OztTQUtLRyxTQUFMLEdBQWlCRixHQUFqQjs7Ozs7U0FLS0csU0FBTCxHQUFpQm5pQyxTQUFqQjs7OztTQUtLaWlDLFVBQUwsQ0FBZ0JoQixtQkFBaEIsQ0FBb0MsS0FBS2lCLFNBQXpDOztRQUVJLEtBQUtBLFNBQUwsQ0FBZXB3QyxVQUFmLEtBQThCLFNBQWxDLEVBQTZDO1dBQ3RDcXdDLFNBQUwsR0FBaUIsSUFBSTFrQixnQkFBSixDQUFxQixLQUFLMmtCLGdCQUFMLENBQXNCeHNDLElBQXRCLENBQTJCLElBQTNCLENBQXJCLENBQWpCOzs7Ozs7V0FNS3VzQyxTQUFMLENBQWV6a0IsT0FBZixDQUF1QixLQUFLd2tCLFNBQTVCLEVBQXVDO21CQUMxQixJQUQwQjtpQkFFNUI7T0FGWDs7Ozs7O2lDQU9TO1VBQ1AsS0FBS0MsU0FBVCxFQUFvQjthQUNiQSxTQUFMLENBQWVFLFVBQWY7Ozs7Ozs7Ozs7cUNBT2FDLFdBQVc7Ozs7VUFJcEJ4d0MsYUFBYSxLQUFLb3dDLFNBQUwsQ0FBZXB3QyxVQUFsQztVQUNJQSxlQUFlLGFBQWYsSUFBZ0NBLGVBQWUsVUFBbkQsRUFBK0Q7YUFDeER1d0MsVUFBTDs7O1dBR0csSUFBSXh4QyxJQUFJLENBQWIsRUFBZ0JBLElBQUl5eEMsVUFBVXh4QyxNQUE5QixFQUFzQ0QsR0FBdEMsRUFBMkM7WUFDbkMweEMsYUFBYUQsVUFBVXp4QyxDQUFWLEVBQWEweEMsVUFBaEM7YUFDSyxJQUFJbjhCLElBQUksQ0FBYixFQUFnQkEsSUFBSW04QixXQUFXenhDLE1BQS9CLEVBQXVDc1YsR0FBdkMsRUFBNEM7Y0FDcEN4RSxPQUFPMmdDLFdBQVduOEIsQ0FBWCxDQUFiO2VBQ0s2N0IsVUFBTCxDQUFnQmhCLG1CQUFoQixDQUFvQ3IvQixJQUFwQzs7Ozs7Ozs7QUM1RFI7OztJQUdxQjRnQztzQkFDTDs7Ozs7Ozs7O1NBS1BDLE1BQUwsR0FBY3ppQyxTQUFkOzs7Ozs7U0FNSzBpQyxRQUFMLEdBQWdCMWlDLFNBQWhCOzs7Ozs7U0FNSzJpQyxRQUFMLEdBQWdCLElBQUlucUMsT0FBSixDQUFZLG1CQUFXO1lBQ2hDa3FDLFFBQUwsR0FBZ0JqcUMsT0FBaEI7O1VBRUksTUFBS2dxQyxNQUFULEVBQWlCO2dCQUNQLE1BQUtBLE1BQWI7O0tBSlksQ0FBaEI7Ozs7Ozs7Ozs7NEJBWU0vdEMsT0FBTztVQUNULEtBQUsrdEMsTUFBVCxFQUFpQjtjQUNULElBQUkxd0MsS0FBSixDQUFVLG1CQUFWLENBQU47OztXQUdHMHdDLE1BQUwsR0FBYy90QyxLQUFkOztVQUVJLEtBQUtndUMsUUFBVCxFQUFtQjthQUNaQSxRQUFMLENBQWNodUMsS0FBZDs7Ozs7Ozs7OztnQ0FPUTthQUNILEtBQUtpdUMsUUFBWjs7Ozs7O0FDNUNKOzs7O0lBR3FCQzs7Ozs7aUNBS1BiLFNBQVosRUFBdUI7Ozs7Ozs7U0FLaEJjLDJCQUFMLEdBQW1DLEtBQW5DOzs7Ozs7U0FNS1osVUFBTCxHQUFrQkYsU0FBbEI7Ozs7OztTQU1LZSxvQkFBTCxHQUE0QixJQUFJM0csR0FBSixFQUE1Qjs7Ozs7OztTQU9LNEcsY0FBTCxHQUFzQjthQUFNbnhDLElBQU47S0FBdEI7Ozs7OztTQU1Lb3hDLGFBQUwsR0FBcUIsS0FBckI7Ozs7OztTQU1LQyxvQkFBTCxHQUE0QixFQUE1Qjs7Ozs7O1NBTUtDLDZCQUFMLEdBQXFDLElBQUlwQiw0QkFBSixDQUFpQ0MsU0FBakMsRUFBNEM1eUMsUUFBNUMsQ0FBckM7Ozs7Ozs7Ozs7OzJCQU9LdXZDLFdBQVd0SixhQUFhOzs7VUFDekIsRUFBRUEsdUJBQXVCeDBCLFFBQXpCLENBQUosRUFBd0M7Y0FDaEMsSUFBSXd0QixTQUFKLENBQWMsZ0RBQWQsQ0FBTjs7O1VBR0UsQ0FBQ3NTLHdCQUFBLENBQW1DaEMsU0FBbkMsQ0FBTCxFQUFvRDtjQUM1QyxJQUFJeUUsV0FBSix5QkFBcUN6RSxTQUFyQyxzQkFBTjs7O1VBR0UsS0FBS3VELFVBQUwsQ0FBZ0JkLHFCQUFoQixDQUFzQ3pDLFNBQXRDLENBQUosRUFBc0Q7Y0FDOUMsSUFBSTNzQyxLQUFKLG1DQUF5QzJzQyxTQUF6QyxrQ0FBTjs7O1VBR0UsS0FBS21FLDJCQUFULEVBQXNDO2NBQzlCLElBQUk5d0MsS0FBSixDQUFVLDRDQUFWLENBQU47O1dBRUc4d0MsMkJBQUwsR0FBbUMsSUFBbkM7O1VBRUlsQywwQkFBSjtVQUNJRSw2QkFBSjtVQUNJdUMsd0JBQUo7VUFDSTVCLGlDQUFKO1VBQ0lDLDJCQUFKO1VBQ0k7WUFPTzRCLFdBUFAsR0FPRixTQUFTQSxXQUFULENBQXFCenpDLElBQXJCLEVBQTJCO2NBQ25CMHpDLGdCQUFnQmgwQyxVQUFVTSxJQUFWLENBQXRCO2NBQ0kwekMsa0JBQWtCdGpDLFNBQWxCLElBQStCLEVBQUVzakMseUJBQXlCMWlDLFFBQTNCLENBQW5DLEVBQXlFO2tCQUNqRSxJQUFJN08sS0FBSixZQUFrQm5DLElBQWxCLHFDQUFOOztpQkFFSzB6QyxhQUFQO1NBWkE7OztZQUVJaDBDLFlBQVk4bEMsWUFBWTlsQyxTQUE5QjtZQUNJLEVBQUVBLHFCQUFxQnFFLE1BQXZCLENBQUosRUFBb0M7Z0JBQzVCLElBQUl5NkIsU0FBSixDQUFjLCtEQUFkLENBQU47Ozs0QkFXa0JpVixZQUFZLG1CQUFaLENBQXBCOytCQUN1QkEsWUFBWSxzQkFBWixDQUF2QjswQkFDa0JBLFlBQVksaUJBQVosQ0FBbEI7bUNBQzJCQSxZQUFZLDBCQUFaLENBQTNCOzZCQUNxQmpPLFlBQVksb0JBQVosS0FBcUMsRUFBMUQ7T0FuQkYsQ0FvQkUsT0FBT3o5QixDQUFQLEVBQVU7O09BcEJaLFNBc0JVO2FBQ0hrckMsMkJBQUwsR0FBbUMsS0FBbkM7OztVQUdJekMsYUFBYTs0QkFBQTtnQ0FBQTs0Q0FBQTtrREFBQTt3Q0FBQTswREFBQTs4Q0FBQTsyQkFRRTtPQVJyQjs7V0FXSzZCLFVBQUwsQ0FBZ0JzQixhQUFoQixDQUE4QjdFLFNBQTlCLEVBQXlDMEIsVUFBekM7O1dBRUs2QyxvQkFBTCxDQUEwQmh5QyxJQUExQixDQUErQnl0QyxTQUEvQjs7OztVQUlJLENBQUMsS0FBS3NFLGFBQVYsRUFBeUI7YUFDbEJBLGFBQUwsR0FBcUIsSUFBckI7YUFDS0QsY0FBTCxDQUFvQjtpQkFBTSxNQUFLUyxNQUFMLEVBQU47U0FBcEI7Ozs7OzZCQUlLOzs7O1VBSUgsS0FBS1IsYUFBTCxLQUF1QixLQUEzQixFQUFrQzs7V0FFN0JBLGFBQUwsR0FBcUIsS0FBckI7V0FDS2YsVUFBTCxDQUFnQmhCLG1CQUFoQixDQUFvQzl4QyxRQUFwQzs7YUFFTyxLQUFLOHpDLG9CQUFMLENBQTBCbnlDLE1BQTFCLEdBQW1DLENBQTFDLEVBQTZDO1lBQ3JDNHRDLFlBQVksS0FBS3VFLG9CQUFMLENBQTBCeG9DLEtBQTFCLEVBQWxCO1lBQ004TyxXQUFXLEtBQUt1NUIsb0JBQUwsQ0FBMEJscUMsR0FBMUIsQ0FBOEI4bEMsU0FBOUIsQ0FBakI7WUFDSW4xQixRQUFKLEVBQWM7bUJBQ0g5USxPQUFULENBQWlCdUgsU0FBakI7Ozs7Ozs7Ozs7OzsyQkFTRjArQixXQUFXO1VBQ1AwQixhQUFhLEtBQUs2QixVQUFMLENBQWdCZCxxQkFBaEIsQ0FBc0N6QyxTQUF0QyxDQUFuQjtVQUNJMEIsVUFBSixFQUFnQjtlQUNQQSxXQUFXaEwsV0FBbEI7OzthQUdLcDFCLFNBQVA7Ozs7Ozs7Ozs7Z0NBT1UwK0IsV0FBVztVQUNqQixDQUFDZ0Msd0JBQUEsQ0FBbUNoQyxTQUFuQyxDQUFMLEVBQW9EO2VBQzNDbG1DLFFBQVFFLE1BQVIsQ0FBZSxJQUFJeXFDLFdBQUosUUFBb0J6RSxTQUFwQiw0Q0FBZixDQUFQOzs7VUFHSStFLFFBQVEsS0FBS1gsb0JBQUwsQ0FBMEJscUMsR0FBMUIsQ0FBOEI4bEMsU0FBOUIsQ0FBZDtVQUNJK0UsS0FBSixFQUFXO2VBQ0ZBLE1BQU1DLFNBQU4sRUFBUDs7O1VBR0luNkIsV0FBVyxJQUFJaTVCLFFBQUosRUFBakI7V0FDS00sb0JBQUwsQ0FBMEJockMsR0FBMUIsQ0FBOEI0bUMsU0FBOUIsRUFBeUNuMUIsUUFBekM7O1VBRU02MkIsYUFBYSxLQUFLNkIsVUFBTCxDQUFnQmQscUJBQWhCLENBQXNDekMsU0FBdEMsQ0FBbkI7Ozs7VUFJSTBCLGNBQWMsS0FBSzZDLG9CQUFMLENBQTBCanlDLE9BQTFCLENBQWtDMHRDLFNBQWxDLE1BQWlELENBQUMsQ0FBcEUsRUFBdUU7aUJBQzVEam1DLE9BQVQsQ0FBaUJ1SCxTQUFqQjs7O2FBR0t1SixTQUFTbTZCLFNBQVQsRUFBUDs7Ozs4Q0FHd0JDLE9BQU87V0FDMUJULDZCQUFMLENBQW1DYixVQUFuQztVQUNNdUIsUUFBUSxLQUFLYixjQUFuQjtXQUNLQSxjQUFMLEdBQXNCO2VBQVNZLE1BQU07aUJBQU1DLE1BQU1DLEtBQU4sQ0FBTjtTQUFOLENBQVQ7T0FBdEI7Ozs7OztBQUlKLEFBQ0E1MEMsT0FBTyx1QkFBUCxJQUFrQzJ6QyxxQkFBbEM7QUFDQUEsc0JBQXNCdHpDLFNBQXRCLENBQWdDLFFBQWhDLElBQTRDc3pDLHNCQUFzQnR6QyxTQUF0QixDQUFnQ2krQixNQUE1RTtBQUNBcVYsc0JBQXNCdHpDLFNBQXRCLENBQWdDLEtBQWhDLElBQXlDc3pDLHNCQUFzQnR6QyxTQUF0QixDQUFnQ3NKLEdBQXpFO0FBQ0FncUMsc0JBQXNCdHpDLFNBQXRCLENBQWdDLGFBQWhDLElBQWlEc3pDLHNCQUFzQnR6QyxTQUF0QixDQUFnQ3cwQyxXQUFqRjtBQUNBbEIsc0JBQXNCdHpDLFNBQXRCLENBQWdDLDJCQUFoQyxJQUErRHN6QyxzQkFBc0J0ekMsU0FBdEIsQ0FBZ0N5MEMseUJBQS9GOztBQzdNQSxhQUFlOzBCQUNXOTBDLE9BQU8rdkMsUUFBUCxDQUFnQjF2QyxTQUFoQixDQUEwQmtILGFBRHJDOzRCQUVhdkgsT0FBTyt2QyxRQUFQLENBQWdCMXZDLFNBQWhCLENBQTBCMDBDLGVBRnZDO3VCQUdRLzBDLE9BQU8rdkMsUUFBUCxDQUFnQjF2QyxTQUFoQixDQUEwQjJXLFVBSGxDO29CQUlLaFgsT0FBTyt2QyxRQUFQLENBQWdCMXZDLFNBQWhCLENBQTBCLFNBQTFCLENBSkw7bUJBS0lMLE9BQU8rdkMsUUFBUCxDQUFnQjF2QyxTQUFoQixDQUEwQixRQUExQixDQUxKO2tCQU1HTCxPQUFPNlYsSUFBUCxDQUFZeFYsU0FBWixDQUFzQjIwQyxTQU56QjtvQkFPS2gxQyxPQUFPNlYsSUFBUCxDQUFZeFYsU0FBWixDQUFzQnNLLFdBUDNCO3FCQVFNM0ssT0FBTzZWLElBQVAsQ0FBWXhWLFNBQVosQ0FBc0IwWixZQVI1QjtvQkFTSy9aLE9BQU82VixJQUFQLENBQVl4VixTQUFaLENBQXNCdTRCLFdBVDNCO3FCQVVNNTRCLE9BQU82VixJQUFQLENBQVl4VixTQUFaLENBQXNCMkssWUFWNUI7b0JBV0t0RyxPQUFPNjlCLHdCQUFQLENBQWdDdmlDLE9BQU82VixJQUFQLENBQVl4VixTQUE1QyxFQUF1RCxhQUF2RCxDQVhMO3dCQVlTTCxPQUFPeTFCLE9BQVAsQ0FBZXAxQixTQUFmLENBQXlCLGNBQXpCLENBWlQ7cUJBYU1xRSxPQUFPNjlCLHdCQUFQLENBQWdDdmlDLE9BQU95MUIsT0FBUCxDQUFlcDFCLFNBQS9DLEVBQTBELFdBQTFELENBYk47d0JBY1NMLE9BQU95MUIsT0FBUCxDQUFlcDFCLFNBQWYsQ0FBeUI0QixZQWRsQzt3QkFlU2pDLE9BQU95MUIsT0FBUCxDQUFlcDFCLFNBQWYsQ0FBeUJ1TixZQWZsQzsyQkFnQlk1TixPQUFPeTFCLE9BQVAsQ0FBZXAxQixTQUFmLENBQXlCNkIsZUFoQnJDOzBCQWlCV2xDLE9BQU95MUIsT0FBUCxDQUFlcDFCLFNBQWYsQ0FBeUI0MEMsY0FqQnBDOzBCQWtCV2oxQyxPQUFPeTFCLE9BQVAsQ0FBZXAxQixTQUFmLENBQXlCNjBDLGNBbEJwQzs2QkFtQmNsMUMsT0FBT3kxQixPQUFQLENBQWVwMUIsU0FBZixDQUF5QjgwQyxpQkFuQnZDO2lDQW9Ca0JuMUMsT0FBT3kxQixPQUFQLENBQWVwMUIsU0FBZixDQUF5Qix1QkFBekIsQ0FwQmxCO21CQXFCSUwsT0FBT3kxQixPQUFQLENBQWVwMUIsU0FBZixDQUF5QixTQUF6QixDQXJCSjtrQkFzQkdMLE9BQU95MUIsT0FBUCxDQUFlcDFCLFNBQWYsQ0FBeUIsUUFBekIsQ0F0Qkg7a0JBdUJHTCxPQUFPeTFCLE9BQVAsQ0FBZXAxQixTQUFmLENBQXlCLFFBQXpCLENBdkJIO2lCQXdCRUwsT0FBT3kxQixPQUFQLENBQWVwMUIsU0FBZixDQUF5QixPQUF6QixDQXhCRjt1QkF5QlFMLE9BQU95MUIsT0FBUCxDQUFlcDFCLFNBQWYsQ0FBeUIsYUFBekIsQ0F6QlI7a0JBMEJHTCxPQUFPeTFCLE9BQVAsQ0FBZXAxQixTQUFmLENBQXlCLFFBQXpCLENBMUJIO2VBMkJBTCxPQUFPb0MsV0EzQlA7eUJBNEJVc0MsT0FBTzY5Qix3QkFBUCxDQUFnQ3ZpQyxPQUFPb0MsV0FBUCxDQUFtQi9CLFNBQW5ELEVBQThELFdBQTlELENBNUJWO3FDQTZCc0JMLE9BQU9vQyxXQUFQLENBQW1CL0IsU0FBbkIsQ0FBNkIsdUJBQTdCO0NBN0JyQzs7QUNBQTs7Ozs7OztJQU9NKzBDOzs7O0FBRU4saUNBQWUsSUFBSUEsd0JBQUosRUFBZjs7QUNKQTs7O0FBR0EsdUJBQWUsVUFBU3RDLFNBQVQsRUFBb0I7U0FDMUIsYUFBUCxJQUF5QixZQUFXOzs7O2FBSXpCMXdDLFdBQVQsR0FBdUI7Ozs7O1VBS2YrakMsY0FBYyxLQUFLQSxXQUF6Qjs7VUFFTWdMLGFBQWEyQixVQUFVdUMsdUJBQVYsQ0FBa0NsUCxXQUFsQyxDQUFuQjtVQUNJLENBQUNnTCxVQUFMLEVBQWlCO2NBQ1QsSUFBSXJ1QyxLQUFKLENBQVUsZ0ZBQVYsQ0FBTjs7O1VBR0lxdkMsb0JBQW9CaEIsV0FBV2dCLGlCQUFyQzs7VUFFSUEsa0JBQWtCdHdDLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO1lBQzVCZCxXQUFVdTBDLE9BQU9DLHNCQUFQLENBQThCaDFDLElBQTlCLENBQW1DTCxRQUFuQyxFQUE2Q2l4QyxXQUFXMUIsU0FBeEQsQ0FBaEI7ZUFDTzdNLGNBQVAsQ0FBc0I3aEMsUUFBdEIsRUFBK0JvbEMsWUFBWTlsQyxTQUEzQztpQkFDUWl4QyxVQUFSLEdBQXFCQyxtQkFBUUMsTUFBN0I7aUJBQ1FjLGVBQVIsR0FBMEJuQixVQUExQjtrQkFDVUMsS0FBVixDQUFnQnJ3QyxRQUFoQjtlQUNPQSxRQUFQOzs7VUFHSXkwQyxZQUFZckQsa0JBQWtCdHdDLE1BQWxCLEdBQTJCLENBQTdDO1VBQ01kLFVBQVVveEMsa0JBQWtCcUQsU0FBbEIsQ0FBaEI7VUFDSXowQyxZQUFZcTBDLDBCQUFoQixFQUEwQztjQUNsQyxJQUFJdHlDLEtBQUosQ0FBVSwwR0FBVixDQUFOOzt3QkFFZ0IweUMsU0FBbEIsSUFBK0JKLDBCQUEvQjs7YUFFT3hTLGNBQVAsQ0FBc0I3aEMsT0FBdEIsRUFBK0JvbEMsWUFBWTlsQyxTQUEzQztnQkFDVSt3QyxLQUFWLDZCQUE2Q3J3QyxPQUE3Qzs7YUFFT0EsT0FBUDs7O2dCQUdVVixTQUFaLEdBQXdCaTFDLE9BQU9sekMsV0FBUCxDQUFtQi9CLFNBQTNDOztXQUVPK0IsV0FBUDtHQTFDc0IsRUFBeEI7OztBQ0VGOzs7OztBQUtBLHNCQUFlLFVBQVMwd0MsU0FBVCxFQUFvQmxDLFdBQXBCLEVBQWlDNkUsT0FBakMsRUFBMEM7Ozs7Y0FJM0MsU0FBWixJQUF5QixZQUFtQjtzQ0FBUEMsS0FBTztXQUFBOzs7O1FBRXBDQyw4Q0FBZ0RELE1BQU05bEMsTUFBTixDQUFhLGdCQUFROzthQUVsRStDLGdCQUFnQmtELElBQWhCLElBQXdCNDdCLFdBQUEsQ0FBc0I5K0IsSUFBdEIsQ0FBL0I7S0FGb0QsQ0FBdEQ7O1lBS1FpakMsT0FBUixDQUFnQjFqQyxLQUFoQixDQUFzQixJQUF0QixFQUE0QndqQyxLQUE1Qjs7U0FFSyxJQUFJOXpDLElBQUksQ0FBYixFQUFnQkEsSUFBSSt6QyxnQkFBZ0I5ekMsTUFBcEMsRUFBNENELEdBQTVDLEVBQWlEO2dCQUNyQ2kwQyxjQUFWLENBQXlCRixnQkFBZ0IvekMsQ0FBaEIsQ0FBekI7OztRQUdFNnZDLFdBQUEsQ0FBc0IsSUFBdEIsQ0FBSixFQUFpQztXQUMxQixJQUFJN3ZDLEtBQUksQ0FBYixFQUFnQkEsS0FBSTh6QyxNQUFNN3pDLE1BQTFCLEVBQWtDRCxJQUFsQyxFQUF1QztZQUMvQitRLE9BQU8raUMsTUFBTTl6QyxFQUFOLENBQWI7WUFDSStRLGdCQUFnQjhpQixPQUFwQixFQUE2QjtvQkFDakJxZ0IsV0FBVixDQUFzQm5qQyxJQUF0Qjs7OztHQWpCUjs7Ozs7Y0EwQlksUUFBWixJQUF3QixZQUFtQjt1Q0FBUCtpQyxLQUFPO1dBQUE7Ozs7UUFFbkNDLDhDQUFnREQsTUFBTTlsQyxNQUFOLENBQWEsZ0JBQVE7O2FBRWxFK0MsZ0JBQWdCa0QsSUFBaEIsSUFBd0I0N0IsV0FBQSxDQUFzQjkrQixJQUF0QixDQUEvQjtLQUZvRCxDQUF0RDs7WUFLUXdsQixNQUFSLENBQWVqbUIsS0FBZixDQUFxQixJQUFyQixFQUEyQndqQyxLQUEzQjs7U0FFSyxJQUFJOXpDLElBQUksQ0FBYixFQUFnQkEsSUFBSSt6QyxnQkFBZ0I5ekMsTUFBcEMsRUFBNENELEdBQTVDLEVBQWlEO2dCQUNyQ2kwQyxjQUFWLENBQXlCRixnQkFBZ0IvekMsQ0FBaEIsQ0FBekI7OztRQUdFNnZDLFdBQUEsQ0FBc0IsSUFBdEIsQ0FBSixFQUFpQztXQUMxQixJQUFJN3ZDLE1BQUksQ0FBYixFQUFnQkEsTUFBSTh6QyxNQUFNN3pDLE1BQTFCLEVBQWtDRCxLQUFsQyxFQUF1QztZQUMvQitRLE9BQU8raUMsTUFBTTl6QyxHQUFOLENBQWI7WUFDSStRLGdCQUFnQjhpQixPQUFwQixFQUE2QjtvQkFDakJxZ0IsV0FBVixDQUFzQm5qQyxJQUF0Qjs7OztHQWpCUjs7O0FDeENGOzs7QUFHQSxvQkFBZSxVQUFTbWdDLFNBQVQsRUFBb0I7c0JBQ2pDLENBQStCL0MsU0FBUzF2QyxTQUF4QyxFQUFtRCxlQUFuRDs7Ozs7O1lBTVdvdkMsU0FBVCxFQUFvQjs7UUFFZCxLQUFLcUMsZ0JBQVQsRUFBMkI7VUFDbkJYLGFBQWEyQixVQUFVWixxQkFBVixDQUFnQ3pDLFNBQWhDLENBQW5CO1VBQ0kwQixVQUFKLEVBQWdCO2VBQ1AsSUFBS0EsV0FBV2hMLFdBQWhCLEVBQVA7Ozs7UUFJRXZqQztXQUNJMnlDLHNCQUFQLENBQThCaDFDLElBQTlCLENBQW1DLElBQW5DLEVBQXlDa3ZDLFNBQXpDLENBREg7Y0FFVTJCLEtBQVYsQ0FBZ0J4dUMsTUFBaEI7V0FDT0EsTUFBUDtHQWxCSjs7c0JBcUJBLENBQStCbXRDLFNBQVMxdkMsU0FBeEMsRUFBbUQsWUFBbkQ7Ozs7Ozs7WUFPV3NTLElBQVQsRUFBZWdRLElBQWYsRUFBcUI7UUFDYm96QixRQUFRVCxPQUFPVSxtQkFBUCxDQUEyQnoxQyxJQUEzQixDQUFnQyxJQUFoQyxFQUFzQ29TLElBQXRDLEVBQTRDZ1EsSUFBNUMsQ0FBZDs7UUFFSSxDQUFDLEtBQUttdkIsZ0JBQVYsRUFBNEI7Z0JBQ2hCbUUsU0FBVixDQUFvQkYsS0FBcEI7S0FERixNQUVPO2dCQUNLL0QsbUJBQVYsQ0FBOEIrRCxLQUE5Qjs7V0FFS0EsS0FBUDtHQWZKOztNQWtCTUcsVUFBVSw4QkFBaEI7O3NCQUVBLENBQStCbkcsU0FBUzF2QyxTQUF4QyxFQUFtRCxpQkFBbkQ7Ozs7Ozs7WUFPV3V5QyxTQUFULEVBQW9CbkQsU0FBcEIsRUFBK0I7O1FBRXpCLEtBQUtxQyxnQkFBTCxLQUEwQmMsY0FBYyxJQUFkLElBQXNCQSxjQUFjc0QsT0FBOUQsQ0FBSixFQUE0RTtVQUNwRS9FLGFBQWEyQixVQUFVWixxQkFBVixDQUFnQ3pDLFNBQWhDLENBQW5CO1VBQ0kwQixVQUFKLEVBQWdCO2VBQ1AsSUFBS0EsV0FBV2hMLFdBQWhCLEVBQVA7Ozs7UUFJRXZqQztXQUNJdXpDLHdCQUFQLENBQWdDNTFDLElBQWhDLENBQXFDLElBQXJDLEVBQTJDcXlDLFNBQTNDLEVBQXNEbkQsU0FBdEQsQ0FESDtjQUVVMkIsS0FBVixDQUFnQnh1QyxNQUFoQjtXQUNPQSxNQUFQO0dBbkJKOztrQkFzQmdCa3dDLFNBQWhCLEVBQTJCL0MsU0FBUzF2QyxTQUFwQyxFQUErQzthQUNwQ2kxQyxPQUFPYyxnQkFENkI7WUFFckNkLE9BQU9lO0dBRmpCOzs7QUNyRUY7OztBQUdBLGdCQUFlLFVBQVN2RCxTQUFULEVBQW9COzs7O3NCQUlqQyxDQUErQmo5QixLQUFLeFYsU0FBcEMsRUFBK0MsY0FBL0M7Ozs7Ozs7WUFPV3NTLElBQVQsRUFBZTJqQyxPQUFmLEVBQXdCO1FBQ2xCM2pDLGdCQUFnQi9JLGdCQUFwQixFQUFzQztVQUM5QjJzQyxnQkFBZ0JuMkMsTUFBTUMsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0I0UixLQUF0QixDQUE0QlMsS0FBS2dELFVBQWpDLENBQXRCO1VBQ002Z0MsZ0JBQWVsQixPQUFPbUIsaUJBQVAsQ0FBeUJsMkMsSUFBekIsQ0FBOEIsSUFBOUIsRUFBb0NvUyxJQUFwQyxFQUEwQzJqQyxPQUExQyxDQUFyQjs7Ozs7VUFLSTdFLFdBQUEsQ0FBc0IsSUFBdEIsQ0FBSixFQUFpQzthQUMxQixJQUFJN3ZDLElBQUksQ0FBYixFQUFnQkEsSUFBSTIwQyxjQUFjMTBDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztvQkFDbkNrMEMsV0FBVixDQUFzQlMsY0FBYzMwQyxDQUFkLENBQXRCOzs7O2FBSUc0MEMsYUFBUDs7O1FBR0lFLG1CQUFtQmpGLFdBQUEsQ0FBc0I5K0IsSUFBdEIsQ0FBekI7UUFDTTZqQyxlQUFlbEIsT0FBT21CLGlCQUFQLENBQXlCbDJDLElBQXpCLENBQThCLElBQTlCLEVBQW9Db1MsSUFBcEMsRUFBMEMyakMsT0FBMUMsQ0FBckI7O1FBRUlJLGdCQUFKLEVBQXNCO2dCQUNWYixjQUFWLENBQXlCbGpDLElBQXpCOzs7UUFHRTgrQixXQUFBLENBQXNCLElBQXRCLENBQUosRUFBaUM7Z0JBQ3JCcUUsV0FBVixDQUFzQm5qQyxJQUF0Qjs7O1dBR0s2akMsWUFBUDtHQW5DSjs7c0JBc0NBLENBQStCM2dDLEtBQUt4VixTQUFwQyxFQUErQyxhQUEvQzs7Ozs7O1lBTVdzUyxJQUFULEVBQWU7UUFDVEEsZ0JBQWdCL0ksZ0JBQXBCLEVBQXNDO1VBQzlCMnNDLGdCQUFnQm4yQyxNQUFNQyxTQUFOLENBQWdCQyxLQUFoQixDQUFzQjRSLEtBQXRCLENBQTRCUyxLQUFLZ0QsVUFBakMsQ0FBdEI7VUFDTTZnQyxpQkFBZWxCLE9BQU9xQixnQkFBUCxDQUF3QnAyQyxJQUF4QixDQUE2QixJQUE3QixFQUFtQ29TLElBQW5DLENBQXJCOzs7OztVQUtJOCtCLFdBQUEsQ0FBc0IsSUFBdEIsQ0FBSixFQUFpQzthQUMxQixJQUFJN3ZDLElBQUksQ0FBYixFQUFnQkEsSUFBSTIwQyxjQUFjMTBDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztvQkFDbkNrMEMsV0FBVixDQUFzQlMsY0FBYzMwQyxDQUFkLENBQXRCOzs7O2FBSUc0MEMsY0FBUDs7O1FBR0lFLG1CQUFtQmpGLFdBQUEsQ0FBc0I5K0IsSUFBdEIsQ0FBekI7UUFDTTZqQyxlQUFlbEIsT0FBT3FCLGdCQUFQLENBQXdCcDJDLElBQXhCLENBQTZCLElBQTdCLEVBQW1Db1MsSUFBbkMsQ0FBckI7O1FBRUkrakMsZ0JBQUosRUFBc0I7Z0JBQ1ZiLGNBQVYsQ0FBeUJsakMsSUFBekI7OztRQUdFOCtCLFdBQUEsQ0FBc0IsSUFBdEIsQ0FBSixFQUFpQztnQkFDckJxRSxXQUFWLENBQXNCbmpDLElBQXRCOzs7V0FHSzZqQyxZQUFQO0dBbENKOztzQkFxQ0EsQ0FBK0IzZ0MsS0FBS3hWLFNBQXBDLEVBQStDLFdBQS9DOzs7Ozs7WUFNV3NpQixJQUFULEVBQWU7UUFDUG96QixRQUFRVCxPQUFPc0IsY0FBUCxDQUFzQnIyQyxJQUF0QixDQUEyQixJQUEzQixFQUFpQ29pQixJQUFqQyxDQUFkOzs7UUFHSSxDQUFDLEtBQUtrMEIsYUFBTCxDQUFtQi9FLGdCQUF4QixFQUEwQztnQkFDOUJtRSxTQUFWLENBQW9CRixLQUFwQjtLQURGLE1BRU87Z0JBQ0svRCxtQkFBVixDQUE4QitELEtBQTlCOztXQUVLQSxLQUFQO0dBZko7O3NCQWtCQSxDQUErQmxnQyxLQUFLeFYsU0FBcEMsRUFBK0MsYUFBL0M7Ozs7OztZQU1Xc1MsSUFBVCxFQUFlO1FBQ1ArakMsbUJBQW1CakYsV0FBQSxDQUFzQjkrQixJQUF0QixDQUF6QjtRQUNNNmpDLGVBQWVsQixPQUFPd0IsZ0JBQVAsQ0FBd0J2MkMsSUFBeEIsQ0FBNkIsSUFBN0IsRUFBbUNvUyxJQUFuQyxDQUFyQjs7UUFFSStqQyxnQkFBSixFQUFzQjtnQkFDVmIsY0FBVixDQUF5QmxqQyxJQUF6Qjs7O1dBR0s2akMsWUFBUDtHQWRKOztzQkFpQkEsQ0FBK0IzZ0MsS0FBS3hWLFNBQXBDLEVBQStDLGNBQS9DOzs7Ozs7O1lBT1cwMkMsWUFBVCxFQUF1QkMsWUFBdkIsRUFBcUM7UUFDL0JELHdCQUF3Qm50QyxnQkFBNUIsRUFBOEM7VUFDdEMyc0MsZ0JBQWdCbjJDLE1BQU1DLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQXNCNFIsS0FBdEIsQ0FBNEI2a0MsYUFBYXBoQyxVQUF6QyxDQUF0QjtVQUNNNmdDLGlCQUFlbEIsT0FBTzJCLGlCQUFQLENBQXlCMTJDLElBQXpCLENBQThCLElBQTlCLEVBQW9DdzJDLFlBQXBDLEVBQWtEQyxZQUFsRCxDQUFyQjs7Ozs7VUFLSXZGLFdBQUEsQ0FBc0IsSUFBdEIsQ0FBSixFQUFpQztrQkFDckJvRSxjQUFWLENBQXlCbUIsWUFBekI7YUFDSyxJQUFJcDFDLElBQUksQ0FBYixFQUFnQkEsSUFBSTIwQyxjQUFjMTBDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztvQkFDbkNrMEMsV0FBVixDQUFzQlMsY0FBYzMwQyxDQUFkLENBQXRCOzs7O2FBSUc0MEMsY0FBUDs7O1FBR0lVLDJCQUEyQnpGLFdBQUEsQ0FBc0JzRixZQUF0QixDQUFqQztRQUNNUCxlQUFlbEIsT0FBTzJCLGlCQUFQLENBQXlCMTJDLElBQXpCLENBQThCLElBQTlCLEVBQW9DdzJDLFlBQXBDLEVBQWtEQyxZQUFsRCxDQUFyQjtRQUNNRyxrQkFBa0IxRixXQUFBLENBQXNCLElBQXRCLENBQXhCOztRQUVJMEYsZUFBSixFQUFxQjtnQkFDVHRCLGNBQVYsQ0FBeUJtQixZQUF6Qjs7O1FBR0VFLHdCQUFKLEVBQThCO2dCQUNsQnJCLGNBQVYsQ0FBeUJrQixZQUF6Qjs7O1FBR0VJLGVBQUosRUFBcUI7Z0JBQ1RyQixXQUFWLENBQXNCaUIsWUFBdEI7OztXQUdLUCxZQUFQO0dBekNKOztXQTZDU1ksaUJBQVQsQ0FBMkJ4RyxXQUEzQixFQUF3Q3lHLGNBQXhDLEVBQXdEO1dBQy9DcmlDLGNBQVAsQ0FBc0I0N0IsV0FBdEIsRUFBbUMsYUFBbkMsRUFBa0Q7a0JBQ3BDeUcsZUFBZUMsVUFEcUI7b0JBRWxDLElBRmtDO1dBRzNDRCxlQUFlMXRDLEdBSDRCOzhCQUl2QixhQUFTNHRDLGFBQVQsRUFBd0I7O1lBRTNDLEtBQUszaEMsUUFBTCxLQUFrQkMsS0FBSzJtQixTQUEzQixFQUFzQzt5QkFDckIzekIsR0FBZixDQUFtQnRJLElBQW5CLENBQXdCLElBQXhCLEVBQThCZzNDLGFBQTlCOzs7O1lBSUVDLGVBQWV6bUMsU0FBbkI7OztZQUdJLEtBQUtpSixVQUFULEVBQXFCOzs7Y0FHYnJFLGFBQWEsS0FBS0EsVUFBeEI7Y0FDTThoQyxtQkFBbUI5aEMsV0FBVzlULE1BQXBDO2NBQ0k0MUMsbUJBQW1CLENBQW5CLElBQXdCaEcsV0FBQSxDQUFzQixJQUF0QixDQUE1QixFQUF5RDs7MkJBRXhDLElBQUlyeEMsS0FBSixDQUFVcTNDLGdCQUFWLENBQWY7aUJBQ0ssSUFBSTcxQyxJQUFJLENBQWIsRUFBZ0JBLElBQUk2MUMsZ0JBQXBCLEVBQXNDNzFDLEdBQXRDLEVBQTJDOzJCQUM1QkEsQ0FBYixJQUFrQitULFdBQVcvVCxDQUFYLENBQWxCOzs7Ozt1QkFLU2lILEdBQWYsQ0FBbUJ0SSxJQUFuQixDQUF3QixJQUF4QixFQUE4QmczQyxhQUE5Qjs7WUFFSUMsWUFBSixFQUFrQjtlQUNYLElBQUk1MUMsS0FBSSxDQUFiLEVBQWdCQSxLQUFJNDFDLGFBQWEzMUMsTUFBakMsRUFBeUNELElBQXpDLEVBQThDO3NCQUNsQ2kwQyxjQUFWLENBQXlCMkIsYUFBYTUxQyxFQUFiLENBQXpCOzs7O0tBaENSOzs7TUF1Q0UwekMsT0FBT29DLGdCQUFQLElBQTJCcEMsT0FBT29DLGdCQUFQLENBQXdCL3RDLEdBQXZELEVBQTREO3NCQUN4Q2tNLEtBQUt4VixTQUF2QixFQUFrQ2kxQyxPQUFPb0MsZ0JBQXpDO0dBREYsTUFFTztjQUNLQyxRQUFWLENBQW1CLFVBQVM1MkMsT0FBVCxFQUFrQjt3QkFDakJBLE9BQWxCLEVBQTJCO29CQUNiLElBRGE7c0JBRVgsSUFGVzs7O2dDQUtBLGVBQVc7O2NBRTVCNjJDLFFBQVEsRUFBZDs7ZUFFSyxJQUFJaDJDLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLK1QsVUFBTCxDQUFnQjlULE1BQXBDLEVBQTRDRCxHQUE1QyxFQUFpRDtrQkFDekNJLElBQU4sQ0FBVyxLQUFLMlQsVUFBTCxDQUFnQi9ULENBQWhCLEVBQW1CdUgsV0FBOUI7OztpQkFHS3l1QyxNQUFNcDNDLElBQU4sQ0FBVyxFQUFYLENBQVA7U0FidUI7Z0NBZUEsYUFBUysyQyxhQUFULEVBQXdCO2lCQUN4QyxLQUFLdjlCLFVBQVosRUFBd0I7bUJBQ2Y4OEIsZ0JBQVAsQ0FBd0J2MkMsSUFBeEIsQ0FBNkIsSUFBN0IsRUFBbUMsS0FBS3laLFVBQXhDOztpQkFFSzI4QixnQkFBUCxDQUF3QnAyQyxJQUF4QixDQUE2QixJQUE3QixFQUFtQ0wsU0FBUzBLLGNBQVQsQ0FBd0Iyc0MsYUFBeEIsQ0FBbkM7O09BbkJKO0tBREY7Ozs7QUNwTUo7Ozs7O0FBS0EscUJBQWUsVUFBU3pFLFNBQVQsRUFBb0JsQyxXQUFwQixFQUFpQzZFLE9BQWpDLEVBQTBDOzs7O2NBSTNDLFFBQVosSUFBd0IsWUFBbUI7c0NBQVBDLEtBQU87V0FBQTs7OztRQUVuQ0MsOENBQWdERCxNQUFNOWxDLE1BQU4sQ0FBYSxnQkFBUTs7YUFFbEUrQyxnQkFBZ0JrRCxJQUFoQixJQUF3QjQ3QixXQUFBLENBQXNCOStCLElBQXRCLENBQS9CO0tBRm9ELENBQXREOztZQUtRa2xDLE1BQVIsQ0FBZTNsQyxLQUFmLENBQXFCLElBQXJCLEVBQTJCd2pDLEtBQTNCOztTQUVLLElBQUk5ekMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJK3pDLGdCQUFnQjl6QyxNQUFwQyxFQUE0Q0QsR0FBNUMsRUFBaUQ7Z0JBQ3JDaTBDLGNBQVYsQ0FBeUJGLGdCQUFnQi96QyxDQUFoQixDQUF6Qjs7O1FBR0U2dkMsV0FBQSxDQUFzQixJQUF0QixDQUFKLEVBQWlDO1dBQzFCLElBQUk3dkMsS0FBSSxDQUFiLEVBQWdCQSxLQUFJOHpDLE1BQU03ekMsTUFBMUIsRUFBa0NELElBQWxDLEVBQXVDO1lBQy9CK1EsT0FBTytpQyxNQUFNOXpDLEVBQU4sQ0FBYjtZQUNJK1EsZ0JBQWdCOGlCLE9BQXBCLEVBQTZCO29CQUNqQnFnQixXQUFWLENBQXNCbmpDLElBQXRCOzs7O0dBakJSOzs7OztjQTBCWSxPQUFaLElBQXVCLFlBQW1CO3VDQUFQK2lDLEtBQU87V0FBQTs7OztRQUVsQ0MsOENBQWdERCxNQUFNOWxDLE1BQU4sQ0FBYSxnQkFBUTs7YUFFbEUrQyxnQkFBZ0JrRCxJQUFoQixJQUF3QjQ3QixXQUFBLENBQXNCOStCLElBQXRCLENBQS9CO0tBRm9ELENBQXREOztZQUtRdWpCLEtBQVIsQ0FBY2hrQixLQUFkLENBQW9CLElBQXBCLEVBQTBCd2pDLEtBQTFCOztTQUVLLElBQUk5ekMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJK3pDLGdCQUFnQjl6QyxNQUFwQyxFQUE0Q0QsR0FBNUMsRUFBaUQ7Z0JBQ3JDaTBDLGNBQVYsQ0FBeUJGLGdCQUFnQi96QyxDQUFoQixDQUF6Qjs7O1FBR0U2dkMsV0FBQSxDQUFzQixJQUF0QixDQUFKLEVBQWlDO1dBQzFCLElBQUk3dkMsTUFBSSxDQUFiLEVBQWdCQSxNQUFJOHpDLE1BQU03ekMsTUFBMUIsRUFBa0NELEtBQWxDLEVBQXVDO1lBQy9CK1EsT0FBTytpQyxNQUFNOXpDLEdBQU4sQ0FBYjtZQUNJK1EsZ0JBQWdCOGlCLE9BQXBCLEVBQTZCO29CQUNqQnFnQixXQUFWLENBQXNCbmpDLElBQXRCOzs7O0dBakJSOzs7OztjQTBCWSxhQUFaLElBQTZCLFlBQW1CO3VDQUFQK2lDLEtBQU87V0FBQTs7OztRQUV4Q0MsOENBQWdERCxNQUFNOWxDLE1BQU4sQ0FBYSxnQkFBUTs7YUFFbEUrQyxnQkFBZ0JrRCxJQUFoQixJQUF3QjQ3QixXQUFBLENBQXNCOStCLElBQXRCLENBQS9CO0tBRm9ELENBQXREOztRQUtNbWxDLGVBQWVyRyxXQUFBLENBQXNCLElBQXRCLENBQXJCOztZQUVRc0csV0FBUixDQUFvQjdsQyxLQUFwQixDQUEwQixJQUExQixFQUFnQ3dqQyxLQUFoQzs7U0FFSyxJQUFJOXpDLElBQUksQ0FBYixFQUFnQkEsSUFBSSt6QyxnQkFBZ0I5ekMsTUFBcEMsRUFBNENELEdBQTVDLEVBQWlEO2dCQUNyQ2kwQyxjQUFWLENBQXlCRixnQkFBZ0IvekMsQ0FBaEIsQ0FBekI7OztRQUdFazJDLFlBQUosRUFBa0I7Z0JBQ05qQyxjQUFWLENBQXlCLElBQXpCO1dBQ0ssSUFBSWowQyxNQUFJLENBQWIsRUFBZ0JBLE1BQUk4ekMsTUFBTTd6QyxNQUExQixFQUFrQ0QsS0FBbEMsRUFBdUM7WUFDL0IrUSxPQUFPK2lDLE1BQU05ekMsR0FBTixDQUFiO1lBQ0krUSxnQkFBZ0I4aUIsT0FBcEIsRUFBNkI7b0JBQ2pCcWdCLFdBQVYsQ0FBc0JuakMsSUFBdEI7Ozs7R0FwQlI7O2NBMEJZLFFBQVosSUFBd0IsWUFBVztRQUMzQm1sQyxlQUFlckcsV0FBQSxDQUFzQixJQUF0QixDQUFyQjs7WUFFUWppQyxNQUFSLENBQWVqUCxJQUFmLENBQW9CLElBQXBCOztRQUVJdTNDLFlBQUosRUFBa0I7Z0JBQ05qQyxjQUFWLENBQXlCLElBQXpCOztHQU5KOzs7QUM1RkY7OztBQUdBLG1CQUFlLFVBQVMvQyxTQUFULEVBQW9CO01BQzdCd0MsT0FBTzBDLG9CQUFYLEVBQWlDO3dCQUMvQixDQUErQnZpQixRQUFRcDFCLFNBQXZDLEVBQWtELGNBQWxEOzs7Ozs7Y0FNVzQzQyxJQUFULEVBQWU7VUFDUHhILGFBQWE2RSxPQUFPMEMsb0JBQVAsQ0FBNEJ6M0MsSUFBNUIsQ0FBaUMsSUFBakMsRUFBdUMwM0MsSUFBdkMsQ0FBbkI7V0FDS3ZILGVBQUwsR0FBdUJELFVBQXZCO2FBQ09BLFVBQVA7S0FUSjtHQURGLE1BWU87WUFDR3J2QyxJQUFSLENBQWEsMERBQWI7OztXQUlPODJDLGVBQVQsQ0FBeUJ0SCxXQUF6QixFQUFzQ3lHLGNBQXRDLEVBQXNEO1dBQzdDcmlDLGNBQVAsQ0FBc0I0N0IsV0FBdEIsRUFBbUMsV0FBbkMsRUFBZ0Q7a0JBQ2xDeUcsZUFBZUMsVUFEbUI7b0JBRWhDLElBRmdDO1dBR3pDRCxlQUFlMXRDLEdBSDBCO2lDQUlsQixhQUFTd3VDLFVBQVQsRUFBcUI7OztZQUN6Q3ZJLGlCQUFjNkIsV0FBQSxDQUFzQixJQUF0QixDQUFwQjs7Ozs7Ozs7WUFRSTJHLGtCQUFrQnJuQyxTQUF0QjtZQUNJNitCLGNBQUosRUFBaUI7NEJBQ0csRUFBbEI7b0NBQ0EsQ0FBcUMsSUFBckMsRUFBMkMsbUJBQVc7Z0JBQ2hEN3VDLGlCQUFKLEVBQXNCOzhCQUNKaUIsSUFBaEIsQ0FBcUJqQixPQUFyQjs7V0FGSjs7O3VCQU9hOEgsR0FBZixDQUFtQnRJLElBQW5CLENBQXdCLElBQXhCLEVBQThCNDNDLFVBQTlCOztZQUVJQyxlQUFKLEVBQXFCO2VBQ2QsSUFBSXgyQyxJQUFJLENBQWIsRUFBZ0JBLElBQUl3MkMsZ0JBQWdCdjJDLE1BQXBDLEVBQTRDRCxHQUE1QyxFQUFpRDtnQkFDekNiLFVBQVVxM0MsZ0JBQWdCeDJDLENBQWhCLENBQWhCO2dCQUNJYixRQUFRdXdDLFVBQVIsS0FBdUJDLG1CQUFRQyxNQUFuQyxFQUEyQzt3QkFDL0JJLG9CQUFWLENBQStCN3dDLE9BQS9COzs7Ozs7O1lBT0YsQ0FBQyxLQUFLODFDLGFBQUwsQ0FBbUIvRSxnQkFBeEIsRUFBMEM7b0JBQzlCbUUsU0FBVixDQUFvQixJQUFwQjtTQURGLE1BRU87b0JBQ0tqRSxtQkFBVixDQUE4QixJQUE5Qjs7ZUFFS21HLFVBQVA7O0tBekNKOzs7TUE4Q0U3QyxPQUFPK0MsaUJBQVAsSUFBNEIvQyxPQUFPK0MsaUJBQVAsQ0FBeUIxdUMsR0FBekQsRUFBOEQ7b0JBQzVDOHJCLFFBQVFwMUIsU0FBeEIsRUFBbUNpMUMsT0FBTytDLGlCQUExQztHQURGLE1BRU8sSUFBSS9DLE9BQU9nRCxxQkFBUCxJQUFnQ2hELE9BQU9nRCxxQkFBUCxDQUE2QjN1QyxHQUFqRSxFQUFzRTtvQkFDM0R2SCxZQUFZL0IsU0FBNUIsRUFBdUNpMUMsT0FBT2dELHFCQUE5QztHQURLLE1BRUE7OztRQUdDQyxTQUFTakQsT0FBT0Msc0JBQVAsQ0FBOEJoMUMsSUFBOUIsQ0FBbUNMLFFBQW5DLEVBQTZDLEtBQTdDLENBQWY7O2NBRVV5M0MsUUFBVixDQUFtQixVQUFTNTJDLE9BQVQsRUFBa0I7c0JBQ25CQSxPQUFoQixFQUF5QjtvQkFDWCxJQURXO3NCQUVULElBRlM7Ozs7bUNBTUssZUFBVztpQkFDOUJ1MEMsT0FBT3NCLGNBQVAsQ0FBc0JyMkMsSUFBdEIsQ0FBMkIsSUFBM0IsRUFBaUMsSUFBakMsRUFBdUN1SyxTQUE5QztTQVBxQjs7OzttQ0FZSyxhQUFTeXNDLGFBQVQsRUFBd0I7Ozs7O2NBSzVDbnVDLFVBQVUsS0FBS3FtQyxTQUFMLEtBQW1CLFVBQW5CLHNDQUFzRSxJQUF0QyxDQUE2Q3JtQyxPQUE3RSxHQUF1RixJQUF2RztpQkFDTzBCLFNBQVAsR0FBbUJ5c0MsYUFBbkI7O2lCQUVPbnVDLFFBQVF1TSxVQUFSLENBQW1COVQsTUFBbkIsR0FBNEIsQ0FBbkMsRUFBc0M7bUJBQzdCaTFDLGdCQUFQLENBQXdCdjJDLElBQXhCLENBQTZCNkksT0FBN0IsRUFBc0NBLFFBQVF1TSxVQUFSLENBQW1CLENBQW5CLENBQXRDOztpQkFFSzRpQyxPQUFPNWlDLFVBQVAsQ0FBa0I5VCxNQUFsQixHQUEyQixDQUFsQyxFQUFxQzttQkFDNUI4MEMsZ0JBQVAsQ0FBd0JwMkMsSUFBeEIsQ0FBNkI2SSxPQUE3QixFQUFzQ212QyxPQUFPNWlDLFVBQVAsQ0FBa0IsQ0FBbEIsQ0FBdEM7OztPQXhCTjtLQURGOzs7c0JBaUNGLENBQStCOGYsUUFBUXAxQixTQUF2QyxFQUFrRCxjQUFsRDs7Ozs7O1lBTVdNLElBQVQsRUFBZWd5QyxRQUFmLEVBQXlCOztRQUVuQixLQUFLckIsVUFBTCxLQUFvQkMsbUJBQVFDLE1BQWhDLEVBQXdDO2FBQy9COEQsT0FBT2tELG9CQUFQLENBQTRCajRDLElBQTVCLENBQWlDLElBQWpDLEVBQXVDSSxJQUF2QyxFQUE2Q2d5QyxRQUE3QyxDQUFQOzs7UUFHSUQsV0FBVzRDLE9BQU9tRCxvQkFBUCxDQUE0Qmw0QyxJQUE1QixDQUFpQyxJQUFqQyxFQUF1Q0ksSUFBdkMsQ0FBakI7V0FDTzYzQyxvQkFBUCxDQUE0Qmo0QyxJQUE1QixDQUFpQyxJQUFqQyxFQUF1Q0ksSUFBdkMsRUFBNkNneUMsUUFBN0M7ZUFDVzJDLE9BQU9tRCxvQkFBUCxDQUE0Qmw0QyxJQUE1QixDQUFpQyxJQUFqQyxFQUF1Q0ksSUFBdkMsQ0FBWDtjQUNVNHhDLHdCQUFWLENBQW1DLElBQW5DLEVBQXlDNXhDLElBQXpDLEVBQStDK3hDLFFBQS9DLEVBQXlEQyxRQUF6RCxFQUFtRSxJQUFuRTtHQWZKOztzQkFrQkEsQ0FBK0JsZCxRQUFRcDFCLFNBQXZDLEVBQWtELGdCQUFsRDs7Ozs7OztZQU9XdXlDLFNBQVQsRUFBb0JqeUMsSUFBcEIsRUFBMEJneUMsUUFBMUIsRUFBb0M7O1FBRTlCLEtBQUtyQixVQUFMLEtBQW9CQyxtQkFBUUMsTUFBaEMsRUFBd0M7YUFDL0I4RCxPQUFPb0Qsc0JBQVAsQ0FBOEJuNEMsSUFBOUIsQ0FBbUMsSUFBbkMsRUFBeUNxeUMsU0FBekMsRUFBb0RqeUMsSUFBcEQsRUFBMERneUMsUUFBMUQsQ0FBUDs7O1FBR0lELFdBQVc0QyxPQUFPcUQsc0JBQVAsQ0FBOEJwNEMsSUFBOUIsQ0FBbUMsSUFBbkMsRUFBeUNxeUMsU0FBekMsRUFBb0RqeUMsSUFBcEQsQ0FBakI7V0FDTyszQyxzQkFBUCxDQUE4Qm40QyxJQUE5QixDQUFtQyxJQUFuQyxFQUF5Q3F5QyxTQUF6QyxFQUFvRGp5QyxJQUFwRCxFQUEwRGd5QyxRQUExRDtlQUNXMkMsT0FBT3FELHNCQUFQLENBQThCcDRDLElBQTlCLENBQW1DLElBQW5DLEVBQXlDcXlDLFNBQXpDLEVBQW9EanlDLElBQXBELENBQVg7Y0FDVTR4Qyx3QkFBVixDQUFtQyxJQUFuQyxFQUF5QzV4QyxJQUF6QyxFQUErQyt4QyxRQUEvQyxFQUF5REMsUUFBekQsRUFBbUVDLFNBQW5FO0dBaEJKOztzQkFtQkEsQ0FBK0JuZCxRQUFRcDFCLFNBQXZDLEVBQWtELGlCQUFsRDs7Ozs7WUFLV00sSUFBVCxFQUFlOztRQUVULEtBQUsyd0MsVUFBTCxLQUFvQkMsbUJBQVFDLE1BQWhDLEVBQXdDO2FBQy9COEQsT0FBT3NELHVCQUFQLENBQStCcjRDLElBQS9CLENBQW9DLElBQXBDLEVBQTBDSSxJQUExQyxDQUFQOzs7UUFHSSt4QyxXQUFXNEMsT0FBT21ELG9CQUFQLENBQTRCbDRDLElBQTVCLENBQWlDLElBQWpDLEVBQXVDSSxJQUF2QyxDQUFqQjtXQUNPaTRDLHVCQUFQLENBQStCcjRDLElBQS9CLENBQW9DLElBQXBDLEVBQTBDSSxJQUExQztRQUNJK3hDLGFBQWEsSUFBakIsRUFBdUI7Z0JBQ1hILHdCQUFWLENBQW1DLElBQW5DLEVBQXlDNXhDLElBQXpDLEVBQStDK3hDLFFBQS9DLEVBQXlELElBQXpELEVBQStELElBQS9EOztHQWROOztzQkFrQkEsQ0FBK0JqZCxRQUFRcDFCLFNBQXZDLEVBQWtELG1CQUFsRDs7Ozs7O1lBTVd1eUMsU0FBVCxFQUFvQmp5QyxJQUFwQixFQUEwQjs7UUFFcEIsS0FBSzJ3QyxVQUFMLEtBQW9CQyxtQkFBUUMsTUFBaEMsRUFBd0M7YUFDL0I4RCxPQUFPdUQseUJBQVAsQ0FBaUN0NEMsSUFBakMsQ0FBc0MsSUFBdEMsRUFBNENxeUMsU0FBNUMsRUFBdURqeUMsSUFBdkQsQ0FBUDs7O1FBR0kreEMsV0FBVzRDLE9BQU9xRCxzQkFBUCxDQUE4QnA0QyxJQUE5QixDQUFtQyxJQUFuQyxFQUF5Q3F5QyxTQUF6QyxFQUFvRGp5QyxJQUFwRCxDQUFqQjtXQUNPazRDLHlCQUFQLENBQWlDdDRDLElBQWpDLENBQXNDLElBQXRDLEVBQTRDcXlDLFNBQTVDLEVBQXVEanlDLElBQXZEOzs7O1FBSU1neUMsV0FBVzJDLE9BQU9xRCxzQkFBUCxDQUE4QnA0QyxJQUE5QixDQUFtQyxJQUFuQyxFQUF5Q3F5QyxTQUF6QyxFQUFvRGp5QyxJQUFwRCxDQUFqQjtRQUNJK3hDLGFBQWFDLFFBQWpCLEVBQTJCO2dCQUNmSix3QkFBVixDQUFtQyxJQUFuQyxFQUF5QzV4QyxJQUF6QyxFQUErQyt4QyxRQUEvQyxFQUF5REMsUUFBekQsRUFBbUVDLFNBQW5FOztHQW5CTjs7V0F3QlNrRywyQkFBVCxDQUFxQ2xJLFdBQXJDLEVBQWtEbUksVUFBbEQsRUFBOEQ7d0JBQzVELENBQStCbkksV0FBL0IsRUFBNEMsdUJBQTVDOzs7Ozs7O2NBT1dvSSxLQUFULEVBQWdCajRDLE9BQWhCLEVBQXlCO1VBQ2pCKzJDLGVBQWVyRyxXQUFBLENBQXNCMXdDLE9BQXRCLENBQXJCO1VBQ01rNEM7aUJBQ1ExNEMsSUFBWCxDQUFnQixJQUFoQixFQUFzQnk0QyxLQUF0QixFQUE2Qmo0QyxPQUE3QixDQURIOztVQUdJKzJDLFlBQUosRUFBa0I7a0JBQ05qQyxjQUFWLENBQXlCOTBDLE9BQXpCOzs7VUFHRTB3QyxXQUFBLENBQXNCd0gsZUFBdEIsQ0FBSixFQUE0QztrQkFDaENuRCxXQUFWLENBQXNCLzBDLE9BQXRCOzthQUVLazRDLGVBQVA7S0FuQko7OztNQXVCRTNELE9BQU80RCxpQ0FBWCxFQUE4QztnQ0FDaEI5MkMsWUFBWS9CLFNBQXhDLEVBQW1EaTFDLE9BQU80RCxpQ0FBMUQ7R0FERixNQUVPLElBQUk1RCxPQUFPNkQsNkJBQVgsRUFBMEM7Z0NBQ25CMWpCLFFBQVFwMUIsU0FBcEMsRUFBK0NpMUMsT0FBTzZELDZCQUF0RDtHQURLLE1BRUE7WUFDRy8zQyxJQUFSLENBQWEsbUVBQWI7OztrQkFJYzB4QyxTQUFoQixFQUEyQnJkLFFBQVFwMUIsU0FBbkMsRUFBOEM7YUFDbkNpMUMsT0FBTzhELGVBRDRCO1lBRXBDOUQsT0FBTytEO0dBRmpCOztpQkFLZXZHLFNBQWYsRUFBMEJyZCxRQUFRcDFCLFNBQWxDLEVBQTZDO1lBQ25DaTFDLE9BQU9nRSxjQUQ0QjtXQUVwQ2hFLE9BQU9pRSxhQUY2QjtpQkFHOUJqRSxPQUFPa0UsbUJBSHVCO1lBSW5DbEUsT0FBT21FO0dBSmpCOzs7QUMzT0Y7Ozs7Ozs7Ozs7QUFVQSxBQVFBLElBQU1DLHNCQUFzQjE1QyxPQUFPLGdCQUFQLENBQTVCOztBQUVBLElBQUksQ0FBQzA1QyxtQkFBRCxJQUNDQSxvQkFBb0IsZUFBcEIsQ0FERCxJQUVFLE9BQU9BLG9CQUFvQixRQUFwQixDQUFQLElBQXdDLFVBRjFDLElBR0UsT0FBT0Esb0JBQW9CLEtBQXBCLENBQVAsSUFBcUMsVUFIM0MsRUFHd0Q7O01BRWhENUcsWUFBWSxJQUFJaEMsc0JBQUosRUFBbEI7O21CQUVpQmdDLFNBQWpCO2dCQUNjQSxTQUFkO1lBQ1VBLFNBQVY7ZUFDYUEsU0FBYjs7O1dBR1NoQixnQkFBVCxHQUE0QixJQUE1Qjs7O01BR01uVCxtQkFBaUIsSUFBSWdWLHFCQUFKLENBQTBCYixTQUExQixDQUF2Qjs7U0FFTzk5QixjQUFQLENBQXNCaFYsTUFBdEIsRUFBOEIsZ0JBQTlCLEVBQWdEO2tCQUNoQyxJQURnQztnQkFFbEMsSUFGa0M7V0FHdkMyK0I7R0FIVDs7O0FDdENGOzs7Ozs7Ozs7OztBQVdBLENBQUMsVUFBU0UsTUFBVCxFQUFpQjtNQUNaQSxPQUFPOGEsa0JBQVgsRUFBK0I7OztNQUczQkMscUJBQXFCLElBQUl0ckIsT0FBSixFQUF6QjtNQUNJdXJCLFlBQUo7TUFDSSxlQUFlMzJDLElBQWYsQ0FBb0JDLFVBQVVDLFNBQTlCLENBQUosRUFBOEM7bUJBQzdCaWMsVUFBZjtHQURGLE1BRU8sSUFBSXJmLE9BQU82NUMsWUFBWCxFQUF5QjttQkFDZjc1QyxPQUFPNjVDLFlBQXRCO0dBREssTUFFQTtRQUNEQyxvQkFBb0IsRUFBeEI7UUFDSUMsV0FBV25aLE9BQU96bUIsS0FBS2ltQixNQUFMLEVBQVAsQ0FBZjtXQUNPcjRCLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLFVBQVNXLENBQVQsRUFBWTtVQUN6Q0EsRUFBRXFpQyxJQUFGLEtBQVdnUCxRQUFmLEVBQXlCO1lBQ25CdDdCLFFBQVFxN0IsaUJBQVo7NEJBQ29CLEVBQXBCO2NBQ001NEMsT0FBTixDQUFjLFVBQVM4NEMsSUFBVCxFQUFlOztTQUE3Qjs7S0FKSjttQkFTZSxzQkFBU0EsSUFBVCxFQUFlO3dCQUNWaDRDLElBQWxCLENBQXVCZzRDLElBQXZCO2FBQ09DLFdBQVAsQ0FBbUJGLFFBQW5CLEVBQTZCLEdBQTdCO0tBRkY7O01BS0VHLGNBQWMsS0FBbEI7TUFDSUMscUJBQXFCLEVBQXpCO1dBQ1NDLGdCQUFULENBQTBCN3JCLFFBQTFCLEVBQW9DO3VCQUNmdnNCLElBQW5CLENBQXdCdXNCLFFBQXhCO1FBQ0ksQ0FBQzJyQixXQUFMLEVBQWtCO29CQUNGLElBQWQ7bUJBQ2FHLGlCQUFiOzs7V0FHS0MsWUFBVCxDQUFzQjNuQyxJQUF0QixFQUE0QjtXQUNuQjNTLE9BQU91NkMsaUJBQVAsSUFBNEJ2NkMsT0FBT3U2QyxpQkFBUCxDQUF5QkQsWUFBekIsQ0FBc0MzbkMsSUFBdEMsQ0FBNUIsSUFBMkVBLElBQWxGOztXQUVPMG5DLGlCQUFULEdBQTZCO2tCQUNiLEtBQWQ7UUFDSUcsWUFBWUwsa0JBQWhCO3lCQUNxQixFQUFyQjtjQUNVcHdCLElBQVYsQ0FBZSxVQUFTMHdCLEVBQVQsRUFBYUMsRUFBYixFQUFpQjthQUN2QkQsR0FBR0UsSUFBSCxHQUFVRCxHQUFHQyxJQUFwQjtLQURGO1FBR0lDLGNBQWMsS0FBbEI7Y0FDVTE1QyxPQUFWLENBQWtCLFVBQVNxdEIsUUFBVCxFQUFtQjtVQUMvQjlQLFFBQVE4UCxTQUFTc3NCLFdBQVQsRUFBWjtrQ0FDNEJ0c0IsUUFBNUI7VUFDSTlQLE1BQU01YyxNQUFWLEVBQWtCO2lCQUNQaTVDLFNBQVQsQ0FBbUJyOEIsS0FBbkIsRUFBMEI4UCxRQUExQjtzQkFDYyxJQUFkOztLQUxKO1FBUUlxc0IsV0FBSixFQUFpQlA7O1dBRVZVLDJCQUFULENBQXFDeHNCLFFBQXJDLEVBQStDO2FBQ3BDeXNCLE1BQVQsQ0FBZ0I5NUMsT0FBaEIsQ0FBd0IsVUFBU3lSLElBQVQsRUFBZTtVQUNqQ3NvQyxnQkFBZ0JyQixtQkFBbUJqd0MsR0FBbkIsQ0FBdUJnSixJQUF2QixDQUFwQjtVQUNJLENBQUNzb0MsYUFBTCxFQUFvQjtvQkFDTi81QyxPQUFkLENBQXNCLFVBQVNnNkMsWUFBVCxFQUF1QjtZQUN2Q0EsYUFBYTNzQixRQUFiLEtBQTBCQSxRQUE5QixFQUF3QzJzQixhQUFhQyx3QkFBYjtPQUQxQztLQUhGOztXQVFPQyx1Q0FBVCxDQUFpRHp5QyxNQUFqRCxFQUF5RFgsUUFBekQsRUFBbUU7U0FDNUQsSUFBSTJLLE9BQU9oSyxNQUFoQixFQUF3QmdLLElBQXhCLEVBQThCQSxPQUFPQSxLQUFLNUgsVUFBMUMsRUFBc0Q7VUFDaERrd0MsZ0JBQWdCckIsbUJBQW1CandDLEdBQW5CLENBQXVCZ0osSUFBdkIsQ0FBcEI7VUFDSXNvQyxhQUFKLEVBQW1CO2FBQ1osSUFBSTlqQyxJQUFJLENBQWIsRUFBZ0JBLElBQUk4akMsY0FBY3A1QyxNQUFsQyxFQUEwQ3NWLEdBQTFDLEVBQStDO2NBQ3pDK2pDLGVBQWVELGNBQWM5akMsQ0FBZCxDQUFuQjtjQUNJOUssVUFBVTZ1QyxhQUFhN3VDLE9BQTNCO2NBQ0lzRyxTQUFTaEssTUFBVCxJQUFtQixDQUFDMEQsUUFBUWd2QyxPQUFoQyxFQUF5QztjQUNyQ0MsU0FBU3R6QyxTQUFTcUUsT0FBVCxDQUFiO2NBQ0lpdkMsTUFBSixFQUFZSixhQUFhSyxPQUFiLENBQXFCRCxNQUFyQjs7Ozs7TUFLaEJFLGFBQWEsQ0FBakI7V0FDUzdCLGtCQUFULENBQTRCM3hDLFFBQTVCLEVBQXNDO1NBQy9COHlDLFNBQUwsR0FBaUI5eUMsUUFBakI7U0FDS2d6QyxNQUFMLEdBQWMsRUFBZDtTQUNLUyxRQUFMLEdBQWdCLEVBQWhCO1NBQ0tkLElBQUwsR0FBWSxFQUFFYSxVQUFkOztxQkFFaUJuN0MsU0FBbkIsR0FBK0I7YUFDcEIsaUJBQVNzSSxNQUFULEVBQWlCMEQsT0FBakIsRUFBMEI7ZUFDeEJpdUMsYUFBYTN4QyxNQUFiLENBQVQ7VUFDSSxDQUFDMEQsUUFBUXFpQixTQUFULElBQXNCLENBQUNyaUIsUUFBUXF2QyxVQUEvQixJQUE2QyxDQUFDcnZDLFFBQVFzaUIsYUFBdEQsSUFBdUV0aUIsUUFBUXN2QyxpQkFBUixJQUE2QixDQUFDdHZDLFFBQVFxdkMsVUFBN0csSUFBMkhydkMsUUFBUXV2QyxlQUFSLElBQTJCdnZDLFFBQVF1dkMsZUFBUixDQUF3Qi81QyxNQUFuRCxJQUE2RCxDQUFDd0ssUUFBUXF2QyxVQUFqTSxJQUErTXJ2QyxRQUFRd3ZDLHFCQUFSLElBQWlDLENBQUN4dkMsUUFBUXNpQixhQUE3UCxFQUE0UTtjQUNwUSxJQUFJdWxCLFdBQUosRUFBTjs7VUFFRStHLGdCQUFnQnJCLG1CQUFtQmp3QyxHQUFuQixDQUF1QmhCLE1BQXZCLENBQXBCO1VBQ0ksQ0FBQ3N5QyxhQUFMLEVBQW9CckIsbUJBQW1CL3dDLEdBQW5CLENBQXVCRixNQUF2QixFQUErQnN5QyxnQkFBZ0IsRUFBL0M7VUFDaEJDLFlBQUo7V0FDSyxJQUFJdDVDLElBQUksQ0FBYixFQUFnQkEsSUFBSXE1QyxjQUFjcDVDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztZQUN6Q3E1QyxjQUFjcjVDLENBQWQsRUFBaUIyc0IsUUFBakIsS0FBOEIsSUFBbEMsRUFBd0M7eUJBQ3ZCMHNCLGNBQWNyNUMsQ0FBZCxDQUFmO3VCQUNhNmEsZUFBYjt1QkFDYXBRLE9BQWIsR0FBdUJBLE9BQXZCOzs7O1VBSUEsQ0FBQzZ1QyxZQUFMLEVBQW1CO3VCQUNGLElBQUlZLFlBQUosQ0FBaUIsSUFBakIsRUFBdUJuekMsTUFBdkIsRUFBK0IwRCxPQUEvQixDQUFmO3NCQUNjckssSUFBZCxDQUFtQms1QyxZQUFuQjthQUNLRixNQUFMLENBQVloNUMsSUFBWixDQUFpQjJHLE1BQWpCOzttQkFFV296QyxZQUFiO0tBdEIyQjtnQkF3QmpCLHNCQUFXO1dBQ2hCZixNQUFMLENBQVk5NUMsT0FBWixDQUFvQixVQUFTeVIsSUFBVCxFQUFlO1lBQzdCc29DLGdCQUFnQnJCLG1CQUFtQmp3QyxHQUFuQixDQUF1QmdKLElBQXZCLENBQXBCO2FBQ0ssSUFBSS9RLElBQUksQ0FBYixFQUFnQkEsSUFBSXE1QyxjQUFjcDVDLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztjQUN6Q3M1QyxlQUFlRCxjQUFjcjVDLENBQWQsQ0FBbkI7Y0FDSXM1QyxhQUFhM3NCLFFBQWIsS0FBMEIsSUFBOUIsRUFBb0M7eUJBQ3JCOVIsZUFBYjswQkFDY3JNLE1BQWQsQ0FBcUJ4TyxDQUFyQixFQUF3QixDQUF4Qjs7OztPQU5OLEVBVUcsSUFWSDtXQVdLNjVDLFFBQUwsR0FBZ0IsRUFBaEI7S0FwQzJCO2lCQXNDaEIsdUJBQVc7VUFDbEJPLGdCQUFnQixLQUFLUCxRQUF6QjtXQUNLQSxRQUFMLEdBQWdCLEVBQWhCO2FBQ09PLGFBQVA7O0dBekNKO1dBNENTQyxjQUFULENBQXdCeHhDLElBQXhCLEVBQThCOUIsTUFBOUIsRUFBc0M7U0FDL0I4QixJQUFMLEdBQVlBLElBQVo7U0FDSzlCLE1BQUwsR0FBY0EsTUFBZDtTQUNLMnFDLFVBQUwsR0FBa0IsRUFBbEI7U0FDS2tFLFlBQUwsR0FBb0IsRUFBcEI7U0FDSzBFLGVBQUwsR0FBdUIsSUFBdkI7U0FDSzlMLFdBQUwsR0FBbUIsSUFBbkI7U0FDSytMLGFBQUwsR0FBcUIsSUFBckI7U0FDS0Msa0JBQUwsR0FBMEIsSUFBMUI7U0FDSzFKLFFBQUwsR0FBZ0IsSUFBaEI7O1dBRU8ySixrQkFBVCxDQUE0QmpQLFFBQTVCLEVBQXNDO1FBQ2hDa08sU0FBUyxJQUFJVyxjQUFKLENBQW1CN08sU0FBUzNpQyxJQUE1QixFQUFrQzJpQyxTQUFTemtDLE1BQTNDLENBQWI7V0FDTzJxQyxVQUFQLEdBQW9CbEcsU0FBU2tHLFVBQVQsQ0FBb0JoekMsS0FBcEIsRUFBcEI7V0FDT2szQyxZQUFQLEdBQXNCcEssU0FBU29LLFlBQVQsQ0FBc0JsM0MsS0FBdEIsRUFBdEI7V0FDTzQ3QyxlQUFQLEdBQXlCOU8sU0FBUzhPLGVBQWxDO1dBQ085TCxXQUFQLEdBQXFCaEQsU0FBU2dELFdBQTlCO1dBQ08rTCxhQUFQLEdBQXVCL08sU0FBUytPLGFBQWhDO1dBQ09DLGtCQUFQLEdBQTRCaFAsU0FBU2dQLGtCQUFyQztXQUNPMUosUUFBUCxHQUFrQnRGLFNBQVNzRixRQUEzQjtXQUNPNEksTUFBUDs7TUFFRWdCLGFBQUosRUFBbUJDLGtCQUFuQjtXQUNTQyxTQUFULENBQW1CL3hDLElBQW5CLEVBQXlCOUIsTUFBekIsRUFBaUM7V0FDeEIyekMsZ0JBQWdCLElBQUlMLGNBQUosQ0FBbUJ4eEMsSUFBbkIsRUFBeUI5QixNQUF6QixDQUF2Qjs7V0FFTzh6QyxxQkFBVCxDQUErQi9KLFFBQS9CLEVBQXlDO1FBQ25DNkosa0JBQUosRUFBd0IsT0FBT0Esa0JBQVA7eUJBQ0hGLG1CQUFtQkMsYUFBbkIsQ0FBckI7dUJBQ21CNUosUUFBbkIsR0FBOEJBLFFBQTlCO1dBQ082SixrQkFBUDs7V0FFT0csWUFBVCxHQUF3QjtvQkFDTkgscUJBQXFCeHJDLFNBQXJDOztXQUVPNHJDLCtCQUFULENBQXlDckIsTUFBekMsRUFBaUQ7V0FDeENBLFdBQVdpQixrQkFBWCxJQUFpQ2pCLFdBQVdnQixhQUFuRDs7V0FFT00sWUFBVCxDQUFzQkMsVUFBdEIsRUFBa0NDLFNBQWxDLEVBQTZDO1FBQ3ZDRCxlQUFlQyxTQUFuQixFQUE4QixPQUFPRCxVQUFQO1FBQzFCTixzQkFBc0JJLGdDQUFnQ0UsVUFBaEMsQ0FBMUIsRUFBdUUsT0FBT04sa0JBQVA7V0FDaEUsSUFBUDs7V0FFT1QsWUFBVCxDQUFzQnZ0QixRQUF0QixFQUFnQzVsQixNQUFoQyxFQUF3QzBELE9BQXhDLEVBQWlEO1NBQzFDa2lCLFFBQUwsR0FBZ0JBLFFBQWhCO1NBQ0s1bEIsTUFBTCxHQUFjQSxNQUFkO1NBQ0swRCxPQUFMLEdBQWVBLE9BQWY7U0FDSzB3QyxzQkFBTCxHQUE4QixFQUE5Qjs7ZUFFVzE4QyxTQUFiLEdBQXlCO2FBQ2QsaUJBQVNpN0MsTUFBVCxFQUFpQjtVQUNwQjBCLFVBQVUsS0FBS3p1QixRQUFMLENBQWNrdEIsUUFBNUI7VUFDSTU1QyxTQUFTbTdDLFFBQVFuN0MsTUFBckI7VUFDSW03QyxRQUFRbjdDLE1BQVIsR0FBaUIsQ0FBckIsRUFBd0I7WUFDbEJnN0MsYUFBYUcsUUFBUW43QyxTQUFTLENBQWpCLENBQWpCO1lBQ0lvN0Msc0JBQXNCTCxhQUFhQyxVQUFiLEVBQXlCdkIsTUFBekIsQ0FBMUI7WUFDSTJCLG1CQUFKLEVBQXlCO2tCQUNmcDdDLFNBQVMsQ0FBakIsSUFBc0JvN0MsbUJBQXRCOzs7T0FKSixNQU9PO3lCQUNZLEtBQUsxdUIsUUFBdEI7O2NBRU0xc0IsTUFBUixJQUFrQnk1QyxNQUFsQjtLQWRxQjtrQkFnQlQsd0JBQVc7V0FDbEI0QixhQUFMLENBQW1CLEtBQUt2MEMsTUFBeEI7S0FqQnFCO21CQW1CUix1QkFBU2dLLElBQVQsRUFBZTtVQUN4QnRHLFVBQVUsS0FBS0EsT0FBbkI7VUFDSUEsUUFBUXF2QyxVQUFaLEVBQXdCL29DLEtBQUs1SyxnQkFBTCxDQUFzQixpQkFBdEIsRUFBeUMsSUFBekMsRUFBK0MsSUFBL0M7VUFDcEJzRSxRQUFRc2lCLGFBQVosRUFBMkJoYyxLQUFLNUssZ0JBQUwsQ0FBc0IsMEJBQXRCLEVBQWtELElBQWxELEVBQXdELElBQXhEO1VBQ3ZCc0UsUUFBUXFpQixTQUFaLEVBQXVCL2IsS0FBSzVLLGdCQUFMLENBQXNCLGlCQUF0QixFQUF5QyxJQUF6QyxFQUErQyxJQUEvQztVQUNuQnNFLFFBQVFxaUIsU0FBUixJQUFxQnJpQixRQUFRZ3ZDLE9BQWpDLEVBQTBDMW9DLEtBQUs1SyxnQkFBTCxDQUFzQixnQkFBdEIsRUFBd0MsSUFBeEMsRUFBOEMsSUFBOUM7S0F4QnJCO3FCQTBCTiwyQkFBVztXQUNyQm8xQyxnQkFBTCxDQUFzQixLQUFLeDBDLE1BQTNCO0tBM0JxQjtzQkE2QkwsMEJBQVNnSyxJQUFULEVBQWU7VUFDM0J0RyxVQUFVLEtBQUtBLE9BQW5CO1VBQ0lBLFFBQVFxdkMsVUFBWixFQUF3Qi9vQyxLQUFLN0ssbUJBQUwsQ0FBeUIsaUJBQXpCLEVBQTRDLElBQTVDLEVBQWtELElBQWxEO1VBQ3BCdUUsUUFBUXNpQixhQUFaLEVBQTJCaGMsS0FBSzdLLG1CQUFMLENBQXlCLDBCQUF6QixFQUFxRCxJQUFyRCxFQUEyRCxJQUEzRDtVQUN2QnVFLFFBQVFxaUIsU0FBWixFQUF1Qi9iLEtBQUs3SyxtQkFBTCxDQUF5QixpQkFBekIsRUFBNEMsSUFBNUMsRUFBa0QsSUFBbEQ7VUFDbkJ1RSxRQUFRcWlCLFNBQVIsSUFBcUJyaUIsUUFBUWd2QyxPQUFqQyxFQUEwQzFvQyxLQUFLN0ssbUJBQUwsQ0FBeUIsZ0JBQXpCLEVBQTJDLElBQTNDLEVBQWlELElBQWpEO0tBbENyQjswQkFvQ0QsOEJBQVM2SyxJQUFULEVBQWU7VUFDL0JBLFNBQVMsS0FBS2hLLE1BQWxCLEVBQTBCO1dBQ3JCdTBDLGFBQUwsQ0FBbUJ2cUMsSUFBbkI7V0FDS29xQyxzQkFBTCxDQUE0Qi82QyxJQUE1QixDQUFpQzJRLElBQWpDO1VBQ0lzb0MsZ0JBQWdCckIsbUJBQW1CandDLEdBQW5CLENBQXVCZ0osSUFBdkIsQ0FBcEI7VUFDSSxDQUFDc29DLGFBQUwsRUFBb0JyQixtQkFBbUIvd0MsR0FBbkIsQ0FBdUI4SixJQUF2QixFQUE2QnNvQyxnQkFBZ0IsRUFBN0M7b0JBQ05qNUMsSUFBZCxDQUFtQixJQUFuQjtLQTFDcUI7OEJBNENHLG9DQUFXO1VBQy9CKzZDLHlCQUF5QixLQUFLQSxzQkFBbEM7V0FDS0Esc0JBQUwsR0FBOEIsRUFBOUI7NkJBQ3VCNzdDLE9BQXZCLENBQStCLFVBQVN5UixJQUFULEVBQWU7YUFDdkN3cUMsZ0JBQUwsQ0FBc0J4cUMsSUFBdEI7WUFDSXNvQyxnQkFBZ0JyQixtQkFBbUJqd0MsR0FBbkIsQ0FBdUJnSixJQUF2QixDQUFwQjthQUNLLElBQUkvUSxJQUFJLENBQWIsRUFBZ0JBLElBQUlxNUMsY0FBY3A1QyxNQUFsQyxFQUEwQ0QsR0FBMUMsRUFBK0M7Y0FDekNxNUMsY0FBY3I1QyxDQUFkLE1BQXFCLElBQXpCLEVBQStCOzBCQUNmd08sTUFBZCxDQUFxQnhPLENBQXJCLEVBQXdCLENBQXhCOzs7O09BTE4sRUFTRyxJQVRIO0tBL0NxQjtpQkEwRFYscUJBQVM4RyxDQUFULEVBQVk7UUFDckI4eEIsd0JBQUY7Y0FDUTl4QixFQUFFK0IsSUFBVjthQUNNLGlCQUFMO2NBQ0s5SixPQUFPK0gsRUFBRTAwQyxRQUFiO2NBQ0l4SyxZQUFZbHFDLEVBQUUyMEMsV0FBRixDQUFjQyxZQUE5QjtjQUNJMzBDLFNBQVNELEVBQUVDLE1BQWY7Y0FDSTJ5QyxTQUFTLElBQUlrQixTQUFKLENBQWMsWUFBZCxFQUE0Qjd6QyxNQUE1QixDQUFiO2lCQUNPd3pDLGFBQVAsR0FBdUJ4N0MsSUFBdkI7aUJBQ095N0Msa0JBQVAsR0FBNEJ4SixTQUE1QjtjQUNJRixXQUFXaHFDLEVBQUU2MEMsVUFBRixLQUFpQkMsY0FBY0MsUUFBL0IsR0FBMEMsSUFBMUMsR0FBaUQvMEMsRUFBRWcxQyxTQUFsRTtrREFDd0MvMEMsTUFBeEMsRUFBZ0QsVUFBUzBELE9BQVQsRUFBa0I7Z0JBQzVELENBQUNBLFFBQVFxdkMsVUFBYixFQUF5QjtnQkFDckJydkMsUUFBUXV2QyxlQUFSLElBQTJCdnZDLFFBQVF1dkMsZUFBUixDQUF3Qi81QyxNQUFuRCxJQUE2RHdLLFFBQVF1dkMsZUFBUixDQUF3Qjc1QyxPQUF4QixDQUFnQ3BCLElBQWhDLE1BQTBDLENBQUMsQ0FBeEcsSUFBNkcwTCxRQUFRdXZDLGVBQVIsQ0FBd0I3NUMsT0FBeEIsQ0FBZ0M2d0MsU0FBaEMsTUFBK0MsQ0FBQyxDQUFqSyxFQUFvSzs7O2dCQUdoS3ZtQyxRQUFRc3ZDLGlCQUFaLEVBQStCLE9BQU9jLHNCQUFzQi9KLFFBQXRCLENBQVA7bUJBQ3hCNEksTUFBUDtXQU5GOzs7YUFVSSwwQkFBTDtjQUNLM3lDLFNBQVNELEVBQUVDLE1BQWY7Y0FDSTJ5QyxTQUFTa0IsVUFBVSxlQUFWLEVBQTJCN3pDLE1BQTNCLENBQWI7Y0FDSStwQyxXQUFXaHFDLEVBQUVnMUMsU0FBakI7a0RBQ3dDLzBDLE1BQXhDLEVBQWdELFVBQVMwRCxPQUFULEVBQWtCO2dCQUM1RCxDQUFDQSxRQUFRc2lCLGFBQWIsRUFBNEI7Z0JBQ3hCdGlCLFFBQVF3dkMscUJBQVosRUFBbUMsT0FBT1ksc0JBQXNCL0osUUFBdEIsQ0FBUDttQkFDNUI0SSxNQUFQO1dBSEY7OzthQU9JLGdCQUFMO2VBQ01xQyxvQkFBTCxDQUEwQmoxQyxFQUFFQyxNQUE1Qjs7YUFFSSxpQkFBTDtjQUNLaTFDLGNBQWNsMUMsRUFBRUMsTUFBcEI7Y0FDSTJxQyxVQUFKLEVBQWdCa0UsWUFBaEI7Y0FDSTl1QyxFQUFFK0IsSUFBRixLQUFXLGlCQUFmLEVBQWtDO3lCQUNuQixDQUFFbXpDLFdBQUYsQ0FBYjsyQkFDZSxFQUFmO1dBRkYsTUFHTzt5QkFDUSxFQUFiOzJCQUNlLENBQUVBLFdBQUYsQ0FBZjs7Y0FFRTFCLGtCQUFrQjBCLFlBQVkxQixlQUFsQztjQUNJOUwsY0FBY3dOLFlBQVl4TixXQUE5QjtjQUNJa0wsU0FBU2tCLFVBQVUsV0FBVixFQUF1Qjl6QyxFQUFFQyxNQUFGLENBQVNvQyxVQUFoQyxDQUFiO2lCQUNPdW9DLFVBQVAsR0FBb0JBLFVBQXBCO2lCQUNPa0UsWUFBUCxHQUFzQkEsWUFBdEI7aUJBQ08wRSxlQUFQLEdBQXlCQSxlQUF6QjtpQkFDTzlMLFdBQVAsR0FBcUJBLFdBQXJCO2tEQUN3QzFuQyxFQUFFMjBDLFdBQTFDLEVBQXVELFVBQVNoeEMsT0FBVCxFQUFrQjtnQkFDbkUsQ0FBQ0EsUUFBUXFpQixTQUFiLEVBQXdCO21CQUNqQjRzQixNQUFQO1dBRkY7Ozs7R0E5R047U0FzSE8zQixrQkFBUCxHQUE0QkEsa0JBQTVCO01BQ0ksQ0FBQzlhLE9BQU9yUSxnQkFBWixFQUE4QjtXQUNyQkEsZ0JBQVAsR0FBMEJtckIsa0JBQTFCO3VCQUNtQmtFLGFBQW5CLEdBQW1DLElBQW5DOztDQTdTSixFQStTRzcrQixJQS9TSDs7QUNYQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkMsV0FBVTZmLE1BQVYsRUFBa0I5dEIsU0FBbEIsRUFBNkI7UUFHdEI4dEIsT0FBT2diLFlBQVgsRUFBeUI7Ozs7UUFJckJpRSxhQUFhLENBQWpCLENBUDBCO1FBUXRCQyxnQkFBZ0IsRUFBcEI7UUFDSUMsd0JBQXdCLEtBQTVCO1FBQ0lqTCxNQUFNbFUsT0FBTzMrQixRQUFqQjtRQUNJMjVDLFlBQUo7O2FBRVNvRSw0QkFBVCxDQUFzQy9tQyxJQUF0QyxFQUE0QztzQkFDMUI0bUMsVUFBZCxJQUE0QkksaUJBQWlCaHNDLEtBQWpCLENBQXVCbkIsU0FBdkIsRUFBa0NtRyxJQUFsQyxDQUE1QjtlQUNPNG1DLFlBQVA7Ozs7O2FBS0tJLGdCQUFULENBQTBCenRDLE9BQTFCLEVBQW1DO1lBQzNCeUcsT0FBTyxHQUFHNVcsS0FBSCxDQUFTQyxJQUFULENBQWNxZixTQUFkLEVBQXlCLENBQXpCLENBQVg7ZUFDTyxZQUFXO2dCQUNWLE9BQU9uUCxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO3dCQUN2QnlCLEtBQVIsQ0FBY25CLFNBQWQsRUFBeUJtRyxJQUF6QjthQURKLE1BRU87b0JBQ0V2RixRQUFKLENBQWEsS0FBS2xCLE9BQWxCLENBQUQ7O1NBSlI7OzthQVNLMHRDLFlBQVQsQ0FBc0JDLE1BQXRCLEVBQThCOzs7WUFHdEJKLHFCQUFKLEVBQTJCOzs7dUJBR1pFLGlCQUFpQkMsWUFBakIsRUFBK0JDLE1BQS9CLENBQVgsRUFBbUQsQ0FBbkQ7U0FISixNQUlPO2dCQUNDQyxPQUFPTixjQUFjSyxNQUFkLENBQVg7Z0JBQ0lDLElBQUosRUFBVTt3Q0FDa0IsSUFBeEI7b0JBQ0k7O2lCQUFKLFNBRVU7bUNBQ1NELE1BQWY7NENBQ3dCLEtBQXhCOzs7Ozs7YUFNUEUsY0FBVCxDQUF3QkYsTUFBeEIsRUFBZ0M7ZUFDckJMLGNBQWNLLE1BQWQsQ0FBUDs7O2FBR0tHLDZCQUFULEdBQXlDO3VCQUN0Qix3QkFBVztnQkFDbEJILFNBQVNILDZCQUE2QnIrQixTQUE3QixDQUFiO29CQUNRNCtCLFFBQVIsQ0FBaUJOLGlCQUFpQkMsWUFBakIsRUFBK0JDLE1BQS9CLENBQWpCO21CQUNPQSxNQUFQO1NBSEo7OzthQU9LSyxpQkFBVCxHQUE2Qjs7O1lBR3JCNWYsT0FBT29iLFdBQVAsSUFBc0IsQ0FBQ3BiLE9BQU82ZixhQUFsQyxFQUFpRDtnQkFDekNDLDRCQUE0QixJQUFoQztnQkFDSUMsZUFBZS9mLE9BQU9nZ0IsU0FBMUI7bUJBQ09BLFNBQVAsR0FBbUIsWUFBVzs0Q0FDRSxLQUE1QjthQURKO21CQUdPNUUsV0FBUCxDQUFtQixFQUFuQixFQUF1QixHQUF2QjttQkFDTzRFLFNBQVAsR0FBbUJELFlBQW5CO21CQUNPRCx5QkFBUDs7OzthQUlDRyxnQ0FBVCxHQUE0Qzs7Ozs7WUFLcENDLGdCQUFnQixrQkFBa0I1a0MsS0FBS2ltQixNQUFMLEVBQWxCLEdBQWtDLEdBQXREO1lBQ0k0ZSxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQVMxdEMsS0FBVCxFQUFnQjtnQkFDOUJBLE1BQU0wdkIsTUFBTixLQUFpQm5DLE1BQWpCLElBQ0EsT0FBT3Z0QixNQUFNeTVCLElBQWIsS0FBc0IsUUFEdEIsSUFFQXo1QixNQUFNeTVCLElBQU4sQ0FBV2hwQyxPQUFYLENBQW1CZzlDLGFBQW5CLE1BQXNDLENBRjFDLEVBRTZDOzZCQUM1QixDQUFDenRDLE1BQU15NUIsSUFBTixDQUFXenFDLEtBQVgsQ0FBaUJ5K0MsY0FBY2w5QyxNQUEvQixDQUFkOztTQUpSOztZQVFJZzlCLE9BQU85MkIsZ0JBQVgsRUFBNkI7bUJBQ2xCQSxnQkFBUCxDQUF3QixTQUF4QixFQUFtQ2kzQyxlQUFuQyxFQUFvRCxLQUFwRDtTQURKLE1BRU87bUJBQ0lDLFdBQVAsQ0FBbUIsV0FBbkIsRUFBZ0NELGVBQWhDOzs7dUJBR1csd0JBQVc7Z0JBQ2xCWixTQUFTSCw2QkFBNkJyK0IsU0FBN0IsQ0FBYjttQkFDT3E2QixXQUFQLENBQW1COEUsZ0JBQWdCWCxNQUFuQyxFQUEyQyxHQUEzQzttQkFDT0EsTUFBUDtTQUhKOzs7YUFPS2MsbUNBQVQsR0FBK0M7WUFDdkNDLFVBQVUsSUFBSUMsY0FBSixFQUFkO2dCQUNRQyxLQUFSLENBQWNSLFNBQWQsR0FBMEIsVUFBU3Z0QyxLQUFULEVBQWdCO2dCQUNsQzhzQyxTQUFTOXNDLE1BQU15NUIsSUFBbkI7eUJBQ2FxVCxNQUFiO1NBRko7O3VCQUtlLHdCQUFXO2dCQUNsQkEsU0FBU0gsNkJBQTZCcitCLFNBQTdCLENBQWI7b0JBQ1EwL0IsS0FBUixDQUFjckYsV0FBZCxDQUEwQm1FLE1BQTFCO21CQUNPQSxNQUFQO1NBSEo7OzthQU9LbUIscUNBQVQsR0FBaUQ7WUFDekM1M0MsT0FBT29yQyxJQUFJNXlDLGVBQWY7dUJBQ2Usd0JBQVc7Z0JBQ2xCaStDLFNBQVNILDZCQUE2QnIrQixTQUE3QixDQUFiOzs7Z0JBR0lwVixTQUFTdW9DLElBQUl4ckMsYUFBSixDQUFrQixRQUFsQixDQUFiO21CQUNPaTRDLGtCQUFQLEdBQTRCLFlBQVk7NkJBQ3ZCcEIsTUFBYjt1QkFDT29CLGtCQUFQLEdBQTRCLElBQTVCO3FCQUNLNW1CLFdBQUwsQ0FBaUJwdUIsTUFBakI7eUJBQ1MsSUFBVDthQUpKO2lCQU1LRyxXQUFMLENBQWlCSCxNQUFqQjttQkFDTzR6QyxNQUFQO1NBWko7OzthQWdCS3FCLCtCQUFULEdBQTJDO3VCQUN4Qix3QkFBVztnQkFDbEJyQixTQUFTSCw2QkFBNkJyK0IsU0FBN0IsQ0FBYjt1QkFDV3MrQixpQkFBaUJDLFlBQWpCLEVBQStCQyxNQUEvQixDQUFYLEVBQW1ELENBQW5EO21CQUNPQSxNQUFQO1NBSEo7Ozs7UUFRQXNCLFdBQVdoN0MsT0FBT3VoQyxjQUFQLElBQXlCdmhDLE9BQU91aEMsY0FBUCxDQUFzQnBILE1BQXRCLENBQXhDO2VBQ1c2Z0IsWUFBWUEsU0FBU3JnQyxVQUFyQixHQUFrQ3FnQyxRQUFsQyxHQUE2QzdnQixNQUF4RDs7O1FBR0ksR0FBR2w2QixRQUFILENBQVlwRSxJQUFaLENBQWlCcytCLE9BQU84Z0IsT0FBeEIsTUFBcUMsa0JBQXpDLEVBQTZEOzs7S0FBN0QsTUFJTyxJQUFJbEIsbUJBQUosRUFBeUI7OztLQUF6QixNQUlBLElBQUk1ZixPQUFPdWdCLGNBQVgsRUFBMkI7OztLQUEzQixNQUlBLElBQUlyTSxPQUFPLHdCQUF3QkEsSUFBSXhyQyxhQUFKLENBQWtCLFFBQWxCLENBQW5DLEVBQWdFOzs7S0FBaEUsTUFJQTs7Ozs7YUFLRXN5QyxZQUFULEdBQXdCQSxZQUF4QjthQUNTeUUsY0FBVCxHQUEwQkEsY0FBMUI7Q0E3S0gsRUE4S0N0L0IsSUE5S0QsQ0FBRDs7QUN2QkE7Ozs7OztBQU1BLEFBRUE7QUFDQSxBQU1BO0FBQ0EsQUFFQTtBQUNBLEFBRUE7O0FDckJBLENBQUMsWUFBVztNQUNONGdDLG1CQUFtQixxRkFBdkI7O01BRUlDLFdBQVc7MkJBQ1UsaUNBQVc7VUFDNUJDLGtCQUFrQjUvQyxTQUFTb0ksYUFBVCxDQUF1QixxQkFBdkIsQ0FBdEI7O1VBRUksQ0FBQ3czQyxlQUFMLEVBQXNCOzBCQUNGNS9DLFNBQVNxSCxhQUFULENBQXVCLE1BQXZCLENBQWxCO3dCQUNnQjVHLElBQWhCLEdBQXVCLFVBQXZCO2lCQUNTby9DLElBQVQsQ0FBY3AxQyxXQUFkLENBQTBCbTFDLGVBQTFCOzs7YUFHS0EsZUFBUDtLQVZXOztXQWFOLGlCQUFXO1VBQ1pBLGtCQUFrQkQsU0FBU0cscUJBQVQsRUFBdEI7O1VBRUksQ0FBQ0YsZUFBTCxFQUFzQjs7OztVQUlsQixDQUFDQSxnQkFBZ0JoeUMsWUFBaEIsQ0FBNkIsU0FBN0IsQ0FBTCxFQUE4Qzt3QkFDNUJGLFlBQWhCLENBQTZCLFNBQTdCLEVBQXdDZ3lDLGdCQUF4Qzs7O0dBckJOOztTQTBCT0MsUUFBUCxHQUFrQkEsUUFBbEI7Q0E3QkY7O0FDTWUsU0FBUzk5QixPQUFULENBQWU2VCxHQUFmLEVBQW9CO01BQzdCNTFCLE9BQU9pZ0QsVUFBWCxFQUF1QjtRQUNqQm5vQixLQUFKLENBQVUxMkIsSUFBVixDQUFlLG9DQUFmOztTQUVLNitDLFVBQVAsR0FBb0IsSUFBcEI7OztTQUdPbDRDLGdCQUFQLENBQXdCLE1BQXhCLEVBQWdDLFlBQU07UUFDaENtNEMsU0FBSixHQUFnQi9tQixZQUFVa0YsTUFBVixDQUFpQm4rQixTQUFTbUksSUFBMUIsQ0FBaEI7O1FBRU04M0MscUJBQXFCLGtCQUFrQmpnRCxTQUFTbUksSUFBVCxDQUFjckgsS0FBM0Q7O1FBRUl3QixRQUFKLENBQWFxUyxvQkFBYixDQUFrQyxZQUFNO1VBQ2xDK2dCLElBQUlwekIsUUFBSixDQUFheUMsU0FBYixFQUFKLEVBQThCOzs7WUFHeEJpN0MsU0FBSixDQUFjandCLE9BQWQ7T0FIRixNQUlPLElBQUkyRixJQUFJcHpCLFFBQUosQ0FBYXdCLEtBQWIsRUFBSixFQUEwQjtZQUMzQm04Qyx1QkFBdUJ2cUIsSUFBSXB6QixRQUFKLENBQWE4QixXQUFiLE1BQThCc3hCLElBQUlwekIsUUFBSixDQUFhK0IsV0FBYixFQUFyRCxDQUFKLEVBQXNGOztjQUVoRjI3QyxTQUFKLENBQWNqd0IsT0FBZDtTQUZGLE1BR087Ozs7S0FUWDtHQUxGLEVBbUJHLEtBbkJIOztNQXFCSW9HLEtBQUosQ0FBVSxZQUFXO1FBQ2ZRLDZCQUFKO1FBQ0lKLCtCQUFKLEdBQXNDYixJQUFJd3FCLFNBQUosQ0FBY2p0QyxhQUFkLENBQTRCa3RDLGFBQTVCLENBQTBDcmdELE9BQU9FLFFBQVAsQ0FBZ0JtSSxJQUExRCxFQUFnRSxZQUFNO1VBQ3RHM0QsT0FBT2tCLGNBQVAsQ0FBc0JyRixJQUF0QixDQUEyQjRDLFNBQTNCLEVBQXNDLEtBQXRDLENBQUosRUFBa0Q7a0JBQ3RDbTlDLEdBQVYsQ0FBY0MsT0FBZDtPQURGLE1BRU87Z0JBQ0duL0MsSUFBUixDQUFhLHFHQUFiOztLQUprQyxDQUF0QzthQU9TaUgsSUFBVCxDQUFjbTRDLGdCQUFkLEdBQWlDLElBQUk1cUIsSUFBSXZWLGVBQVIsQ0FBd0JuZ0IsU0FBU21JLElBQWpDLEVBQXVDLEVBQUU2aEIsU0FBUyxJQUFYLEVBQXZDLENBQWpDOzs7UUFHSSxDQUFDMEwsSUFBSXB6QixRQUFKLENBQWEyRSxTQUFiLEVBQUwsRUFBK0I7ZUFDcEJrQixJQUFULENBQWNOLGdCQUFkLENBQStCLFNBQS9CLEVBQTBDLFVBQVN1SixLQUFULEVBQWdCO1lBQ3BEQSxNQUFNaWYsT0FBTixLQUFrQixFQUF0QixFQUEwQjtjQUNwQnVHLHlCQUFKOztPQUZKOzs7O1FBUUU2Qix5QkFBSjtHQXJCRjs7O1dBeUJTNVcsS0FBVDs7O0FDM0RGOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxTQUFTMCtCLGVBQVQsR0FBMkI7TUFDckIsT0FBT3IrQyxXQUFQLEtBQXVCLFVBQTNCLEVBQXVDOztRQUMvQnMrQyxlQUFjLFNBQWRBLFlBQWMsR0FBTSxFQUExQjtpQkFDWXJnRCxTQUFaLEdBQXdCSCxTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUF4QjtXQUNPbTVDLFlBQVA7R0FIRixNQUlPO1dBQ0V0K0MsV0FBUDs7OztJQUlpQnMrQzs7O3lCQUNMOzs7Ozs7RUFEeUJEOztBQzNCekM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTBCcUJFOzs7Ozs7Ozs7Ozs2QkFVTDs7Ozs7VUFHUGw0QyxRQUFMLEdBQWdCLE1BQUtxQyxTQUFyQjs7V0FFTyxNQUFLa1AsVUFBWixFQUF3QjtZQUNqQjRlLFdBQUwsQ0FBaUIsTUFBSzVlLFVBQXRCOzs7Ozs7O3dDQUlnQjtVQUNkLEtBQUtqUCxVQUFULEVBQXFCOzs7WUFFZixLQUFLQSxVQUFMLEtBQW9CN0ssU0FBU21JLElBQWpDLEVBQXVDOztpQkFDaENqSCxJQUFMLHlCQUFnQyxLQUFLYSxZQUFMLENBQWtCLElBQWxCLENBQWhDLG1EQUFxRyxLQUFLOEksVUFBTCxDQUFnQjYxQyxTQUFoQixhQUFvQyxLQUFLNzFDLFVBQUwsQ0FBZ0I2MUMsU0FBcEQsR0FBa0UsR0FBdks7Ozs7VUFJQXR2QyxRQUFRLElBQUk4RyxXQUFKLENBQWdCLGlCQUFoQixFQUFtQyxFQUFDeW9DLFNBQVMsSUFBVixFQUFnQi9sQyxZQUFZLElBQTVCLEVBQW5DLENBQVo7WUFDTXJTLFFBQU4sR0FBaUIsS0FBS0EsUUFBdEI7WUFDTUssVUFBTixHQUFtQixLQUFLN0csWUFBTCxDQUFrQixJQUFsQixDQUFuQjs7V0FFS3dQLGFBQUwsQ0FBbUJILEtBQW5COzs7O0VBaEN5Q292Qzs7QUFvQzdDN2tDLFlBQVlpbEMsUUFBWixHQUF1QkgsZUFBdkI7QUFDQWhpQixlQUFlTCxNQUFmLENBQXNCLGNBQXRCLEVBQXNDcWlCLGVBQXRDOztBQ3BGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5QnFCSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJBbUJMOzs7Ozt3QkFHTyxZQUFNO1VBQ25CditDLFNBQVNpQixvQkFBVCxPQUFvQyxJQUF4QyxFQUE4QztjQUN2Q3MwQixlQUFMO09BREYsTUFFTyxJQUFJLENBQUMsTUFBS2lwQixrQkFBTCxFQUFMLEVBQWdDO2VBQzlCLE1BQUtyckMsVUFBTCxDQUFnQixDQUFoQixDQUFQLEVBQTJCO2dCQUNwQkEsVUFBTCxDQUFnQixDQUFoQixFQUFtQm5HLE1BQW5COztjQUVHdW9CLGVBQUw7O0tBUEo7O1VBV0tsRixvQkFBTDs7Ozs7O3dDQUdrQjtrQkFDTjFYLEVBQVosQ0FBZSxRQUFmLEVBQXlCLEtBQUswWCxvQkFBTCxDQUEwQmxzQixJQUExQixDQUErQixJQUEvQixDQUF6Qjs7Ozs2Q0FPdUJoRyxNQUFNO1VBQ3pCQSxTQUFTLGFBQWIsRUFBNEI7YUFDckJreUIsb0JBQUw7Ozs7OzJDQUltQjtrQkFDVDNYLEdBQVosQ0FBZ0IsUUFBaEIsRUFBMEIsS0FBSzJYLG9CQUEvQjs7OztzQ0FHZ0I7V0FDWDd4QixLQUFMLENBQVdzUixPQUFYLEdBQXFCLEtBQUswdUMsa0JBQUwsS0FBNEIsRUFBNUIsR0FBaUMsTUFBdEQ7Ozs7eUNBR21CO2FBQ1osQ0FBQyxLQUFLLytDLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBRCxJQUFrQyxLQUFLQSxZQUFMLENBQWtCLFVBQWxCLEVBQThCVixLQUE5QixDQUFvQyxLQUFwQyxFQUEyQ1EsT0FBM0MsQ0FBbURTLFNBQVN5RSxXQUFULEVBQW5ELEtBQThFLENBQXZIOzs7OzJDQUdxQjtVQUNqQixLQUFLNkcsWUFBTCxDQUFrQixhQUFsQixLQUFvQyxLQUFLa3pDLGtCQUFMLEVBQXhDLEVBQW1FO1lBQzNEQyx5QkFBeUIsS0FBS2gvQyxZQUFMLENBQWtCLGFBQWxCLEVBQWlDUyxXQUFqQyxFQUEvQjtZQUNNdytDLHFCQUFxQi90QixZQUFZUCxVQUFaLEtBQTJCLFVBQTNCLEdBQXdDLFdBQW5FOzthQUVLNXhCLEtBQUwsQ0FBV3NSLE9BQVgsR0FBc0IydUMsMkJBQTJCQyxrQkFBNUIsR0FBa0QsRUFBbEQsR0FBdUQsTUFBNUU7Ozs7OzJCQTNCNEI7YUFDdkIsQ0FBQyxhQUFELENBQVA7Ozs7RUF6Q21DUjs7QUF3RXZDN2tDLFlBQVlzbEMsRUFBWixHQUFpQkosU0FBakI7QUFDQXBpQixlQUFlTCxNQUFmLENBQXNCLFFBQXRCLEVBQWdDeWlCLFNBQWhDOztBQ3pIQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFFcUJLOzs7Ozs7OzswQkFRTztRQUFkLzBDLE9BQWMsdUVBQUosRUFBSTs7O1NBQ25CK1AsTUFBTCxHQUFjL1AsUUFBUStQLE1BQVIsSUFBa0IsUUFBaEM7U0FDS3RQLFFBQUwsR0FBZ0JULFFBQVFTLFFBQVIsSUFBb0IsQ0FBcEM7U0FDS0MsS0FBTCxHQUFhVixRQUFRVSxLQUFSLElBQWlCLENBQTlCOztTQUVLdzRCLEdBQUwsR0FBVztjQUNELEtBQUtucEIsTUFESjtnQkFFQyxLQUFLdFAsUUFGTjthQUdGLEtBQUtDO0tBSGQ7Ozs7OzZCQU82QjtVQUFqQnMwQyxVQUFpQix1RUFBSixFQUFJOztVQUN2QkMsbUJBQW1CLElBQXpCO1VBQ01DLGNBQWMsU0FBZEEsV0FBYyxHQUFXO3lCQUNacnZDLEtBQWpCLENBQXVCLElBQXZCLEVBQTZCME4sU0FBN0I7ZUFDS2pULE1BQUwsQ0FBWSxJQUFaLEVBQWtCMDBDLFVBQWxCO09BRkY7O2tCQUtZaGhELFNBQVosR0FBd0IsS0FBS0EsU0FBN0I7YUFDT2toRCxXQUFQOzs7Ozs7QUMvQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxJQUFNQyxlQUFlLEVBQXJCOztBQUVBQSxhQUFhQyw0QkFBYixHQUE0QyxZQUFNO1NBQ3pDdmhELFNBQVNDLGVBQVQsQ0FBeUI4QixZQUF6QixDQUFzQywwQkFBdEMsS0FBcUUsSUFBckUsSUFBNkVqQyxPQUFPZ3pCLFVBQVAsR0FBb0JoekIsT0FBTyt5QixXQUEvRztDQURGOztBQUlBeXVCLGFBQWFFLDZCQUFiLEdBQTZDLFlBQU07O1NBRTFDeGhELFNBQVNDLGVBQVQsQ0FBeUI4QixZQUF6QixDQUFzQywyQkFBdEMsS0FBc0UsSUFBdEUsSUFBOEVqQyxPQUFPZ3pCLFVBQVAsSUFBcUJoekIsT0FBTyt5QixXQUFqSDtDQUZGOzs7OztBQVFBeXVCLGFBQWFHLGtCQUFiLEdBQWtDLFlBQU07TUFDbENDLHdCQUFKO01BQ0lKLGFBQWFDLDRCQUFiLEVBQUosRUFBaUQ7c0JBQzdCO1dBQ1gsRUFEVzthQUVULENBRlM7Y0FHUixFQUhRO1lBSVY7S0FKUjtHQURGLE1BT08sSUFBSUQsYUFBYUUsNkJBQWIsRUFBSixFQUFrRDtzQkFDckM7V0FDWCxDQURXO2FBRVQsRUFGUztjQUdSLEVBSFE7WUFJVjtLQUpSO0dBREssTUFPQTtzQkFDYTtXQUNYLENBRFc7YUFFVCxDQUZTO2NBR1IsQ0FIUTtZQUlWO0tBSlI7OztTQVFLRSxlQUFQO0NBekJGOzs7OztBQStCQUosYUFBYUssa0JBQWIsR0FBa0MsWUFBTTtNQUNsQ0MscUJBQUo7TUFDSU4sYUFBYUMsNEJBQWIsRUFBSixFQUFpRDttQkFDaEM7U0FDVixDQURVO1NBRVYsRUFGVTthQUdOemhELE9BQU9nekIsVUFIRDtjQUlMaHpCLE9BQU8reUIsV0FBUCxHQUFxQixFQUpoQjtLQUFmO0dBREYsTUFPTyxJQUFJeXVCLGFBQWFFLDZCQUFiLEVBQUosRUFBa0Q7bUJBQ3hDO1NBQ1YsRUFEVTtTQUVWLENBRlU7YUFHTjFoRCxPQUFPZ3pCLFVBQVAsR0FBb0IsRUFIZDtjQUlMaHpCLE9BQU8reUIsV0FBUCxHQUFxQixFQUpoQjtLQUFmO0dBREssTUFPQTttQkFDVTtTQUNWLENBRFU7U0FFVixDQUZVO2FBR04veUIsT0FBT2d6QixVQUhEO2NBSUxoekIsT0FBTyt5QjtLQUpqQjs7O3NCQVNHK3VCLFlBREw7VUFFUUEsYUFBYS85QixDQUZyQjtTQUdPKzlCLGFBQWE5OUIsQ0FIcEI7V0FJUzg5QixhQUFhLzlCLENBQWIsR0FBaUIrOUIsYUFBYXYrQyxLQUp2QztZQUtVdStDLGFBQWE5OUIsQ0FBYixHQUFpQjg5QixhQUFhdCtDOztDQTlCMUM7O0FDL0RBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUlhdStDLG1CQUFiOzs7aUNBRW1FO21GQUFKLEVBQUk7MkJBQXBEM2xDLE1BQW9EO1FBQXBEQSxNQUFvRCwrQkFBM0MsUUFBMkM7MEJBQWpDclAsS0FBaUM7UUFBakNBLEtBQWlDLDhCQUF6QixDQUF5Qjs2QkFBdEJELFFBQXNCO1FBQXRCQSxRQUFzQixpQ0FBWCxHQUFXOzs7b0lBQ3pELEVBQUVzUCxjQUFGLEVBQVVyUCxZQUFWLEVBQWlCRCxrQkFBakIsRUFEeUQ7Ozs7Ozs7Ozs7O3lCQVE1RGlqQixNQVZQLEVBVWU1UixJQVZmLEVBVXFCOzs7Ozs7Ozs7Ozt5QkFRZDRSLE1BbEJQLEVBa0JlNVIsSUFsQmYsRUFrQnFCOzs7OztFQWxCb0JpakMsWUFBekM7Ozs7O0FBMEJBLElBQWFZLHFCQUFiOzs7bUNBRW1FO29GQUFKLEVBQUk7NkJBQW5ENWxDLE1BQW1EO1FBQW5EQSxNQUFtRCxnQ0FBMUMsTUFBMEM7NEJBQWxDclAsS0FBa0M7UUFBbENBLEtBQWtDLCtCQUExQixDQUEwQjsrQkFBdkJELFFBQXVCO1FBQXZCQSxRQUF1QixrQ0FBWixHQUFZOzs7OzhJQUN6RCxFQUFDc1AsY0FBRCxFQUFTclAsWUFBVCxFQUFnQkQsa0JBQWhCLEVBRHlEOztXQUcxRG0xQyxVQUFMLEdBQWtCLFFBQWxCO1dBQ0tDLFlBQUwsR0FBb0IsR0FBcEI7Ozs7Ozs7Ozs7Ozt5QkFPR255QixNQWJQLEVBYWUvbkIsUUFiZixFQWF5Qjs7YUFFZDJYLE1BQVAsQ0FDRXdpQyxPQUFPcHlCLE9BQU9xeUIsS0FBZCxFQUNHM2pDLEtBREgsQ0FDUyxFQUFFNGpDLFNBQVMsQ0FBWCxFQURULEVBRUczakMsSUFGSCxDQUVRLEtBQUszUixLQUZiLEVBR0cwUixLQUhILENBR1MsRUFBRTRqQyxTQUFTLEdBQVgsRUFIVCxFQUcyQjtrQkFDYixLQUFLSCxZQURRO2dCQUVmLEtBQUtEO09BTGpCLENBREYsRUFTRUUsT0FBT3B5QixPQUFPdXlCLE1BQWQsRUFBc0IsS0FBSy9jLEdBQTNCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsbUNBQUYsRUFBdUNILFNBQVMsQ0FBaEQsRUFGSixFQUdJLEVBQUVHLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsQ0FBOUMsRUFISixFQUtHNWpDLEtBTEgsQ0FLUyxnQkFBUTtvQkFDRHpXLFVBQVo7O09BTkosQ0FURjs7Ozs7Ozs7Ozt5QkF5QkcrbkIsTUF4Q1AsRUF3Q2UvbkIsUUF4Q2YsRUF3Q3lCO2FBQ2QyWCxNQUFQLENBRUV3aUMsT0FBT3B5QixPQUFPcXlCLEtBQWQsRUFDRzNqQyxLQURILENBQ1MsRUFBRTRqQyxTQUFTLENBQVgsRUFEVCxFQUVHM2pDLElBRkgsQ0FFUSxLQUFLM1IsS0FGYixFQUdHMFIsS0FISCxDQUdTLEVBQUU0akMsU0FBUyxDQUFYLEVBSFQsRUFHeUI7a0JBQ1gsS0FBS0gsWUFETTtnQkFFYixLQUFLRDtPQUxqQixDQUZGLEVBVUVFLE9BQU9weUIsT0FBT3V5QixNQUFkLEVBQXNCLEtBQUsvYyxHQUEzQixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsQ0FBOUMsRUFGSixFQUdJLEVBQUVHLG1DQUFGLEVBQXVDSCxTQUFTLENBQWhELEVBSEosRUFLRzVqQyxLQUxILENBS1MsZ0JBQVE7b0JBQ0R6VyxVQUFaOztPQU5KLENBVkY7Ozs7RUF6Q3VDKzVDLG1CQUEzQzs7Ozs7QUFtRUEsSUFBYVUsc0JBQWI7OztvQ0FFbUU7b0ZBQUosRUFBSTs2QkFBbkRybUMsTUFBbUQ7UUFBbkRBLE1BQW1ELGdDQUExQyxNQUEwQzs0QkFBbENyUCxLQUFrQztRQUFsQ0EsS0FBa0MsK0JBQTFCLENBQTBCOytCQUF2QkQsUUFBdUI7UUFBdkJBLFFBQXVCLGtDQUFaLEdBQVk7Ozs7Z0pBQ3pELEVBQUNzUCxjQUFELEVBQVNyUCxZQUFULEVBQWdCRCxrQkFBaEIsRUFEeUQ7O1dBRzFEbTFDLFVBQUwsR0FBa0IsUUFBbEI7V0FDS0MsWUFBTCxHQUFvQixHQUFwQjtRQUNJVixhQUFhQyw0QkFBYixFQUFKLEVBQWlEO2FBQzFDaUIsVUFBTCxHQUFrQixtQkFBbEI7S0FERixNQUVPLElBQUlsQixhQUFhRSw2QkFBYixFQUFKLEVBQWtEO2FBQ2xEZ0IsVUFBTCxHQUFrQixtQkFBbEI7S0FESyxNQUVBO2FBQ0FBLFVBQUwsR0FBa0J4aUQsU0FBU21JLElBQVQsQ0FBY3M2QyxZQUFkLEdBQTZCLEdBQTdCLEdBQW1DLENBQW5DLEdBQXVDLElBQXpELENBREs7Ozs7Ozs7Ozs7Ozs7eUJBU0o1eUIsTUFwQlAsRUFvQmUvbkIsUUFwQmYsRUFvQnlCO2FBQ2QyWCxNQUFQLENBRUV3aUMsT0FBT3B5QixPQUFPcXlCLEtBQWQsRUFDQzNqQyxLQURELENBQ08sRUFBRTRqQyxTQUFTLENBQVgsRUFEUCxFQUVDM2pDLElBRkQsQ0FFTSxLQUFLM1IsS0FGWCxFQUdDMFIsS0FIRCxDQUdPLEVBQUU0akMsU0FBUyxDQUFYLEVBSFAsRUFHdUI7a0JBQ1gsS0FBS0gsWUFETTtnQkFFYixLQUFLRDtPQUxmLENBRkYsRUFVRUUsT0FBT3B5QixPQUFPdXlCLE1BQWQsRUFBc0IsS0FBSy9jLEdBQTNCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsK0JBQTZCLEtBQUtFLFVBQWxDLFNBQUYsRUFGSixFQUdJLEVBQUVGLFdBQVcsc0JBQWIsRUFISixFQUtHL2pDLEtBTEgsQ0FLUyxnQkFBUTtvQkFDRHpXLFVBQVo7O09BTkosQ0FWRjs7Ozs7Ozs7Ozt5QkEwQkcrbkIsTUEvQ1AsRUErQ2UvbkIsUUEvQ2YsRUErQ3lCO2FBQ2QyWCxNQUFQLENBRUV3aUMsT0FBT3B5QixPQUFPcXlCLEtBQWQsRUFDQzNqQyxLQURELENBQ08sRUFBRTRqQyxTQUFTLENBQVgsRUFEUCxFQUVDM2pDLElBRkQsQ0FFTSxLQUFLM1IsS0FGWCxFQUdDMFIsS0FIRCxDQUdPLEVBQUU0akMsU0FBUyxDQUFYLEVBSFAsRUFHdUI7a0JBQ1gsS0FBS0gsWUFETTtnQkFFYixLQUFLRDtPQUxmLENBRkYsRUFVRUUsT0FBT3B5QixPQUFPdXlCLE1BQWQsRUFBc0IsS0FBSy9jLEdBQTNCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBVyxzQkFBYixFQUZKLEVBR0ksRUFBRUEsK0JBQTZCLEtBQUtFLFVBQWxDLFNBQUYsRUFISixFQUtHamtDLEtBTEgsQ0FLUyxnQkFBUTtvQkFDRHpXLFVBQVo7O09BTkosQ0FWRjs7OztFQWhEd0MrNUMsbUJBQTVDOztBQ2xIQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFRcUJhOzs7OzZDQU1NO2FBQ2xCbG9DLFdBQUw7Ozs7aUNBR1dtb0MsWUFBWTtXQUNsQjdoRCxLQUFMLENBQVdzUixPQUFYLEdBQXFCdXdDLGFBQWEsT0FBYixHQUF1QixNQUE1Qzs7OzsyQkFUWTthQUNQbm9DLFdBQUw7Ozs7K0JBV1k7Ozs7O1FBR1IsTUFBS3lyQixXQUFMLEtBQXFCeWMsaUJBQXpCLEVBQTRDO2FBQ3JDbm9DLGFBQUw7OztVQUdHbVosUUFBTCxHQUFnQixLQUFoQjtVQUNLa3ZCLFNBQUwsR0FBaUIsSUFBSXZ1QixRQUFKLEVBQWpCO1VBQ0t3dUIsT0FBTCxHQUFlLE1BQUtBLE9BQUwsQ0FBYXA4QyxJQUFiLE9BQWY7VUFDS3E4QyxjQUFMLEdBQXNCcGlELE9BQUs4VixRQUFMLENBQWMsTUFBS25KLE9BQUwsQ0FBYWpOLEtBQWIsQ0FBbUIsQ0FBbkIsQ0FBZCxDQUF0QjtVQUNLMmlELFdBQUwsR0FBbUI7YUFBSyxNQUFLbm9DLFVBQUwsR0FBa0IsTUFBS2lvQyxPQUFMLEVBQWxCLEdBQW1DcjZDLEVBQUV3NkMsaUJBQUYsRUFBeEM7S0FBbkI7VUFDS0MsZ0JBQUwsR0FBd0IsTUFBS0Msc0JBQUwsRUFBeEI7Ozs7Ozs4QkFlUTs7O1VBQ0osS0FBS3RvQyxVQUFMLElBQW1CLENBQUMsS0FBS3VvQyxRQUE3QixFQUF1QzthQUNoQ0EsUUFBTCxHQUFnQixJQUFoQjthQUNLN3lCLElBQUwsR0FDRzNCLElBREgsQ0FFSSxZQUFNO2lCQUNDdzBCLFFBQUwsR0FBZ0IsS0FBaEI7aUJBQ0twckMsbUJBQUwsU0FBK0IsZUFBL0I7U0FKTixFQU1JO2lCQUFNLE9BQUtvckMsUUFBTCxHQUFnQixLQUF0QjtTQU5KOzs7OzsyQkFXVTt3Q0FBTm5zQyxJQUFNO1lBQUE7OzthQUNMLEtBQUtvc0MsV0FBTCxjQUFpQixJQUFqQixTQUEwQnBzQyxJQUExQixFQUFQOzs7OzJCQUdZO3lDQUFOQSxJQUFNO1lBQUE7OzthQUNMLEtBQUtvc0MsV0FBTCxjQUFpQixLQUFqQixTQUEyQnBzQyxJQUEzQixFQUFQOzs7OzZCQUdjO3lDQUFOQSxJQUFNO1lBQUE7OzthQUNQLEtBQUtvc0MsV0FBTCxjQUFpQixDQUFDLEtBQUtudkIsT0FBdkIsU0FBbUNqZCxJQUFuQyxFQUFQOzs7O2dDQUdVMnJDLFlBQTBCOzs7O1VBQWR4MkMsT0FBYyx1RUFBSixFQUFJOztVQUM5Qm1LLFNBQVNxc0MsYUFBYSxNQUFiLEdBQXNCLE1BQXJDOzs2QkFFZXgyQyxPQUFmO2NBQ1FPLGdCQUFSLEdBQTJCaE0sT0FBSytMLE1BQUwsQ0FDekJOLFFBQVFPLGdCQUFSLElBQTRCLEVBREgsRUFFekJuQixnQkFBZ0I4M0MsMkJBQWhCLENBQTRDLEtBQUt0aEQsWUFBTCxDQUFrQixtQkFBbEIsQ0FBNUMsQ0FGeUIsQ0FBM0I7O1VBS0l1aEQsV0FBVyxLQUFmO2FBQ0t2ckMsbUJBQUwsQ0FBeUIsSUFBekIsVUFBcUN6QixNQUFyQyxxRUFDRyxLQUFLd3NDLGNBRFIsRUFDeUIsSUFEekIsbURBRVU7ZUFBTVEsV0FBVyxJQUFqQjtPQUZWOztVQUtJQSxRQUFKLEVBQWM7ZUFDTGo2QyxRQUFRRSxNQUFSLHFCQUFpQytNLE1BQWpDLGFBQVA7OzthQUdLLElBQUlqTixPQUFKLENBQVksbUJBQVc7ZUFDdkJ1NUMsU0FBTCxDQUFleHNCLFVBQWYsQ0FBMEIsWUFBTTtjQUN4QjFCLFNBQVMsT0FBS2t1QixTQUFMLENBQWVocUIsSUFBZixFQUFmO2NBQ012c0IsV0FBVyxPQUFLNDJDLGdCQUFMLENBQXNCNUIsV0FBdEIsQ0FBa0NsMUMsT0FBbEMsQ0FBakI7O3dCQUVjLE9BQUtvM0MsWUFBTCxDQUFrQixJQUFsQixFQUF3QnAzQyxPQUF4QixDQUFkO2lCQUNLdW5CLFFBQUwsR0FBZ0JpdkIsVUFBaEI7aUJBQ0t6bkMsZ0JBQUwsQ0FBc0J5bkMsVUFBdEI7OytCQUVtQixZQUFNO3FCQUNkcnNDLE1BQVQsVUFBdUIsWUFBTTtlQUMxQnFzQyxVQUFELElBQWUsT0FBS1ksWUFBTCxDQUFrQixLQUFsQixFQUF5QnAzQyxPQUF6QixDQUFmOzs7O3FCQUlLa0ssZUFBTCxTQUEyQixNQUFNQyxNQUFqQztxQkFDS3lCLG1CQUFMLFNBQStCLFNBQVN6QixNQUF4QyxxQkFBa0QsT0FBS3dzQyxjQUF2RCxXQU4yQjs7a0JBUXZCMzJDLFFBQVFyRSxRQUFSLFlBQTRCMkosUUFBaEMsRUFBMEM7d0JBQ2hDM0osUUFBUjs7OzthQVRKO1dBREY7U0FSRjtPQURLLENBQVA7Ozs7a0NBa0RZOzs7bUJBQ0MsSUFBYixFQUFtQixZQUFNO1lBQ25CLE9BQUtvNkMsS0FBTCxJQUFjLE9BQUtuZ0QsWUFBTCxDQUFrQixZQUFsQixDQUFsQixFQUFtRDtpQkFDNUNtZ0QsS0FBTCxDQUFXcGhELEtBQVgsQ0FBaUIwaUQsZUFBakIsR0FBbUMsT0FBS3poRCxZQUFMLENBQWtCLFlBQWxCLENBQW5DOztPQUZKOzs7O3dDQU9rQjs7O1dBQ2IwaEQsa0JBQUwsR0FBMEIsS0FBS1YsV0FBTCxDQUFpQnQ4QyxJQUFqQixDQUFzQixJQUF0QixDQUExQjs7bUJBRWEsSUFBYixFQUFtQixZQUFNO1lBQ25CLE9BQUt5N0MsS0FBVCxFQUFnQjtpQkFDVEEsS0FBTCxDQUFXcjZDLGdCQUFYLENBQTRCLE9BQTVCLEVBQXFDLE9BQUtnN0MsT0FBMUMsRUFBbUQsS0FBbkQ7aUJBQ0t6bkMsZ0JBQUwsQ0FBc0IsT0FBSzhtQyxLQUEzQixFQUFrQyxJQUFsQzs7T0FISjs7OzsyQ0FRcUI7V0FDaEJ3QixrQkFBTCxDQUF3QjN6QixPQUF4QjtXQUNLMnpCLGtCQUFMLEdBQTBCLElBQTFCOztVQUVJLEtBQUt4QixLQUFULEVBQWdCO2FBQ1RBLEtBQUwsQ0FBV3Q2QyxtQkFBWCxDQUErQixPQUEvQixFQUF3QyxLQUFLaTdDLE9BQTdDLEVBQXNELEtBQXREO2VBQ0t6bkMsZ0JBQUwsQ0FBc0IsS0FBSzhtQyxLQUEzQixFQUFrQyxLQUFsQzs7Ozs7NkNBUXFCemhELE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLFVBQUw7dUJBQ2VrakQsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9ELEtBQUtnMUMsT0FBekQ7O2FBRUcsV0FBTDtlQUNPWCxnQkFBTCxHQUF3QixLQUFLQyxzQkFBTCxFQUF4Qjs7YUFFRyxZQUFMO2VBQ09XLFdBQUw7Ozs7OzsyQkFySm1CO2FBQ2hCLEtBQUtILGtCQUFaOzt5QkFHcUI1N0MsVUFBVTtVQUMzQixLQUFLNDdDLGtCQUFULEVBQTZCO2FBQ3RCQSxrQkFBTCxDQUF3QjN6QixPQUF4Qjs7O1dBR0cyekIsa0JBQUwsR0FBMEJ4d0MsMkJBQTJCaXRDLGFBQTNCLENBQXlDLElBQXpDLEVBQStDcjRDLFFBQS9DLENBQTFCOzs7OzJCQThFWTthQUNMLEtBQUs0ckIsUUFBWjs7Ozt5QkFHV251QixPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7OzJCQUdhO2FBQ04sS0FBS3FJLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7Ozt5QkFHYXJJLE9BQU87YUFDYjdFLE9BQUt3WSxlQUFMLENBQXFCLElBQXJCLEVBQTJCLFlBQTNCLEVBQXlDM1QsS0FBekMsQ0FBUDs7MkJBR2U7YUFDUixLQUFLcUksWUFBTCxDQUFrQixZQUFsQixDQUFQOzs7OzJCQWdDOEI7YUFDdkIsQ0FBQyxVQUFELEVBQWEsV0FBYixFQUEwQixZQUExQixDQUFQOzs7OzJCQWlCa0I7YUFDWCxDQUFDLFNBQUQsRUFBWSxVQUFaLEVBQXdCLFNBQXhCLEVBQW1DLFVBQW5DLEVBQStDLGVBQS9DLENBQVA7Ozs7RUF4TDJDNHlDOztBQ3pCL0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBVUEsSUFBTWp4QyxTQUFTO21CQUNJLGlCQURKO3dCQUVTLHNCQUZUO3lCQUdVO0NBSHpCOztBQU1BLElBQU11MEMsZ0JBQWdCO2FBQ1Q7V0FBTXhoRCxTQUFTeUMsU0FBVCxLQUF1Qis4QyxxQkFBdkIsR0FBK0NTLHNCQUFyRDtHQURTO1VBRVpWO0NBRlY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnRHFCa0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBNEdMOzs7Ozt3QkFHTzthQUFNLE1BQUtDLFFBQUwsRUFBTjtLQUFuQjs7Ozs7OzZDQW1CdUI7YUFDaEIsSUFBSXo0QyxlQUFKLENBQW9CO21CQUNkdTRDLGFBRGM7bUJBRWRqQyxtQkFGYzt1QkFHVixxQkFIVTswQkFJUCxLQUFLOS9DLFlBQUwsQ0FBa0IsV0FBbEI7T0FKYixDQUFQOzs7OytCQVFTO2dCQUNDc00sT0FBVixDQUFrQixJQUFsQjs7V0FFS3ZOLEtBQUwsQ0FBV3NSLE9BQVgsR0FBcUIsTUFBckI7V0FDS3RSLEtBQUwsQ0FBV2dTLE1BQVgsR0FBb0IsS0FBcEI7Ozs7Ozs7Ozs7OztVQVlJLENBQUMsS0FBS3N2QyxNQUFWLEVBQWtCO1lBQ1Y2QixRQUFRamtELFNBQVNxSCxhQUFULENBQXVCLEtBQXZCLENBQWQ7Y0FDTTZILFNBQU4sQ0FBZ0JFLEdBQWhCLENBQW9CLGNBQXBCOztlQUVPLEtBQUswSyxVQUFaLEVBQXdCO2dCQUNoQnJQLFdBQU4sQ0FBa0IsS0FBS3FQLFVBQXZCOzs7YUFHR3JQLFdBQUwsQ0FBaUJ3NUMsS0FBakI7OztVQUdFLENBQUMsS0FBS0MsTUFBTixJQUFnQixLQUFLdDJDLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBcEIsRUFBZ0Q7WUFDeENxaUIsUUFBUWp3QixTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFkO2NBQ011RCxTQUFOLEdBQWtCLEtBQUs3SSxZQUFMLENBQWtCLE9BQWxCLENBQWxCO2NBQ01tTixTQUFOLENBQWdCRSxHQUFoQixDQUFvQixvQkFBcEI7YUFDS2d6QyxNQUFMLENBQVl2b0MsWUFBWixDQUF5Qm9XLEtBQXpCLEVBQWdDLEtBQUtteUIsTUFBTCxDQUFZdG9DLFVBQTVDOzs7VUFHRSxDQUFDLEtBQUtvb0MsS0FBVixFQUFpQjtZQUNUaUMsT0FBT25rRCxTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFiO2FBQ0s2SCxTQUFMLENBQWVFLEdBQWYsQ0FBbUIsbUJBQW5CO2FBQ0t5SyxZQUFMLENBQWtCc3FDLElBQWxCLEVBQXdCLEtBQUtycUMsVUFBN0I7OztXQUdHc29DLE1BQUwsQ0FBWXRoRCxLQUFaLENBQWtCZ1MsTUFBbEIsR0FBMkIsS0FBM0I7V0FDS292QyxLQUFMLENBQVdwaEQsS0FBWCxDQUFpQmdTLE1BQWpCLEdBQTBCLEtBQTFCOzttQkFFYXN4QyxZQUFiLENBQTBCLElBQTFCLEVBQWdDLEtBQUtSLE9BQXJDOzs7O21DQUdhO1VBQ1QsS0FBS00sTUFBVCxFQUFpQjthQUNWQSxNQUFMLENBQVl0NUMsU0FBWixHQUF3QixLQUFLN0ksWUFBTCxDQUFrQixPQUFsQixDQUF4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkNBcUZxQnRCLE1BQU1rTyxNQUFNQyxTQUFTO1VBQ3hDbk8sU0FBUyxPQUFiLEVBQXNCO2FBQ2Y0akQsWUFBTDtPQURGLE1BRU87d0pBQzBCNWpELElBQS9CLEVBQXFDa08sSUFBckMsRUFBMkNDLE9BQTNDOzs7Ozs7Ozs7OzsyQkFsS1U7YUFDTFcsTUFBUDs7OzsyQkFHVTthQUNIN08sT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLG9CQUFyQixDQUFQOzs7OzJCQUdXO2FBQ0o5VSxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsZUFBckIsQ0FBUDs7OzsyQkFHVzthQUNKLEtBQUtwTixhQUFMLENBQW1CLHFCQUFuQixDQUFQOzs7O3FDQTZKc0IzSCxNQUFNOEwsVUFBVTtVQUNsQyxFQUFFQSxTQUFTcE0sU0FBVCxZQUE4QjBoRCxtQkFBaEMsQ0FBSixFQUEwRDtlQUNuRG5uQyxhQUFMLENBQW1CLGFBQW5COztvQkFFWWphLElBQWQsSUFBc0I4TCxRQUF0Qjs7OzsyQkFwQjhCO3VKQUNPLE9BQXJDOzs7OzJCQXNCcUI7YUFDZHUzQyxhQUFQOzs7OzJCQUcrQjthQUN4QmpDLG1CQUFQOzs7O0VBeFM0Q2E7O0FBNFNoRC9tQyxZQUFZMm9DLFdBQVosR0FBMEJQLGtCQUExQjtBQUNBdGxCLGVBQWVMLE1BQWYsQ0FBc0Isa0JBQXRCLEVBQTBDMmxCLGtCQUExQzs7QUM5WEE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBT3FCUTs7OzsyQkFFTDthQUNQL3BDLFdBQUw7Ozs7MkJBR3NCO2FBQ2pCQSxXQUFMOzs7OzJCQUdlO2FBQ1IsQ0FBQyxJQUFELENBQVA7Ozs7K0JBR1k7Ozs7O1FBR1IsTUFBS3lyQixXQUFMLEtBQXFCc2UsaUJBQXpCLEVBQTRDO2FBQ3JDaHFDLGFBQUw7Ozt3QkFHaUI7YUFBTSxNQUFLeXBDLFFBQUwsRUFBTjtLQUFuQjs7Ozs7OytCQWVTO2dCQUNDMzFDLE9BQVYsQ0FBa0IsSUFBbEI7O1dBRUthLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixLQUFLbzFDLGlCQUF4Qjs7VUFFSSxDQUFDLEtBQUtDLEtBQU4sSUFBZSxLQUFLNzJDLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBbkIsRUFBOEM7ZUFDdkM2TixrQkFBTCxDQUF3QixNQUF4QjtZQUNNeVcsT0FBT3h4QixPQUFLMkcsYUFBTCxzQkFBc0MsS0FBS3RGLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBdEMsbUJBQWI7YUFDS21OLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixLQUFLbzFDLGlCQUFMLENBQXVCNWdELE9BQXZCLENBQStCLFFBQS9CLEVBQXlDLE1BQXpDLENBQW5CO2FBQ0tpVyxZQUFMLENBQWtCcVksSUFBbEIsRUFBd0IsS0FBS3BZLFVBQTdCOzs7V0FHRzRxQyxhQUFMOzttQkFFYU4sWUFBYixDQUEwQixJQUExQixFQUFnQyxLQUFLUixPQUFyQzs7OztrQ0FHWTtVQUNSLEtBQUthLEtBQVQsRUFBZ0I7YUFDVEEsS0FBTCxDQUFXLzJDLFlBQVgsQ0FBd0IsTUFBeEIsRUFBZ0MsS0FBSzNMLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBaEM7Ozs7O29DQUlZO1dBQ1Q0aUQsVUFBTCxJQUFtQmprRCxPQUFLK1ksWUFBTCxpQ0FBcUIsS0FBS2tyQyxVQUExQixFQUFuQjs7Ozs2Q0FPdUJsa0QsTUFBTWtPLE1BQU1DLFNBQVM7Y0FDcENuTyxJQUFSO2FBQ08sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsS0FBSzhyQyxpQkFBN0IsRUFBZ0QsS0FBS1osT0FBckQ7O2FBRUcsVUFBTDt1QkFDZUQsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9ELEtBQUtnMUMsT0FBekQ7O2FBRUcsTUFBTDtlQUNPZ0IsV0FBTDs7YUFFRyxRQUFMO2VBQ08xMUMsU0FBTCxDQUFlNkcsUUFBZixDQUF3QixLQUFLeXVDLGlCQUE3QixLQUFtRCxLQUFLRSxhQUFMLEVBQW5EOzs7Ozs7eUJBdkRPbi9DLE9BQU87YUFDWDdFLE9BQUt3WSxlQUFMLENBQXFCLElBQXJCLEVBQTJCLFVBQTNCLEVBQXVDM1QsS0FBdkMsQ0FBUDs7MkJBR2E7YUFDTixLQUFLcUksWUFBTCxDQUFrQixVQUFsQixDQUFQOzs7OzJCQUdVO2FBQ0hsTixPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsVUFBckIsQ0FBUDs7OzsyQkE4QjhCO2FBQ3ZCLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0IsTUFBdEIsRUFBOEIsUUFBOUIsQ0FBUDs7OztFQWhFMkNnckM7O0FDeEIvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQ3FCcUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBa0JMO2FBQ0w7WUFDRCx3QkFEQzs4QkFFaUI7T0FGeEI7Ozs7MkJBTXNCO2FBQ2YscUJBQVA7Ozs7MkJBR2U7YUFDUmgwQyxTQUFQOzs7O0VBOUJrRDB6Qzs7QUFrQ3RENW9DLFlBQVltcEMsaUJBQVosR0FBZ0NELHdCQUFoQztBQUNBcG1CLGVBQWVMLE1BQWYsQ0FBc0IseUJBQXRCLEVBQWlEeW1CLHdCQUFqRDs7QUN6RkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBR2FFLG1CQUFiOzs7aUNBRW1FO21GQUFKLEVBQUk7MkJBQXBEN29DLE1BQW9EO1FBQXBEQSxNQUFvRCwrQkFBM0MsUUFBMkM7MEJBQWpDclAsS0FBaUM7UUFBakNBLEtBQWlDLDhCQUF6QixDQUF5Qjs2QkFBdEJELFFBQXNCO1FBQXRCQSxRQUFzQixpQ0FBWCxHQUFXOzs7b0lBQ3pELEVBQUVzUCxjQUFGLEVBQVVyUCxZQUFWLEVBQWlCRCxrQkFBakIsRUFEeUQ7Ozs7Ozs7Ozs7O3lCQVE1RGlqQixNQVZQLEVBVWU1UixJQVZmLEVBVXFCOzs7Ozs7Ozs7Ozt5QkFRZDRSLE1BbEJQLEVBa0JlNVIsSUFsQmYsRUFrQnFCOzs7OztFQWxCb0JpakMsWUFBekM7Ozs7O0FBMEJBLElBQWE4RCwwQkFBYjs7O3dDQUV3RjtvRkFBSixFQUFJOzZCQUF6RTlvQyxNQUF5RTtRQUF6RUEsTUFBeUUsZ0NBQWhFLDZCQUFnRTsrQkFBakN0UCxRQUFpQztRQUFqQ0EsUUFBaUMsa0NBQXRCLEdBQXNCOzRCQUFqQkMsS0FBaUI7UUFBakJBLEtBQWlCLCtCQUFULENBQVM7OztrSkFDOUUsRUFBQ0Qsa0JBQUQsRUFBV3NQLGNBQVgsRUFBbUJyUCxZQUFuQixFQUQ4RTs7Ozs7Ozs7Ozs7eUJBUWpGZ2pCLE1BVlAsRUFVZS9uQixRQVZmLEVBVXlCO2lCQUNWQSxXQUFXQSxRQUFYLEdBQXNCLFlBQVcsRUFBNUM7O2FBRU8yWCxNQUFQLENBRUV3aUMsT0FBT3B5QixPQUFPcXlCLEtBQWQsRUFBcUIsS0FBSzdjLEdBQTFCLEVBQ0dnZCxPQURILENBQ1csRUFBRUYsU0FBUyxDQUFYLEVBRFgsRUFDMkIsRUFBRUEsU0FBUyxDQUFYLEVBRDNCLENBRkYsRUFLRUYsT0FBT3B5QixPQUFPbzFCLE9BQWQsRUFBdUIsS0FBSzVmLEdBQTVCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBVywrQ0FBYixFQUE4REgsU0FBUyxDQUF2RSxFQUZKLEVBR0ksRUFBRUcsV0FBVyw2Q0FBYixFQUE0REgsU0FBUyxDQUFyRSxFQUhKLEVBS0c1akMsS0FMSCxDQUtTLGdCQUFROzs7T0FMakIsQ0FMRjs7Ozs7Ozs7Ozt5QkFxQkdzUixNQWxDUCxFQWtDZS9uQixRQWxDZixFQWtDeUI7aUJBQ1ZBLFdBQVdBLFFBQVgsR0FBc0IsWUFBVyxFQUE1Qzs7YUFFTzJYLE1BQVAsQ0FFRXdpQyxPQUFPcHlCLE9BQU9xeUIsS0FBZCxFQUFxQixLQUFLN2MsR0FBMUIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLENBQVgsRUFEM0IsQ0FGRixFQUtFRixPQUFPcHlCLE9BQU9vMUIsT0FBZCxFQUF1QixLQUFLNWYsR0FBNUIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLDZDQUFiLEVBQTRESCxTQUFTLENBQXJFLEVBRkosRUFHSSxFQUFFRyxXQUFXLCtDQUFiLEVBQThESCxTQUFTLENBQXZFLEVBSEosRUFLRzVqQyxLQUxILENBS1MsZ0JBQVE7OztPQUxqQixDQUxGOzs7O0VBckM0Q3dtQyxtQkFBaEQ7Ozs7O0FBMERBLElBQWFHLHNCQUFiOzs7b0NBRXdGO29GQUFKLEVBQUk7NkJBQXpFaHBDLE1BQXlFO1FBQXpFQSxNQUF5RSxnQ0FBaEUsNkJBQWdFOytCQUFqQ3RQLFFBQWlDO1FBQWpDQSxRQUFpQyxrQ0FBdEIsR0FBc0I7NEJBQWpCQyxLQUFpQjtRQUFqQkEsS0FBaUIsK0JBQVQsQ0FBUzs7OzBJQUM5RSxFQUFDRCxrQkFBRCxFQUFXc1AsY0FBWCxFQUFtQnJQLFlBQW5CLEVBRDhFOzs7Ozs7Ozs7Ozt5QkFRakZnakIsTUFWUCxFQVVlL25CLFFBVmYsRUFVeUI7aUJBQ1ZBLFdBQVdBLFFBQVgsR0FBc0IsWUFBVyxFQUE1Qzs7YUFFTzJYLE1BQVAsQ0FFRXdpQyxPQUFPcHlCLE9BQU9xeUIsS0FBZCxFQUFxQixLQUFLN2MsR0FBMUIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLENBQVgsRUFEM0IsQ0FGRixFQUtFRixPQUFPcHlCLE9BQU9vMUIsT0FBZCxFQUF1QixLQUFLNWYsR0FBNUIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLGlEQUFiLEVBQWdFSCxTQUFTLENBQXpFLEVBRkosRUFHSSxFQUFFRyxXQUFXLDZDQUFiLEVBQTRESCxTQUFTLENBQXJFLEVBSEosRUFLRzVqQyxLQUxILENBS1MsZ0JBQVE7OztPQUxqQixDQUxGOzs7Ozs7Ozs7O3lCQXFCR3NSLE1BbENQLEVBa0NlL25CLFFBbENmLEVBa0N5QjtpQkFDVkEsV0FBV0EsUUFBWCxHQUFzQixZQUFXLEVBQTVDOzthQUVPMlgsTUFBUCxDQUVFd2lDLE9BQU9weUIsT0FBT3F5QixLQUFkLEVBQXFCLEtBQUs3YyxHQUExQixFQUNHZ2QsT0FESCxDQUNXLEVBQUVGLFNBQVMsQ0FBWCxFQURYLEVBQzJCLEVBQUVBLFNBQVMsQ0FBWCxFQUQzQixDQUZGLEVBS0VGLE9BQU9weUIsT0FBT28xQixPQUFkLEVBQXVCLEtBQUs1ZixHQUE1QixFQUNHZ2QsT0FESCxDQUNXLEVBQUVGLFNBQVMsQ0FBWCxFQURYLEVBQzJCLEVBQUVBLFNBQVMsQ0FBWCxFQUQzQixFQUVHNWpDLEtBRkgsQ0FFUyxnQkFBUTs7O09BRmpCLENBTEY7Ozs7RUFyQ3dDd21DLG1CQUE1Qzs7QUN4R0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBVUEsSUFBTXgxQyxXQUFTO21CQUNJLGlCQURKOzZCQUVjLDJCQUZkO3lCQUdVLHVCQUhWOzJCQUlZLHlCQUpaOzBCQUtXLHdCQUxYO3FDQU1zQixtQ0FOdEI7cUNBT3NCLG1DQVB0QjtrQ0FRbUIsZ0NBUm5COzBCQVNXLHdCQVRYOzZCQVVjLHdCQVZkO3dCQVdTLHNCQVhUO2lCQVlFO0NBWmpCOztBQWVBLElBQU11MEMsa0JBQWdCO1VBQ1ppQixtQkFEWTthQUVUO1dBQU16aUQsU0FBU3lDLFNBQVQsS0FBdUJpZ0QsMEJBQXZCLEdBQW9ERSxzQkFBMUQ7R0FGUztVQUdaO1dBQU01aUQsU0FBU3lDLFNBQVQsS0FBdUJpZ0QsMEJBQXZCLEdBQW9ERSxzQkFBMUQ7O0NBSFY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpRHFCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBb0dMOzs7Ozt3QkFHTzthQUFNLE1BQUtuQixRQUFMLEVBQU47S0FBbkI7Ozs7Ozs2Q0FvQ3VCO2FBQ2hCLElBQUl6NEMsZUFBSixDQUFvQjttQkFDZHU0QyxlQURjO21CQUVkaUIsbUJBRmM7dUJBR1YscUJBSFU7MEJBSVAsS0FBS2hqRCxZQUFMLENBQWtCLFdBQWxCO09BSmIsQ0FBUDs7OzsrQkFRUztnQkFDQ3NNLE9BQVYsQ0FBa0IsSUFBbEI7O1dBRUt2TixLQUFMLENBQVdzUixPQUFYLEdBQXFCLE1BQXJCO1dBQ0t0UixLQUFMLENBQVdnUyxNQUFYLEdBQW9CLEtBQXBCOzs7Ozs7Ozs7Ozs7O1VBYU01SixVQUFVbEosU0FBUzh4QixzQkFBVCxFQUFoQjs7VUFFSSxDQUFDLEtBQUtvd0IsS0FBTixJQUFlLENBQUMsS0FBSytDLE9BQXpCLEVBQWtDO2VBQ3pCLEtBQUtuckMsVUFBWixFQUF3QjtrQkFDZHJQLFdBQVIsQ0FBb0IsS0FBS3FQLFVBQXpCOzs7O1VBSUEsQ0FBQyxLQUFLb29DLEtBQVYsRUFBaUI7WUFDVGlDLE9BQU9ua0QsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBYjthQUNLNkgsU0FBTCxDQUFlRSxHQUFmLENBQW1CLG1CQUFuQjthQUNLeUssWUFBTCxDQUFrQnNxQyxJQUFsQixFQUF3QixLQUFLanlDLFFBQUwsQ0FBYyxDQUFkLENBQXhCOzs7VUFHRSxDQUFDLEtBQUsreUMsT0FBVixFQUFtQjtZQUNYcDFCLFNBQVM3dkIsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZjtlQUNPNkgsU0FBUCxDQUFpQkUsR0FBakIsQ0FBcUIsY0FBckI7YUFDS3lLLFlBQUwsQ0FBa0JnVyxNQUFsQixFQUEwQixJQUExQjs7O1VBR0UsQ0FBQ252QixPQUFLOFUsU0FBTCxDQUFlLEtBQUt5dkMsT0FBcEIsRUFBNkIseUJBQTdCLENBQUwsRUFBOEQ7WUFDdER4dEMsWUFBWXpYLFNBQVNxSCxhQUFULENBQXVCLEtBQXZCLENBQWxCO2tCQUNVNkgsU0FBVixDQUFvQkUsR0FBcEIsQ0FBd0Isd0JBQXhCO2FBQ0s2MUMsT0FBTCxDQUFheDZDLFdBQWIsQ0FBeUJnTixTQUF6Qjs7O1dBR0d3dEMsT0FBTCxDQUFhL3lDLFFBQWIsQ0FBc0IsQ0FBdEIsRUFBeUJ6SCxXQUF6QixDQUFxQ3ZCLE9BQXJDOztXQUVLKzdDLE9BQUwsQ0FBYW5rRCxLQUFiLENBQW1CZ1MsTUFBbkIsR0FBNEIsS0FBNUI7V0FDS292QyxLQUFMLENBQVdwaEQsS0FBWCxDQUFpQmdTLE1BQWpCLEdBQTBCLEtBQTFCOzttQkFFYXN4QyxZQUFiLENBQTBCLElBQTFCLEVBQWdDLEtBQUtSLE9BQXJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkExRlk7YUFDTHIwQyxRQUFQOzs7Ozs7Ozs7MkJBTVU7YUFDSDdPLE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixvQkFBckIsQ0FBUDs7Ozs7Ozs7OzJCQU1ZO2FBQ0w5VSxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsZUFBckIsQ0FBUDs7Ozs7Ozs7OzJCQU9rQjthQUNYOVUsT0FBSzhVLFNBQUwsQ0FBZSxLQUFLeXZDLE9BQUwsQ0FBYS95QyxRQUFiLENBQXNCLENBQXRCLENBQWYsRUFBeUMscUJBQXpDLENBQVA7Ozs7Ozs7OzsyQkFNb0I7YUFDYnhSLE9BQUs4VSxTQUFMLENBQWUsS0FBS3l2QyxPQUFMLENBQWEveUMsUUFBYixDQUFzQixDQUF0QixDQUFmLEVBQXlDLHVCQUF6QyxDQUFQOzs7O3FDQWtKc0J6UixNQUFNOEwsVUFBVTtVQUNsQyxFQUFFQSxTQUFTcE0sU0FBVCxZQUE4QjRrRCxtQkFBaEMsQ0FBSixFQUEwRDtlQUNuRHJxQyxhQUFMLENBQW1CLGFBQW5COztzQkFFWWphLElBQWQsSUFBc0I4TCxRQUF0Qjs7OzsyQkFHcUI7YUFDZHUzQyxlQUFQOzs7OzJCQUcrQjthQUN4QmlCLG1CQUFQOzs7O0VBdFM0Q3JDOztBQTBTaEQvbUMsWUFBWXlwQyxXQUFaLEdBQTBCRCxrQkFBMUI7QUFDQTFtQixlQUFlTCxNQUFmLENBQXNCLGtCQUF0QixFQUEwQyttQixrQkFBMUM7O0FDdFlBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1QnFCRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBeUJMO2FBQ0wsRUFBRSxJQUFJLHdCQUFOLEVBQVA7Ozs7MkJBR3NCO2FBQ2YscUJBQVA7Ozs7MkJBR2U7YUFDUixDQUFDLElBQUQsRUFBT3gwQyxTQUFQLEVBQWtCLEVBQUUsWUFBWSxZQUFkLEVBQWxCLENBQVA7Ozs7RUFsQ2tEMHpDOztBQXNDdEQ1b0MsWUFBWTJwQyxpQkFBWixHQUFnQ0Qsd0JBQWhDO0FBQ0E1bUIsZUFBZUwsTUFBZixDQUFzQix5QkFBdEIsRUFBaURpbkIsd0JBQWpEOzs7Ozs7QUNsRkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBU0EsSUFBTUUsbUJBQW1CLGFBQXpCOztBQUVBLElBQU1oMkMsV0FBUztNQUNULGdCQURTO3dCQUVTLHNCQUZUO3lCQUdVO0NBSHpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBc0NxQmkyQzs7Ozs7Ozs7Ozs7K0JBU0w7Ozs7O3dCQUdPLFlBQU07WUFDbEJ4QixRQUFMO0tBREY7O1VBSUt5QixRQUFMLEdBQWdCLEVBQWhCO1VBQ0tDLGFBQUwsR0FBcUIsTUFBS0MsUUFBTCxDQUFjbC9DLElBQWQsT0FBckI7Ozs7OztrQ0FHNkQ7VUFBbkR5ckIsSUFBbUQsdUVBQTVDeHhCLE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixvQkFBckIsQ0FBNEM7O1dBQ3hENUssU0FBTCxHQUFpQnlOLFVBQVVwSyxXQUFWLENBQXNCLElBQXRCLE1BQWdDLFNBQWhDLElBQTZDdk4sT0FBSzRNLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsVUFBdkIsQ0FBN0MsR0FBa0ZzNEMsZ0JBQWxGLEdBQXFHQyxpQkFBdEg7Ozs7K0JBR1M7Z0JBQ0N4M0MsT0FBVixDQUFrQixJQUFsQjs7V0FFS2EsU0FBTCxDQUFlRSxHQUFmLENBQW1CbTJDLGdCQUFuQjs7VUFFSSxDQUFDN2tELE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixxQkFBckIsQ0FBTCxFQUFrRDtZQUMxQ2thLFFBQVFodkIsT0FBS2lXLE1BQUwsQ0FBWSx5QkFBWixDQUFkOztlQUVPLEtBQUtsQixVQUFMLENBQWdCLENBQWhCLENBQVAsRUFBMkI7Z0JBQ25CaEwsV0FBTixDQUFrQixLQUFLZ0wsVUFBTCxDQUFnQixDQUFoQixDQUFsQjs7YUFFR2hMLFdBQUwsQ0FBaUJpbEIsS0FBakI7OztVQUdFLENBQUNodkIsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLG9CQUFyQixDQUFMLEVBQWlEO1lBQ3pDMGMsT0FBT3h4QixPQUFLaVcsTUFBTCxDQUFZLHdCQUFaLENBQWI7YUFDS2l1QyxXQUFMLENBQWlCMXlCLElBQWpCOzthQUVLclksWUFBTCxDQUFrQnFZLElBQWxCLEVBQXdCLEtBQUtoZ0IsUUFBTCxDQUFjLENBQWQsQ0FBeEI7OzthQUdHdUgsWUFBTCxDQUFrQixJQUFsQixFQUF3QjVJLFNBQXhCLEVBQW1DLEVBQUM4WCxRQUFRLEVBQVQsRUFBYSxRQUFRLFNBQXJCLEVBQWdDLGNBQWMsYUFBOUMsRUFBbkM7O21CQUVheTdCLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsUUFBaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBcURTO1VBQ0wsS0FBSzBxQixPQUFULEVBQWtCO2FBQ1hBLE9BQUwsQ0FBYWpvQixLQUFiLENBQW1CLElBQW5CO09BREYsTUFHSztZQUNHL08sWUFBWXZDLE9BQUtpUCxVQUFMLENBQWdCLElBQWhCLEVBQXNCLGVBQXRCLENBQWxCO1lBQ0kxTSxTQUFKLEVBQWU7b0JBQ0g2aUQsT0FBVixDQUFrQixLQUFLMzVDLE9BQXZCOzs7Ozs7d0NBS2M7V0FDYnRFLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLEtBQUs2OUMsYUFBcEMsRUFBbUQsS0FBbkQ7Ozs7NkNBT3VCamxELE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCNnNDLGdCQUF4QixFQUEwQ2gyQyxRQUExQzs7O2FBR0csVUFBTDs7eUJBQ2VvMEMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxRQUFwRCxLQUErRCxLQUFLcTFDLFdBQUwsRUFBL0Q7Ozs7Ozs7MkNBTWlCO1dBQ2hCaDlDLG1CQUFMLENBQXlCLE9BQXpCLEVBQWtDLEtBQUs4OUMsYUFBdkMsRUFBc0QsS0FBdEQ7Ozs7MkJBR0s7V0FDQTVrRCxLQUFMLENBQVdzUixPQUFYLEdBQXFCLGNBQXJCOzs7OzJCQUdLO1dBQ0F0UixLQUFMLENBQVdzUixPQUFYLEdBQXFCLE1BQXJCOzs7OzJCQXpEWTthQUNMLEtBQUtxekMsUUFBWjs7eUJBR1VyeEMsUUFBUTtXQUNicXhDLFFBQUwsR0FBZ0JyeEMsTUFBaEI7Ozs7MkJBMEI4QjthQUN2QixDQUFDLFVBQUQsRUFBYSxPQUFiLENBQVA7Ozs7RUFySDJDb3NDOztBQWtKL0M3a0MsWUFBWW9xQyxVQUFaLEdBQXlCUCxpQkFBekI7QUFDQS9tQixlQUFlTCxNQUFmLENBQXNCLGlCQUF0QixFQUF5Q29uQixpQkFBekM7O0FDck5BOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQU1BLElBQU1ELHFCQUFtQixZQUF6QjtBQUNBLElBQU1oMkMsV0FBUyxFQUFDLElBQUksZUFBTCxFQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvQnFCeTJDOzs7Ozs7Ozs7OztrQ0FTTDs7Ozs7VUFHUDkyQyxTQUFMLENBQWVFLEdBQWYsQ0FBbUJtMkMsa0JBQW5CO2lCQUNhbkIsWUFBYixRQUFnQzcwQyxRQUFoQzs7Ozs7OzZDQU91QjlPLE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCNnNDLGtCQUF4QixFQUEwQ2gyQyxRQUExQzs7YUFFRyxVQUFMO3VCQUNlbzBDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsUUFBcEQ7Ozs7OzsyQkFWMEI7YUFDdkIsQ0FBQyxVQUFELEVBQWEsT0FBYixDQUFQOzs7O0VBakI4Q2l4Qzs7QUFpQ2xEN2tDLFlBQVlzcUMsYUFBWixHQUE0QkQsb0JBQTVCO0FBQ0F2bkIsZUFBZUwsTUFBZixDQUFzQixvQkFBdEIsRUFBNEM0bkIsb0JBQTVDOztBQzlFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUErQ3FCRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQWdDTDthQUNMLEVBQUUsSUFBSSxXQUFOLEVBQVA7Ozs7MkJBR3NCO2FBQ2YsUUFBUDs7OztFQXJDdUMzQjs7QUF5QzNDNW9DLFlBQVl3cUMsTUFBWixHQUFxQkQsYUFBckI7QUFDQXpuQixlQUFlTCxNQUFmLENBQXNCLFlBQXRCLEVBQW9DOG5CLGFBQXBDOztBQzdHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFPQSxJQUFNWCxxQkFBbUIsTUFBekI7QUFDQSxJQUFNaDJDLFdBQVM7TUFDVCxTQURTO2tCQUVHLGdCQUZIO29CQUdLO0NBSHBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF3QnFCNjJDOzs7Ozs7Ozs7Ozt5QkFVTDs7Ozs7d0JBR08sWUFBTTtZQUNsQnBDLFFBQUw7S0FERjs7Ozs7OytCQUtTO1dBR0osSUFBSXRpRCxJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS3dRLFFBQUwsQ0FBY3ZRLE1BQWxDLEVBQTBDRCxHQUExQyxFQUErQztZQUN2QzhJLEtBQUssS0FBSzBILFFBQUwsQ0FBY3hRLENBQWQsQ0FBWDs7WUFFSThJLEdBQUcwRSxTQUFILENBQWE2RyxRQUFiLENBQXNCLE9BQXRCLENBQUosRUFBb0M7YUFDL0I3RyxTQUFILENBQWFFLEdBQWIsQ0FBaUIsYUFBakI7O1NBREYsTUFJSyxJQUFJNUUsR0FBRzBFLFNBQUgsQ0FBYTZHLFFBQWIsQ0FBc0IsU0FBdEIsQ0FBSixFQUFzQzthQUN0QzdHLFNBQUgsQ0FBYUUsR0FBYixDQUFpQixlQUFqQjs7Ozs7Z0JBS01mLE9BQVYsQ0FBa0IsSUFBbEI7V0FDS2EsU0FBTCxDQUFlRSxHQUFmLENBQW1CbTJDLGtCQUFuQjttQkFDYW5CLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsUUFBaEM7Ozs7NkNBT3VCOU8sTUFBTWtPLE1BQU1DLFNBQVM7Y0FDcENuTyxJQUFSO2FBQ08sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I2c0Msa0JBQXhCLEVBQTBDaDJDLFFBQTFDOzthQUVHLFVBQUw7dUJBQ2VvMEMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxRQUFwRDs7Ozs7OzJCQVYwQjthQUN2QixDQUFDLFVBQUQsRUFBYSxPQUFiLENBQVA7Ozs7RUF4Q3FDaXhDOztBQXVEekM3a0MsWUFBWTBxQyxJQUFaLEdBQW1CRCxXQUFuQjtBQUNBM25CLGVBQWVMLE1BQWYsQ0FBc0IsVUFBdEIsRUFBa0Nnb0IsV0FBbEM7O0FDekdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUlBLElBQU03MkMsV0FBUyxFQUFDLElBQUksa0JBQUwsRUFBZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5QnFCKzJDOzs7aUNBRUw7Ozs7O1VBR1B4bEQsS0FBTCxDQUFXdUMsS0FBWCxHQUFtQixNQUFuQjtpQkFDYStnRCxZQUFiLFFBQWdDNzBDLFFBQWhDOzs7Ozs7NkNBT3VCOU8sTUFBTWtPLE1BQU1DLFNBQVM7VUFDeENuTyxTQUFTLFVBQWIsRUFBeUI7ZUFDaEJpTyxhQUFhaTFDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsUUFBcEQsQ0FBUDs7Ozs7MkJBTjRCO2FBQ3ZCLENBQUMsVUFBRCxDQUFQOzs7O0VBVjZDaXhDOztBQW9CakQ3a0MsWUFBWTRxQyxZQUFaLEdBQTJCRCxtQkFBM0I7QUFDQTduQixlQUFlTCxNQUFmLENBQXNCLG1CQUF0QixFQUEyQ2tvQixtQkFBM0M7O0FDOURBLElBQU1FLGVBQWU7WUFDVDtVQUNGLEdBREU7VUFFRixRQUZFO1NBR0gsQ0FBQyxJQUFELEVBQU8sTUFBUCxDQUhHO1NBSUgsQ0FBQyxPQUFELEVBQVUsU0FBVjtHQUxZO2NBT1A7VUFDSixHQURJO1VBRUosT0FGSTtTQUdMLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FISztTQUlMLENBQUMsRUFBRCxFQUFLLGNBQUw7O0NBWFQ7O0lBZXFCQztrQkFDUHpxQyxNQUFaLEVBQW9COzs7Ozs7UUFFWjBxQyxRQUFTLFNBQVRBLEtBQVM7YUFBTSxLQUFOO0tBQWY7MEpBR0dybEQsS0FGSCxDQUVTLEtBRlQsRUFHR0wsT0FISCxDQUdXO2FBQU8sTUFBS0MsR0FBTCxJQUFZK2EsT0FBTy9hLEdBQVAsS0FBZXlsRCxLQUFsQztLQUhYOztTQUtLQyxVQUFMLEdBQWtCM3FDLE9BQU8ycUMsVUFBekIsQ0FSa0I7U0FTYkMsVUFBTCxHQUFrQjVxQyxPQUFPNHFDLFVBQXpCLENBVGtCO1NBVWJDLFFBQUwsR0FBZ0I3cUMsT0FBTzZxQyxRQUFQLElBQW1CLE1BQW5DOztTQUVLQyxrQkFBTCxHQUEwQixZQUFhO1VBQ2pDQyxRQUFRL3FDLE9BQU84cUMsa0JBQVAsSUFBNkI5cUMsT0FBTzhxQyxrQkFBUCx5QkFBekM7Y0FDUSxPQUFPQyxLQUFQLEtBQWlCLFFBQWpCLElBQTZCQSxVQUFVQSxLQUF2QyxHQUErQ0EsS0FBL0MsR0FBdUQsRUFBL0Q7VUFDSUEsUUFBUSxHQUFSLElBQWVBLFFBQVEsR0FBM0IsRUFBZ0M7ZUFDekIzaEQsS0FBTCxDQUFXLCtCQUErQjJoRCxLQUEvQixHQUF1QywyQkFBbEQ7O2FBRUtBLEtBQVA7S0FORjs7O1NBVUtDLFdBQUwsR0FBbUJ0bUQsT0FBS2dVLE9BQUwsQ0FBYUUsY0FBYixLQUFnQyxPQUFuRDs7O1NBR0txeUMsV0FBTCxHQUFtQixLQUFLQSxXQUFMLENBQWlCeGdELElBQWpCLENBQXNCLElBQXRCLENBQW5CO1NBQ0t5Z0QsTUFBTCxHQUFjLEtBQUtBLE1BQUwsQ0FBWXpnRCxJQUFaLENBQWlCLElBQWpCLENBQWQ7U0FDSzBnRCxTQUFMLEdBQWlCLEtBQUtBLFNBQUwsQ0FBZTFnRCxJQUFmLENBQW9CLElBQXBCLENBQWpCO1NBQ0syZ0QsUUFBTCxHQUFnQixLQUFLQSxRQUFMLENBQWMzZ0QsSUFBZCxDQUFtQixJQUFuQixDQUFoQjs7U0FFSzRnRCxnQkFBTCxHQUF3QjNtRCxPQUFLZ1UsT0FBTCxDQUFhRSxjQUFiLEtBQWdDLEtBQXhEOzs7OzsyQkFHb0M7OztxRkFBSixFQUFJO1VBQS9CMHlDLFNBQStCLFFBQS9CQSxTQUErQjtVQUFwQkMsV0FBb0IsUUFBcEJBLFdBQW9COztXQUMvQkMsV0FBTCxHQUFtQixJQUFuQjtXQUNLLytDLE1BQUwsR0FBYyxLQUFLaytDLFVBQUwsR0FBa0J6MEMsUUFBbEIsQ0FBMkIsQ0FBM0IsQ0FBZDtXQUNLdTFDLE9BQUwsR0FBZSxLQUFLZCxVQUFMLEdBQWtCejBDLFFBQWxCLENBQTJCLENBQTNCLENBQWY7VUFDSSxDQUFDLEtBQUt6SixNQUFOLElBQWdCLENBQUMsS0FBS2cvQyxPQUExQixFQUFtQztlQUM1QnJpRCxLQUFMLENBQVcsOEVBQVg7OztVQUdFLENBQUMsS0FBSzRoRCxXQUFWLEVBQXVCO2FBQ2hCUyxPQUFMLENBQWEzbUQsS0FBYixDQUFtQnNSLE9BQW5CLEdBQTZCLE1BQTdCOzs7O1dBSUd1MEMsVUFBTCxHQUFrQnozQyxTQUFsQixDQUE0QkUsR0FBNUIsQ0FBZ0MsWUFBaEM7V0FDSzNHLE1BQUwsQ0FBWXlHLFNBQVosQ0FBc0JFLEdBQXRCLENBQTBCLG1CQUExQjtXQUNLcTRDLE9BQUwsQ0FBYXY0QyxTQUFiLENBQXVCRSxHQUF2QixDQUEyQixvQkFBM0I7OztXQUdLa3hDLGdCQUFMLEdBQXdCLElBQUluZ0MsZUFBSixDQUFvQixLQUFLd21DLFVBQUwsRUFBcEIsRUFDdEIsRUFBRTk3QixpQkFBaUIsQ0FBbkIsRUFBc0JJLGdCQUFnQixJQUF0QyxFQUE0Q2pCLFNBQVMsQ0FBQyxLQUFLcTlCLGdCQUEzRCxFQURzQixDQUF4QjtXQUdLSyxpQkFBTCxHQUF5QixJQUFJcDVCLGdCQUFKLENBQXFCO2VBQU0sT0FBSzFWLE9BQUwsRUFBTjtPQUFyQixDQUF6QjtXQUNLK3VDLGVBQUwsQ0FBcUJMLFNBQXJCO1dBQ0tNLGlCQUFMLENBQXVCTCxXQUF2Qjs7O1dBR0tNLE9BQUwsR0FBZSxLQUFLQyxPQUFMLEdBQWUsS0FBS0MsZ0JBQUwsR0FBd0IsQ0FBdEQ7V0FDS0MsYUFBTDtXQUNLQyxrQkFBTDttQkFDYTtlQUFNLE9BQUtULFdBQUwsSUFBb0IsT0FBS1Msa0JBQUwsRUFBMUI7T0FBYjs7OztVQUlJbm9ELFdBQVdBLE9BQU8rUCxNQUFsQixJQUE0QixLQUFLcU4sWUFBTCxLQUFzQixDQUF0RCxFQUF5RDtlQUNoREsscUJBQVAsQ0FBNkI7aUJBQU0sT0FBS2lxQyxXQUFMLElBQW9CLE9BQUtKLFFBQUwsRUFBMUI7U0FBN0I7Ozs7OzhCQUlNO1dBQ0hJLFdBQUwsR0FBbUIsS0FBbkI7V0FDS0csZUFBTCxDQUFxQixLQUFyQjtXQUNLQyxpQkFBTCxDQUF1QixLQUF2Qjs7V0FFS3RILGdCQUFMLElBQXlCLEtBQUtBLGdCQUFMLENBQXNCOTFCLE9BQXRCLEVBQXpCO1dBQ0svaEIsTUFBTCxHQUFjLEtBQUtnL0MsT0FBTCxHQUFlLEtBQUtuSCxnQkFBTCxHQUF3QixLQUFLb0gsaUJBQUwsR0FBeUIsSUFBOUU7O1dBRUtRLFdBQUwsQ0FBaUIsS0FBakI7Ozs7K0JBR1M7VUFDSHhtRCxJQUFJLEtBQUttbUQsT0FBTCxHQUFlLEtBQUtNLFVBQTlCO1dBQ0tDLE1BQUw7V0FDS0MsY0FBTCxDQUFvQjNtRCxDQUFwQjtXQUNLa1gsT0FBTDs7Ozt5Q0FtQm1CO1VBQ2J4RCxVQUFVLEtBQUt5eEMsUUFBTCxDQUFjdG1ELEtBQWQsQ0FBb0IsY0FBcEIsQ0FBaEI7O1VBRUksQ0FBQzZVLE9BQUwsRUFBYztlQUNQaFEsS0FBTDs7O1VBR0lHLFFBQVE5QixTQUFTMlIsUUFBUSxDQUFSLENBQVQsRUFBcUIsRUFBckIsQ0FBZDthQUNPQSxRQUFRLENBQVIsTUFBZSxHQUFmLEdBQXFCNkUsS0FBS3F1QyxLQUFMLENBQVcvaUQsUUFBUSxHQUFSLEdBQWMsS0FBSzRpRCxVQUE5QixDQUFyQixHQUFpRTVpRCxLQUF4RTs7Ozt5Q0FHbUI7V0FDZDZpRCxNQUFMO1dBQ0tMLGdCQUFMLEdBQXdCOXRDLEtBQUttSixHQUFMLENBQVNuSixLQUFLa0osR0FBTCxDQUFTb2xDLE9BQU8sS0FBS0MsZUFBTCxFQUFQLENBQVQsRUFBeUMsS0FBS0MsU0FBOUMsQ0FBVCxFQUFtRSxDQUFuRSxDQUF4QjtXQUNLWixPQUFMLEdBQWUsS0FBS0MsT0FBTCxHQUFlLEtBQUtZLFdBQUwsR0FBbUIsS0FBS1gsZ0JBQXREO1dBQ0tZLFNBQUwsQ0FBZSxLQUFLZCxPQUFwQjs7OztnQ0FHVXB2QyxRQUFRO1dBQ2JoUSxNQUFMLENBQVl5RyxTQUFaLENBQXNCdUosTUFBdEIsQ0FBNkIsU0FBN0IsRUFBd0NBLE1BQXhDLEVBRGtCOzs7O21DQUlMeEksT0FBcUI7OztVQUFkOUQsT0FBYyx1RUFBSixFQUFJOztXQUM3Qnk4QyxXQUFMLENBQWlCLElBQWpCO2NBQ1EzdUMsS0FBS21KLEdBQUwsQ0FBUyxDQUFULEVBQVluSixLQUFLa0osR0FBTCxDQUFTbFQsS0FBVCxFQUFnQixLQUFLdzRDLFNBQUwsR0FBaUIsQ0FBakMsQ0FBWixDQUFSO1VBQ01JLFNBQVM1dUMsS0FBS21KLEdBQUwsQ0FBUyxDQUFULEVBQVluSixLQUFLa0osR0FBTCxDQUFTLEtBQUsybEMsU0FBZCxFQUF5QixLQUFLaEIsT0FBTCxHQUFlLEtBQUtZLFdBQUwsR0FBbUJ6NEMsS0FBM0QsQ0FBWixDQUFmOztVQUVJM04sU0FBU3VTLFdBQVQsRUFBSixFQUE0Qjs7WUFFcEJwVCxTQUFTLFNBQVRBLE1BQVM7aUJBQWdCdkIsTUFBTUMsU0FBTixDQUFnQnNCLE1BQWhCLENBQXVCdVEsS0FBdkIsQ0FBNkIsRUFBN0IsRUFBaUMrMkMsWUFBakMsQ0FBaEI7U0FBZjtZQUNNQyxXQUFXdm5ELE9BQ2ZmLE9BQUsySixTQUFMLENBQWUsS0FBSzVCLE1BQUwsQ0FBWXlKLFFBQTNCLEVBQXFDM0wsR0FBckMsQ0FBeUMsZ0JBQVE7aUJBQ3hDN0YsT0FBSzJKLFNBQUwsQ0FBZWpCLEtBQUs4SSxRQUFwQixFQUNKeEMsTUFESSxDQUNHO21CQUFTNkcsTUFBTXJILFNBQU4sQ0FBZ0I2RyxRQUFoQixDQUF5QixlQUF6QixDQUFUO1dBREgsQ0FBUDtTQURGLENBRGUsQ0FBakI7O1lBT014UCxNQUFNLElBQUl5bUMsR0FBSixFQUFaO2VBRUUsSUFBSTNqQyxPQUFKLENBQVksbUJBQVc7bUJBQ1pySSxPQUFULENBQWlCLG1CQUFXO2dCQUN0QjJILEdBQUosQ0FBUU8sT0FBUixFQUFpQkEsUUFBUW5ILFlBQVIsQ0FBcUIsT0FBckIsQ0FBakI7b0JBQ1FtTixTQUFSLENBQWtCRSxHQUFsQixDQUFzQix3Q0FBdEI7V0FGRjtnQ0FJc0I5RixPQUF0QjtTQUxGLEVBT0NxbEIsSUFQRCxDQU9NO2lCQUFNLE9BQUtzNkIsU0FBTCxDQUFlSixNQUFmLEVBQXVCMThDLE9BQXZCLENBQU47U0FQTixFQVFDd2lCLElBUkQsQ0FRTTtpQkFBTSxJQUFJdGxCLE9BQUosQ0FBWSxtQkFBVztxQkFDeEJySSxPQUFULENBQWlCLG1CQUFXO3NCQUNsQjBNLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEJuSCxJQUFJa0QsR0FBSixDQUFRUCxPQUFSLENBQTlCO2FBREY7a0NBR3NCSSxPQUF0QjtXQUpVLENBQU47U0FSTixDQURGOztPQVhGLE1BNEJPO2VBQ0UsS0FBSzIvQyxTQUFMLENBQWVKLE1BQWYsRUFBdUIxOEMsT0FBdkIsQ0FBUDs7Ozs7cUNBSWtDO1VBQXZCMDhDLE1BQXVCLHVFQUFkLEtBQUtoQixPQUFTOztnQkFDMUIsS0FBS0MsT0FBZjtVQUNNb0IsUUFBUSxLQUFLVCxTQUFuQjtVQUNFVSxPQUFPLEtBQUtULFdBRGQ7O1VBR0ksS0FBS0EsV0FBTCxLQUFxQixDQUFyQixJQUEwQixDQUFDaG9ELE9BQUtxWixTQUFMLENBQWU4dUMsTUFBZixDQUEvQixFQUF1RDtlQUM5QyxLQUFLZCxnQkFBWjs7O1VBR0VjLFVBQVUsQ0FBZCxFQUFpQjtlQUNSLENBQVA7OztXQUdHLElBQUlubkQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJd25ELEtBQXBCLEVBQTJCeG5ELEdBQTNCLEVBQWdDO1lBQzFCeW5ELE9BQU96bkQsQ0FBUCxJQUFZbW5ELE1BQVosSUFBc0JNLFFBQVF6bkQsSUFBSSxDQUFaLElBQWlCbW5ELE1BQTNDLEVBQW1EO2lCQUMxQ25uRCxDQUFQOzs7O2FBSUd3bkQsUUFBUSxDQUFmOzs7O2dDQUdVOTVDLEtBQUs7YUFDUixDQUFDQSxNQUFNLEtBQU4sR0FBYyxRQUFmLElBQTJCLGVBQWxDLEVBQW1ELFFBQW5ELEVBQTZELEtBQUtnNEMsUUFBbEUsRUFBNEUsSUFBNUU7Ozs7MkJBR0s7OztXQUNBYyxXQUFMLENBQWlCLElBQWpCO1dBQ0tkLFFBQUw7aUJBQ1c7ZUFBTSxPQUFLMytDLE1BQUwsSUFBZSxPQUFLQSxNQUFMLENBQVl5RyxTQUFaLENBQXNCRSxHQUF0QixDQUEwQixRQUExQixDQUFyQjtPQUFYLEVBQXFFLE9BQUssRUFBMUUsRUFISzs7OzsyQkFNQTtXQUNBODRDLFdBQUwsQ0FBaUIsS0FBakI7V0FDS3ovQyxNQUFMLENBQVl5RyxTQUFaLENBQXNCSSxNQUF0QixDQUE2QixRQUE3QixFQUZLOzs7O29DQUtTODVDLGNBQWM7VUFDeEIsS0FBSzlJLGdCQUFULEVBQTJCO1lBQ25CaHFDLFNBQVM4eUMsZUFBZSxJQUFmLEdBQXNCLEtBQXJDO2FBQ0s5SSxnQkFBTCxDQUFzQmhxQyxNQUF0QixFQUE4QixNQUE5QixFQUFzQyxLQUFLNHdDLE1BQTNDO2FBQ0s1RyxnQkFBTCxDQUFzQmhxQyxNQUF0QixFQUE4QixXQUE5QixFQUEyQyxLQUFLMndDLFdBQWhEO2FBQ0szRyxnQkFBTCxDQUFzQmhxQyxNQUF0QixFQUE4QixTQUE5QixFQUF5QyxLQUFLNndDLFNBQTlDOzs7OztzQ0FJY2tDLGFBQWE7VUFDekIsS0FBSzNCLGlCQUFULEVBQTRCO3NCQUV0QixLQUFLQSxpQkFBTCxDQUF1Qm41QixPQUF2QixDQUErQixLQUFLOWxCLE1BQXBDLEVBQTRDLEVBQUUrbEIsV0FBVyxJQUFiLEVBQTVDLENBREosR0FFSSxLQUFLazVCLGlCQUFMLENBQXVCeFUsVUFBdkIsRUFGSjs7Ozs7bUNBTVdvVyxTQUFTO1dBQ2pCekMsUUFBTCxHQUFnQnlDLFdBQVcsTUFBM0I7V0FDSzF3QyxPQUFMOzs7O2tDQUdZMndDLE9BQU87V0FDZDlCLE9BQUwsQ0FBYTNtRCxLQUFiLENBQW1CMG9ELGFBQW5CLEdBQW1DRCxRQUFRLE1BQVIsR0FBaUIsTUFBcEQ7Ozs7dUNBR2lCanVDLFNBQVM7VUFDcEJxVyxJQUFJclcsUUFBUW1KLFNBQWxCO1VBQ01nbEMsVUFBVSxLQUFLNUIsT0FBTCxLQUFpQixDQUFqQixJQUFzQixDQUFDLEtBQUs2QixnQkFBTCxFQUF2QztVQUNNQyxTQUFTLEtBQUs5QixPQUFMLEtBQWlCLEtBQUtpQixTQUF0QixJQUFtQyxDQUFDLEtBQUtZLGdCQUFMLEVBQW5EOzthQUVPLEtBQUtsbEMsVUFBTCxLQUNEbU4sTUFBTSxNQUFOLElBQWdCLENBQUM4M0IsT0FBbEIsSUFBK0I5M0IsTUFBTSxJQUFOLElBQWMsQ0FBQ2c0QixNQUQ1QyxHQUVEaDRCLE1BQU0sT0FBTixJQUFpQixDQUFDODNCLE9BQW5CLElBQWdDOTNCLE1BQU0sTUFBTixJQUFnQixDQUFDZzRCLE1BRnREOzs7O2dDQUtVdjRDLE9BQU87OztXQUNadzRDLFdBQUwsR0FBbUJ4NEMsTUFBTXk0QyxRQUFOLElBQWtCLENBQUNucEQsT0FBSzJhLGNBQUwsQ0FBb0JqSyxLQUFwQixDQUF0Qzs7VUFFSSxDQUFDLEtBQUt3NEMsV0FBVixFQUF1QjtZQUNmRSxVQUFVMTRDLE1BQU0wNEMsT0FBdEI7Y0FDTUEsT0FBTixHQUFnQixZQUFNO3FCQUFhQSxTQUFYLENBQXNCLE9BQUtGLFdBQUwsR0FBbUIsSUFBbkI7U0FBOUM7O1lBRUksS0FBS0csa0JBQUwsQ0FBd0IzNEMsTUFBTWtLLE9BQTlCLENBQUosRUFBNEM7Y0FDcEMwdUMsU0FBUzU0QyxNQUFNa0ssT0FBTixDQUFjcU4sTUFBZCxJQUF3QnZYLE1BQU1rSyxPQUFOLENBQWNxTixNQUFkLENBQXFCMUYsT0FBN0MsSUFBd0QsQ0FBdkU7Y0FDRWduQyxlQUFlLEtBQUtDLGNBQUwsTUFBeUIsQ0FEMUM7Y0FFRTdsQyxRQUFRLFNBQVJBLEtBQVEsR0FBTTt1QkFDRHlsQyxTQUFYO2tCQUNNRCxRQUFOLEdBQWlCLElBQWpCO21CQUNLTSxRQUFMLEdBQWdCLElBQWhCLENBSFk7bUJBSVBuRCxXQUFMLElBQW9CLE9BQUtvRCxhQUFMLENBQW1CLElBQW5CLENBQXBCO21CQUNLeEIsV0FBTCxDQUFpQixJQUFqQjttQkFDSzl0QyxnQkFBTCxDQUFzQixPQUFLd2xDLGdCQUEzQjtXQVJKOzs7bUJBWVMySixZQUFULElBQXlCRCxTQUFVLEtBQUs3QixVQUFMLEdBQWtCOEIsWUFBckQsR0FDSXRRLGFBQWE7bUJBQU0sQ0FBQyxPQUFLaVEsV0FBTixJQUFxQnZsQyxPQUEzQjtXQUFiLENBREosR0FFSUEsT0FGSjs7Ozs7OzJCQU9DalQsT0FBTztVQUNSLENBQUNBLE1BQU1rSyxPQUFQLElBQWtCLEtBQUtzdUMsV0FBdkIsSUFBc0MsQ0FBQyxLQUFLTyxRQUFoRCxFQUEwRDs7OztXQUlyREUsVUFBTCxHQUFrQixJQUFsQixDQUxZO1lBTU4vdEMsZUFBTjs7V0FFS3FzQyxTQUFMLENBQWUsS0FBS2QsT0FBTCxHQUFlLEtBQUt5QyxTQUFMLENBQWVsNUMsS0FBZixDQUE5QixFQUFxRCxFQUFFbTVDLFVBQVUsSUFBWixFQUFyRDs7Ozs4QkFHUW41QyxPQUFPO1dBQ1YrNEMsUUFBTCxHQUFnQixLQUFoQjtVQUNJLENBQUMvNEMsTUFBTWtLLE9BQVAsSUFBa0IsS0FBS3N1QyxXQUF2QixJQUFzQyxDQUFDLEtBQUtTLFVBQWhELEVBQTREO2FBQ3JEVCxXQUFMLEdBQW1CLElBQW5CLENBRDBEOzs7O1dBS3ZEUyxVQUFMLEdBQWtCLEtBQWxCO1lBQ00vdEMsZUFBTjs7VUFFTXVzQyxTQUFTLEtBQUtoQixPQUFMLEdBQWUsS0FBS3lDLFNBQUwsQ0FBZWw1QyxLQUFmLENBQTlCO1VBQ01vNUMsbUJBQW1CLEtBQUtDLGdCQUFMLENBQXNCNUIsTUFBdEIsQ0FBekI7aUJBQ1cyQixnQkFBWCxHQUE4QixLQUFLRSxvQkFBTCxDQUEwQjdCLE1BQTFCLEVBQWtDejNDLEtBQWxDLENBQTlCLEdBQXlFLEtBQUt1NUMsZUFBTCxDQUFxQkgsZ0JBQXJCLENBQXpFO1dBQ0t4RCxXQUFMLElBQW9CLEtBQUtvRCxhQUFMLENBQW1CLEtBQW5CLENBQXBCOzs7O3lDQUdtQnZCLFFBQVF6M0MsT0FBTztVQUM1QmdZLFdBQVcsS0FBS3doQyxZQUFMLENBQWtCeDVDLEtBQWxCLENBQWpCO1VBQ0V5NUMsbUJBQW1CejVDLE1BQU1rSyxPQUFOLENBQWNtTyxnQkFBZCxLQUFtQyxLQUFLcWhDLEVBQUwsQ0FBUUMsR0FBUixDQUFZLEtBQUtULFNBQUwsQ0FBZWw1QyxLQUFmLElBQXdCLENBQXhCLEdBQTRCLENBQTVCLEdBQWdDLENBQTVDLENBRHhEOztVQUdNNDVDLGFBQWEsS0FBS0MsY0FBTCxDQUFvQnBDLE1BQXBCLEVBQTRCei9CLFFBQTVCLEVBQXNDeWhDLGdCQUF0QyxDQUFuQjtVQUNJaitDLFdBQVdxTixLQUFLd0osR0FBTCxDQUFTdW5DLGFBQWFuQyxNQUF0QixLQUFpQ3ovQixXQUFXLElBQTVDLElBQW9ELElBQW5FO2lCQUNXblAsS0FBS2tKLEdBQUwsQ0FBUyxHQUFULEVBQWNsSixLQUFLbUosR0FBTCxDQUFTLEVBQVQsRUFBYXhXLFFBQWIsQ0FBZCxDQUFYOztXQUVLcThDLFNBQUwsQ0FBZStCLFVBQWYsRUFBMkIsRUFBRUUsT0FBTyxJQUFULEVBQWV4K0Msa0JBQWtCLEVBQUVFLGtCQUFGLEVBQVlzUCxRQUFRLDZCQUFwQixFQUFqQyxFQUEzQjs7OztvQ0FHYzJzQyxRQUFROzs7V0FDakJoQixPQUFMLEdBQWVnQixNQUFmO1VBQ01wa0MsWUFBWSxLQUFLcW1DLEVBQUwsQ0FBUUMsR0FBUixDQUFZeEMsT0FBT00sU0FBUyxDQUFoQixDQUFaLENBQWxCO1VBQ01zQyxpQkFBaUIsU0FBakJBLGNBQWlCO2VBQU0sT0FBS2xDLFNBQUwsQ0FBZUosTUFBZixFQUF1QixFQUFFbjhDLGtCQUFrQixFQUFFRSxVQUFVLEVBQVosRUFBZ0JzUCxRQUFRLDZCQUF4QixFQUFwQixFQUF2QixDQUFOO09BQXZCO1dBQ0trdkMsY0FBTCxDQUFvQixFQUFFM21DLG9CQUFGLEVBQWEwbUMsOEJBQWIsRUFBcEIsS0FBc0RBLGdCQUF0RDs7Ozs4QkFHUXRDLFFBQXNCOzs7VUFBZDE4QyxPQUFjLHVFQUFKLEVBQUk7O1VBQ3hCM0QsSUFBSSxFQUFFNmlELGFBQWEsS0FBS0MsY0FBTCxDQUFvQnpDLE1BQXBCLENBQWYsRUFBNEMwQyxpQkFBaUIsS0FBS3hELGdCQUFsRSxFQUFvRm1ELE9BQU8vK0MsUUFBUSsrQyxLQUFSLElBQWlCLEtBQTVHLEVBQVY7VUFDTU0sU0FBU2hqRCxFQUFFNmlELFdBQUYsS0FBa0I3aUQsRUFBRStpRCxlQUFuQztVQUNNakksV0FBV2tJLFNBQVMsS0FBS0MsYUFBTCxDQUFtQmpqRCxDQUFuQixDQUFULEdBQWlDLEtBQWxEOztXQUVLcS9DLE9BQUwsR0FBZXZFLFdBQVcsS0FBS3dFLE9BQUwsR0FBZXQvQyxFQUFFK2lELGVBQUYsR0FBb0IsS0FBSzdDLFdBQW5ELEdBQWlFRyxNQUFoRjtXQUNLZCxnQkFBTCxHQUF3QnpFLFdBQVc5NkMsRUFBRStpRCxlQUFiLEdBQStCL2lELEVBQUU2aUQsV0FBekQ7O2FBRU8sS0FBSzFDLFNBQUwsQ0FBZSxLQUFLZCxPQUFwQixFQUE2QjE3QyxPQUE3QixFQUFzQ3dpQixJQUF0QyxDQUEyQyxZQUFNO1lBQ2xEazZCLFdBQVcsT0FBS2hCLE9BQWhCLElBQTJCLENBQUN2RSxRQUFoQyxFQUEwQztpQkFDbkNzRixXQUFMLENBQWlCLEtBQWpCO29CQUNVLE9BQUs4QyxjQUFMLENBQW9CbGpELENBQXBCLENBQVY7U0FGRixNQUdPLElBQUkyRCxRQUFRNUMsTUFBWixFQUFvQjtpQkFDcEJxL0MsV0FBTCxDQUFpQixLQUFqQjtpQkFDT3YvQyxRQUFRRSxNQUFSLENBQWUsVUFBZixDQUFQOztPQU5HLENBQVA7Ozs7OEJBV1FzL0MsUUFBc0I7OztVQUFkMThDLE9BQWMsdUVBQUosRUFBSTs7VUFDMUJBLFFBQVFvK0MsUUFBWixFQUFzQjtZQUNkeEQsUUFBUSxJQUFkO1lBQ0k4QixTQUFTLENBQWIsRUFBZ0I7bUJBQ0wsS0FBS2EsZ0JBQUwsS0FBMEJ6dkMsS0FBS3F1QyxLQUFMLENBQVdPLFNBQVM5QixLQUFwQixDQUExQixHQUF1RCxDQUFoRTtTQURGLE1BRU87Y0FDQytCLFlBQVksS0FBS0EsU0FBdkI7Y0FDSUEsWUFBWUQsTUFBaEIsRUFBd0I7cUJBQ2IsS0FBS2EsZ0JBQUwsS0FBMEJaLFlBQVk3dUMsS0FBS3F1QyxLQUFMLENBQVcsQ0FBQ08sU0FBU0MsU0FBVixJQUF1Qi9CLEtBQWxDLENBQXRDLEdBQWlGK0IsU0FBMUY7Ozs7O1VBS0E5ekMsTUFBTTdJLFFBQVFHLFNBQVIsS0FBdUIsTUFBdkIsR0FBZ0MsRUFBaEMsR0FBcUNILFFBQVFPLGdCQUF6RDtXQUNLazZDLFVBQUwsSUFBbUIsS0FBSzhCLFdBQUwsR0FBbUIsQ0FBdEMsSUFBMkMsS0FBSzlCLFVBQUwsQ0FBZ0IsQ0FBQ2lDLFNBQVMsS0FBS0gsV0FBZixFQUE0QmlELE9BQTVCLENBQW9DLENBQXBDLENBQWhCLEVBQXdEeC9DLFFBQVFPLGdCQUFSLElBQTRCLEVBQXBGLENBQTNDOzthQUVPLElBQUlyRCxPQUFKLENBQVk7ZUFDakI0NEMsT0FBTyxPQUFLeDVDLE1BQVosRUFDRzhWLEtBREgsQ0FDUyxFQUFFK2pDLFdBQVcsT0FBS3NKLGFBQUwsQ0FBbUIvQyxNQUFuQixDQUFiLEVBRFQsRUFDb0Q3ekMsR0FEcEQsRUFFRzJLLElBRkgsQ0FFUXJXLE9BRlIsQ0FEaUI7T0FBWixDQUFQOzs7O21DQU9hdS9DLFFBQVF6L0IsVUFBVXloQyxrQkFBa0I7VUFDM0N6bkMsTUFBTSxLQUFLMGxDLFNBQWpCO1VBQ0UrQyxTQUFTLEtBQUsvRCxPQURoQjtVQUVFcUIsT0FBTyxLQUFLVCxXQUZkOztVQUlJLENBQUMsS0FBS29ELGdCQUFMLEVBQUwsRUFBOEI7ZUFDckI3eEMsS0FBS21KLEdBQUwsQ0FBUyxDQUFULEVBQVluSixLQUFLa0osR0FBTCxDQUFTQyxHQUFULEVBQWN5bEMsTUFBZCxDQUFaLENBQVA7OztVQUdFMWQsTUFBTSxFQUFWO1dBQ0ssSUFBSTNwQyxJQUFJcXFELE1BQWIsRUFBcUJycUQsSUFBSTRoQixHQUF6QixFQUE4QjVoQixLQUFLMm5ELElBQW5DLEVBQXlDO1lBQ25Dcm5ELElBQUosQ0FBU04sQ0FBVDs7VUFFRU0sSUFBSixDQUFTc2hCLEdBQVQ7O1lBRU0rbkIsSUFDSHRoQixJQURHLENBQ0UsVUFBQ2xYLElBQUQsRUFBT0MsS0FBUDtlQUFpQnFILEtBQUt3SixHQUFMLENBQVM5USxPQUFPazJDLE1BQWhCLElBQTBCNXVDLEtBQUt3SixHQUFMLENBQVM3USxRQUFRaTJDLE1BQWpCLENBQTNDO09BREYsRUFFSG41QyxNQUZHLENBRUksVUFBQ3FpQixJQUFELEVBQU8yUixHQUFQO2VBQWUsQ0FBQ0EsR0FBRCxJQUFRM1IsU0FBU29aLElBQUl6SCxNQUFNLENBQVYsQ0FBaEM7T0FGSixDQUFOOztVQUlJaGhDLFNBQVN5b0MsSUFBSSxDQUFKLENBQWI7VUFDTTRnQixhQUFhLEtBQUtoRSxnQkFBTCxHQUF3Qm9CLElBQXhCLEdBQStCMEMsTUFBbEQ7VUFDTUcsY0FBYy94QyxLQUFLd0osR0FBTCxDQUFTb2xDLFNBQVNrRCxVQUFsQixJQUFnQzVDLElBQXBEOztVQUVJNkMsZUFBZSxLQUFLbEYsa0JBQUwsQ0FBd0IrRCxnQkFBeEIsRUFBMEN6aEMsUUFBMUMsRUFBb0QrL0IsSUFBcEQsQ0FBbkIsRUFBOEU7aUJBQ25FNEMsVUFBVDtPQURGLE1BRU87WUFDREMsY0FBYyxHQUFkLElBQXFCN2dCLElBQUksQ0FBSixNQUFXNGdCLFVBQWhDLElBQThDNWdCLElBQUl4cEMsTUFBSixHQUFhLENBQS9ELEVBQWtFO21CQUN2RHdwQyxJQUFJLENBQUosQ0FBVDs7O2FBR0dseEIsS0FBS21KLEdBQUwsQ0FBUyxDQUFULEVBQVluSixLQUFLa0osR0FBTCxDQUFTQyxHQUFULEVBQWMxZ0IsTUFBZCxDQUFaLENBQVA7Ozs7NkJBR087V0FDRnVwRCxXQUFMLEdBQW1CLEtBQUtDLFlBQUwsR0FBb0JyN0MsU0FBdkM7Ozs7cUNBR2VnNEMsUUFBUTthQUNoQjV1QyxLQUFLbUosR0FBTCxDQUFVbkosS0FBS2tKLEdBQUwsQ0FBUzBsQyxNQUFULEVBQWlCLEtBQUtDLFNBQXRCLENBQVYsRUFBNEMsQ0FBNUMsQ0FBUDs7Ozs4QkFHUTtXQUNIVixNQUFMO1dBQ0tKLGFBQUw7O1VBRUl0bkQsT0FBS3FaLFNBQUwsQ0FBZSxLQUFLOHRDLE9BQXBCLENBQUosRUFBa0M7WUFDMUJnQixTQUFTLEtBQUs0QixnQkFBTCxDQUFzQixLQUFLNUMsT0FBM0IsQ0FBZjttQkFDVyxLQUFLQSxPQUFoQixHQUEwQixLQUFLOEMsZUFBTCxDQUFxQjlCLE1BQXJCLENBQTFCLEdBQXlELEtBQUtJLFNBQUwsQ0FBZUosTUFBZixDQUF6RDtPQUZGLE1BR087YUFDQVosa0JBQUw7OztXQUdHa0UsV0FBTDs7Ozs4QkFVUS82QyxPQUFPO2FBQ1JBLE1BQU1rSyxPQUFOLFdBQXNCLEtBQUt3dkMsRUFBTCxDQUFRc0IsSUFBOUIsQ0FBUDs7OztpQ0FHV2g3QyxPQUFPO2FBQ1hBLE1BQU1rSyxPQUFOLGNBQXlCLEtBQUt3dkMsRUFBTCxDQUFRc0IsSUFBakMsQ0FBUDs7OztrQ0FHWXZELFFBQVE7OEJBQ0UsS0FBS2lDLEVBQUwsQ0FBUXVCLEdBQVIsQ0FBWSxDQUFaLENBQXRCLEdBQXVDLENBQUN4RCxNQUF4QyxHQUFpRCxLQUFLaUMsRUFBTCxDQUFRdUIsR0FBUixDQUFZLENBQVosQ0FBakQ7Ozs7b0NBR2M7V0FDVHZCLEVBQUwsR0FBVXRFLGFBQWEsS0FBS2hpQyxVQUFMLEtBQW9CLFVBQXBCLEdBQWlDLFlBQTlDLENBQVY7V0FDSy9iLE1BQUwsQ0FBWXlHLFNBQVosQ0FBc0J1SixNQUF0QixDQUE2Qiw2QkFBN0IsRUFBNEQsS0FBSytMLFVBQUwsRUFBNUQ7O1dBRUssSUFBSTVlLElBQUksS0FBSzZDLE1BQUwsQ0FBWXlKLFFBQVosQ0FBcUIsQ0FBckIsQ0FBYixFQUFzQ3RNLENBQXRDLEVBQXlDQSxJQUFJQSxFQUFFMG1ELGtCQUEvQyxFQUFtRTtVQUMvRHhyRCxLQUFGLENBQVEsS0FBS2dxRCxFQUFMLENBQVEzQixJQUFSLENBQWEzbUQsV0FBYixFQUFSLElBQXNDLEtBQUtxa0QsUUFBM0M7OztVQUdFLEtBQUswRixVQUFMLEVBQUosRUFBdUI7YUFDaEJ6RSxPQUFMLEdBQWUsQ0FBQyxLQUFLSyxVQUFMLEdBQWtCLEtBQUtPLFdBQXhCLElBQXVDLENBQUMsQ0FBeEMsSUFBNkMsQ0FBNUQ7Ozs7OzJCQTFWWTthQUNQLEtBQUtqZ0QsTUFBTCxDQUFZeUosUUFBWixDQUFxQnZRLE1BQTVCOzs7OzJCQUdnQjtVQUNaLE9BQU8sS0FBS3VxRCxZQUFaLEtBQTZCLFFBQTdCLElBQXlDLEtBQUtBLFlBQUwsS0FBc0IsS0FBS0EsWUFBeEUsRUFBc0Y7YUFDL0VBLFlBQUwsR0FBb0IsS0FBS00sa0JBQUwsRUFBcEI7O2FBRUssS0FBS04sWUFBWjs7OzsyQkFHYztVQUNSOW9DLE1BQU0sS0FBS3FsQyxTQUFMLEdBQWlCLEtBQUtDLFdBQXRCLEdBQW9DLEtBQUtQLFVBQXJEO2FBQ09sdUMsS0FBS3dwQixJQUFMLENBQVVyZ0IsTUFBTSxDQUFOLEdBQVUsQ0FBVixHQUFjQSxHQUF4QixDQUFQLENBRmM7Ozs7MkJBbVRDO1VBQ1gsQ0FBQyxLQUFLNm9DLFdBQVYsRUFBdUI7YUFDaEJBLFdBQUwsR0FBbUIsS0FBS3hqRCxNQUFMLFlBQXFCLEtBQUtxaUQsRUFBTCxDQUFRM0IsSUFBN0IsQ0FBbkI7O2FBRUssS0FBSzhDLFdBQVo7Ozs7OztBQ2hiSjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5QnFCUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBbUtMOzs7Ozt3QkFHTzthQUFNLE1BQUt6SSxRQUFMLEVBQU47S0FBbkI7Ozs7OzsrQkFHUztVQUNIdjdDLFNBQVMsS0FBS3lKLFFBQUwsQ0FBYyxDQUFkLEtBQW9CLEtBQUtBLFFBQUwsQ0FBYyxDQUFkLEVBQWlCN0UsT0FBakIsS0FBNkIsbUJBQWpELElBQXdFLEtBQUs2RSxRQUFMLENBQWMsQ0FBZCxDQUF4RSxJQUE0RmxTLFNBQVNxSCxhQUFULENBQXVCLEtBQXZCLENBQTNHO1VBQ0ksQ0FBQ29CLE9BQU9vQyxVQUFaLEVBQXdCO2VBQ2YsS0FBS2lQLFVBQVosRUFBd0I7aUJBQ2ZyUCxXQUFQLENBQW1CLEtBQUtxUCxVQUF4Qjs7YUFFR3JQLFdBQUwsQ0FBaUJoQyxNQUFqQjs7O09BR0QsS0FBS3lKLFFBQUwsQ0FBYyxDQUFkLENBQUQsSUFBcUIsS0FBS3pILFdBQUwsQ0FBaUJ6SyxTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFqQixDQUFyQjs7V0FFS29ELFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQmhFLElBQWpCLENBQXNCZ0MsTUFBdEIsQ0FBbkI7V0FDS29SLFlBQUwsR0FBb0IsS0FBS0EsWUFBTCxDQUFrQnBULElBQWxCLENBQXVCZ0MsTUFBdkIsQ0FBcEI7Ozs7d0NBR2tCOzs7VUFDZCxDQUFDLEtBQUtpa0QsT0FBVixFQUFtQjthQUNaQSxPQUFMLEdBQWUsSUFBSWpHLE1BQUosQ0FBVztzQkFDWjs7V0FEWTsyQkFFUDttQkFBTSxPQUFLMWtELFlBQUwsQ0FBa0IsZUFBbEIsQ0FBTjtXQUZPOzhCQUdKO21CQUFNLE9BQUs0cUQsZUFBWDtXQUhJO3NCQUlaO21CQUFNLE9BQUtDLFFBQVg7V0FKWTs0QkFLTjttQkFBTSxPQUFLQyxjQUFYO1dBTE07c0JBTVo7bUJBQU0sT0FBS0MsUUFBWDtXQU5ZOzRCQU9OO21CQUFNLE9BQUtDLFVBQVg7V0FQTTtvQkFRZCxLQUFLbEcsUUFSUzswQkFTUixLQUFLbUcsYUFBTCxDQUFtQnZtRCxJQUFuQixDQUF3QixJQUF4QixDQVRRO3lCQVVULEtBQUt3bUQsU0FBTCxDQUFleG1ELElBQWYsQ0FBb0IsSUFBcEIsRUFBMEIsV0FBMUIsQ0FWUzswQkFXUixLQUFLd21ELFNBQUwsQ0FBZXhtRCxJQUFmLENBQW9CLElBQXBCLEVBQTBCLFlBQTFCLENBWFE7dUJBWVgsS0FBS3ltRCxVQUFMLENBQWdCem1ELElBQWhCLENBQXFCLElBQXJCLENBWlc7c0JBYVo7bUJBQWEsT0FBSzBtRCxRQUFMLElBQWlCLE9BQUtBLFFBQUwseUJBQTlCOztTQWJDLENBQWY7O3FCQWdCYSxJQUFiLEVBQW1CO2lCQUFNLE9BQUtULE9BQUwsQ0FBYTNVLElBQWIsQ0FBa0I7dUJBQzlCLE9BQUtucUMsWUFBTCxDQUFrQixXQUFsQixDQUQ4Qjt5QkFFNUIsT0FBS0EsWUFBTCxDQUFrQixjQUFsQjtXQUZVLENBQU47U0FBbkI7Ozs7OzJDQU9tQjtVQUNqQixLQUFLOCtDLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhbEYsV0FBakMsRUFBOEM7YUFDdkNrRixPQUFMLENBQWFsaUMsT0FBYjthQUNLa2lDLE9BQUwsR0FBZSxJQUFmOzs7Ozs2Q0FRcUJqc0QsTUFBTWtPLE1BQU1DLFNBQVM7VUFDeEMsQ0FBQyxLQUFLODlDLE9BQVYsRUFBbUI7Ozs7Y0FJWGpzRCxJQUFSO2FBQ08sV0FBTDtlQUNPaXNELE9BQUwsQ0FBYS9FLGVBQWIsQ0FBNkIsS0FBSy81QyxZQUFMLENBQWtCLFdBQWxCLENBQTdCOzthQUVHLGNBQUw7ZUFDTzgrQyxPQUFMLENBQWE5RSxpQkFBYixDQUErQixLQUFLaDZDLFlBQUwsQ0FBa0IsY0FBbEIsQ0FBL0I7O2FBRUcsYUFBTDtlQUNPZy9DLFFBQUwsSUFBaUIsS0FBS0YsT0FBTCxDQUFhVSxjQUFiLENBQTRCLEtBQUt2RyxRQUFqQyxDQUFqQjs7YUFFRyxZQUFMO2VBQ08rRixRQUFMLElBQWlCLEtBQUtGLE9BQUwsQ0FBYVUsY0FBYixDQUE0QixLQUFLdkcsUUFBakMsQ0FBakI7O2FBRUcsV0FBTDtlQUNPNkYsT0FBTCxDQUFhOXpDLE9BQWI7Ozs7OzRCQUlFO1dBQ0Q4ekMsT0FBTCxDQUFhOTdCLElBQWI7Ozs7NEJBR007V0FDRDg3QixPQUFMLENBQWFwOEIsSUFBYjs7Ozt3Q0FHMkM7VUFBN0I3TCxTQUE2QixRQUE3QkEsU0FBNkI7VUFBbEIwbUMsY0FBa0IsUUFBbEJBLGNBQWtCOztVQUN2Q2tDLGdCQUFnQixLQUFwQjthQUNLdDFDLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLFlBQS9CLEVBQTZDO2tCQUNqQyxJQURpQztxQkFFOUIsS0FBS3V6QyxjQUFMLEVBRjhCOzRCQUFBO3NCQUk3QiwrQkFBVzswQkFDUCxJQUFoQjtrQkFDUTM4QixJQUFSLENBQWF3OEIsY0FBYjs7T0FOSjs7YUFVT2tDLGFBQVA7Ozs7OEJBR1FyMUMsa0JBQTZDO1VBQWhDcXpDLFdBQWdDLFNBQWhDQSxXQUFnQztVQUFuQkUsZUFBbUIsU0FBbkJBLGVBQW1COzthQUNoRHh6QyxtQkFBTCxDQUF5QixJQUF6QixFQUErQkMsU0FBL0IsRUFBMEMsRUFBRXMxQyxVQUFVLElBQVosRUFBa0JqQyx3QkFBbEIsRUFBK0JFLGdDQUEvQixFQUExQzs7OztpQ0FHVzthQUNOeHpDLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLFNBQS9CLEVBQTBDLEVBQUV1MUMsVUFBVSxJQUFaLEVBQTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQTRCYXI5QyxPQUFxQjs7O1VBQWQ5RCxPQUFjLHVFQUFKLEVBQUk7OzttQkFFckIsS0FBS3BLLFlBQUwsQ0FBa0IsV0FBbEIsQ0FEYjswQkFFb0IsS0FBSzZMLFlBQUwsQ0FBa0IsbUJBQWxCLElBQ2RsTixPQUFLcU0scUJBQUwsQ0FBMkIsS0FBS2hMLFlBQUwsQ0FBa0IsbUJBQWxCLENBQTNCLENBRGMsR0FFZCxFQUFFNkssVUFBVSxFQUFaLEVBQWdCc1AsUUFBUSw2QkFBeEI7U0FDRC9QLE9BTEw7O2FBUU8sS0FBS3VnRCxPQUFMLENBQWFyRSxjQUFiLENBQTRCcDRDLEtBQTVCLEVBQW1DOUQsT0FBbkMsRUFDSndpQixJQURJLENBQ0MsWUFBTTtnQkFDRjdtQixRQUFSLFlBQTRCMkosUUFBNUIsSUFBd0N0RixRQUFRckUsUUFBUixRQUF4QztlQUNPdUIsUUFBUUMsT0FBUixRQUFQO09BSEcsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7OztxQ0FpQmU7YUFDUixLQUFLb2pELE9BQUwsQ0FBYXBCLGNBQWIsRUFBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkF5QkduL0MsU0FBUzthQUNMLEtBQUtrOEMsY0FBTCxDQUFvQixLQUFLaUQsY0FBTCxLQUF3QixDQUE1QyxFQUErQ24vQyxPQUEvQyxDQUFQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQXlCR0EsU0FBUzthQUNMLEtBQUtrOEMsY0FBTCxDQUFvQixLQUFLaUQsY0FBTCxLQUF3QixDQUE1QyxFQUErQ24vQyxPQUEvQyxDQUFQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQXlCSUEsU0FBUzthQUNOLEtBQUtrOEMsY0FBTCxDQUFvQixDQUFwQixFQUF1Qmw4QyxPQUF2QixDQUFQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQXlCR0EsU0FBUztXQUNQazhDLGNBQUwsQ0FBb0JwdUMsS0FBS21KLEdBQUwsQ0FBUyxLQUFLcWxDLFNBQUwsR0FBaUIsQ0FBMUIsRUFBNkIsQ0FBN0IsQ0FBcEIsRUFBcUR0OEMsT0FBckQ7Ozs7Ozs7Ozs7Ozs7OEJBVVE7V0FDSHVnRCxPQUFMLENBQWE5ekMsT0FBYjs7Ozs7Ozs7Ozs7Ozs7MkJBV2M7YUFDUCxLQUFLOHpDLE9BQUwsQ0FBYWpFLFNBQXBCOzs7Ozs7Ozs7Ozs7OzJCQVVjO2FBQ1AsS0FBSzc2QyxZQUFMLENBQWtCLFdBQWxCLENBQVA7O3lCQUdZckksT0FBTzthQUNaN0UsT0FBS3dZLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsV0FBM0IsRUFBd0MzVCxLQUF4QyxDQUFQOzs7Ozs7Ozs7Ozs7OzJCQVVZO2FBQ0wsS0FBSzRuRCxRQUFaOzt5QkFHVTVuRCxPQUFPO1VBQ2JBLFNBQVMsRUFBRUEsaUJBQWlCa00sUUFBbkIsQ0FBYixFQUEyQztlQUNwQ3JNLEtBQUw7O1dBRUcrbkQsUUFBTCxHQUFnQjVuRCxLQUFoQjs7Ozs7Ozs7Ozs7OzsyQkFVZTthQUNSLEtBQUtxSSxZQUFMLENBQWtCLGFBQWxCLENBQVA7O3lCQUdhckksT0FBTzthQUNiN0UsT0FBS3dZLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsYUFBM0IsRUFBMEMzVCxLQUExQyxDQUFQOzs7OzJCQUdhO2FBQ04sS0FBS3hELFlBQUwsQ0FBa0IsV0FBbEIsTUFBbUMsVUFBMUM7Ozs7MkJBR2E7VUFDUHdyRCxlQUFlLENBQUMsS0FBS3hyRCxZQUFMLFlBQTBCLEtBQUs2cUQsUUFBTCxHQUFnQixRQUFoQixHQUEyQixPQUFyRCxNQUFtRSxFQUFwRSxFQUF3RXJxRCxJQUF4RSxFQUFyQjthQUNPZ3JELGFBQWFodEQsS0FBYixDQUFtQixhQUFuQixJQUFvQ2d0RCxZQUFwQyxHQUFtRCxNQUExRDs7Ozs7Ozs7Ozs7OzsyQkFVb0I7YUFDYkMsV0FBVyxLQUFLenJELFlBQUwsQ0FBa0IsbUJBQWxCLENBQVgsQ0FBUDs7eUJBR2tCZ2xELE9BQU87V0FDcEJyNUMsWUFBTCxDQUFrQixtQkFBbEIsRUFBdUNxNUMsS0FBdkM7Ozs7Ozs7Ozs7Ozs7MkJBVWE7YUFDTixLQUFLbjVDLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7eUJBR1dySSxPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7Ozs7Ozs7Ozs7Ozs7MkJBVW1CO2FBQ1osS0FBS3FJLFlBQUwsQ0FBa0IsZ0JBQWxCLENBQVA7O3lCQUdpQnJJLE9BQU87YUFDakI3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixnQkFBM0IsRUFBNkMzVCxLQUE3QyxDQUFQOzs7Ozs7Ozs7Ozs7OzJCQVVhO2FBQ04sS0FBS3FJLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7eUJBR1dySSxPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7Ozs7MkJBbFc4QjthQUN2QixDQUFDLFdBQUQsRUFBYyxjQUFkLEVBQThCLFdBQTlCLEVBQTJDLGFBQTNDLEVBQTBELFlBQTFELENBQVA7Ozs7MkJBb1drQjthQUNYLENBQUMsWUFBRCxFQUFlLFNBQWYsRUFBMEIsWUFBMUIsQ0FBUDs7OztFQTlqQnlDaTdDOztBQWtrQjdDN2tDLFlBQVk4eEMsUUFBWixHQUF1QmhCLGVBQXZCO0FBQ0FodUIsZUFBZUwsTUFBZixDQUFzQixjQUF0QixFQUFzQ3F1QixlQUF0Qzs7QUNubkJBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0NxQmlCOzs7d0JBRUw7Ozs7O1FBR1IsTUFBSzNyRCxZQUFMLENBQWtCLE9BQWxCLENBQUosRUFBZ0M7WUFDekI0ckQsWUFBTDs7Ozs7Ozs2Q0FRcUJsdEQsTUFBTWtPLE1BQU1DLFNBQVM7VUFDeENuTyxTQUFTLE9BQWIsRUFBc0I7YUFDZmt0RCxZQUFMOzs7OzttQ0FJVztVQUNUdHFELFFBQVEsS0FBS3RCLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBWjtVQUNJLENBQUNzQixLQUFMLEVBQVk7ZUFDSGxDLEtBQVAsQ0FBYSxJQUFiLEVBQW1CLGVBQW5CO09BREYsTUFFTztnQkFDR2tDLE1BQU1kLElBQU4sR0FBYWhDLEtBQWIsQ0FBbUIsT0FBbkIsSUFBOEI4QyxRQUFRLEdBQXRDLEdBQTRDQSxLQUFwRDs7ZUFFTyxJQUFQLEVBQWE7Z0JBQ0wsU0FBU0EsS0FESjtvQkFFREE7U0FGWjs7Ozs7MkJBakI0QjthQUN2QixDQUFDLE9BQUQsQ0FBUDs7OztFQVhvQ205Qzs7QUFtQ3hDN2tDLFlBQVlpeUMsR0FBWixHQUFrQkYsVUFBbEI7QUFDQWp2QixlQUFlTCxNQUFmLENBQXNCLFNBQXRCLEVBQWlDc3ZCLFVBQWpDOztBQzdGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFHYUcsY0FBYjs7OzRCQUVtRTttRkFBSixFQUFJOzJCQUFwRDN4QyxNQUFvRDtRQUFwREEsTUFBb0QsK0JBQTNDLFFBQTJDOzBCQUFqQ3JQLEtBQWlDO1FBQWpDQSxLQUFpQyw4QkFBekIsQ0FBeUI7NkJBQXRCRCxRQUFzQjtRQUF0QkEsUUFBc0IsaUNBQVgsR0FBVzs7OzBIQUN6RCxFQUFFc1AsY0FBRixFQUFVclAsWUFBVixFQUFpQkQsa0JBQWpCLEVBRHlEOzs7Ozs7Ozs7Ozt5QkFRNURpakIsTUFWUCxFQVVlNVIsSUFWZixFQVVxQjs7Ozs7Ozs7Ozs7eUJBUWQ0UixNQWxCUCxFQWtCZTVSLElBbEJmLEVBa0JxQjs7Ozs7RUFsQmVpakMsWUFBcEM7Ozs7O0FBMEJBLElBQWE0TSxxQkFBYjs7O21DQUV3RTtvRkFBSixFQUFJOzZCQUF6RDV4QyxNQUF5RDtRQUF6REEsTUFBeUQsZ0NBQWhELGFBQWdEOzRCQUFqQ3JQLEtBQWlDO1FBQWpDQSxLQUFpQywrQkFBekIsQ0FBeUI7K0JBQXRCRCxRQUFzQjtRQUF0QkEsUUFBc0Isa0NBQVgsR0FBVzs7O3dJQUM5RCxFQUFDc1AsY0FBRCxFQUFTclAsWUFBVCxFQUFnQkQsa0JBQWhCLEVBRDhEOzs7Ozs7Ozs7Ozt5QkFRakVpakIsTUFWUCxFQVVlL25CLFFBVmYsRUFVeUI7aUJBQ1ZBLFdBQVdBLFFBQVgsR0FBc0IsWUFBVyxFQUE1Qzs7YUFFTzJYLE1BQVAsQ0FFRXdpQyxPQUFPcHlCLE9BQU9xeUIsS0FBZCxFQUFxQixLQUFLN2MsR0FBMUIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLENBQVgsRUFEM0IsQ0FGRixFQUtFRixPQUFPcHlCLE9BQU9vMUIsT0FBZCxFQUF1QixLQUFLNWYsR0FBNUIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLDRCQUFiLEVBQTJDSCxTQUFTLENBQXBELEVBRkosRUFHSSxFQUFFRyxXQUFXLDRCQUFiLEVBQTJDSCxTQUFTLENBQXBELEVBSEosRUFLRzVqQyxLQUxILENBS1MsZ0JBQVE7OztPQUxqQixDQUxGOzs7Ozs7Ozs7O3lCQXFCR3NSLE1BbENQLEVBa0NlL25CLFFBbENmLEVBa0N5QjtpQkFDVkEsV0FBV0EsUUFBWCxHQUFzQixZQUFXLEVBQTVDOzthQUVPMlgsTUFBUCxDQUVFd2lDLE9BQU9weUIsT0FBT3F5QixLQUFkLEVBQXFCLEtBQUs3YyxHQUExQixFQUNHZ2QsT0FESCxDQUNXLEVBQUVGLFNBQVMsQ0FBWCxFQURYLEVBQzJCLEVBQUVBLFNBQVMsQ0FBWCxFQUQzQixDQUZGLEVBS0VGLE9BQU9weUIsT0FBT28xQixPQUFkLEVBQXVCLEtBQUs1ZixHQUE1QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsNEJBQWIsRUFBMkNILFNBQVMsQ0FBcEQsRUFGSixFQUdJLEVBQUVHLFdBQVcsNEJBQWIsRUFBMkNILFNBQVMsQ0FBcEQsRUFISixFQUtHNWpDLEtBTEgsQ0FLUyxnQkFBUTs7O09BTGpCLENBTEY7Ozs7RUFyQ3VDc3ZDLGNBQTNDOzs7OztBQTBEQSxJQUFhRSxpQkFBYjs7OytCQUV3RTtvRkFBSixFQUFJOzZCQUF6RDd4QyxNQUF5RDtRQUF6REEsTUFBeUQsZ0NBQWhELGFBQWdEOzRCQUFqQ3JQLEtBQWlDO1FBQWpDQSxLQUFpQywrQkFBekIsQ0FBeUI7K0JBQXRCRCxRQUFzQjtRQUF0QkEsUUFBc0Isa0NBQVgsR0FBVzs7OztzSUFDOUQsRUFBQ3NQLGNBQUQsRUFBU3JQLFlBQVQsRUFBZ0JELGtCQUFoQixFQUQ4RDs7V0FHL0RvaEQsVUFBTCxHQUFrQmh1RCxTQUFTbUksSUFBVCxDQUFjczZDLFlBQWhDLENBSG9FOzs7Ozs7Ozs7Ozs7eUJBVWpFNXlCLE1BWlAsRUFZZS9uQixRQVpmLEVBWXlCO2lCQUNWQSxXQUFXQSxRQUFYLEdBQXNCLFlBQVcsRUFBNUM7O2FBRU8yWCxNQUFQLENBRUV3aUMsT0FBT3B5QixPQUFPcXlCLEtBQWQsRUFBcUIsS0FBSzdjLEdBQTFCLEVBQ0dnZCxPQURILENBQ1csRUFBRUYsU0FBUyxDQUFYLEVBRFgsRUFDMkIsRUFBRUEsU0FBUyxDQUFYLEVBRDNCLENBRkYsRUFLRUYsT0FBT3B5QixPQUFPbzFCLE9BQWQsRUFBdUIsS0FBSzVmLEdBQTVCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsbUNBQWdDLEtBQUswTCxVQUFMLEdBQWtCLEdBQWxCLEdBQXdCLENBQXhELFlBQUYsRUFGSixFQUdJLEVBQUUxTCxXQUFXLDRCQUFiLEVBSEosRUFLRy9qQyxLQUxILENBS1MsZ0JBQVE7OztPQUxqQixDQUxGOzs7Ozs7Ozs7O3lCQXFCR3NSLE1BcENQLEVBb0NlL25CLFFBcENmLEVBb0N5QjtpQkFDVkEsV0FBV0EsUUFBWCxHQUFzQixZQUFXLEVBQTVDOzthQUVPMlgsTUFBUCxDQUVFd2lDLE9BQU9weUIsT0FBT3F5QixLQUFkLEVBQXFCLEtBQUs3YyxHQUExQixFQUNHZ2QsT0FESCxDQUNXLEVBQUVGLFNBQVMsQ0FBWCxFQURYLEVBQzJCLEVBQUVBLFNBQVMsQ0FBWCxFQUQzQixDQUZGLEVBS0VGLE9BQU9weUIsT0FBT28xQixPQUFkLEVBQXVCLEtBQUs1ZixHQUE1QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsNEJBQWIsRUFGSixFQUdJLEVBQUVBLG1DQUFnQyxLQUFLMEwsVUFBTCxHQUFrQixHQUFsQixHQUF3QixDQUF4RCxZQUFGLEVBSEosRUFLR3p2QyxLQUxILENBS1MsZ0JBQVE7OztPQUxqQixDQUxGOzs7O0VBdkNtQ3N2QyxjQUF2Qzs7Ozs7QUE0REEsSUFBYUksbUJBQWI7OztpQ0FFd0Y7b0ZBQUosRUFBSTs2QkFBekUveEMsTUFBeUU7UUFBekVBLE1BQXlFLGdDQUFoRSw2QkFBZ0U7NEJBQWpDclAsS0FBaUM7UUFBakNBLEtBQWlDLCtCQUF6QixDQUF5QjsrQkFBdEJELFFBQXNCO1FBQXRCQSxRQUFzQixrQ0FBWCxHQUFXOzs7OzBJQUM5RSxFQUFDc1AsY0FBRCxFQUFTclAsWUFBVCxFQUFnQkQsa0JBQWhCLEVBRDhFOztXQUcvRW9oRCxVQUFMLEdBQWtCaHVELFNBQVNtSSxJQUFULENBQWNzNkMsWUFBaEMsQ0FIb0Y7Ozs7Ozs7Ozs7Ozt5QkFVakY1eUIsTUFaUCxFQVllL25CLFFBWmYsRUFZeUI7aUJBQ1ZBLFdBQVdBLFFBQVgsR0FBc0IsWUFBVyxFQUE1Qzs7YUFFTzJYLE1BQVAsQ0FFRXdpQyxPQUFPcHlCLE9BQU9xeUIsS0FBZCxFQUFxQixLQUFLN2MsR0FBMUIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLENBQVgsRUFEM0IsQ0FGRixFQUtFRixPQUFPcHlCLE9BQU9vMUIsT0FBZCxFQUF1QixLQUFLNWYsR0FBNUIsRUFDR2dkLE9BREg7O1FBR01DLG1DQUFnQyxFQUFHLEtBQUswTCxVQUFMLEdBQWtCLEdBQXJCLElBQTRCLENBQTVCLEdBQWdDbitCLE9BQU9vMUIsT0FBUCxDQUFleEMsWUFBL0UsWUFBRixFQUhKLEVBSUksRUFBRUgsV0FBVyw0QkFBYixFQUpKLEVBTUcvakMsS0FOSCxDQU1TLGdCQUFROzs7T0FOakIsQ0FMRjs7Ozs7Ozs7Ozt5QkFzQkdzUixNQXJDUCxFQXFDZS9uQixRQXJDZixFQXFDeUI7aUJBQ1ZBLFdBQVdBLFFBQVgsR0FBc0IsWUFBVyxFQUE1Qzs7YUFFTzJYLE1BQVAsQ0FFRXdpQyxPQUFPcHlCLE9BQU9xeUIsS0FBZCxFQUFxQixLQUFLN2MsR0FBMUIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLENBQVgsRUFEM0IsQ0FGRixFQUtFRixPQUFPcHlCLE9BQU9vMUIsT0FBZCxFQUF1QixLQUFLNWYsR0FBNUIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLDRCQUFiLEVBRko7O1FBSU1BLG1DQUFnQyxFQUFHLEtBQUswTCxVQUFMLEdBQWtCLEdBQXJCLElBQTRCLENBQTVCLEdBQWdDbitCLE9BQU9vMUIsT0FBUCxDQUFleEMsWUFBL0UsWUFBRixFQUpKLEVBTUdsa0MsS0FOSCxDQU1TLGdCQUFROzs7T0FOakIsQ0FMRjs7OztFQXhDcUNzdkMsY0FBekM7O0FDcEtBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQVVBLElBQU10K0MsV0FBUzthQUNGLFdBREU7dUJBRVEscUJBRlI7a0JBR0c7Q0FIbEI7O0FBTUEsSUFBTXUwQyxrQkFBZ0I7YUFDVDtXQUFNeGhELFNBQVN5QyxTQUFULEtBQXVCK29ELHFCQUF2QixHQUErQ0MsaUJBQXJEO0dBRFM7V0FFWEUsbUJBRlc7VUFHWko7Q0FIVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE0Q3FCSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBb0dMOzs7Ozt3QkFHTzthQUFNLE1BQUtsSyxRQUFMLEVBQU47S0FBbkI7Ozs7Ozs2Q0FldUI7YUFDaEIsSUFBSXo0QyxlQUFKLENBQW9CO21CQUNkdTRDLGVBRGM7bUJBRWQrSixjQUZjO3VCQUdWLGdCQUhVOzBCQUlQLEtBQUs5ckQsWUFBTCxDQUFrQixXQUFsQjtPQUpiLENBQVA7Ozs7K0JBUVM7Z0JBQ0NzTSxPQUFWLENBQWtCLElBQWxCOztXQUVLdk4sS0FBTCxDQUFXc1IsT0FBWCxHQUFxQixNQUFyQjtXQUNLdFIsS0FBTCxDQUFXZ1MsTUFBWCxHQUFvQixLQUFwQjs7Ozs7Ozs7Ozs7VUFXSSxDQUFDLEtBQUtteUMsT0FBVixFQUFtQjtZQUNYcDFCLFNBQVM3dkIsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZjtlQUNPNkgsU0FBUCxDQUFpQkUsR0FBakIsQ0FBcUIsUUFBckI7O1lBRU1xSSxZQUFZelgsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBbEI7a0JBQ1U2SCxTQUFWLENBQW9CRSxHQUFwQixDQUF3QixrQkFBeEI7ZUFDTyxLQUFLMEssVUFBWixFQUF3QjtvQkFDWnJQLFdBQVYsQ0FBc0IsS0FBS3FQLFVBQTNCOztlQUVLclAsV0FBUCxDQUFtQmdOLFNBQW5COzthQUVLaE4sV0FBTCxDQUFpQm9sQixNQUFqQjs7O1VBR0UsQ0FBQyxLQUFLcXlCLEtBQVYsRUFBaUI7WUFDVGlDLE9BQU9ua0QsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBYjthQUNLNkgsU0FBTCxDQUFlRSxHQUFmLENBQW1CLGFBQW5CO2FBQ0t5SyxZQUFMLENBQWtCc3FDLElBQWxCLEVBQXdCLEtBQUtycUMsVUFBN0I7OztXQUdHbXJDLE9BQUwsQ0FBYW5rRCxLQUFiLENBQW1CZ1MsTUFBbkIsR0FBNEIsS0FBNUI7V0FDS292QyxLQUFMLENBQVdwaEQsS0FBWCxDQUFpQmdTLE1BQWpCLEdBQTBCLEtBQTFCOztXQUVLcEYsWUFBTCxDQUFrQixpQkFBbEIsRUFBcUMsRUFBckM7O21CQUVhMDJDLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0MsS0FBS1IsT0FBckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkE3RFk7YUFDTHIwQyxRQUFQOzs7OzJCQUdVO2FBQ0g3TyxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsY0FBckIsQ0FBUDs7OzsyQkFHWTthQUNMOVUsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLFNBQXJCLENBQVA7Ozs7cUNBd0lzQi9VLE1BQU04TCxVQUFVO1VBQ2xDLEVBQUVBLFNBQVNwTSxTQUFULFlBQThCMHRELGNBQWhDLENBQUosRUFBcUQ7ZUFDOUNuekMsYUFBTCxDQUFtQixRQUFuQjs7c0JBRVlqYSxJQUFkLElBQXNCOEwsUUFBdEI7Ozs7MkJBR3FCO2FBQ2R1M0MsZUFBUDs7OzsyQkFHMEI7YUFDbkIrSixjQUFQOzs7O0VBdlF1Q25MOztBQTJRM0MvbUMsWUFBWXd5QyxNQUFaLEdBQXFCRCxhQUFyQjtBQUNBenZCLGVBQWVMLE1BQWYsQ0FBc0IsWUFBdEIsRUFBb0M4dkIsYUFBcEM7O0FDelZBOzs7Ozs7Ozs7Ozs7O0FBYUEsQUFRQSxJQUFNM0kscUJBQW1CLEtBQXpCOztBQUVBLElBQU1oMkMsV0FBUztNQUNULFFBRFM7Z0JBRUM7Q0FGaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF3QnFCNitDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBZ0NMOzs7Ozs7O1VBS1A5OUIsSUFBTDtVQUNLcGhCLFNBQUwsQ0FBZUUsR0FBZixDQUFtQm0yQyxrQkFBbkI7O3dCQUVtQixZQUFNO1lBQ2xCdkIsUUFBTDtLQURGOzs7Ozs7K0JBS1M7Z0JBQ0MzMUMsT0FBVixDQUFrQixJQUFsQjs7VUFFSSxDQUFDM04sT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLFlBQXJCLENBQUwsRUFBeUM7WUFDakN0TSxVQUFVbEosU0FBU3FILGFBQVQsQ0FBdUIsTUFBdkIsQ0FBaEI7Z0JBQ1E2SCxTQUFSLENBQWtCRSxHQUFsQixDQUFzQixXQUF0Qjs7ZUFFSy9FLFNBQUwsQ0FBZSxLQUFLb0wsVUFBcEIsRUFBZ0N6VSxPQUFoQyxDQUF3QyxtQkFBVztjQUM3QyxDQUFDSCxRQUFRd00sT0FBVCxJQUFvQnhNLFFBQVF3TSxPQUFSLENBQWdCN0ssV0FBaEIsT0FBa0MsWUFBMUQsRUFBd0U7b0JBQzlEaUksV0FBUixDQUFvQjVKLE9BQXBCOztTQUZKO2FBS0s0SixXQUFMLENBQWlCdkIsT0FBakI7OztXQUdHdzdDLGFBQUw7O21CQUVhTixZQUFiLENBQTBCLElBQTFCLEVBQWdDNzBDLFFBQWhDOztXQUVLdW9CLGVBQUw7Ozs7d0NBR2tCOzs7bUJBQ0w7ZUFBTSxPQUFLbEgsSUFBTCxFQUFOO09BQWI7Ozs7NkNBT3VCbndCLE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCNnNDLGtCQUF4QixFQUEwQ2gyQyxRQUExQzs7YUFFRyxVQUFMO3VCQUNlbzBDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsUUFBcEQ7O2FBRUcsUUFBTDtlQUNPbTFDLGFBQUw7O2FBRUcsVUFBTDtlQUNPNXNCLGVBQUw7Ozs7Ozs0QkFLRTtXQUNEbEgsSUFBTDs7Ozs0QkFHTTs7O21CQUNPO2VBQU0sT0FBS04sSUFBTCxFQUFOO09BQWI7Ozs7b0NBR2M7YUFDVDdXLFlBQUwsQ0FBa0IsSUFBbEI7Ozs7c0NBR2dCO1VBQ1ZSLFdBQVcsS0FBS2xYLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBakI7V0FDS21OLFNBQUwsQ0FBZUksTUFBZixDQUNFLGdCQURGLEVBRUUsb0JBRkYsRUFHRSxtQkFIRixFQUlFLGlCQUpGLEVBS0Usa0JBTEYsRUFNRSxxQkFORjtjQU9RMkosUUFBUjthQUNPLFdBQUw7YUFDSyxXQUFMO2VBQ08vSixTQUFMLENBQWVFLEdBQWYsQ0FBbUIsaUJBQW5COzthQUVHLFVBQUw7YUFDSyxVQUFMO2VBQ09GLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixnQkFBbkI7O2FBRUcsY0FBTDthQUNLLGNBQUw7ZUFDT0YsU0FBTCxDQUFlRSxHQUFmLENBQW1CLG9CQUFuQjs7YUFFRyxhQUFMO2FBQ0ssYUFBTDtlQUNPRixTQUFMLENBQWVFLEdBQWYsQ0FBbUIsbUJBQW5COzthQUVHLFlBQUw7YUFDSyxZQUFMO2VBQ09GLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixrQkFBbkI7O2FBRUcsZUFBTDthQUNLLGVBQUw7ZUFDT0YsU0FBTCxDQUFlRSxHQUFmLENBQW1CLHFCQUFuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBY0M7V0FDQXFKLE1BQUwsQ0FBWSxJQUFaOzs7Ozs7Ozs7Ozs7OzJCQVVLO1dBQ0FBLE1BQUwsQ0FBWSxLQUFaOzs7Ozs7Ozs7Ozs7OzZCQVU2QjtVQUF4Qm5DLE1BQXdCLHVFQUFmLENBQUMsS0FBSzJkLE9BQVM7O1VBQ3ZCbzZCLFdBQVcsQ0FBQyxLQUFLdHNELFlBQUwsQ0FBa0IsVUFBbEIsS0FBaUMsRUFBbEMsRUFBc0NGLE9BQXRDLENBQThDLFFBQTlDLEtBQTJELENBQTVFO1VBQ015c0QsWUFBWUQsbUNBQWdDM3RELE9BQUtnVSxPQUFMLENBQWE2NUMsU0FBYixJQUEwQixDQUExRCxpQkFBd0UsRUFBMUY7O2FBRU8sSUFBUCxFQUFhLEVBQUVqTSxXQUFjZ00sU0FBZCxlQUFpQy9GLE9BQU9qeUMsTUFBUCxDQUFqQyxNQUFGLEVBQWI7Ozs7Ozs7Ozs7Ozs7eUJBVVcvUSxPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7OzJCQUdhO2FBQ04sS0FBS3FJLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7MkJBV1k7YUFDTCxLQUFLOU0sS0FBTCxDQUFXd2hELFNBQVgsQ0FBcUJ6Z0QsT0FBckIsQ0FBNkIsVUFBN0IsTUFBNkMsQ0FBQyxDQUE5QyxJQUFtRCxLQUFLZixLQUFMLENBQVdzUixPQUFYLEtBQXVCLE1BQWpGOzs7OzJCQXBJOEI7YUFDdkIsQ0FBQyxVQUFELEVBQWEsUUFBYixFQUF1QixVQUF2QixFQUFtQyxPQUFuQyxDQUFQOzs7O0VBeEVvQ291Qzs7QUErTXhDN2tDLFlBQVk2eUMsR0FBWixHQUFrQkosVUFBbEI7QUFDQTN2QixlQUFlTCxNQUFmLENBQXNCLFNBQXRCLEVBQWlDZ3dCLFVBQWpDOztBQy9QQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZ0NxQks7OztvQ0FDTDs7Ozs7VUFHUG5PLGdCQUFMLEdBQXdCLElBQUluZ0MsZUFBSixRQUEwQixFQUFFNkosU0FBUyxJQUFYLEVBQTFCLENBQXhCOzs7OztFQUpnRHcyQjs7QUFRcEQ3a0MsWUFBWXdFLGVBQVosR0FBOEJzdUMsc0JBQTlCO0FBQ0Fod0IsZUFBZUwsTUFBZixDQUFzQixzQkFBdEIsRUFBOENxd0Isc0JBQTlDOztBQzlEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFLQSxJQUFJQyxhQUFhLElBQWpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQStCcUJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQWtFTDs7Ozs7VUFHUDNLLFFBQUw7Ozs7Ozs2Q0FPdUJ2akQsTUFBTWtPLE1BQU1DLFNBQVM7V0FDdkNnZ0Qsb0JBQUwsQ0FBMEJudUQsU0FBUyxNQUFULEdBQWtCa08sSUFBbEIsR0FBeUIsS0FBSzVNLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBbkQsRUFBOEV0QixTQUFTLFVBQVQsR0FBc0JrTyxJQUF0QixHQUE2QmtDLFNBQTNHO1dBQ0tnK0MsT0FBTDs7OzsrQkFHUztnQkFDQ3hnRCxPQUFWLENBQWtCLElBQWxCO1dBQ0t3Z0QsT0FBTDs7Ozs4QkFHUTs7O2lDQUNtQixLQUFLQyxtQkFBTCxDQUF5QixLQUFLQyxVQUFMLENBQWdCLE1BQWhCLENBQXpCLEVBQWtELEtBQUtBLFVBQUwsQ0FBZ0IsTUFBaEIsQ0FBbEQsQ0FEbkI7VUFDRDcvQyxTQURDLHdCQUNEQSxTQURDO1VBQ1VwTyxLQURWLHdCQUNVQSxLQURWOzthQUVIMkwsTUFBTCxDQUFZLEtBQUszTCxLQUFqQixFQUF3QkEsS0FBeEI7O2dCQUVVRSxPQUFWLENBQWtCO2VBQWEsT0FBS2tPLFNBQUwsQ0FBZUUsR0FBZixDQUFtQndILFNBQW5CLENBQWI7T0FBbEI7Ozs7K0JBR1NzbUMsVUFBMEQ7VUFBaEQzdUMsUUFBZ0QsdUVBQXJDLEtBQUt4TSxZQUFMLENBQWtCLFVBQWxCLEtBQWlDLEVBQUk7O1VBQzdEaXRELE9BQU8sS0FBS2p0RCxZQUFMLENBQWtCbTdDLFFBQWxCLEtBQStCQSxRQUEvQixJQUEyQyxFQUF4RDtVQUNNeEYsUUFBUXNYLEtBQUszdEQsS0FBTCxDQUFXLFNBQVgsQ0FBZDtVQUNNZ2tDLE1BQU1xUyxNQUFNLENBQU4sQ0FBWjtVQUNJdVgsS0FBS3ZYLE1BQU0sQ0FBTixDQUFUO1dBQ0ssQ0FBQ3VYLE1BQU0sRUFBUCxFQUFXNXRELEtBQVgsQ0FBaUIsU0FBakIsQ0FBTDs7YUFFTyxDQUFDa04sWUFBYTZKLG9CQUFrQjYyQyxHQUFHLENBQUgsQ0FBbEIsZUFBbUMsR0FBbkMsRUFBd0Nqc0QsSUFBeEMsQ0FBNkN1TCxRQUE3QyxDQUFiLEdBQXVFMGdELEdBQUcsQ0FBSCxDQUF2RSxHQUErRTVwQixHQUFoRixLQUF3RixFQUEvRjs7Ozs7Ozs7O3lDQU1tQjZwQixVQUFVQyxjQUFjOzs7eUJBQ2IsS0FBS0MsV0FBTCxDQUFpQixLQUFLTCxVQUFMLENBQWdCRyxRQUFoQixFQUEwQkMsWUFBMUIsQ0FBakIsQ0FEYTtVQUNuQ3Y0QyxTQURtQyxnQkFDbkNBLFNBRG1DO1VBQ3hCaFgsTUFEd0IsZ0JBQ3hCQSxNQUR3Qjs7VUFFckN5dkQsaUJBQWlCejRDLGNBQWNoWCxNQUFkLFNBQTJCQSxNQUEzQixVQUFzQ0EsTUFBdEMsU0FBa0QsTUFBSWdYLFNBQUosVUFBb0IsRUFBN0Y7VUFDTXpRLEtBQUssSUFBSWlTLE1BQUosMkNBQW1EaTNDLGNBQW5ELE9BQVg7O2FBRUtobEQsU0FBTCxDQUFlLEtBQUs2RSxTQUFwQixFQUNHUSxNQURILENBQ1U7ZUFBYXZKLEdBQUduRCxJQUFILENBQVE0VCxTQUFSLENBQWI7T0FEVixFQUVHNVYsT0FGSCxDQUVXO2VBQWEsT0FBS2tPLFNBQUwsQ0FBZUksTUFBZixDQUFzQnNILFNBQXRCLENBQWI7T0FGWDs7OztnQ0FLVTA0QyxVQUFVO1VBQ2QxNEMsWUFBWTgzQyxjQUFjQSxhQUFhLEdBQWIsR0FBbUIsRUFBakMsSUFBdUNZLFFBQXpEO2FBQ08sRUFBRTE0QyxvQkFBRixFQUFhaFgsUUFBUWdYLFVBQVV2VixLQUFWLENBQWdCLEdBQWhCLEVBQXFCLENBQXJCLENBQXJCLEVBQVA7Ozs7d0NBR2tCaXVELFVBQVVuRyxNQUFNO1VBQzVCajZDLFlBQVksQ0FBQyxVQUFELENBQWxCO1VBQ01wTyxRQUFRLEVBQWQ7OztVQUdJd3VELFNBQVN6dEQsT0FBVCxDQUFpQixNQUFqQixNQUE2QixDQUFqQyxFQUFvQztrQkFDeEJDLElBQVYsQ0FBZXd0RCxRQUFmO2tCQUNVeHRELElBQVYsQ0FBZSxlQUFmO09BRkYsTUFHTyxJQUFJd3RELFNBQVN6dEQsT0FBVCxDQUFpQixLQUFqQixNQUE0QixDQUFoQyxFQUFtQztrQkFDOUJDLElBQVYsQ0FBZXd0RCxRQUFmO2tCQUNVeHRELElBQVYsQ0FBZSxJQUFmO09BRkssTUFHQSxJQUFJd3RELFNBQVN6dEQsT0FBVCxDQUFpQixLQUFqQixNQUE0QixDQUFoQyxFQUFvQztrQkFDL0JDLElBQVYsQ0FBZSxNQUFmO2tCQUNVQSxJQUFWLENBQWUsVUFBVXd0RCxTQUFTanVELEtBQVQsQ0FBZSxRQUFmLEVBQXlCLENBQXpCLENBQXpCO09BRkssTUFHQTsyQkFDeUIsS0FBSyt0RCxXQUFMLENBQWlCRSxRQUFqQixDQUR6QjtZQUNHMTRDLFNBREgsZ0JBQ0dBLFNBREg7WUFDY2hYLE1BRGQsZ0JBQ2NBLE1BRGQ7O2tCQUVLc1AsVUFBVXBOLElBQVYsQ0FBZWxDLE1BQWYsQ0FBVjtxQkFDYXNQLFVBQVVwTixJQUFWLENBQWU4VSxTQUFmLENBQWI7Ozs7VUFJRXV5QyxLQUFLNW9ELEtBQUwsQ0FBVyxhQUFYLENBQUosRUFBK0I7a0JBQ25CdUIsSUFBVixDQUFlLGVBQWVxbkQsSUFBOUI7YUFDS3JvRCxLQUFMLENBQVd5dUQsY0FBWCxDQUEwQixXQUExQjtPQUZGLE1BR087Y0FDQ0MsUUFBTixHQUFpQnJHLElBQWpCOzs7YUFHSzttQkFDTWo2QyxTQUROO2VBRUVwTztPQUZUOzs7O2tDQU1tQmxCLFFBQVE7bUJBQ2RBLFNBQVUsT0FBT0EsTUFBUCxLQUFrQixRQUFsQixJQUE4QkEsTUFBOUIsSUFBd0MsSUFBbEQsR0FBMEQsRUFBdkU7Ozs7MkJBcEY4QjthQUN2QixDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLFVBQWpCLEVBQTZCLE9BQTdCLENBQVA7Ozs7RUF6RXFDNGdEOztBQWdLekM3a0MsWUFBWTZiLElBQVosR0FBbUJtM0IsV0FBbkI7QUFDQWx3QixlQUFlTCxNQUFmLENBQXNCLFVBQXRCLEVBQWtDdXdCLFdBQWxDOztBQ3ROQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFHYWMsa0JBQWI7OEJBRWNDLFlBQVosRUFBa0Q7UUFBeEJDLGVBQXdCLHVFQUFOLElBQU07OztRQUM1QyxRQUFPRCxZQUFQLHlDQUFPQSxZQUFQLE9BQXdCLFFBQXhCLElBQW9DQSxpQkFBaUIsSUFBekQsRUFBK0Q7YUFDeER0cUQsS0FBTCxDQUFXLHdDQUFYOztTQUVHd3FELGFBQUwsR0FBcUJGLFlBQXJCOztRQUVJLEVBQUVDLDJCQUEyQnA2QixPQUE3QixLQUF5Q282QixvQkFBb0IsSUFBakUsRUFBdUU7YUFDaEV2cUQsS0FBTCxDQUFXLG9FQUFYOztTQUVHeXFELGdCQUFMLEdBQXdCRixlQUF4Qjs7Ozs7Ozs7Ozt3Q0FVa0I7YUFDWCxLQUFLQyxhQUFMLENBQW1CRSxPQUFuQixZQUFzQ3IrQyxRQUE3Qzs7Ozs7Ozs7OzhCQU1RO1dBQ0htK0MsYUFBTCxDQUFtQkUsT0FBbkIsQ0FBMkI5OUMsS0FBM0IsQ0FBaUMsS0FBSzQ5QyxhQUF0QyxFQUFxRGx3QyxTQUFyRDs7Ozs7Ozs7OztvQ0FPY3pQLEtBcENsQixFQW9DeUJnTyxJQXBDekIsRUFvQytCO1VBQ3ZCLEtBQUsyeEMsYUFBTCxDQUFtQkcsZUFBbkIsWUFBOEN0K0MsUUFBbEQsRUFBNEQ7YUFDckRtK0MsYUFBTCxDQUFtQkcsZUFBbkIsQ0FBbUM5L0MsS0FBbkMsRUFBMENnTyxJQUExQztPQURGLE1BRU87WUFDQ3BkLFVBQVUsS0FBSyt1RCxhQUFMLENBQW1CSSxpQkFBbkIsQ0FBcUMvL0MsS0FBckMsRUFBNEMsS0FBSzQvQyxnQkFBakQsQ0FBaEI7WUFDSSxFQUFFaHZELG1CQUFtQjAwQixPQUFyQixDQUFKLEVBQW1DO2lCQUM1Qm53QixLQUFMLENBQVcsd0RBQVg7OzthQUdHLEVBQUN2RSxnQkFBRCxFQUFMOzs7Ozs7Ozs7O2lDQU9TO1VBQ0xxb0QsUUFBUSxLQUFLMEcsYUFBTCxDQUFtQkssVUFBbkIsRUFBZDtVQUNJLE9BQU8vRyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO2VBQ3hCOWpELEtBQUwsQ0FBVyxtQ0FBWDs7YUFFSzhqRCxLQUFQOzs7Ozs7Ozs7OzsrQkFRU2o1QyxLQWpFYixFQWlFb0I4aEIsSUFqRXBCLEVBaUUwQjtVQUNsQixLQUFLNjlCLGFBQUwsQ0FBbUJNLGlCQUFuQixZQUFnRHorQyxRQUFwRCxFQUE4RDthQUN2RG0rQyxhQUFMLENBQW1CTSxpQkFBbkIsQ0FBcUNqZ0QsS0FBckMsRUFBNEM4aEIsSUFBNUM7Ozs7Ozs7Ozs7d0NBT2dCOWhCLEtBMUV0QixFQTBFNkI7VUFDckIsS0FBSzIvQyxhQUFMLENBQW1CTyxtQkFBbkIsWUFBa0QxK0MsUUFBdEQsRUFBZ0U7WUFDeERuTyxTQUFTLEtBQUtzc0QsYUFBTCxDQUFtQk8sbUJBQW5CLENBQXVDbGdELEtBQXZDLENBQWY7O1lBRUksT0FBTzNNLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7aUJBQ3pCOEIsS0FBTCxDQUFXLDRDQUFYOzs7ZUFHSzlCLE1BQVA7OzthQUdLLENBQVA7Ozs7Ozs7Ozs7Z0NBT1UyTSxLQTVGZCxFQTRGcUI4aEIsSUE1RnJCLEVBNEYyQjtVQUNuQixLQUFLNjlCLGFBQUwsQ0FBbUJRLFdBQW5CLFlBQTBDMytDLFFBQTlDLEVBQXdEO2FBQ2pEbStDLGFBQUwsQ0FBbUJRLFdBQW5CLENBQStCbmdELEtBQS9CLEVBQXNDOGhCLElBQXRDOzs7Ozs7Ozs7OzhCQU9NO1VBQ0osS0FBSzY5QixhQUFMLENBQW1CNy9CLE9BQW5CLFlBQXNDdGUsUUFBMUMsRUFBb0Q7YUFDN0NtK0MsYUFBTCxDQUFtQjcvQixPQUFuQjs7O1dBR0c2L0IsYUFBTCxHQUFxQixLQUFLQyxnQkFBTCxHQUF3QixJQUE3Qzs7OzsyQkE1RmU7YUFDUixLQUFLRCxhQUFMLENBQW1CUyxVQUExQjs7Ozs7Ozs7O0FBa0dKLElBQWFDLGtCQUFiOzs7Ozs7OEJBTWNDLGNBQVosRUFBNEJDLFFBQTVCLEVBQXNDOzs7UUFDaEMsRUFBRUEsb0JBQW9CZixrQkFBdEIsQ0FBSixFQUErQzthQUN4Q3JxRCxLQUFMLENBQVcsZ0VBQVg7OztTQUdHcXJELGVBQUwsR0FBdUJGLGNBQXZCO1NBQ0tHLFNBQUwsR0FBaUJGLFFBQWpCO1NBQ0tHLFlBQUwsR0FBcUIsS0FBS0YsZUFBTCxDQUFxQnYrQyxRQUFyQixDQUE4QixDQUE5QixLQUFvQyxLQUFLdStDLGVBQUwsQ0FBcUJ2K0MsUUFBckIsQ0FBOEIsQ0FBOUIsRUFBaUM3RSxPQUFqQyxLQUE2QyxpQkFBbEYsR0FBdUcsQ0FBdkcsR0FBMkcsQ0FBL0g7O1FBRUlrakQsZUFBZWxqRCxPQUFmLENBQXVCN0ssV0FBdkIsT0FBeUMsVUFBN0MsRUFBeUQ7cUJBQ3hDME0sU0FBZixDQUF5QkUsR0FBekIsQ0FBNkIsV0FBN0I7OztTQUdHd2hELFlBQUwsR0FBb0IsS0FBS0MsdUJBQUwsQ0FBNkJOLGNBQTdCLENBQXBCOztRQUVJLENBQUMsS0FBS0ssWUFBVixFQUF3QjthQUNqQnhyRCxLQUFMLENBQVcsaURBQVg7OztTQUdHMHJELGFBQUwsR0FBcUIsS0FBS0YsWUFBTCxDQUFrQnowQixTQUF2QztTQUNLNDBCLE9BQUwsR0FBZSxDQUFmO1NBQ0tDLGFBQUwsR0FBcUIsQ0FBQyxDQUFELENBQXJCO1NBQ0tDLGNBQUwsR0FBc0IsRUFBdEI7O1FBRUksQ0FBQyxLQUFLUCxTQUFMLENBQWVMLFVBQWhCLElBQThCLENBQUMsS0FBS0ssU0FBTCxDQUFlUCxtQkFBZixDQUFtQyxDQUFuQyxDQUFuQyxFQUEwRTtXQUNuRWUsa0JBQUwsR0FBMEIsSUFBMUI7OztTQUdHQyxrQkFBTDtTQUNLbEUsU0FBTDs7Ozs7NENBV3NCc0QsY0E5QzFCLEVBOEMwQztVQUNoQ2EsY0FBYzF3RCxPQUFLaVAsVUFBTCxDQUFnQjRnRCxjQUFoQixFQUFnQyxnQkFBaEMsQ0FBcEI7O1VBRUlhLFdBQUosRUFBaUI7ZUFDUkEsV0FBUDs7O1VBR0lob0QsT0FBTzFJLE9BQUtpUCxVQUFMLENBQWdCNGdELGNBQWhCLEVBQWdDLFVBQWhDLENBQWI7VUFDSW5uRCxJQUFKLEVBQVU7WUFDRkYsVUFBVXhJLE9BQUs4VSxTQUFMLENBQWVwTSxJQUFmLEVBQXFCLFVBQXJCLENBQWhCO1lBQ0lGLE9BQUosRUFBYTtpQkFDSkEsT0FBUDs7OzthQUlHLElBQVA7Ozs7cUNBR2VwQixRQWhFbkIsRUFnRTZCOzs7V0FDcEI0b0QsU0FBTCxDQUFlWCxlQUFmLENBQStCLENBQS9CLEVBQWtDLGdCQUFRO1lBQ3BDLENBQUMsTUFBS21CLGtCQUFWLEVBQThCO2lCQUN2QjlyRCxLQUFMLENBQVcsZUFBWDs7O2NBR0dxckQsZUFBTCxDQUFxQmhtRCxXQUFyQixDQUFpQ3NuQixLQUFLbHhCLE9BQXRDOztZQUVNb2QsT0FBTyxTQUFQQSxJQUFPLEdBQU07Z0JBQ1p5eUMsU0FBTCxDQUFlTixXQUFmLENBQTJCLENBQTNCLEVBQThCcitCLElBQTlCO2VBQ0tseEIsT0FBTCxJQUFnQmt4QixLQUFLbHhCLE9BQUwsQ0FBYXlPLE1BQWIsRUFBaEI7aUJBQ08sTUFBSzRoRCxrQkFBWjs7U0FIRjs7Y0FPS0csV0FBTCxHQUFtQnQvQixLQUFLbHhCLE9BQUwsQ0FBYXFjLFlBQWhDOztZQUVJLE1BQUttMEMsV0FBTCxHQUFtQixDQUF2QixFQUEwQjs7Ozs7OztjQU9yQlosZUFBTCxDQUFxQjN2RCxLQUFyQixDQUEyQnd3RCxVQUEzQixHQUF3QyxRQUF4QzthQUNLendELE9BQUwsQ0FBYUMsS0FBYixDQUFtQnd3RCxVQUFuQixHQUFnQyxRQUFoQzs7cUJBRWEsWUFBTTtnQkFDWkQsV0FBTCxHQUFtQnQvQixLQUFLbHhCLE9BQUwsQ0FBYXFjLFlBQWhDO2NBQ0ksTUFBS20wQyxXQUFMLElBQW9CLENBQXhCLEVBQTJCO21CQUNwQmpzRCxLQUFMLENBQVcsdURBQVg7O2dCQUVHcXJELGVBQUwsQ0FBcUIzdkQsS0FBckIsQ0FBMkJ3d0QsVUFBM0IsR0FBd0MsRUFBeEM7O1NBTEY7T0ExQkY7Ozs7a0NBd0NZO2FBQ0wsS0FBS1osU0FBTCxDQUFlVCxVQUFmLEVBQVA7Ozs7bUNBR2F2dUQsQ0E3R2pCLEVBNkdvQjs7VUFFWixLQUFLdXZELGNBQUwsQ0FBb0J2ckQsY0FBcEIsQ0FBbUNoRSxDQUFuQyxDQUFKLEVBQTJDO1lBQ3JDLENBQUMsS0FBS3V2RCxjQUFMLENBQW9CdnZELENBQXBCLEVBQXVCZ0UsY0FBdkIsQ0FBc0MsUUFBdEMsQ0FBTCxFQUFzRDtlQUMvQ3VyRCxjQUFMLENBQW9CdnZELENBQXBCLEVBQXVCNEIsTUFBdkIsR0FBZ0MsS0FBSzJ0RCxjQUFMLENBQW9CdnZELENBQXBCLEVBQXVCYixPQUF2QixDQUErQnFjLFlBQS9EOztlQUVLLEtBQUsrekMsY0FBTCxDQUFvQnZ2RCxDQUFwQixFQUF1QjRCLE1BQTlCOzs7O1VBSUUsS0FBSzB0RCxhQUFMLENBQW1CdHZELElBQUksQ0FBdkIsS0FBNkIsS0FBS3N2RCxhQUFMLENBQW1CdHZELENBQW5CLENBQWpDLEVBQXdEO2VBQy9DLEtBQUtzdkQsYUFBTCxDQUFtQnR2RCxJQUFJLENBQXZCLElBQTRCLEtBQUtzdkQsYUFBTCxDQUFtQnR2RCxDQUFuQixDQUFuQzs7O2FBR0ssS0FBSzZ2RCxnQkFBTCxJQUF5QixLQUFLYixTQUFMLENBQWVQLG1CQUFmLENBQW1DenVELENBQW5DLENBQWhDOzs7OytDQUd5Qjs7O2FBQ2xCOEMsT0FBT3pELElBQVAsQ0FBWSxLQUFLa3dELGNBQWpCLEVBQWlDM3ZELE1BQWpDLENBQXdDLFVBQUNxYixDQUFELEVBQUltTixDQUFKO2VBQVVuTixJQUFJLE9BQUs2MEMsY0FBTCxDQUFvQixDQUFFMW5DLENBQXRCLENBQWQ7T0FBeEMsRUFBaUYsQ0FBakYsQ0FBUDs7OztnQ0FHVTtXQUNMZ21DLE9BQUw7Ozs7d0NBR2tCO2FBQ1g3MUMsS0FBS21KLEdBQUwsK0JBQVk1ZSxPQUFPekQsSUFBUCxDQUFZLEtBQUtrd0QsY0FBakIsQ0FBWixFQUFQOzs7O3lDQUdtQjthQUNaaDNDLEtBQUtrSixHQUFMLCtCQUFZM2UsT0FBT3pELElBQVAsQ0FBWSxLQUFLa3dELGNBQWpCLENBQVosRUFBUDs7Ozs4QkFHUTtVQUNGUSxjQUFjLEVBQUVDLGlCQUFpQixJQUFuQixFQUFwQjtVQUNNQyxpQkFBaUIsS0FBS0Msa0JBQUwsRUFBdkI7O1VBRUlseEQsT0FBS3FaLFNBQUwsQ0FBZTQzQyxjQUFmLENBQUosRUFBb0M7YUFDN0JsQixlQUFMLENBQXFCM3ZELEtBQXJCLENBQTJCd0MsTUFBM0IsR0FBb0MsS0FBSzB0RCxhQUFMLENBQW1CVyxjQUFuQixJQUFxQyxLQUFLRSx3QkFBTCxFQUFyQyxHQUF1RSxJQUEzRzthQUNLZCxPQUFMLEdBQWUsS0FBS0MsYUFBTCxDQUFtQlcsY0FBbkIsQ0FBZjtvQkFDWUcsZUFBWixHQUE4QkgsY0FBOUI7OztXQUdHSSxrQkFBTDtXQUNLakMsT0FBTCxDQUFhMkIsV0FBYjtXQUNLaEIsZUFBTCxDQUFxQjN2RCxLQUFyQixDQUEyQndDLE1BQTNCLEdBQW9DLFNBQXBDOzs7OzhCQUd1RTs7O3FGQUFKLEVBQUk7c0NBQWhFb3VELGVBQWdFO1VBQWhFQSxlQUFnRSx3Q0FBOUMsS0FBOEM7VUFBdkNJLGVBQXVDLFFBQXZDQSxlQUF1QztVQUF0QkUsY0FBc0IsUUFBdEJBLGNBQXNCOztVQUNuRSxLQUFLZCxrQkFBVCxFQUE2QjtlQUNwQixLQUFLZSxnQkFBTCxDQUFzQixLQUFLbkMsT0FBTCxDQUFhcnBELElBQWIsQ0FBa0IsSUFBbEIsRUFBd0JpWixVQUFVLENBQVYsQ0FBeEIsQ0FBdEIsQ0FBUDs7O1VBR0l3eUMsYUFBYSxDQUFDUixlQUFELElBQW9CLEtBQUtaLGFBQUwsR0FBcUIsS0FBS0YsWUFBTCxDQUFrQnowQixTQUE5RTtXQUNLMjBCLGFBQUwsR0FBcUIsS0FBS0YsWUFBTCxDQUFrQnowQixTQUF2QztVQUNNZzJCLE9BQU8sRUFBYjs7VUFFTXRHLFNBQVMsS0FBSzRFLGVBQUwsQ0FBcUIyQixxQkFBckIsR0FBNkM3MEIsR0FBNUQ7VUFDTXZwQixRQUFRLElBQUlsVSxPQUFPK3lCLFdBQVgsR0FBeUJnNUIsTUFBdkM7VUFDTTNDLFFBQVEsS0FBS21KLFdBQUwsRUFBZDs7VUFHTWh1QyxRQUFReXRDLG1CQUFtQjczQyxLQUFLbUosR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLa3ZDLG9CQUFMLENBQTBCekcsTUFBMUIsSUFBb0MsRUFBaEQsQ0FBakMsQ0FkdUU7VUFlbkVucUQsSUFBSTJpQixLQUFSOztXQUVLLElBQUlrWixNQUFNLEtBQUt5ekIsYUFBTCxDQUFtQnR2RCxDQUFuQixDQUFmLEVBQXNDQSxJQUFJd25ELEtBQUosSUFBYTNyQixNQUFNdnBCLEtBQXpELEVBQWdFdFMsR0FBaEUsRUFBcUU7WUFDL0RBLEtBQUssS0FBS3N2RCxhQUFMLENBQW1CcnZELE1BQTVCLEVBQW9DOztlQUM3QnF2RCxhQUFMLENBQW1CcnZELE1BQW5CLElBQTZCLEdBQTdCOzs7YUFHR3F2RCxhQUFMLENBQW1CdHZELENBQW5CLElBQXdCNjdCLEdBQXhCO2VBQ08sS0FBS2kwQixjQUFMLENBQW9COXZELENBQXBCLENBQVA7OztVQUdFLEtBQUtndkQsU0FBTCxDQUFlNkIsaUJBQWYsSUFBb0MsS0FBSzdCLFNBQUwsQ0FBZTZCLGlCQUFmLEVBQXhDLEVBQTRFO2VBQ25FLEtBQUs3QixTQUFMLENBQWVaLE9BQWYsQ0FBdUJ6ckMsS0FBdkIsRUFBOEIzaUIsQ0FBOUIsRUFBaUMsWUFBTTtpQkFDdkNxdkQsT0FBTCxHQUFlLE9BQUtDLGFBQUwsQ0FBbUIzc0MsS0FBbkIsQ0FBZjtTQURLLENBQVA7OztVQUtFNnRDLFVBQUosRUFBZ0I7YUFDVCxJQUFJajdDLElBQUl2VixJQUFJLENBQWpCLEVBQW9CdVYsS0FBS29OLEtBQXpCLEVBQWdDcE4sR0FBaEMsRUFBcUM7ZUFDOUJBLENBQUwsSUFBVSxJQUFWO2VBQ0t1N0MsY0FBTCxDQUFvQnY3QyxDQUFwQixFQUF1Qmk3QyxVQUF2Qjs7T0FISixNQUtPO1lBQ0M1YyxZQUFZMGMsa0JBQWtCLzNDLEtBQUttSixHQUFMLGNBQVMxaEIsSUFBSSxDQUFiLDJCQUFtQjhDLE9BQU96RCxJQUFQLENBQVksS0FBS2t3RCxjQUFqQixDQUFuQixHQUFwQyxDQURLO2FBRUEsSUFBSWg2QyxLQUFJb04sS0FBYixFQUFvQnBOLE1BQUtxK0IsU0FBekIsRUFBb0NyK0IsSUFBcEMsRUFBeUM7ZUFDbENBLEVBQUwsSUFBVSxJQUFWO2VBQ0t1N0MsY0FBTCxDQUFvQnY3QyxFQUFwQixFQUF1Qmk3QyxVQUF2Qjs7OzthQUlHbnhELElBQVAsQ0FBWSxLQUFLa3dELGNBQWpCLEVBQWlDandELE9BQWpDLENBQXlDO2VBQU9teEQsS0FBS2x4RCxHQUFMLEtBQWEsT0FBS3d4RCxjQUFMLENBQW9CeHhELEdBQXBCLEVBQXlCaXhELFVBQXpCLENBQXBCO09BQXpDOzs7Ozs7Ozs7O21DQU9hamlELEtBak5qQixFQWlOd0JpaUQsVUFqTnhCLEVBaU5vQzs7O1VBQzFCbmdDLE9BQU8sS0FBS2svQixjQUFMLENBQW9CaGhELEtBQXBCLENBQWI7VUFDSThoQixJQUFKLEVBQVU7YUFDSDIrQixTQUFMLENBQWVnQyxVQUFmLENBQTBCemlELEtBQTFCLEVBQWlDOGhCLElBQWpDLEVBRFE7Ozs7V0FLTDIrQixTQUFMLENBQWVYLGVBQWYsQ0FBK0I5L0MsS0FBL0IsRUFBc0MsZ0JBQVE7WUFDeENpaUQsVUFBSixFQUFnQjtpQkFDVHpCLGVBQUwsQ0FBcUI1MkMsWUFBckIsQ0FBa0NrWSxLQUFLbHhCLE9BQXZDLEVBQWdELE9BQUs0dkQsZUFBTCxDQUFxQnYrQyxRQUFyQixDQUE4QixPQUFLeStDLFlBQW5DLENBQWhEO2lCQUNLSSxPQUFMLEdBQWUsT0FBS0MsYUFBTCxDQUFtQi9nRCxLQUFuQixDQUFmO2VBQ0szTSxNQUFMLEdBQWMsT0FBSzB0RCxhQUFMLENBQW1CL2dELFFBQVEsQ0FBM0IsSUFBZ0MsT0FBSytnRCxhQUFMLENBQW1CL2dELEtBQW5CLENBQTlDO1NBSEYsTUFJTztpQkFDQXdnRCxlQUFMLENBQXFCaG1ELFdBQXJCLENBQWlDc25CLEtBQUtseEIsT0FBdEM7OztlQUdHb3dELGNBQUwsQ0FBb0JoaEQsS0FBcEIsSUFBNkI4aEIsSUFBN0I7T0FURjs7Ozs7Ozs7OzttQ0FpQmE5aEIsS0F6T2pCLEVBeU8yQztVQUFuQmlpRCxVQUFtQix1RUFBTixJQUFNOztjQUMvQixDQUFFamlELEtBQVY7VUFDTThoQixPQUFPLEtBQUtrL0IsY0FBTCxDQUFvQmhoRCxLQUFwQixDQUFiO1dBQ0t5Z0QsU0FBTCxDQUFlTixXQUFmLENBQTJCbmdELEtBQTNCLEVBQWtDOGhCLElBQWxDOztVQUVJbWdDLFVBQUosRUFBZ0I7YUFDVGxCLGFBQUwsQ0FBbUIvZ0QsUUFBUSxDQUEzQixJQUFnQ1ksU0FBaEM7T0FERixNQUVPO2FBQ0FrZ0QsT0FBTCxHQUFlLEtBQUtBLE9BQUwsR0FBZSxLQUFLUyxjQUFMLENBQW9CdmhELEtBQXBCLENBQTlCOzs7VUFHRThoQixLQUFLbHhCLE9BQUwsQ0FBYWtZLGFBQWpCLEVBQWdDO2FBQ3pCbFksT0FBTCxDQUFha1ksYUFBYixDQUEyQjJmLFdBQTNCLENBQXVDM0csS0FBS2x4QixPQUE1Qzs7O2FBR0ssS0FBS293RCxjQUFMLENBQW9CaGhELEtBQXBCLENBQVA7Ozs7eUNBR21COzs7YUFDWmxQLElBQVAsQ0FBWSxLQUFLa3dELGNBQWpCLEVBQWlDandELE9BQWpDLENBQXlDO2VBQU8sT0FBS3l4RCxjQUFMLENBQW9CeHhELEdBQXBCLENBQVA7T0FBekM7Ozs7NkNBR3VCb2pCLEtBL1AzQixFQStQa0NDLEdBL1BsQyxFQStQdUM7V0FDOUIsSUFBSTVpQixJQUFJMmlCLEtBQWIsRUFBb0IzaUIsS0FBSzRpQixHQUF6QixFQUE4QjVpQixHQUE5QixFQUFtQzthQUM1QnN2RCxhQUFMLENBQW1CdHZELElBQUksQ0FBdkIsSUFBNEIsS0FBS3N2RCxhQUFMLENBQW1CdHZELENBQW5CLElBQXdCLEtBQUs4dkQsY0FBTCxDQUFvQjl2RCxDQUFwQixDQUFwRDs7Ozs7eUNBSWlCa04sT0FyUXZCLEVBcVFnQztVQUN0QitpRCxpQkFBaUIsS0FBS0Msa0JBQUwsRUFBdkI7VUFDTWUsZ0JBQWdCLEtBQUtDLGlCQUFMLEVBQXRCOzs7V0FHS0Msd0JBQUwsQ0FBOEJsQixjQUE5QixFQUE4Q2dCLGFBQTlDOztVQUVJdHVDLFFBQVEsQ0FBWjtVQUNJQyxNQUFNLEtBQUsrdEMsV0FBTCxLQUFxQixDQUEvQjs7O2VBR1M7WUFDRFMsU0FBUzc0QyxLQUFLQyxLQUFMLENBQVcsQ0FBQ21LLFFBQVFDLEdBQVQsSUFBZ0IsQ0FBM0IsQ0FBZjtZQUNNL2UsUUFBUXFKLFVBQVUsS0FBS29pRCxhQUFMLENBQW1COEIsTUFBbkIsQ0FBeEI7O1lBRUl4dUMsTUFBTUQsS0FBVixFQUFpQjtpQkFDUixDQUFQO1NBREYsTUFFTyxJQUFJOWUsU0FBUyxDQUFULElBQWNBLFFBQVEsS0FBS2lzRCxjQUFMLENBQW9Cc0IsTUFBcEIsQ0FBUixHQUFzQyxDQUF4RCxFQUEyRDtpQkFDekRBLE1BQVA7U0FESyxNQUVBLElBQUk5L0MsTUFBTXpOLEtBQU4sS0FBZ0JBLFNBQVMsQ0FBN0IsRUFBZ0M7Z0JBQy9CdXRELFNBQVMsQ0FBZjtTQURLLE1BRUE7a0JBQ0dBLFNBQVMsQ0FBakI7Ozs7Ozs4QkFLSWhaLElBaFNaLEVBZ1NrQnQ3QixJQWhTbEIsRUFnU3dCdTBDLFNBaFN4QixFQWdTbUM7VUFDM0JsekMsZ0JBQUo7YUFDTyxZQUFXOzs7O1lBQ1ZtekMsVUFBVUQsYUFBYSxDQUFDbHpDLE9BQTlCO3FCQUNhQSxPQUFiO1lBQ0ltekMsT0FBSixFQUFhO2VBQ05oaEQsS0FBTCxDQUFXLElBQVgsRUFBaUIwTixTQUFqQjtTQURGLE1BRU87b0JBQ0tQLFdBQVcsWUFBTTtzQkFDZixJQUFWO2lCQUNLbk4sS0FBTDtXQUZRLEVBR1B3TSxJQUhPLENBQVY7O09BTko7Ozs7NENBY3NCO1dBQ2pCc3hDLE9BQUw7V0FDS21ELFNBQUwsQ0FBZSxLQUFLbkQsT0FBTCxDQUFhcnBELElBQWIsQ0FBa0IsSUFBbEIsQ0FBZixFQUF3QyxHQUF4Qzs7Ozt5Q0FHbUI7YUFDZDBTLGFBQUwsQ0FBbUIsSUFBbkIsRUFBeUIsQ0FBQyxXQUFELEVBQWMsdUJBQWQsQ0FBekI7O1VBRUk3VyxTQUFTd0IsS0FBVCxFQUFKLEVBQXNCO2FBQ2ZvdkQsY0FBTCxHQUFzQixLQUFLRCxTQUFMLENBQWUsS0FBS0MsY0FBcEIsRUFBb0MsRUFBcEMsQ0FBdEI7OztXQUdHdEMsWUFBTCxDQUFrQi9vRCxnQkFBbEIsQ0FBbUMsUUFBbkMsRUFBNkMsS0FBS3FyRCxjQUFsRCxFQUFrRSxJQUFsRTs7VUFFSTV3RCxTQUFTd0IsS0FBVCxFQUFKLEVBQXNCO2VBQ2YrRCxnQkFBTCxDQUFzQixLQUFLK29ELFlBQTNCLEVBQXlDLFdBQXpDLEVBQXNELEtBQUtzQyxjQUEzRCxFQUEyRSxFQUFFaCtDLFNBQVMsSUFBWCxFQUFpQjhVLFNBQVMsSUFBMUIsRUFBM0U7YUFDSzRtQyxZQUFMLENBQWtCL29ELGdCQUFsQixDQUFtQyxVQUFuQyxFQUErQyxLQUFLc3JELDBCQUFwRCxFQUFnRixJQUFoRjs7O2FBR0tuekQsUUFBUCxDQUFnQjZILGdCQUFoQixDQUFpQyxRQUFqQyxFQUEyQyxLQUFLcXJELGNBQWhELEVBQWdFLElBQWhFOzs7OzRDQUdzQjtXQUNqQnRDLFlBQUwsQ0FBa0JocEQsbUJBQWxCLENBQXNDLFFBQXRDLEVBQWdELEtBQUtzckQsY0FBckQsRUFBcUUsSUFBckU7O1VBRUk1d0QsU0FBU3dCLEtBQVQsRUFBSixFQUFzQjtlQUNmOEQsbUJBQUwsQ0FBeUIsS0FBS2dwRCxZQUE5QixFQUE0QyxXQUE1QyxFQUF5RCxLQUFLc0MsY0FBOUQsRUFBOEUsRUFBRWgrQyxTQUFTLElBQVgsRUFBaUI4VSxTQUFTLElBQTFCLEVBQTlFO2FBQ0s0bUMsWUFBTCxDQUFrQmhwRCxtQkFBbEIsQ0FBc0MsVUFBdEMsRUFBa0QsS0FBS3VyRCwwQkFBdkQsRUFBbUYsSUFBbkY7OzthQUdLbnpELFFBQVAsQ0FBZ0I0SCxtQkFBaEIsQ0FBb0MsUUFBcEMsRUFBOEMsS0FBS3NyRCxjQUFuRCxFQUFtRSxJQUFuRTs7Ozs4QkFHUTtXQUNIbkIsa0JBQUw7V0FDS3JCLFNBQUwsQ0FBZTNnQyxPQUFmO1dBQ0txakMsY0FBTCxHQUFzQixLQUFLMUMsU0FBTCxHQUFpQixLQUFLTyxjQUFMLEdBQXNCLElBQTdEO1dBQ0tvQyxxQkFBTDs7OzsyQkEvU1k7YUFDTDV2RCxTQUFTLEtBQUtndEQsZUFBTCxDQUFxQjN2RCxLQUFyQixDQUEyQnd5RCxVQUFwQyxFQUFnRCxFQUFoRCxDQUFQO0tBdkNKO3lCQTBDYzdnQixRQTFDZCxFQTBDd0I7V0FDZmdlLGVBQUwsQ0FBcUIzdkQsS0FBckIsQ0FBMkJ3eUQsVUFBM0IsR0FBd0M3Z0IsV0FBVyxJQUFuRDs7OzsyQkEyRHFCO2FBQ2QsS0FBS2llLFNBQUwsQ0FBZUwsVUFBZixJQUE2QixLQUFLZ0IsV0FBekM7Ozs7OztBQzVPSjs7Ozs7Ozs7Ozs7OztBQWFBLEFBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBOENxQmtDOzs7Ozs7Ozs7O3dDQUVDOztVQUVkLEtBQUszbEQsWUFBTCxDQUFrQixVQUFsQixDQUFKLEVBQW1DO2FBQzVCNGlELFFBQUwsR0FBZ0Ixd0QsT0FBTyxLQUFLaUMsWUFBTCxDQUFrQixVQUFsQixDQUFQLENBQWhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQTZGTTtXQUNIeXhELG1CQUFMLElBQTRCLEtBQUtBLG1CQUFMLENBQXlCNTZDLE9BQXpCLEVBQTVCOzs7OzZDQUd1Qm5ZLE1BQU1rTyxNQUFNQyxTQUFTOzs7MkNBRXZCO1VBQ2pCLEtBQUs0a0QsbUJBQVQsRUFBOEI7YUFDdkJBLG1CQUFMLENBQXlCempDLE9BQXpCO2FBQ0t5akMsbUJBQUwsR0FBMkIsSUFBM0I7Ozs7O3lCQS9CUzlELGNBQWM7V0FDcEI4RCxtQkFBTCxJQUE0QixLQUFLQSxtQkFBTCxDQUF5QnpqQyxPQUF6QixFQUE1Qjs7VUFFSSxDQUFDLEtBQUs4L0IsZ0JBQU4sSUFBMEIsS0FBSzM5QyxRQUFMLENBQWMsQ0FBZCxDQUE5QixFQUFnRDthQUN6QzI5QyxnQkFBTCxHQUF3QixLQUFLbjNCLFdBQUwsQ0FBaUIsS0FBS3htQixRQUFMLENBQWMsQ0FBZCxDQUFqQixDQUF4Qjs7O1VBR0lzK0MsV0FBVyxJQUFJZixrQkFBSixDQUF1QkMsWUFBdkIsRUFBcUMsS0FBS0csZ0JBQUwsSUFBeUIsSUFBOUQsQ0FBakI7V0FDSzJELG1CQUFMLEdBQTJCLElBQUlsRCxrQkFBSixDQUF1QixLQUFLdjNDLGFBQTVCLEVBQTJDeTNDLFFBQTNDLENBQTNCOzsyQkFHYTthQUNScHJELEtBQUwsQ0FBVyxvQkFBWDs7OztFQXhGMkNvN0M7O0FBaUgvQ3Q1QyxXQUFTdW9ELGtCQUFULEdBQThCQSxrQkFBOUI7QUFDQXZvRCxXQUFTb3BELGtCQUFULEdBQThCQSxrQkFBOUI7O0FBRUEzMEMsWUFBWTgzQyxVQUFaLEdBQXlCRixpQkFBekI7QUFDQTkwQixlQUFlTCxNQUFmLENBQXNCLGlCQUF0QixFQUF5Q20xQixpQkFBekM7O0FDdExBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQU1BLElBQU1oTyxxQkFBbUIsYUFBekI7QUFDQSxJQUFNaDJDLFdBQVMsRUFBQyxJQUFJLGdCQUFMLEVBQWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTBCcUJta0Q7Ozs7Ozs7Ozs7OytCQVVMOzs7OztVQUdQMVAsUUFBTDs7Ozs7OytCQUdTO2dCQUNDMzFDLE9BQVYsQ0FBa0IsSUFBbEI7V0FDS2EsU0FBTCxDQUFlRSxHQUFmLENBQW1CbTJDLGtCQUFuQjttQkFDYW5CLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsUUFBaEM7Ozs7NkNBT3VCOU8sTUFBTWtPLE1BQU1DLFNBQVM7Y0FDcENuTyxJQUFSO2FBQ08sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I2c0Msa0JBQXhCLEVBQTBDaDJDLFFBQTFDOzthQUVHLFVBQUw7dUJBQ2VvMEMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxRQUFwRDs7Ozs7OzJCQVYwQjthQUN2QixDQUFDLFVBQUQsRUFBYSxPQUFiLENBQVA7Ozs7RUF2QjJDaXhDOztBQXNDL0M3a0MsWUFBWWc0QyxVQUFaLEdBQXlCRCxpQkFBekI7QUFDQWoxQixlQUFlTCxNQUFmLENBQXNCLGlCQUF0QixFQUF5Q3MxQixpQkFBekM7O0FDekZBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQU1BLElBQU1uTyxxQkFBbUIsWUFBekI7QUFDQSxJQUFNaDJDLFdBQVMsRUFBQyxJQUFJLGVBQUwsRUFBZjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0JxQnFrRDs7OzhCQUVMOzs7OztVQUdQNVAsUUFBTDs7Ozs7OytCQUdTO2dCQUNDMzFDLE9BQVYsQ0FBa0IsSUFBbEI7V0FDS2EsU0FBTCxDQUFlRSxHQUFmLENBQW1CbTJDLGtCQUFuQjttQkFDYW5CLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsUUFBaEM7Ozs7NkNBT3VCOU8sTUFBTWtPLE1BQU1DLFNBQVM7Y0FDcENuTyxJQUFSO2FBQ08sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I2c0Msa0JBQXhCLEVBQTBDaDJDLFFBQTFDOzthQUVHLFVBQUw7dUJBQ2VvMEMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxRQUFwRDs7Ozs7OzJCQVYwQjthQUN2QixDQUFDLFVBQUQsRUFBYSxPQUFiLENBQVA7Ozs7RUFmMENpeEM7O0FBOEI5QzdrQyxZQUFZazRDLFNBQVosR0FBd0JELGdCQUF4QjtBQUNBbjFCLGVBQWVMLE1BQWYsQ0FBc0IsZ0JBQXRCLEVBQXdDdzFCLGdCQUF4Qzs7QUN6RUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsSUFHYUUsZ0JBQWI7Ozs4QkFDbUU7bUZBQUosRUFBSTsyQkFBcEQ1M0MsTUFBb0Q7UUFBcERBLE1BQW9ELCtCQUEzQyxRQUEyQzswQkFBakNyUCxLQUFpQztRQUFqQ0EsS0FBaUMsOEJBQXpCLENBQXlCOzZCQUF0QkQsUUFBc0I7UUFBdEJBLFFBQXNCLGlDQUFYLEdBQVc7Ozs4SEFDekQsRUFBRXNQLGNBQUYsRUFBVXJQLFlBQVYsRUFBaUJELGtCQUFqQixFQUR5RDs7Ozs7a0NBSW5EbW5ELFFBTGhCLEVBSzBCanNELFFBTDFCLEVBS29DOzs7OztrQ0FJcEJpc0QsUUFUaEIsRUFTMEJqc0QsUUFUMUIsRUFTb0M7Ozs7O0VBVEVvNUMsWUFBdEM7O0FBY0EsSUFBYThTLHFCQUFiOzs7Ozs7Ozs7O2tDQUVnQkQsUUFGaEIsRUFFMEJqc0QsUUFGMUIsRUFFb0M7V0FDM0Jtc0QsaUJBQUwsQ0FBdUJGLFFBQXZCLEVBQWlDLElBQWpDLEVBQXVDanNELFFBQXZDOzs7O2tDQUdZaXNELFFBTmhCLEVBTTBCanNELFFBTjFCLEVBTW9DO1dBQzNCbXNELGlCQUFMLENBQXVCRixRQUF2QixFQUFpQyxLQUFqQyxFQUF3Q2pzRCxRQUF4Qzs7OztzQ0FHZ0Jpc0QsUUFWcEIsRUFVOEJHLFVBVjlCLEVBVTBDcHNELFFBVjFDLEVBVW9EOzs7Ozs7VUFJMUNxc0QsWUFBWUosU0FBU0ssaUJBQVQsQ0FBMkJ0ekQsS0FBM0IsQ0FBaUN3QyxNQUFuRDtVQUNNK3dELGFBQWFOLFNBQVNLLGlCQUFULENBQTJCdHpELEtBQTNCLENBQWlDc1IsT0FBcEQ7ZUFDU2dpRCxpQkFBVCxDQUEyQnR6RCxLQUEzQixDQUFpQ3dDLE1BQWpDLEdBQTBDLE1BQTFDO2VBQ1M4d0QsaUJBQVQsQ0FBMkJ0ekQsS0FBM0IsQ0FBaUNzUixPQUFqQyxHQUEyQyxPQUEzQztVQUNNa2lELGdCQUFnQngwRCxPQUFPQyxnQkFBUCxDQUF3QmcwRCxTQUFTSyxpQkFBakMsQ0FBdEI7O1VBRU1HLDBCQUEwQixDQUM5QixFQUFFanhELFFBQVEsQ0FBVixFQUFhZ3dELFlBQVksQ0FBekIsRUFBNEJrQixlQUFlLENBQTNDLEVBRDhCLEVBRTlCO2dCQUNVRixjQUFjaHhELE1BRHhCO29CQUVjZ3hELGNBQWNoQixVQUY1Qjt1QkFHaUJnQixjQUFjRTtPQUxELENBQWhDO1VBUU1DLHFCQUFxQixDQUFDLEVBQUNuUyxXQUFXLGVBQVosRUFBRCxFQUErQixFQUFDQSxXQUFXLGdCQUFaLEVBQS9CLENBQTNCOzs7ZUFHUzhSLGlCQUFULENBQTJCdHpELEtBQTNCLENBQWlDd0MsTUFBakMsR0FBMEM2d0QsU0FBMUM7O3dCQUVPSixTQUFTSyxpQkFBaEIsRUFBbUMsRUFBRXhuRCxVQUFVLEtBQUtBLFFBQWpCLEVBQTJCcVAsVUFBVSxtQ0FBckMsRUFBbkMsR0FDR29tQyxPQURILGtDQUNlNlIsYUFBYUssdUJBQWIsR0FBdUNBLHdCQUF3QkcsT0FBeEIsRUFEdEQsR0FFRy8wQyxJQUZILENBRVEsWUFBTTtpQkFDRHkwQyxpQkFBVCxDQUEyQnR6RCxLQUEzQixDQUFpQ3NSLE9BQWpDLEdBQTJDaWlELFVBQTNDO29CQUNZdnNELFVBQVo7T0FKSjs7VUFPSWlzRCxTQUFTWSxhQUFiLEVBQTRCOzs7MkJBQ25CWixTQUFTWSxhQUFoQixFQUErQixFQUFFL25ELFVBQVUsS0FBS0EsUUFBakIsRUFBMkJxUCxVQUFVLFdBQXJDLEVBQS9CLEdBQ0dvbUMsT0FESCxtQ0FDZTZSLGFBQWFPLGtCQUFiLEdBQWtDQSxtQkFBbUJDLE9BQW5CLEVBRGpELEdBRUcvMEMsSUFGSDs7Ozs7RUF6Q3FDbTBDLGdCQUEzQzs7QUNqQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBV0EsSUFBTXZPLHFCQUFtQixXQUF6QjtBQUNBLElBQU1oMkMsWUFBUztnQkFDQyxjQUREO3NCQUVPLG9CQUZQO3dCQUdTLHNCQUhUO3VCQUlRLHFCQUpSO3VCQUtRLHFCQUxSO3VCQU1RLHFCQU5SOzBCQU9XLHdCQVBYOzJCQVFZLHlCQVJaO3NCQVNPO0NBVHRCOztBQVlBLElBQU11MEMsa0JBQWdCO2FBQ1RrUSxxQkFEUztVQUVaRjtDQUZWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTZEcUJjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQW1ETDs7Ozs7VUFHUDNSLGdCQUFMLEdBQXdCLE1BQUtDLHNCQUFMLEVBQXhCO1VBQ0syUixlQUFMLEdBQXVCLE1BQUtBLGVBQUwsQ0FBcUJwdUQsSUFBckIsT0FBdkI7OztRQUdNTixLQUFLLHlCQUFYO1VBQ0sydUQsZ0JBQUwsR0FBd0I7YUFBS3RzRCxFQUFFb0YsWUFBRixDQUFlLGFBQWYsS0FBaUN6SCxHQUFHbkQsSUFBSCxDQUFRd0YsRUFBRTZFLE9BQVYsQ0FBdEM7S0FBeEI7OztVQUdLdWpCLElBQUwsR0FBWSxNQUFLbWtDLGFBQWpCO1VBQ0t6a0MsSUFBTCxHQUFZLE1BQUswa0MsYUFBakI7O3dCQUVtQixZQUFNO1lBQ2xCaFIsUUFBTDtLQURGOzs7Ozs7K0JBS1M7Z0JBQ0MzMUMsT0FBVixDQUFrQixJQUFsQjs7V0FFS2EsU0FBTCxDQUFlRSxHQUFmLENBQW1CbTJDLGtCQUFuQjs7VUFFSSxLQUFLMzNDLFlBQUwsQ0FBa0IsWUFBbEIsQ0FBSixFQUFxQzthQUM5QnNCLFNBQUwsQ0FBZUUsR0FBZixDQUFtQix1QkFBbkI7OztVQUdFdUQsYUFBSjtVQUFVZ1csZUFBVjtVQUFrQi9WLGNBQWxCO1VBQXlCMnFCLFlBQXpCO1VBQThCNjJCLDBCQUE5Qjs7VUFFTWEsV0FBV3YwRCxPQUFLdVYsZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FBakI7O1dBRUssSUFBSXZVLElBQUksQ0FBYixFQUFnQkEsSUFBSXV6RCxTQUFTdHpELE1BQTdCLEVBQXFDRCxHQUFyQyxFQUEwQztZQUNsQzhJLEtBQUt5cUQsU0FBU3Z6RCxDQUFULENBQVg7O1lBRUk4SSxHQUFHMEUsU0FBSCxDQUFhNkcsUUFBYixDQUFzQixNQUF0QixDQUFKLEVBQW1DO2FBQzlCN0csU0FBSCxDQUFhRSxHQUFiLENBQWlCLGlCQUFqQjtpQkFDTzVFLEVBQVA7U0FGRixNQUlLLElBQUlBLEdBQUcwRSxTQUFILENBQWE2RyxRQUFiLENBQXNCLFFBQXRCLENBQUosRUFBcUM7bUJBQy9CdkwsRUFBVDtTQURHLE1BR0EsSUFBSUEsR0FBRzBFLFNBQUgsQ0FBYTZHLFFBQWIsQ0FBc0IsT0FBdEIsQ0FBSixFQUFvQzthQUNwQzdHLFNBQUgsQ0FBYUUsR0FBYixDQUFpQixrQkFBakI7a0JBQ1E1RSxFQUFSO1NBRkcsTUFJQSxJQUFJQSxHQUFHMEUsU0FBSCxDQUFhNkcsUUFBYixDQUFzQixLQUF0QixDQUFKLEVBQWtDO2FBQ2xDN0csU0FBSCxDQUFhRSxHQUFiLENBQWlCLGdCQUFqQjtnQkFDTTVFLEVBQU47U0FGRyxNQUlBLElBQUlBLEdBQUcwRSxTQUFILENBQWE2RyxRQUFiLENBQXNCLG9CQUF0QixDQUFKLEVBQWlEO2FBQ2pEN0csU0FBSCxDQUFhRSxHQUFiLENBQWlCLCtCQUFqQjs4QkFDb0I1RSxFQUFwQjs7OztVQUlBLENBQUNvSSxLQUFELElBQVUsS0FBS2hGLFlBQUwsQ0FBa0IsWUFBbEIsQ0FBZCxFQUErQztnQkFDckM1TixTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFSO2NBQ002SCxTQUFOLENBQWdCRSxHQUFoQixDQUFvQixrQkFBcEIsRUFBd0MsT0FBeEM7Ozs7WUFJTThsRCxVQUFVbDFELFNBQVNxSCxhQUFULENBQXVCLE1BQXZCLENBQWhCO2dCQUNRNkgsU0FBUixDQUFrQkUsR0FBbEIsQ0FBc0IsMkJBQXRCO2NBQ00zRSxXQUFOLENBQWtCeXFELE9BQWxCOzs7VUFHRSxDQUFDdnNDLE1BQUwsRUFBYTtpQkFDRjNvQixTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFUOztZQUVJLENBQUNzTCxJQUFELElBQVMsQ0FBQ0MsS0FBVixJQUFtQixDQUFDd2hELGlCQUF4QixFQUEyQztpQkFDbEMsS0FBSzMrQyxVQUFMLENBQWdCLENBQWhCLENBQVAsRUFBMkI7bUJBQ2xCaEwsV0FBUCxDQUFtQixLQUFLZ0wsVUFBTCxDQUFnQixDQUFoQixDQUFuQjs7U0FGSixNQUlPO2VBQ0EsSUFBSS9ULEtBQUksS0FBSytULFVBQUwsQ0FBZ0I5VCxNQUFoQixHQUF5QixDQUF0QyxFQUF5Q0QsTUFBSyxDQUE5QyxFQUFpREEsSUFBakQsRUFBc0Q7Z0JBQzlDOEksTUFBSyxLQUFLaUwsVUFBTCxDQUFnQi9ULEVBQWhCLENBQVg7Z0JBQ0k4SSxRQUFPbUksSUFBUCxJQUFlbkksUUFBT29JLEtBQXRCLElBQStCcEksUUFBTzRwRCxpQkFBdEMsSUFBMkQ1cEQsSUFBRzZDLE9BQUgsS0FBZSxZQUE5RSxFQUE0RjtxQkFDbkZ3TSxZQUFQLENBQW9CclAsR0FBcEIsRUFBd0JtZSxPQUFPN08sVUFBL0I7Ozs7O1lBS0YsQ0FBQ3M2QyxpQkFBTCxFQUF3QjtlQUNqQnY2QyxZQUFMLENBQWtCOE8sTUFBbEIsRUFBMEIvVixTQUFTLElBQW5DOzs7O2FBSUcxRCxTQUFQLENBQWlCRSxHQUFqQixDQUFxQixRQUFyQixFQUErQixtQkFBL0I7O1VBRUlnbEQsaUJBQUosRUFBdUI7OzthQUdoQmUsSUFBTCxHQUFZNTNCLE9BQU92OUIsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBbkI7YUFDSzh0RCxJQUFMLENBQVVqbUQsU0FBVixDQUFvQkUsR0FBcEIsQ0FBd0IsS0FBeEIsRUFBK0IsZ0JBQS9CO2FBQ0szRSxXQUFMLENBQWlCLEtBQUswcUQsSUFBdEI7O2FBRUtBLElBQUwsQ0FBVTFxRCxXQUFWLENBQXNCa2UsTUFBdEI7WUFDSWhXLElBQUosRUFBVTtlQUNId2lELElBQUwsQ0FBVTFxRCxXQUFWLENBQXNCa0ksSUFBdEI7O1lBRUVDLEtBQUosRUFBVztlQUNKdWlELElBQUwsQ0FBVTFxRCxXQUFWLENBQXNCbUksS0FBdEI7Ozs7YUFJQzZHLFlBQUwsQ0FBa0IsSUFBbEI7O21CQUVhMnFDLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsU0FBaEM7Ozs7Ozs7Ozs7Ozs7b0NBVWM7OztVQUNWLEtBQUszQixZQUFMLENBQWtCLFlBQWxCLEtBQW1DLENBQUMsS0FBS3duRCxVQUE3QyxFQUF5RDthQUNsREMsUUFBTCxHQUFnQixJQUFoQjthQUNLRCxVQUFMLEdBQWtCLElBQWxCOztZQUVNL29ELFdBQVcsS0FBSzQyQyxnQkFBTCxDQUFzQjVCLFdBQXRCLEVBQWpCO2lCQUNTMFQsYUFBVCxDQUF1QixJQUF2QixFQUE2QixZQUFNO2lCQUM1QjdsRCxTQUFMLENBQWVFLEdBQWYsQ0FBbUIsVUFBbkI7aUJBQ0tnbUQsVUFBTCxHQUFrQixLQUFsQjtTQUZGOzs7Ozs7Ozs7Ozs7OztvQ0FjWTs7O1VBQ1YsS0FBS3huRCxZQUFMLENBQWtCLFlBQWxCLEtBQW1DLENBQUMsS0FBS3duRCxVQUE3QyxFQUF5RDthQUNsREMsUUFBTCxHQUFnQixLQUFoQjthQUNLRCxVQUFMLEdBQWtCLElBQWxCOztZQUVNL29ELFdBQVcsS0FBSzQyQyxnQkFBTCxDQUFzQjVCLFdBQXRCLEVBQWpCO2lCQUNTMlQsYUFBVCxDQUF1QixJQUF2QixFQUE2QixZQUFNO2lCQUM1QjlsRCxTQUFMLENBQWVJLE1BQWYsQ0FBc0IsVUFBdEI7aUJBQ0s4bEQsVUFBTCxHQUFrQixLQUFsQjtTQUZGOzs7OztzQ0FPYztXQUNYbG1ELFNBQUwsQ0FBZTZHLFFBQWYsQ0FBd0IsVUFBeEIsSUFBc0MsS0FBS2kvQyxhQUFMLEVBQXRDLEdBQTZELEtBQUtELGFBQUwsRUFBN0Q7Ozs7NkNBR3VCO2FBQ2hCLElBQUl4cEQsZUFBSixDQUFvQjttQkFDZHU0QyxlQURjO21CQUVkZ1EsZ0JBRmM7dUJBR1Ysa0JBSFU7MEJBSVAsS0FBSy94RCxZQUFMLENBQWtCLFdBQWxCLEtBQWtDO09BSi9DLENBQVA7Ozs7NkNBb0J1QnRCLE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCNnNDLGtCQUF4QixFQUEwQ2gyQyxTQUExQzs7YUFFRyxVQUFMO3VCQUNlbzBDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsU0FBcEQ7O2FBRUcsUUFBTDtpQkFDT2tLLFlBQUwsQ0FBa0IsSUFBbEI7O2FBRUcsV0FBTDtlQUNPd3BDLGdCQUFMLEdBQXdCLEtBQUtDLHNCQUFMLEVBQXhCOzs7Ozs7d0NBS2M7OzttQkFDTCxJQUFiLEVBQW1CLFlBQU07ZUFDbEJvUyxlQUFMLENBQXFCLElBQXJCO2VBQ0tDLHdCQUFMLEdBQWdDLE9BQUt6MEQsS0FBTCxDQUFXMGlELGVBQTNDO2VBQ0tnUyxNQUFMLEdBQWMsS0FBZDtPQUhGOzs7OzJDQU9xQjtXQUNoQkYsZUFBTCxDQUFxQixLQUFyQjs7OztvQ0FHY2xtRCxLQUFLO1VBQ2JrSCxTQUFTLENBQUNsSCxNQUFNLEtBQU4sR0FBYyxRQUFmLElBQTJCLGVBQTFDO2FBQ0trSCxNQUFMLEVBQWEsSUFBYixFQUFtQixZQUFuQixFQUFpQyxLQUFLbS9DLFFBQXRDLEVBQWdELEVBQUV6ckMsU0FBUyxJQUFYLEVBQWhEO2FBQ0sxVCxNQUFMLEVBQWEsSUFBYixFQUFtQixXQUFuQixFQUFnQyxLQUFLby9DLFVBQXJDLEVBQWlELEVBQUUxckMsU0FBUyxJQUFYLEVBQWpEO1dBQ0sxVCxNQUFMLEVBQWEsYUFBYixFQUE0QixLQUFLby9DLFVBQWpDO1dBQ0twL0MsTUFBTCxFQUFhLFVBQWIsRUFBeUIsS0FBS28vQyxVQUE5QjtXQUNLcC9DLE1BQUwsRUFBYSxZQUFiLEVBQTJCLEtBQUtvL0MsVUFBaEM7V0FDS3AvQyxNQUFMLEVBQWEsTUFBYixFQUFxQixLQUFLcS9DLE9BQTFCO1dBQ0tyL0MsTUFBTCxFQUFhLFdBQWIsRUFBMEIsS0FBS20vQyxRQUEvQjtXQUNLbi9DLE1BQUwsRUFBYSxTQUFiLEVBQXdCLEtBQUtvL0MsVUFBN0I7V0FDS3AvQyxNQUFMLEVBQWEsVUFBYixFQUF5QixLQUFLby9DLFVBQTlCOztVQUVJLEtBQUtQLElBQVQsRUFBZTthQUNSQSxJQUFMLENBQVU3K0MsTUFBVixFQUFrQixPQUFsQixFQUEyQixLQUFLdStDLGVBQWhDOzs7Ozs0QkFJSXpqRCxPQUFPO1VBQ1BrSyxVQUFVbEssTUFBTWtLLE9BQXRCOztVQUVJLEtBQUsxTixZQUFMLENBQWtCLGNBQWxCLEtBQXFDLENBQUMsTUFBRCxFQUFTLE9BQVQsRUFBa0IvTCxPQUFsQixDQUEwQnlaLFFBQVFtSixTQUFsQyxJQUErQyxDQUFDLENBQXpGLEVBQTRGO2dCQUNsRjVKLGNBQVI7Ozs7OzZCQUlLclMsR0FBRzs7O1VBQ04sS0FBS2d0RCxNQUFMLElBQ0QsU0FBU2h0RCxFQUFFQyxNQUFYLEtBQXNCLEtBQUtxc0QsZ0JBQUwsQ0FBc0J0c0QsRUFBRUMsTUFBeEIsS0FBbUMvSCxPQUFLaVAsVUFBTCxDQUFnQm5ILEVBQUVDLE1BQWxCLEVBQTBCLEtBQUtxc0QsZ0JBQS9CLEVBQWlEO2VBQUtwd0QsWUFBTDtPQUFqRCxDQUF6RCxDQURILEVBRUU7ZUFBQTs7O1dBSUc4d0QsTUFBTCxHQUFjLElBQWQ7VUFDTUksYUFBYSxFQUFFbDNDLFlBQVksa0VBQWQsRUFBbkI7O1VBRUksS0FBSzlRLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBSixFQUFtQztZQUM3QixLQUFLOU0sS0FBTCxDQUFXMGlELGVBQWYsRUFBZ0M7ZUFDekIrUix3QkFBTCxHQUFnQyxLQUFLejBELEtBQUwsQ0FBVzBpRCxlQUEzQzs7O21CQUdTQSxlQUFYLEdBQTZCLEtBQUt6aEQsWUFBTCxDQUFrQixzQkFBbEIsS0FBNkMsU0FBMUU7bUJBQ1c4ekQsU0FBWCx5QkFBMkNELFdBQVdwUyxlQUF0RDs7O2FBR0ssSUFBUCxFQUFhb1MsVUFBYjs7OztpQ0FHVztXQUNOSixNQUFMLEdBQWMsS0FBZDtXQUNLMTBELEtBQUwsQ0FBVzBpRCxlQUFYLEdBQTZCLEtBQUsrUix3QkFBTCxJQUFpQyxFQUE5RDthQUNPcDBELEtBQVAsQ0FBYSxJQUFiLEVBQW1CLHNCQUFuQjs7OzsyQkF2RnNCO2FBQ2YsS0FBS2lILGFBQUwsQ0FBbUIsZ0NBQW5CLENBQVA7Ozs7MkJBR2tCO2FBQ1gsS0FBS0EsYUFBTCxDQUFtQiw0QkFBbkIsQ0FBUDs7OzsyQkFUOEI7YUFDdkIsQ0FBQyxVQUFELEVBQWEsT0FBYixFQUFzQixRQUF0QixFQUFnQyxXQUFoQyxDQUFQOzs7O0VBeE55Q280Qzs7QUFzVDdDN2tDLFlBQVltNkMsUUFBWixHQUF1QmxCLGVBQXZCO0FBQ0FuMkIsZUFBZUwsTUFBZixDQUFzQixlQUF0QixFQUF1Q3cyQixlQUF2Qzs7QUM3WkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBTUEsSUFBTXJQLHFCQUFtQixNQUF6QjtBQUNBLElBQU1oMkMsWUFBUyxFQUFDLElBQUksU0FBTCxFQUFmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQ3FCd21EOzs7Ozs7Ozs7Ozt5QkFVTDs7Ozs7VUFHUC9SLFFBQUw7Ozs7OzsrQkFHUztnQkFDQzMxQyxPQUFWLENBQWtCLElBQWxCO1dBQ0thLFNBQUwsQ0FBZUUsR0FBZixDQUFtQm0yQyxrQkFBbkI7bUJBQ2FuQixZQUFiLENBQTBCLElBQTFCLEVBQWdDNzBDLFNBQWhDOzs7OzZDQU91QjlPLE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCNnNDLGtCQUF4QixFQUEwQ2gyQyxTQUExQzs7YUFFRyxVQUFMO3VCQUNlbzBDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsU0FBcEQ7Ozs7OzsyQkFWMEI7YUFDdkIsQ0FBQyxVQUFELEVBQWEsT0FBYixDQUFQOzs7O0VBdkJxQ2l4Qzs7QUFzQ3pDN2tDLFlBQVlxNkMsSUFBWixHQUFtQkQsV0FBbkI7QUFDQXQzQixlQUFlTCxNQUFmLENBQXNCLFVBQXRCLEVBQWtDMjNCLFdBQWxDOztBQy9GQTs7Ozs7Ozs7Ozs7OztBQWFBLEFBTUEsSUFBTUUsbUJBQW1CLENBQ3ZCLGdCQUR1QixFQUV2QixjQUZ1QixFQUd2QixhQUh1QixFQUl2QixXQUp1QixFQUt2QixVQUx1QixFQU12QixXQU51QixFQU92QixLQVB1QixFQVF2QixXQVJ1QixFQVN2QixLQVR1QixFQVV2QixXQVZ1QixFQVd2QixNQVh1QixFQVl2QixTQVp1QixFQWF2QixhQWJ1QixFQWN2QixVQWR1QixFQWV2QixVQWZ1QixFQWdCdkIsTUFoQnVCLEVBaUJ2QixNQWpCdUIsRUFrQnZCLFdBbEJ1QixFQW1CdkIsT0FuQnVCLENBQXpCOztJQXNCcUJDOzs7OzhCQUVUOzs7OzJCQUVJO2FBQ1AxN0MsV0FBTDs7OzsyQkFHYzthQUNUQSxXQUFMOzs7OzJCQUdTO2FBQ0pBLFdBQUw7Ozs7OEJBR1k7Ozs7O1FBR1IsTUFBS3lyQixXQUFMLEtBQXFCaXdCLGdCQUF6QixFQUEyQzthQUNwQzM3QyxhQUFMOzs7d0JBR2lCO2FBQU0sTUFBS3lwQyxRQUFMLEVBQU47S0FBbkI7VUFDS21TLG1CQUFMLEdBQTJCLE1BQUtDLGNBQUwsQ0FBb0IzdkQsSUFBcEIsT0FBM0I7Ozs7OzsrQkFHUztnQkFDQzRILE9BQVYsQ0FBa0IsSUFBbEI7V0FDS20yQyxpQkFBTCxJQUEwQixLQUFLdDFDLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixLQUFLbzFDLGlCQUF4QixDQUExQjs7VUFFSSxLQUFLdHlDLFFBQUwsQ0FBY3ZRLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0M7Ozs7V0FJM0I4SSxXQUFMLENBQWlCL0osT0FBSzBKLGNBQUwsQ0FBb0IsS0FBS2lzRCxTQUF6QixDQUFqQjs7V0FFS0MsV0FBTDs7V0FFS0Msc0JBQUw7O21CQUVhblMsWUFBYixDQUEwQixJQUExQixFQUFnQyxLQUFLUixPQUFyQzs7Ozs2Q0FHdUI7Ozt1QkFDTjVpRCxPQUFqQixDQUF5QixnQkFBUTtZQUMzQixPQUFLNE0sWUFBTCxDQUFrQm9oRCxJQUFsQixDQUFKLEVBQTZCO2lCQUN0QndILE1BQUwsQ0FBWTlvRCxZQUFaLENBQXlCc2hELElBQXpCLEVBQStCLE9BQUtqdEQsWUFBTCxDQUFrQml0RCxJQUFsQixDQUEvQjtTQURGLE1BRU87aUJBQ0F3SCxNQUFMLENBQVl4MEQsZUFBWixDQUE0Qmd0RCxJQUE1Qjs7T0FKSjs7V0FRS0gsT0FBTDs7OzttQ0FHYXo5QyxPQUFPO1VBQ2Q1SSxJQUFJLElBQUkwUCxXQUFKLENBQWdCOUcsTUFBTTdHLElBQXRCLEVBQTRCO2lCQUMzQixLQUQyQjtvQkFFeEI7T0FGSixDQUFWOzthQUtPLEtBQUtnSCxhQUFMLENBQW1CL0ksQ0FBbkIsQ0FBUDs7OztrQ0FHWTtVQUNSLEtBQUtvRixZQUFMLENBQWtCLFVBQWxCLENBQUosRUFBbUM7YUFDNUI0b0QsTUFBTCxDQUFZOWxELEVBQVosR0FBaUIsS0FBSzNPLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBakI7Ozs7O3dDQW9DZ0I7OzttQkFDTCxJQUFiLEVBQW1CLFlBQU07ZUFDbEJ5MEQsTUFBTCxDQUFZM3VELGdCQUFaLENBQTZCLE9BQTdCLEVBQXNDLE9BQUtzdUQsbUJBQTNDO2VBQ0tLLE1BQUwsQ0FBWTN1RCxnQkFBWixDQUE2QixNQUE3QixFQUFxQyxPQUFLc3VELG1CQUExQztPQUZGOzs7OzJDQU1xQjs7O21CQUNSLElBQWIsRUFBbUIsWUFBTTtlQUNsQkssTUFBTCxDQUFZNXVELG1CQUFaLENBQWdDLE9BQWhDLEVBQXlDLE9BQUt1dUQsbUJBQTlDO2VBQ0tLLE1BQUwsQ0FBWTV1RCxtQkFBWixDQUFnQyxNQUFoQyxFQUF3QyxPQUFLdXVELG1CQUE3QztPQUZGOzs7OzZDQVV1QjExRCxNQUFNa08sTUFBTUMsU0FBUzs7O2NBQ3BDbk8sSUFBUjthQUNPLFVBQUw7dUJBQ2UsSUFBYixFQUFtQjttQkFBTWlPLGFBQWFpMUMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLFVBQW9ELE9BQUtnMUMsT0FBekQsQ0FBTjtXQUFuQjs7YUFFRyxVQUFMO3VCQUNlLElBQWIsRUFBbUI7bUJBQU0sT0FBSzBTLFdBQUwsRUFBTjtXQUFuQjs7YUFFRyxPQUFMO2lCQUNPNTlDLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0IsS0FBSzhyQyxpQkFBN0IsRUFBZ0QsS0FBS1osT0FBckQ7Ozs7VUFJQXFTLGlCQUFpQnAwRCxPQUFqQixDQUF5QnBCLElBQXpCLEtBQWtDLENBQXRDLEVBQXlDO3FCQUMxQixJQUFiLEVBQW1CO2lCQUFNLE9BQUs4MUQsc0JBQUwsRUFBTjtTQUFuQjs7Ozs7MkJBaEVvQjthQUNmLEVBQVA7Ozs7MkJBR1c7YUFDSixLQUFLbnVELGFBQUwsQ0FBbUIsT0FBbkIsQ0FBUDs7OzsyQkFHVTthQUNILEtBQUtvdUQsTUFBTCxLQUFnQixJQUFoQixHQUNILEtBQUt6MEQsWUFBTCxDQUFrQixPQUFsQixDQURHLEdBRUgsS0FBS3kwRCxNQUFMLENBQVlqeEQsS0FGaEI7O3lCQUtRZzZCLEtBQUs7OzttQkFDQSxJQUFiLEVBQW1CLFlBQU07WUFDbkJBLGVBQWV2WSxJQUFuQixFQUF5QjtnQkFDakJ1WSxJQUFJazNCLFdBQUosR0FBa0J2d0QsU0FBbEIsQ0FBNEIsQ0FBNUIsRUFBK0IsRUFBL0IsQ0FBTjs7ZUFFR3N3RCxNQUFMLENBQVlqeEQsS0FBWixHQUFvQmc2QixHQUFwQjtlQUNLc3ZCLE9BQUw7T0FMRjs7Ozt5QkFTV3RwRCxPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7OzJCQUdhO2FBQ04sS0FBS3FJLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7OzsyQkFpQjhCO2NBQ3RCLFVBQVIsRUFBb0IsVUFBcEIsRUFBZ0MsT0FBaEMsU0FBNENxb0QsZ0JBQTVDOzs7O0VBdEgwQ3pWOztBQ3pDOUM7Ozs7Ozs7Ozs7Ozs7QUFhQSxBQUtBLElBQU1qeEMsWUFBUztpQkFDRSxlQURGO3dCQUVTO0NBRnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQThDcUJtbkQ7OzswQkFFTDs7Ozs7VUFHUEMsYUFBTCxHQUFxQixNQUFLOUgsT0FBTCxDQUFhcG9ELElBQWIsT0FBckI7VUFDS213RCxlQUFMLEdBQXVCLE1BQUsvSCxPQUFMLENBQWFwb0QsSUFBYixPQUF2Qjs7Ozs7Ozs7OEJBS1E7V0FDSG93RCxZQUFMO1dBQ0tDLGlCQUFMOzs7Ozs7OzttQ0FxQmE7VUFDUHBuQyxRQUFRLEtBQUszdEIsWUFBTCxDQUFrQixhQUFsQixLQUFvQyxFQUFsRDs7VUFFSSxPQUFPLEtBQUtnMUQsT0FBTCxDQUFhOXRELFdBQXBCLEtBQW9DLFdBQXhDLEVBQXFEO2FBQzlDOHRELE9BQUwsQ0FBYTl0RCxXQUFiLEdBQTJCeW1CLEtBQTNCO09BREYsTUFFTzthQUNBcW5DLE9BQUwsQ0FBYUMsU0FBYixHQUF5QnRuQyxLQUF6Qjs7Ozs7d0NBSWdCO1VBQ2QsS0FBS25xQixLQUFMLEtBQWUsRUFBbkIsRUFBdUI7YUFDaEJ3eEQsT0FBTCxDQUFhN25ELFNBQWIsQ0FBdUJJLE1BQXZCLENBQThCLHFDQUE5QjtPQURGLE1BRU87YUFDQXluRCxPQUFMLENBQWE3bkQsU0FBYixDQUF1QkUsR0FBdkIsQ0FBMkIscUNBQTNCOzs7Ozt3Q0FRZ0I7Ozs7O21CQUdMLElBQWIsRUFBbUIsWUFBTTtlQUNsQm9uRCxNQUFMLENBQVkzdUQsZ0JBQVosQ0FBNkIsT0FBN0IsRUFBc0MsT0FBSzh1RCxhQUEzQztlQUNLSCxNQUFMLENBQVkzdUQsZ0JBQVosQ0FBNkIsU0FBN0IsRUFBd0MsT0FBSyt1RCxlQUE3QztPQUZGOztVQUtNcnNELE9BQU8sS0FBS3hJLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBYjtVQUNJLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0JGLE9BQXRCLENBQThCMEksSUFBOUIsS0FBdUMsQ0FBM0MsRUFBOEM7ZUFDdkNySixJQUFMLDZCQUFvQ3FKLElBQXBDLGdEQUFtRkEsSUFBbkY7Ozs7OzJDQUltQjs7Ozs7bUJBR1IsSUFBYixFQUFtQixZQUFNO2VBQ2xCaXNELE1BQUwsQ0FBWTV1RCxtQkFBWixDQUFnQyxPQUFoQyxFQUF5QyxPQUFLK3VELGFBQTlDO2VBQ0tILE1BQUwsQ0FBWTV1RCxtQkFBWixDQUFnQyxTQUFoQyxFQUEyQyxPQUFLZ3ZELGVBQWhEO09BRkY7Ozs7NkNBVXVCbjJELE1BQU1rTyxNQUFNQyxTQUFTOzs7Y0FDcENuTyxJQUFSO2FBQ08sTUFBTDt1QkFDZSxJQUFiLEVBQW1CO21CQUFNLE9BQUsrMUQsTUFBTCxDQUFZOW9ELFlBQVosQ0FBeUIsTUFBekIsRUFBaUMsT0FBS25ELElBQXRDLENBQU47V0FBbkI7Ozs4SUFHK0I5SixJQUEvQixFQUFxQ2tPLElBQXJDLEVBQTJDQyxPQUEzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQXpFUTthQUNMVyxTQUFQOzs7OzJCQUdjO3VDQUVHLEtBQUtoRixJQUR0Qjs7OzsyQkFNUztVQUNIQSxPQUFPLEtBQUt4SSxZQUFMLENBQWtCLE1BQWxCLENBQWI7YUFDUSxDQUFDLFVBQUQsRUFBYSxPQUFiLEVBQXNCRixPQUF0QixDQUE4QjBJLElBQTlCLElBQXNDLENBQXZDLElBQTZDQSxJQUE3QyxJQUFxRCxNQUE1RDs7OzsyQkF1Qlk7YUFDTCxLQUFLbkMsYUFBTCxDQUFtQixNQUFuQixDQUFQOzs7OzJCQTBCOEI7MklBQ08sTUFBckM7Ozs7RUFoRnNDOHREOztBQWlKMUN2NkMsWUFBWXM3QyxLQUFaLEdBQW9CUCxZQUFwQjtBQUNBajRCLGVBQWVMLE1BQWYsQ0FBc0IsV0FBdEIsRUFBbUNzNEIsWUFBbkM7O0FDbE5BOzs7Ozs7Ozs7Ozs7O0FBYUEsSUFHcUJROzs7aUNBRUw7Ozs7O1FBR1IsTUFBS2p4QixXQUFMLEtBQXFCaXhCLG1CQUF6QixFQUE4QztXQUN2QzM4QyxhQUFMOzs7d0JBR2lCLFlBQU07WUFDbEI4M0Isd0JBQUwsQ0FBOEIsU0FBOUIsRUFBeUMsSUFBekMsRUFBK0MsTUFBS3R3QyxZQUFMLENBQWtCLFNBQWxCLENBQS9DO0tBREY7Ozs7Ozs7OzZDQWtDdUJ0QixNQUFNa08sTUFBTUMsU0FBUztjQUNwQ25PLElBQVI7YUFDTyxTQUFMO2VBQ08wMkQsT0FBTCxHQUFldm9ELFlBQVksSUFBM0I7Ozs0SkFHK0JuTyxJQUEvQixFQUFxQ2tPLElBQXJDLEVBQTJDQyxPQUEzQzs7Ozs7MkJBakNVO3VDQUVHLEtBQUtyRSxJQUR0QixpQkFDc0MsS0FBS2k2QyxpQkFEM0Msc0NBRWlCLEtBQUtBLGlCQUZ0Qjs7Ozs7OzsyQkFRWTthQUNMLEtBQUtwOEMsYUFBTCxDQUFtQixNQUFuQixDQUFQOzs7OzJCQUdZO2FBQ0wsS0FBS291RCxNQUFMLENBQVlXLE9BQW5COzt5QkFHVTUzQixLQUFLOzs7bUJBQ0YsSUFBYixFQUFtQixZQUFNO2VBQ2xCaTNCLE1BQUwsQ0FBWVcsT0FBWixHQUFzQjUzQixHQUF0QjtPQURGOzs7OzJCQUs4Qjt5SkFDTyxTQUFyQzs7OztFQXhDNkMyMkI7O0FDaEJqRDs7Ozs7Ozs7Ozs7OztBQWFBLEFBR0EsSUFBTTNtRCxZQUFTO2VBQ0EsYUFEQTtzQkFFTyxvQkFGUDswQkFHVztDQUgxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNkNxQjZuRDs7Ozs7Ozs7OzsyQkFFTDthQUNMN25ELFNBQVA7Ozs7MkJBR3NCO2FBQ2YsVUFBUDs7OzsyQkFHUzthQUNGLFVBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFYeUMybkQ7O0FBK0M3Q3Y3QyxZQUFZMDdDLFFBQVosR0FBdUJELGVBQXZCO0FBQ0EzNEIsZUFBZUwsTUFBZixDQUFzQixjQUF0QixFQUFzQ2c1QixlQUF0Qzs7QUM3R0E7Ozs7Ozs7Ozs7Ozs7QUFhQSxBQUdBLElBQU03bkQsWUFBUzttQkFDSSxpQkFESjswQkFFVyx3QkFGWDs4QkFHZTtDQUg5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMENxQituRDs7Ozs7Ozs7OzsyQkFFTDthQUNML25ELFNBQVA7Ozs7MkJBR3NCO2FBQ2YsY0FBUDs7OzsyQkFHUzthQUNGLE9BQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFYc0MybkQ7O0FBK0MxQ3Y3QyxZQUFZNDdDLEtBQVosR0FBb0JELFlBQXBCO0FBQ0E3NEIsZUFBZUwsTUFBZixDQUFzQixXQUF0QixFQUFtQ2s1QixZQUFuQzs7QUMxR0E7Ozs7Ozs7Ozs7Ozs7QUFhQSxBQUdBLElBQU0vbkQsWUFBUzttQkFDSTtDQURuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBd0NxQmlvRDs7Ozs7Ozs7OzsyQkFFTDthQUNMam9ELFNBQVA7Ozs7MkJBR2M7dUNBRUcsS0FBS2hGLElBRHRCOzs7OzJCQUtTO2FBQ0YsUUFBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFiNEMyckQ7O0FBeUNoRHY2QyxZQUFZODdDLFdBQVosR0FBMEJELGtCQUExQjtBQUNBLzRCLGVBQWVMLE1BQWYsQ0FBc0Isa0JBQXRCLEVBQTBDbzVCLGtCQUExQzs7QUNsR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBRXFCRTs7Ozs7Ozs7OzJCQVE4QzttRkFBSixFQUFJOzJCQUFwRHg3QyxNQUFvRDtRQUFwREEsTUFBb0QsK0JBQTNDLFFBQTJDOzBCQUFqQ3JQLEtBQWlDO1FBQWpDQSxLQUFpQyw4QkFBekIsQ0FBeUI7NkJBQXRCRCxRQUFzQjtRQUF0QkEsUUFBc0IsaUNBQVgsR0FBVzs7O3dIQUN6RCxFQUFFc1AsY0FBRixFQUFVclAsWUFBVixFQUFpQkQsa0JBQWpCLEVBRHlEOzs7Ozs7Ozs7Ozt5QkFRNUQrcUQsT0FBTzd2RCxVQUFVOzs7Ozs7Ozs7Ozt5QkFRakI2dkQsT0FBTzd2RCxVQUFVOzs7OztFQXhCbUJvNUM7O0FDbEIzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFHQTs7OztJQUdxQjBXOzs7K0JBRThDO21GQUFKLEVBQUk7MkJBQXBEMTdDLE1BQW9EO1FBQXBEQSxNQUFvRCwrQkFBM0MsUUFBMkM7MEJBQWpDclAsS0FBaUM7UUFBakNBLEtBQWlDLDhCQUF6QixDQUF5Qjs2QkFBdEJELFFBQXNCO1FBQXRCQSxRQUFzQixpQ0FBWCxHQUFXOzs7Z0lBQ3pELEVBQUVzUCxjQUFGLEVBQVVyUCxZQUFWLEVBQWlCRCxrQkFBakIsRUFEeUQ7Ozs7Ozs7Ozs7O3lCQVE1RCtxRCxPQUFPN3ZELFVBQVU7aUJBQ1RBLFdBQVdBLFFBQVgsR0FBc0IsWUFBVyxFQUE1Qzs7YUFFTzZ2RCxLQUFQLEVBQWMsS0FBS3R5QixHQUFuQixFQUNHZ2QsT0FESCxDQUNXLEVBQUVGLFNBQVMsQ0FBWCxFQURYLEVBQzJCLEVBQUVBLFNBQVMsQ0FBWCxFQUQzQixFQUVHNWpDLEtBRkgsQ0FFUyxnQkFBUTs7O09BRmpCLEVBTUdvQixJQU5IOzs7Ozs7Ozs7O3lCQWFHZzRDLE9BQU83dkQsVUFBVTtpQkFDVEEsV0FBV0EsUUFBWCxHQUFzQixZQUFXLEVBQTVDOzthQUVPNnZELEtBQVAsRUFBYyxLQUFLdHlCLEdBQW5CLEVBQ0dnZCxPQURILENBQ1csRUFBRUYsU0FBUyxDQUFYLEVBRFgsRUFDMkIsRUFBRUEsU0FBUyxDQUFYLEVBRDNCLEVBRUc1akMsS0FGSCxDQUVTLGdCQUFROzs7T0FGakIsRUFNR29CLElBTkg7Ozs7RUE3QjJDKzNDOztBQ3hCL0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBR0E7Ozs7SUFJcUJHOzs7K0JBRW9FO21GQUFKLEVBQUk7MkJBQTFFMzdDLE1BQTBFO1FBQTFFQSxNQUEwRSwrQkFBakUsOEJBQWlFOzBCQUFqQ3JQLEtBQWlDO1FBQWpDQSxLQUFpQyw4QkFBekIsQ0FBeUI7NkJBQXRCRCxRQUFzQjtRQUF0QkEsUUFBc0IsaUNBQVgsR0FBVzs7O2dJQUMvRSxFQUFFc1AsY0FBRixFQUFVclAsWUFBVixFQUFpQkQsa0JBQWpCLEVBRCtFOzs7Ozs7Ozs7Ozt5QkFRbEYrcUQsT0FBTzd2RCxVQUFVO2lCQUNUQSxXQUFXQSxRQUFYLEdBQXNCLFlBQVcsRUFBNUM7O2FBRU82dkQsS0FBUCxFQUFjLEtBQUt0eUIsR0FBbkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLHlCQUFiLEVBRkosRUFHSSxFQUFFQSxXQUFXLHNCQUFiLEVBSEosRUFLRy9qQyxLQUxILENBS1MsZ0JBQVE7OztPQUxqQixFQVNHb0IsSUFUSDs7Ozs7Ozs7Ozt5QkFnQkdnNEMsT0FBTzd2RCxVQUFVO2lCQUNUQSxXQUFXQSxRQUFYLEdBQXNCLFlBQVcsRUFBNUM7O2FBRU82dkQsS0FBUCxFQUFjLEtBQUt0eUIsR0FBbkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLHNCQUFiLEVBRkosRUFHSSxFQUFFQSxXQUFXLHlCQUFiLEVBSEosRUFLRy9qQyxLQUxILENBS1MsZ0JBQVE7OztPQUxqQixFQVNHb0IsSUFUSDs7OztFQWhDMkMrM0M7O0FDeEIvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFXQSxJQUFNbm9ELFlBQVM7TUFDVCxVQURTO29CQUVLO0NBRnBCOztBQUtBLElBQU1nMkMscUJBQW1CLE9BQXpCOztBQUVBLElBQU16QixrQkFBZ0I7YUFDVDRULGFBRFM7VUFFWkUsaUJBRlk7VUFHWkMsaUJBSFk7VUFJWkg7Q0FKVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0NxQkk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBcUVMOzs7OztVQUdQL1UsV0FBTCxHQUFtQjthQUFNbHlDLFNBQU47S0FBbkI7d0JBQ21CO2FBQU0sTUFBS216QyxRQUFMLEVBQU47S0FBbkI7Ozs7Ozs2Q0FPdUI7YUFDaEIsSUFBSXo0QyxlQUFKLENBQW9CO21CQUNkdTRDLGVBRGM7bUJBRWQ0VCxhQUZjO3VCQUdWLGVBSFU7MEJBSVAsS0FBSzMxRCxZQUFMLENBQWtCLFdBQWxCO09BSmIsQ0FBUDs7Ozs7Ozs7Ozs7OzsrQkFnQlM7V0FDSmpCLEtBQUwsQ0FBV3NSLE9BQVgsR0FBcUIsTUFBckI7V0FDS3RSLEtBQUwsQ0FBV2dTLE1BQVgsR0FBb0IsS0FBcEI7V0FDSzVELFNBQUwsQ0FBZUUsR0FBZixDQUFtQm0yQyxrQkFBbkI7O1VBRUksQ0FBQzdrRCxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsaUJBQXJCLENBQUwsRUFBOEM7WUFDdEN0TSxVQUFVbEosU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7Z0JBQ1E2SCxTQUFSLENBQWtCRSxHQUFsQixDQUFzQixnQkFBdEI7O2VBRU8sS0FBS3FHLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBUCxFQUEyQjtjQUNuQmhELE9BQU8sS0FBS2dELFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBYjtlQUNLaWpCLFdBQUwsQ0FBaUJqbUIsSUFBakI7a0JBQ1FvSCxZQUFSLENBQXFCcEgsSUFBckIsRUFBMkIsSUFBM0I7OzthQUdHaEksV0FBTCxDQUFpQnZCLE9BQWpCOzs7bUJBR1drN0MsWUFBYixDQUEwQixJQUExQixFQUFnQyxLQUFLUixPQUFyQzs7OztpQ0FHV2pCLFlBQVk7V0FDbEI3aEQsS0FBTCxDQUFXc1IsT0FBWCxHQUFxQnV3QyxhQUFhLE9BQWIsR0FBdUIsTUFBNUM7Ozs7d0NBR2tCOzs7OzsyQ0FJRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZDQW1GRWxpRCxNQUFNa08sTUFBTUMsU0FBUztVQUN4Q25PLFNBQVMsT0FBYixFQUFzQjtlQUNmaVksWUFBTCxDQUFrQixJQUFsQixFQUF3QjZzQyxrQkFBeEIsRUFBMENoMkMsU0FBMUM7T0FERixNQUVPOzRJQUMwQjlPLElBQS9CLEVBQXFDa08sSUFBckMsRUFBMkNDLE9BQTNDOzs7Ozs7Ozs7OzsyQkF6SVU7YUFDTFcsU0FBUDs7OztxQ0FnSnNCOU8sTUFBTThMLFVBQVU7VUFDbEMsRUFBRUEsU0FBU3BNLFNBQVQsWUFBOEJ1M0QsYUFBaEMsQ0FBSixFQUFvRDtlQUM3Q2g5QyxhQUFMLENBQW1CLE9BQW5COztzQkFFWWphLElBQWQsSUFBc0I4TCxRQUF0Qjs7OzsyQkFwQjhCOzJJQUNPLE9BQXJDOzs7OzJCQXNCcUI7YUFDZHUzQyxlQUFQOzs7OzJCQUd5QjthQUNsQjRULGFBQVA7Ozs7RUF6T3NDaFY7O0FBNk8xQy9tQyxZQUFZbzhDLEtBQVosR0FBb0JELFlBQXBCO0FBQ0FyNUIsZUFBZUwsTUFBZixDQUFzQixXQUF0QixFQUFtQzA1QixZQUFuQzs7QUNuVEE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBR0EsSUFBTUUsWUFBWSxTQUFaQSxTQUFZLENBQUMzMEQsS0FBRCxFQUFXO2FBQ1AsQ0FBQ0ksU0FBU0osS0FBVCxFQUFnQixFQUFoQixDQUFELEVBQXNCLEtBQUtMLElBQUwsQ0FBVUssS0FBVixDQUF0QixDQURPO01BQ3BCa0MsS0FEb0I7TUFDYjA2QixFQURhOztTQUVwQkEsS0FBSzE2QixLQUFMLEdBQWEwVSxLQUFLcXVDLEtBQUwsQ0FBV3RvRCxTQUFTbUksSUFBVCxDQUFjOHZELFdBQWQsR0FBNEIxeUQsS0FBNUIsR0FBb0MsR0FBL0MsQ0FBcEI7Q0FGRjs7SUFLcUIyeUQ7dUJBRVBsOEMsTUFBWixFQUFvQjs7Ozs7bUZBRWYzYSxLQURILENBQ1MsS0FEVCxFQUNnQkwsT0FEaEIsQ0FDd0I7YUFBTyxNQUFLQyxHQUFMLElBQVkrYSxPQUFPL2EsR0FBUCxDQUFuQjtLQUR4Qjs7U0FHS2szRCxjQUFMLEdBQXNCbjhDLE9BQU9tOEMsY0FBUCxJQUF5Qm44QyxPQUFPbmIsT0FBdEQ7U0FDS3UzRCxZQUFMLEdBQW9CcDhDLE9BQU9vOEMsWUFBUCxJQUF3QjthQUFNLEVBQU47S0FBNUM7U0FDS0MsT0FBTCxHQUFlcjhDLE9BQU9xOEMsT0FBUCxJQUFtQjthQUFNLE1BQU47S0FBbEM7O1NBRUtDLGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQjd4RCxJQUFuQixDQUF3QixJQUF4QixDQUFyQjs7U0FFSzRnRCxnQkFBTCxHQUF3QjNtRCxPQUFLZ1UsT0FBTCxDQUFhRSxjQUFiLEtBQWdDLEtBQXhEOzs7Ozs2QkFHeUQ7VUFBcEQweUMsU0FBb0QsdUVBQXhDLEtBQUt6bUQsT0FBTCxDQUFhK00sWUFBYixDQUEwQixXQUExQixDQUF3Qzs7VUFDckQsQ0FBQyxLQUFLMnFELGVBQVYsRUFBMkI7YUFDcEJBLGVBQUwsR0FBdUIsSUFBSXA0QyxlQUFKLENBQW9CLEtBQUtnNEMsY0FBekIsRUFBeUMsRUFBRXR0QyxpQkFBaUIsQ0FBbkIsRUFBc0JiLFNBQVMsQ0FBQyxLQUFLcTlCLGdCQUFyQyxFQUF6QyxDQUF2Qjs7O1VBR0kvd0MsU0FBU2d4QyxZQUFZLElBQVosR0FBbUIsS0FBbEM7V0FDS2lSLGVBQUwsQ0FBcUJqaUQsTUFBckIsRUFBNkIsd0JBQTdCLEVBQXVELEtBQUtnaUQsYUFBNUQ7Ozs7a0NBR1k5dkQsR0FBRztVQUNYQSxFQUFFOFMsT0FBTixFQUFlO1lBQ1Q5UyxFQUFFK0IsSUFBRixLQUFXLFdBQWYsRUFBNEI7ZUFDckIwOEMsV0FBTCxDQUFpQnorQyxDQUFqQjtTQURGLE1BRU8sSUFBSSxDQUFDLEtBQUtvaEQsV0FBVixFQUF1QjtZQUMxQnIvQyxJQUFGLEtBQVcsU0FBWCxHQUF1QixLQUFLNDhDLFNBQUwsQ0FBZTMrQyxDQUFmLENBQXZCLEdBQTJDLEtBQUswK0MsTUFBTCxDQUFZMStDLENBQVosQ0FBM0M7Ozs7OztnQ0FLTTRJLE9BQU87OztVQUNYOFMsY0FBYyxTQUFkQSxXQUFjO2VBQU0sT0FBS20wQyxPQUFMLE9BQW1CLE1BQW5CLEdBQTRCam5ELE1BQU1rSyxPQUFOLENBQWNxTixNQUFkLENBQXFCMUYsT0FBakQsR0FBMkRuakIsT0FBT2d6QixVQUFQLEdBQW9CMWhCLE1BQU1rSyxPQUFOLENBQWNxTixNQUFkLENBQXFCMUYsT0FBMUc7T0FBcEI7V0FDSzJtQyxXQUFMLEdBQW1CeDRDLE1BQU15NEMsUUFBTixJQUFrQixDQUFDbnBELE9BQUsyYSxjQUFMLENBQW9CakssS0FBcEIsQ0FBbkIsSUFBaUQsS0FBS29uRCxXQUFMLENBQWlCcG5ELEtBQWpCLEVBQXdCOFMsYUFBeEIsQ0FBcEU7O1VBRUksQ0FBQyxLQUFLMGxDLFdBQVYsRUFBdUI7Y0FDZkUsT0FBTixJQUFpQjE0QyxNQUFNMDRDLE9BQU4sRUFBakI7Y0FDTUQsUUFBTixHQUFpQixJQUFqQjs7YUFFSzRPLE1BQUwsR0FBY1QsVUFBVSxLQUFLbjNELE9BQUwsQ0FBYUMsS0FBYixDQUFtQnVDLEtBQW5CLElBQTRCLE1BQXRDLENBQWQ7YUFDS3ExRCxjQUFMLEdBQXNCLEtBQUtDLFNBQUwsR0FBa0IsRUFBRSxLQUFLQyxjQUFMLFlBQStCbm5ELFFBQWpDLEtBQThDLEtBQUttbkQsY0FBTCxFQUEvQyxHQUF3RSxDQUF4RSxHQUE0RSxLQUFLSCxNQUF4SDs7ZUFFSzM5QyxnQkFBTCxDQUFzQixLQUFLeTlDLGVBQTNCOzs7OzsyQkFJR25uRCxPQUFPO1lBQ05rTCxlQUFOOztVQUVNdThDLFFBQVEsS0FBS1IsT0FBTCxPQUFtQixNQUFuQixHQUE0QmpuRCxNQUFNa0ssT0FBTixDQUFjaUksTUFBMUMsR0FBbUQsQ0FBQ25TLE1BQU1rSyxPQUFOLENBQWNpSSxNQUFoRjtVQUNNaEksV0FBV3RCLEtBQUttSixHQUFMLENBQVMsQ0FBVCxFQUFZbkosS0FBS2tKLEdBQUwsQ0FBUyxLQUFLczFDLE1BQWQsRUFBc0IsS0FBS0MsY0FBTCxHQUFzQkcsS0FBNUMsQ0FBWixDQUFqQjtVQUNJdDlDLGFBQWEsS0FBS285QyxTQUF0QixFQUFpQzthQUMxQkEsU0FBTCxHQUFpQnA5QyxRQUFqQjthQUNLdTlDLFFBQUwsQ0FBYyxLQUFLSCxTQUFuQixFQUE4QixLQUFLRixNQUFuQzs7Ozs7OEJBSU1ybkQsT0FBTztZQUNUa0wsZUFBTjs7VUFFTW1JLFlBQVlyVCxNQUFNa0ssT0FBTixDQUFjbU8sZ0JBQWhDO1VBQ01zdkMsYUFBYSxLQUFLVixPQUFMLE9BQW1CNXpDLFNBQW5CLElBQWdDLEtBQUtrMEMsU0FBTCxHQUFpQixLQUFLRixNQUFMLEdBQWMsS0FBS0wsWUFBTCxFQUFsRjttQkFDYSxLQUFLWSxRQUFMLEVBQWIsR0FBK0IsS0FBS0MsUUFBTCxFQUEvQjs7Ozs4QkFHUTtXQUNIVixlQUFMLElBQXdCLEtBQUtBLGVBQUwsQ0FBcUIvdEMsT0FBckIsRUFBeEI7V0FDSyt0QyxlQUFMLEdBQXVCLEtBQUsxM0QsT0FBTCxHQUFlLEtBQUtzM0QsY0FBTCxHQUFzQixJQUE1RDs7Ozs7O0FDL0ZKOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUdxQmU7Ozs7Ozs7Ozs2QkFRUC9zRCxPQUFaLEVBQXFCOzs7Y0FDVHpMLE9BQUsrTCxNQUFMLENBQVk7Y0FDWixRQURZO2dCQUVWLEtBRlU7YUFHYjtLQUhDLEVBSVBOLFdBQVcsRUFKSixDQUFWOztnSUFNTUEsT0FQYTs7Ozs7eUJBVWhCZ3RELFdBQVdDLFdBQVd0eEQsVUFBVTs7Ozs7d0JBSWpDcXhELFdBQVdDLFdBQVd0eEQsVUFBVTs7Ozs7MEJBSTlCc0IsTUFBTTtVQUNKcStDLFVBQVUvbUQsT0FBSzJHLGFBQUwsbUlBQWhCO1dBR0t3RCxVQUFMLENBQWdCSixXQUFoQixDQUE0Qmc5QyxPQUE1QjthQUNPO2VBQU1BLFFBQVFuNEMsTUFBUixFQUFOO09BQVA7Ozs7RUEvQjJDNHhDOztBQ3BCL0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBSUE7Ozs7SUFHcUJtWTs7OzsyQkFFSTthQUNkLElBQVA7Ozs7dUNBR2lHO21GQUFKLEVBQUk7O29DQUFyRkMsZUFBcUY7UUFBckZBLGVBQXFGLHdDQUFuRSxHQUFtRTtrQ0FBOURDLGFBQThEO1FBQTlEQSxhQUE4RCxzQ0FBOUMsSUFBOEM7Z0NBQXhDQyxXQUF3QztRQUF4Q0EsV0FBd0Msb0NBQTFCLFFBQTBCO1FBQWJDLElBQWE7OztrS0FDdkZBLElBRHVGOztRQUc3RixNQUFLeHpCLFdBQUwsS0FBcUJvekIseUJBQXpCLEVBQW9EO2FBQzdDOStDLGFBQUw7OztVQUdHKytDLGVBQUwsR0FBdUJBLGVBQXZCO1VBQ0tDLGFBQUwsR0FBcUJBLGFBQXJCO1VBQ0tDLFdBQUwsR0FBbUJBLFdBQW5COztVQUVLRSxRQUFMLEdBQWdCLEVBQUV4OUMsUUFBUXM5QyxXQUFWLEVBQXVCNXNELFVBQVUyc0QsYUFBakMsRUFBaEI7VUFDS0ksVUFBTCxHQUFrQixFQUFFejlDLFFBQVFzOUMsV0FBVixFQUF1QjVzRCxVQUFVMHNELGVBQWpDLEVBQWxCOztVQUVLTSxXQUFMLEdBQW1CbDVELE9BQUsyRyxhQUFMLENBQ2pCLDJPQURpQixDQUFuQjs7VUFLS3d5RCxXQUFMLEdBQW1CLElBQW5COzs7Ozs7aUNBR1c7YUFDTnIvQyxXQUFMOzs7OzRDQUdzQjthQUNqQkEsV0FBTDs7OztzQ0FHZ0I7YUFDWEEsV0FBTDs7OztvQ0FHYzIrQyxXQUFXQyxXQUFXO1dBQy9CUyxXQUFMLEdBQW1CLEtBQW5COzs7V0FHS0MsT0FBTCw4SUFBMkJWLFNBQTNCOzs7Z0JBR1VyZ0QsYUFBVixDQUF3QmMsWUFBeEIsQ0FBcUMsS0FBS2tnRCxjQUExQyxFQUEwRFosU0FBMUQ7OztXQUdLMXdELE1BQUwsR0FBYztlQUNML0gsT0FBS2lYLGVBQUwsQ0FBcUJ3aEQsU0FBckIsS0FBbUNBLFNBRDlCO2VBRUx6NEQsT0FBS2lYLGVBQUwsQ0FBcUJ5aEQsU0FBckIsS0FBbUNBO09BRjVDO1dBSUtZLE1BQUwsR0FBYztlQUNMLEtBQUtDLFVBQUwsQ0FBZ0IsS0FBS3h4RCxNQUFMLENBQVl5eEQsS0FBNUIsQ0FESztlQUVMLEtBQUtELFVBQUwsQ0FBZ0IsS0FBS3h4RCxNQUFMLENBQVkweEQsS0FBNUI7T0FGVDs7O1dBTUt0QixLQUFMLEdBQWEsS0FBS3VCLGVBQUwsQ0FBcUJoQixTQUFyQixFQUFnQyxLQUFLWSxNQUFMLENBQVlHLEtBQTVDLENBQWI7V0FDS0Usb0JBQUwsR0FBNEIsS0FBS0MscUJBQUwsQ0FBMkIsS0FBSzd4RCxNQUFMLENBQVl5eEQsS0FBdkMsRUFBOEMsS0FBS3p4RCxNQUFMLENBQVkweEQsS0FBMUQsQ0FBNUI7OztVQUdJLEtBQUtFLG9CQUFULEVBQStCO2FBQ3hCVCxXQUFMLENBQWlCOTRELEtBQWpCLENBQXVCeThCLEdBQXZCLEdBQTZCLEtBQUt5OEIsTUFBTCxDQUFZRyxLQUFaLENBQWtCSSxPQUFsQixDQUEwQnI5QyxZQUExQixHQUF5QyxJQUF0RTthQUNLelUsTUFBTCxDQUFZMHhELEtBQVosQ0FBa0IxdkQsV0FBbEIsQ0FBOEIsS0FBS212RCxXQUFuQzthQUNLWSxVQUFMLENBQWdCLEtBQUsveEQsTUFBTCxDQUFZeXhELEtBQTVCLEVBQW1DLEtBQUt6eEQsTUFBTCxDQUFZMHhELEtBQS9DO09BSEYsTUFJTztrQkFDSzF2RCxXQUFWLENBQXNCLEtBQUttdkQsV0FBM0I7YUFDS1ksVUFBTCxDQUFnQnJCLFNBQWhCLEVBQTJCQyxTQUEzQjs7Z0JBRVFscUQsU0FBVixDQUFvQkUsR0FBcEIsQ0FBd0Isa0JBQXhCO1dBQ0txckQsZUFBTCxHQUF1QnJCLFNBQXZCO1dBQ0tZLE1BQUwsQ0FBWUcsS0FBWixDQUFrQmp4RCxPQUFsQixDQUEwQmdHLFNBQTFCLENBQW9DRSxHQUFwQyxDQUF3QyxpQkFBeEM7Ozs7OEJBSVFtTSxVQUFVbS9DLFVBQVV2QixXQUFXQyxXQUFXO1dBQzdDdUIsU0FBTCxHQUFpQixJQUFqQjs7VUFFSXhCLFVBQVVyNEQsS0FBVixDQUFnQnNSLE9BQWhCLEtBQTRCLE1BQWhDLEVBQXdDO2tCQUM1QnRSLEtBQVYsQ0FBZ0JzUixPQUFoQixHQUEwQixFQUExQjs7O1VBR0UsS0FBS3luRCxXQUFULEVBQXNCO2FBQ2ZhLFFBQUwsR0FBZ0JBLFFBQWhCO2FBQ0tFLGVBQUwsQ0FBcUJ6QixTQUFyQixFQUFnQ0MsU0FBaEM7OztVQUdJeUIsYUFBYSxDQUFDdC9DLFdBQVdtL0MsUUFBWixJQUF3QkEsUUFBM0M7O1VBRUksS0FBS0wsb0JBQVQsRUFBK0I7O2VBRXRCNTZDLE1BQVA7Ozs7ZUFJUyxDQUFDLEtBQUt1NkMsTUFBTCxDQUFZRSxLQUFaLENBQWtCaHhELE9BQW5CLEVBQTRCLEtBQUs4d0QsTUFBTCxDQUFZRSxLQUFaLENBQWtCWSxhQUE5QyxFQUE2RCxLQUFLZCxNQUFMLENBQVlFLEtBQVosQ0FBa0JhLFVBQS9FLENBQVAsRUFDR3g4QyxLQURILENBQ1M7c0NBQ3FCczhDLGFBQWEsRUFBdkMsYUFESzttQkFFSSxJQUFJQSxhQUFhLEVBQWIsR0FBa0IsR0FGMUI7U0FEVCxDQUpGLEVBVUU1WSxPQUFPLEtBQUsrWCxNQUFMLENBQVlFLEtBQVosQ0FBa0JjLGFBQXpCLEVBQ0d6OEMsS0FESCxDQUNTO3NDQUNxQixLQUFLczZDLEtBQUwsQ0FBVzVvQyxLQUFYLEdBQW1CNHFDLFVBQTdDLGNBREs7bUJBRUksSUFBSUEsVUFGUjtTQURULENBVkYsRUFnQkU1WSxPQUFPLEtBQUsrWCxNQUFMLENBQVlFLEtBQVosQ0FBa0JlLGVBQXpCLEVBQ0cxOEMsS0FESCxDQUNTO21CQUNJLElBQUlzOEMsYUFBYSxFQUFiLEdBQWtCLEdBRDFCO3NDQUVxQixLQUFLaEMsS0FBTCxDQUFXbnBDLEtBQVgsR0FBbUJtckMsVUFBN0M7U0FISixDQWhCRixFQXNCRTVZLE9BQU8sS0FBSytYLE1BQUwsQ0FBWUUsS0FBWixDQUFrQmdCLEtBQXpCLEVBQ0czOEMsS0FESCxDQUNTO21CQUNJLElBQUlzOEMsVUFEUjtTQURULENBdEJGOzs7O2VBNkJTLENBQUMsS0FBS2IsTUFBTCxDQUFZRyxLQUFaLENBQWtCanhELE9BQW5CLEVBQTRCLEtBQUs4d0QsTUFBTCxDQUFZRyxLQUFaLENBQWtCVyxhQUE5QyxFQUE2RCxLQUFLZCxNQUFMLENBQVlHLEtBQVosQ0FBa0JZLFVBQS9FLEVBQTJGLEtBQUtuQixXQUFoRyxDQUFQLEVBQ0dyN0MsS0FESCxDQUNTO3NDQUNxQmhELFFBQTFCO1NBRkosQ0E3QkYsRUFrQ0UwbUMsT0FBTyxLQUFLK1gsTUFBTCxDQUFZRyxLQUFaLENBQWtCSSxPQUF6QixFQUNHaDhDLEtBREgsQ0FDUzttQkFDSSxDQUFDLENBQUQsR0FBS3M4QyxVQURUO1NBRFQsQ0FsQ0YsRUF1Q0U1WSxPQUFPLEtBQUsrWCxNQUFMLENBQVlHLEtBQVosQ0FBa0JhLGFBQXpCLEVBQ0d6OEMsS0FESCxDQUNTO3NDQUNxQixDQUFDLElBQUlzOEMsVUFBTCxJQUFtQixHQUE3QztTQUZKLENBdkNGLEVBNENFNVksT0FBTyxLQUFLK1gsTUFBTCxDQUFZRyxLQUFaLENBQWtCYyxlQUF6QixFQUNHMThDLEtBREgsQ0FDUzttQkFDSSxDQUFDLENBQUQsR0FBS3M4QyxVQURUO3NDQUVxQixLQUFLaEMsS0FBTCxDQUFXNW9DLEtBQVgsSUFBb0IsSUFBSTRxQyxVQUF4QixDQUExQjtTQUhKLENBNUNGOzs7O2VBcURTLEtBQUtqQixXQUFaLEVBQ0dyN0MsS0FESCxDQUNTO21CQUNJLENBQUMsQ0FBRCxHQUFLczhDLFVBRFQ7U0FEVCxDQXJERjtPQUZGLE1BOERPO2VBQ0VwN0MsTUFBUCxDQUNFd2lDLE9BQU9tWCxTQUFQLEVBQ0c3NkMsS0FESCxDQUNTO3NDQUNxQmhELFFBQTFCO1NBRkosQ0FERixFQU1FMG1DLE9BQU9rWCxTQUFQLEVBQ0c1NkMsS0FESCxDQUNTO3NDQUNxQnM4QyxhQUFhLEVBQXZDLGFBREs7bUJBRUksSUFBSUEsYUFBYSxFQUFiLEdBQWtCLEdBRjFCO1NBRFQsQ0FORixFQVlFNVksT0FBTyxLQUFLMlgsV0FBWixFQUNHcjdDLEtBREgsQ0FDUzttQkFDSSxDQUFDLENBQUQsR0FBS3M4QyxVQURUO1NBRFQsQ0FaRjs7Ozs7NEJBb0JJMUIsV0FBV0MsV0FBV3R4RCxVQUFVOzs7VUFDbEMsS0FBSyt4RCxXQUFULEVBQXNCOzs7O1VBSWxCLEtBQUtRLG9CQUFULEVBQStCOztlQUV0QjU2QyxNQUFQOzs7O2VBSVMsQ0FBQyxLQUFLdTZDLE1BQUwsQ0FBWUUsS0FBWixDQUFrQmh4RCxPQUFuQixFQUE0QixLQUFLOHdELE1BQUwsQ0FBWUUsS0FBWixDQUFrQlksYUFBOUMsRUFBNkQsS0FBS2QsTUFBTCxDQUFZRSxLQUFaLENBQWtCYSxVQUEvRSxDQUFQLEVBQ0d4OEMsS0FESCxDQUNTO3FCQUNNLHlCQUROO21CQUVJO1NBSGIsRUFJSyxLQUFLbzdDLFVBSlYsQ0FKRixFQVVFMVgsT0FBTyxLQUFLK1gsTUFBTCxDQUFZRSxLQUFaLENBQWtCYyxhQUF6QixFQUNHejhDLEtBREgsQ0FDUzt1Q0FDc0IsS0FBS3M2QyxLQUFMLENBQVc1b0MsS0FBdEMsY0FESzttQ0FFa0IsS0FBS3FwQyxlQUE1Qiw0QkFBa0UsS0FBS0EsZUFBdkUsVUFBMkYsS0FBS0UsV0FGM0Y7bUJBR0k7U0FKYixDQVZGLEVBaUJFdlgsT0FBTyxLQUFLK1gsTUFBTCxDQUFZRSxLQUFaLENBQWtCZSxlQUF6QixFQUNHMThDLEtBREgsQ0FDUzt1Q0FDc0IsS0FBS3M2QyxLQUFMLENBQVducEMsS0FBdEM7U0FGSixFQUdLLEtBQUtpcUMsVUFIVixDQWpCRixFQXNCRTFYLE9BQU8sS0FBSytYLE1BQUwsQ0FBWUUsS0FBWixDQUFrQmdCLEtBQXpCLEVBQ0czOEMsS0FESCxDQUNTO21CQUNJO1NBRmIsRUFHSyxLQUFLbzdDLFVBSFYsQ0F0QkY7Ozs7ZUE2QlMsQ0FBQyxLQUFLSyxNQUFMLENBQVlHLEtBQVosQ0FBa0JqeEQsT0FBbkIsRUFBNEIsS0FBSzh3RCxNQUFMLENBQVlHLEtBQVosQ0FBa0JXLGFBQTlDLEVBQTZELEtBQUtkLE1BQUwsQ0FBWUcsS0FBWixDQUFrQlksVUFBL0UsRUFBMkYsS0FBS25CLFdBQWhHLENBQVAsRUFDR3I3QyxLQURILENBQ1M7O1NBRFQsRUFHSyxLQUFLbzdDLFVBSFYsQ0E3QkYsRUFrQ0UxWCxPQUFPLEtBQUsrWCxNQUFMLENBQVlHLEtBQVosQ0FBa0JJLE9BQXpCLEVBQ0doOEMsS0FESCxDQUNTO21CQUNJO1NBRmIsRUFHSyxLQUFLbzdDLFVBSFYsQ0FsQ0YsRUF1Q0UxWCxPQUFPLEtBQUsrWCxNQUFMLENBQVlHLEtBQVosQ0FBa0JhLGFBQXpCLEVBQ0d6OEMsS0FESCxDQUNTOztTQURULEVBR0ssS0FBS283QyxVQUhWLENBdkNGLEVBNENFMVgsT0FBTyxLQUFLK1gsTUFBTCxDQUFZRyxLQUFaLENBQWtCYyxlQUF6QixFQUNHMThDLEtBREgsQ0FDUzttQkFDSSxDQURKOzJDQUFBO21DQUdrQixLQUFLKzZDLGVBQTVCLDRCQUFrRSxLQUFLQSxlQUF2RSxVQUEyRixLQUFLRTtTQUpwRyxDQTVDRjs7OztlQXNEUyxLQUFLSSxXQUFaLEVBQ0dyN0MsS0FESCxDQUNTO21CQUNJO1NBRmIsRUFHSyxLQUFLbzdDLFVBSFYsRUFJR3A3QyxLQUpILENBSVMsZ0JBQVE7aUJBQ1I2cEMsTUFBTCxDQUFZLE9BQUszL0MsTUFBTCxDQUFZeXhELEtBQXhCLEVBQStCLE9BQUt6eEQsTUFBTCxDQUFZMHhELEtBQTNDO29CQUNVcjVELEtBQVYsQ0FBZ0JzUixPQUFoQixHQUEwQixNQUExQjtzQkFDWXRLLFVBQVo7O1NBUEosQ0F0REY7T0FGRixNQXFFTztlQUNFMlgsTUFBUCxDQUVFd2lDLE9BQU9rWCxTQUFQLEVBQ0M1NkMsS0FERCxDQUNPO3FCQUNNLHlCQUROO21CQUVJO1NBSFgsRUFJRyxLQUFLbzdDLFVBSlIsQ0FGRixFQVFFMVgsT0FBT21YLFNBQVAsRUFDQzc2QyxLQURELENBQ087cUJBQ007U0FGYixFQUdHLEtBQUtvN0MsVUFIUixFQUlDcDdDLEtBSkQsQ0FJTyxnQkFBUTtpQkFDUjZwQyxNQUFMLENBQVkrUSxTQUFaLEVBQXVCQyxTQUF2QjtvQkFDVXQ0RCxLQUFWLENBQWdCc1IsT0FBaEIsR0FBMEIsTUFBMUI7c0JBQ1l0SyxVQUFaOztTQVBGLENBUkY7Ozs7OzZCQXNCS3F4RCxXQUFXQyxXQUFXdHhELFVBQVU7OztVQUNuQyxLQUFLK3hELFdBQVQsRUFBc0I7Ozs7VUFJbEIsS0FBS1Esb0JBQVQsRUFBK0I7O2VBRXRCNTZDLE1BQVA7Ozs7ZUFJUyxDQUFDLEtBQUt1NkMsTUFBTCxDQUFZRSxLQUFaLENBQWtCaHhELE9BQW5CLEVBQTRCLEtBQUs4d0QsTUFBTCxDQUFZRSxLQUFaLENBQWtCWSxhQUE5QyxFQUE2RCxLQUFLZCxNQUFMLENBQVlFLEtBQVosQ0FBa0JhLFVBQS9FLENBQVAsRUFDR3g4QyxLQURILENBQ1M7cUJBQ00sc0JBRE47bUJBRUk7U0FIYixFQUlLLEtBQUttN0MsUUFKVixDQUpGLEVBVUV6WCxPQUFPLEtBQUsrWCxNQUFMLENBQVlFLEtBQVosQ0FBa0JjLGFBQXpCLEVBQ0d6OEMsS0FESCxDQUNTOzJDQUFBO21DQUVrQixLQUFLZzdDLGFBQTVCLDRCQUFnRSxLQUFLQSxhQUFyRSxVQUF1RixLQUFLQyxXQUZ2RjttQkFHSTtTQUpiLENBVkYsRUFpQkV2WCxPQUFPLEtBQUsrWCxNQUFMLENBQVlFLEtBQVosQ0FBa0JlLGVBQXpCLEVBQ0cxOEMsS0FESCxDQUNTOztTQURULEVBR0ssS0FBS203QyxRQUhWLENBakJGLEVBc0JFelgsT0FBTyxLQUFLK1gsTUFBTCxDQUFZRSxLQUFaLENBQWtCZ0IsS0FBekIsRUFDRzM4QyxLQURILENBQ1M7bUJBQ0k7U0FGYixFQUdLLEtBQUttN0MsUUFIVixDQXRCRjs7OztlQTZCUyxDQUFDLEtBQUtNLE1BQUwsQ0FBWUcsS0FBWixDQUFrQmp4RCxPQUFuQixFQUE0QixLQUFLOHdELE1BQUwsQ0FBWUcsS0FBWixDQUFrQlcsYUFBOUMsRUFBNkQsS0FBS2QsTUFBTCxDQUFZRyxLQUFaLENBQWtCWSxVQUEvRSxDQUFQLEVBQ0d4OEMsS0FESCxDQUNTOztTQURULEVBR0ssS0FBS203QyxRQUhWLENBN0JGLEVBa0NFelgsT0FBTyxLQUFLK1gsTUFBTCxDQUFZRyxLQUFaLENBQWtCSSxPQUF6QixFQUNHaDhDLEtBREgsQ0FDUzttQkFDSTtTQUZiLEVBR0ssS0FBS203QyxRQUhWLENBbENGLEVBdUNFelgsT0FBTyxLQUFLK1gsTUFBTCxDQUFZRyxLQUFaLENBQWtCYSxhQUF6QixFQUNHejhDLEtBREgsQ0FDUzs7U0FEVCxFQUdLLEtBQUttN0MsUUFIVixDQXZDRixFQTRDRXpYLE9BQU8sS0FBSytYLE1BQUwsQ0FBWUcsS0FBWixDQUFrQmMsZUFBekIsRUFDRzE4QyxLQURILENBQ1M7bUJBQ0ksQ0FESjtzQ0FFcUIsS0FBS3M2QyxLQUFMLENBQVc1b0MsS0FBckMsY0FGSzttQ0FHa0IsS0FBS3NwQyxhQUE1Qiw0QkFBZ0UsS0FBS0EsYUFBckUsVUFBdUYsS0FBS0M7U0FKaEcsQ0E1Q0Y7Ozs7ZUFzRFMsS0FBS0ksV0FBWixFQUNHcjdDLEtBREgsQ0FDUzttQkFDSSxDQURKO3NDQUVxQixLQUFLbThDLFFBQS9CO1NBSEosRUFJSyxLQUFLaEIsUUFKVixFQUtHbjdDLEtBTEgsQ0FLUyxnQkFBUTtpQkFDUjZwQyxNQUFMLENBQVksT0FBSzMvQyxNQUFMLENBQVl5eEQsS0FBeEIsRUFBK0IsT0FBS3p4RCxNQUFMLENBQVkweEQsS0FBM0M7c0JBQ1lyeUQsVUFBWjs7U0FQSixDQXRERjtPQUZGLE1Bb0VPO2VBQ0UyWCxNQUFQLENBRUV3aUMsT0FBT2tYLFNBQVAsRUFDQzU2QyxLQURELENBQ087cUJBQ00sc0JBRE47bUJBRUk7U0FIWCxFQUlHLEtBQUttN0MsUUFKUixDQUZGLEVBUUV6WCxPQUFPbVgsU0FBUCxFQUNDNzZDLEtBREQsQ0FDTztxQkFDTTtTQUZiLEVBR0csS0FBS203QyxRQUhSLEVBSUNuN0MsS0FKRCxDQUlPLGdCQUFRO2lCQUNSNnBDLE1BQUwsQ0FBWStRLFNBQVosRUFBdUJDLFNBQXZCO3NCQUNZdHhELFVBQVo7O1NBTkYsQ0FSRjs7Ozs7aUNBcUJnQjs7O1dBQ2JxekQsV0FBTCxHQUFtQixJQUFJL3NDLE9BQUosRUFBbkI7VUFDTWd0QyxPQUFPLFNBQVBBLElBQU87ZUFBTSxPQUFLRCxXQUFMLENBQWlCeHlELEdBQWpCLENBQXFCNkIsRUFBckIsRUFBeUJBLEdBQUd6SSxZQUFILENBQWdCLE9BQWhCLENBQXpCLENBQU47T0FBYjs7d0NBRllpVixJQUFNO1lBQUE7OztXQUdiaFcsT0FBTCxDQUFhbzZELElBQWI7O2FBRU9yNkQsSUFBUCxDQUFZLEtBQUtpNUQsTUFBakIsRUFBeUJoNUQsT0FBekIsQ0FBaUMsYUFBSztlQUM3QkQsSUFBUCxDQUFZLE9BQUtpNUQsTUFBTCxDQUFZdDFELENBQVosQ0FBWixFQUE0QjFELE9BQTVCLENBQW9DLGFBQUs7V0FDdEMsT0FBS2c1RCxNQUFMLENBQVl0MUQsQ0FBWixFQUFlMkssQ0FBZixhQUE2Qm5QLEtBQTdCLEdBQXFDLE9BQUs4NUQsTUFBTCxDQUFZdDFELENBQVosRUFBZTJLLENBQWYsQ0FBckMsR0FBeUQsQ0FBQyxPQUFLMnFELE1BQUwsQ0FBWXQxRCxDQUFaLEVBQWUySyxDQUFmLENBQUQsQ0FBMUQsRUFBK0VyTyxPQUEvRSxDQUF1Rm82RCxJQUF2RjtTQURGO09BREY7Ozs7b0NBT3FCOzs7VUFDZkMsVUFBVSxTQUFWQSxPQUFVLEtBQU07ZUFDZkYsV0FBTCxDQUFpQjF4RCxHQUFqQixDQUFxQmUsRUFBckIsTUFBNkIsSUFBN0IsR0FBb0NBLEdBQUd4SSxlQUFILENBQW1CLE9BQW5CLENBQXBDLEdBQWtFd0ksR0FBR2tELFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUIsT0FBS3l0RCxXQUFMLENBQWlCMXhELEdBQWpCLENBQXFCZSxFQUFyQixDQUF6QixDQUFsRTtlQUNLMndELFdBQUwsQ0FBaUJqdEMsTUFBakIsQ0FBd0IxakIsRUFBeEI7T0FGRjs7eUNBRGV3TSxJQUFNO1lBQUE7OztXQUtoQmhXLE9BQUwsQ0FBYXE2RCxPQUFiOzthQUVPdDZELElBQVAsQ0FBWSxLQUFLaTVELE1BQWpCLEVBQXlCaDVELE9BQXpCLENBQWlDLGFBQUs7ZUFDN0JELElBQVAsQ0FBWSxPQUFLaTVELE1BQUwsQ0FBWXQxRCxDQUFaLENBQVosRUFBNEIxRCxPQUE1QixDQUFvQyxhQUFLO1dBQ3RDLE9BQUtnNUQsTUFBTCxDQUFZdDFELENBQVosRUFBZTJLLENBQWYsYUFBNkJuUCxLQUE3QixHQUFxQyxPQUFLODVELE1BQUwsQ0FBWXQxRCxDQUFaLEVBQWUySyxDQUFmLENBQXJDLEdBQXlELENBQUMsT0FBSzJxRCxNQUFMLENBQVl0MUQsQ0FBWixFQUFlMkssQ0FBZixDQUFELENBQTFELEVBQStFck8sT0FBL0UsQ0FBdUZxNkQsT0FBdkY7U0FERjtPQURGOzs7OzZCQU9jO1dBQ1RWLFNBQUwsR0FBaUIsS0FBakI7V0FDS1EsV0FBTCxJQUFvQixLQUFLRyxhQUFMLHVCQUFwQjtXQUNLeEIsT0FBTCxJQUFnQixLQUFLQSxPQUFMLEVBQWhCO1dBQ0tGLFdBQUwsQ0FBaUJ0cUQsTUFBakI7V0FDS3lxRCxjQUFMLENBQW9CenFELE1BQXBCO1dBQ0ttckQsZUFBTCxDQUFxQnZyRCxTQUFyQixDQUErQkksTUFBL0IsQ0FBc0Msa0JBQXRDO1dBQ0swcUQsTUFBTCxDQUFZRyxLQUFaLENBQWtCanhELE9BQWxCLENBQTBCZ0csU0FBMUIsQ0FBb0NJLE1BQXBDLENBQTJDLGlCQUEzQztXQUNLMHFELE1BQUwsR0FBYyxLQUFLdnhELE1BQUwsR0FBYyxLQUFLZ3lELGVBQUwsR0FBdUIsS0FBS1UsV0FBTCxHQUFtQixJQUF0RTtXQUNLdEIsV0FBTCxHQUFtQixJQUFuQjs7OztFQWxabURYOztBQ3hCdkQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBS0EsSUFBTXFDLGNBQWMsU0FBZEEsV0FBYztNQUFDMTNDLENBQUQsdUVBQUssQ0FBTDtNQUFRQyxDQUFSLHVFQUFZLENBQVo7TUFBZWxILENBQWYsdUVBQW1CLENBQW5COzBCQUF3Q2lILENBQXhDLFVBQThDQyxDQUE5QyxVQUFvRGxILENBQXBEO0NBQXBCOzs7Ozs7SUFLcUI0K0M7Ozt1Q0FFK0U7bUZBQUosRUFBSTs7MkJBQXBGdC9DLE1BQW9GO1FBQXBGQSxNQUFvRiwrQkFBM0UsOEJBQTJFOzBCQUEzQ3JQLEtBQTJDO1FBQTNDQSxLQUEyQyw4QkFBbkMsQ0FBbUM7NkJBQWhDRCxRQUFnQztRQUFoQ0EsUUFBZ0MsaUNBQXJCLEdBQXFCO1FBQWI2c0QsSUFBYTs7O2dLQUN4RnY5QyxjQUR3RixFQUNoRnJQLFlBRGdGLEVBQ3pFRCxrQkFEeUUsSUFDNUQ2c0QsSUFENEQ7O1VBRzNGTSxjQUFMLEdBQXNCcjVELE9BQUsyRyxhQUFMLENBQ3BCLDRHQURvQixDQUF0Qjs7Ozs7OytCQU1TK0IsTUFBTTtVQUNUbXhELFVBQVVueEQsS0FBS3F5RCxrQkFBTCxFQUFoQjtVQUNNOW9ELE9BQU80bkQsUUFBUW1CLDJCQUFSLEVBQWI7VUFDTTlvRCxRQUFRMm5ELFFBQVFvQiw0QkFBUixFQUFkOztVQUVNQyxvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFTanVELFFBQVQsRUFBbUI7WUFDckNqTCxTQUFTLEVBQWY7O2FBRUssSUFBSWhCLElBQUksQ0FBYixFQUFnQkEsSUFBSWlNLFNBQVNoTSxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7Y0FDcENpTSxTQUFTak0sQ0FBVCxFQUFZZ0gsUUFBWixDQUFxQmxHLFdBQXJCLE9BQXVDLGlCQUEzQyxFQUE4RDttQkFDckRWLElBQVAsQ0FBWTZMLFNBQVNqTSxDQUFULENBQVo7Ozs7ZUFJR2dCLE1BQVA7T0FURjs7VUFZTXc0RCxRQUFRLEdBQ1h6NUQsTUFEVyxDQUNKa1IsS0FBS1QsUUFBTCxDQUFjdlEsTUFBZCxLQUF5QixDQUF6QixHQUE2QmdSLElBQTdCLEdBQW9DaXBELGtCQUFrQmpwRCxLQUFLVCxRQUF2QixDQURoQyxFQUVYelEsTUFGVyxDQUVKbVIsTUFBTVYsUUFBTixDQUFldlEsTUFBZixLQUEwQixDQUExQixHQUE4QmlSLEtBQTlCLEdBQXNDZ3BELGtCQUFrQmhwRCxNQUFNVixRQUF4QixDQUZsQyxDQUFkOzthQUlPO3VCQUNVcW9ELFFBQVFzQiw2QkFBUixFQURWO3dCQUVXdEIsUUFBUXVCLGdDQUFSLEVBRlg7eUJBR1l2QixRQUFRd0IsaUNBQVIsRUFIWjtlQUlFYixLQUpGO2lCQUtJOXhELEtBQUs0eUQsa0JBQUwsRUFMSjtvQkFNTzV5RCxLQUFLNnlELHFCQUFMLEVBTlA7aUJBT0kxQixPQVBKO3VCQVFVbnhELEtBQUs4eUQsd0JBQUw7T0FSakI7Ozs7MENBWW9CL0MsV0FBV0MsV0FBVztVQUNwQytDLFdBQVdoRCxVQUFVdmhELGtCQUFWLE1BQWtDd2hELFVBQVV4aEQsa0JBQVYsRUFBbkQ7O1VBRU13a0QsZUFBZWpELFVBQVVzQyxrQkFBVixFQUFyQjtVQUNNWSxlQUFlakQsVUFBVXFDLGtCQUFWLEVBQXJCOztVQUVNYSxXQUFXRixhQUFheHVELFlBQWIsQ0FBMEIsUUFBMUIsS0FBdUN5dUQsYUFBYXp1RCxZQUFiLENBQTBCLFFBQTFCLENBQXhEO1VBQ00ydUQsYUFBYTc3RCxPQUFLNE0sV0FBTCxDQUFpQjh1RCxZQUFqQixFQUErQixVQUEvQixLQUE4QzE3RCxPQUFLNE0sV0FBTCxDQUFpQit1RCxZQUFqQixFQUErQixVQUEvQixDQUFqRTtVQUNNRyxnQkFBZ0I5N0QsT0FBSzRNLFdBQUwsQ0FBaUI4dUQsWUFBakIsRUFBK0IsYUFBL0IsS0FBaUQxN0QsT0FBSzRNLFdBQUwsQ0FBaUIrdUQsWUFBakIsRUFBK0IsYUFBL0IsQ0FBdkU7O2FBRU9GLFlBQVksQ0FBQ0csUUFBYixJQUF5QixDQUFDQyxVQUExQixJQUF3QyxDQUFDQyxhQUFoRDs7OztvQ0FHYzM3RCxTQUFTNDdELGVBQWU7VUFDbEN4c0MsY0FBSjtVQUFXUCxjQUFYOztVQUVNZ3RDLFdBQVc3N0QsUUFBUXV4RCxxQkFBUixFQUFqQjtVQUNJcUssY0FBY3hCLGVBQWQsQ0FBOEIvckQsU0FBOUIsQ0FBd0M2RyxRQUF4QyxDQUFpRCxvQkFBakQsQ0FBSixFQUE0RTtZQUNwRTRtRCxZQUFZRixjQUFjeEIsZUFBZCxDQUE4QjdJLHFCQUE5QixFQUFsQjtnQkFDUW40QyxLQUFLcXVDLEtBQUwsQ0FBV29VLFNBQVNyNUQsS0FBVCxHQUFpQixDQUFqQixHQUFxQnM1RCxVQUFVdDVELEtBQVYsR0FBa0IsQ0FBdkMsR0FBMkNzNUQsVUFBVWhxRCxJQUFoRSxDQUFSO09BRkYsTUFHTztnQkFDR3NILEtBQUtxdUMsS0FBTCxDQUFZb1UsU0FBU3I1RCxLQUFULEdBQWlCLENBQWxCLEdBQXVCLEdBQWxDLENBQVI7OztVQUdFbzVELGNBQWNHLGNBQWQsQ0FBNkIxdEQsU0FBN0IsQ0FBdUM2RyxRQUF2QyxDQUFnRCxtQkFBaEQsQ0FBSixFQUEwRTtnQkFDaEUwbUQsY0FBY0csY0FBZCxDQUE2QnhLLHFCQUE3QixHQUFxRHgvQyxLQUFyRCxHQUE2RCxDQUFyRTs7O2FBR0ssRUFBQ3FkLFlBQUQsRUFBUVAsWUFBUixFQUFQOzs7Ozs7Ozs7Ozt5QkFRR3lwQyxXQUFXQyxXQUFXdHhELFVBQVU7OztXQUM5Qml5RCxjQUFMLENBQW9CenFELE1BQXBCO2dCQUNVekUsVUFBVixDQUFxQmdQLFlBQXJCLENBQWtDLEtBQUtrZ0QsY0FBdkMsRUFBdURYLFNBQXZEOztVQUVNVSxxSkFBc0JYLFNBQXRCLENBQU47O21CQUVhQSxTQUFiLEVBQXdCLFlBQU07WUFDdEIwRCxrQkFBa0JuOEQsT0FBS2lYLGVBQUwsQ0FBcUJ3aEQsU0FBckIsS0FBbUNBLFNBQTNEO1lBQ00yRCxrQkFBa0JwOEQsT0FBS2lYLGVBQUwsQ0FBcUJ5aEQsU0FBckIsS0FBbUNBLFNBQTNEO1lBQ00yRCx5QkFBeUIsT0FBSzlDLFVBQUwsQ0FBZ0I0QyxlQUFoQixDQUEvQjtZQUNNRyx5QkFBeUIsT0FBSy9DLFVBQUwsQ0FBZ0I2QyxlQUFoQixDQUEvQjs7WUFFTWpFLFFBQVEsT0FBS3VCLGVBQUwsQ0FBcUJoQixTQUFyQixFQUFnQzJELHNCQUFoQyxDQUFkOztZQUVNMUMsdUJBQXVCLE9BQUtDLHFCQUFMLENBQTJCdUMsZUFBM0IsRUFBNENDLGVBQTVDLENBQTdCOztZQUVJekMsb0JBQUosRUFBMEI7O2lCQUVqQjU2QyxNQUFQLENBRUV3aUMsT0FBTyxDQUFDOGEsdUJBQXVCN3pELE9BQXhCLEVBQWlDNnpELHVCQUF1QmpDLGFBQXhELEVBQXVFaUMsdUJBQXVCaEMsVUFBOUYsQ0FBUCxFQUFrSCxPQUFLMTFCLEdBQXZILEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBV2laLFlBQVksTUFBWixDQUFiLEVBRkosRUFHSSxFQUFFalosV0FBV2laLGFBQWIsRUFISixDQUZGLEVBUUV0WixPQUFPOGEsdUJBQXVCeEMsT0FBOUIsRUFBdUMsT0FBS2wxQixHQUE1QyxFQUNHZ2QsT0FESCxDQUNXLEVBQUVGLFNBQVMsQ0FBWCxFQURYLEVBQzJCLEVBQUVBLFNBQVMsQ0FBWCxFQUQzQixDQVJGLEVBV0VGLE9BQU84YSx1QkFBdUIvQixhQUE5QixFQUE2QyxPQUFLMzFCLEdBQWxELEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBV2laLFlBQVksTUFBWixDQUFiLEVBQWtDcFosU0FBUyxDQUEzQyxFQUZKLEVBR0ksRUFBRUcsV0FBV2laLGFBQWIsRUFBNEJwWixTQUFTLENBQXJDLEVBSEosQ0FYRixFQWlCRUYsT0FBTzhhLHVCQUF1QjlCLGVBQTlCLEVBQStDLE9BQUs1MUIsR0FBcEQsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosWUFBZTFDLE1BQU01b0MsS0FBckIsUUFBYixFQUE4Q2t5QixTQUFTLENBQXZELEVBRkosRUFHSTt1QkFDYW9aLGFBRGI7cUJBRVcsQ0FGWDtxQ0FHeUIsT0FBSzN1RCxRQUE1Qiw0QkFBMkQsT0FBS0EsUUFBaEUsVUFBNkUsT0FBS3NQO1dBTnhGLENBakJGLEVBMkJFK2xDLE9BQU84YSx1QkFBdUI3QixLQUE5QixFQUFxQyxPQUFLNzFCLEdBQTFDLEVBQ0dnZCxPQURILENBRUksRUFBRUYsU0FBUyxDQUFYLEVBRkosRUFHSSxFQUFFOWpDLEtBQUssRUFBRThqQyxTQUFTLENBQVgsRUFBUCxFQUF1QmptQyxRQUFRLFFBQS9CLEVBSEosQ0EzQkYsRUFpQ0UrbEMsT0FBTyxDQUFDK2EsdUJBQXVCOXpELE9BQXhCLEVBQWlDOHpELHVCQUF1QmxDLGFBQXhELEVBQXVFa0MsdUJBQXVCakMsVUFBOUYsQ0FBUCxFQUFrSCxPQUFLMTFCLEdBQXZILEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBV2laLGFBQWIsRUFBNEJwWixTQUFTLENBQXJDLEVBRkosRUFHSSxFQUFFRyxXQUFXaVosWUFBWSxNQUFaLENBQWIsRUFBa0NwWixTQUFTLEdBQTNDLEVBSEosRUFLRzVqQyxLQUxILENBS1MsZ0JBQVE7bUJBQ1J3N0MsY0FBTCxDQUFvQnpxRCxNQUFwQjs7OztXQU5KLENBakNGLEVBNkNFMnlDLE9BQU8rYSx1QkFBdUJoQyxhQUE5QixFQUE2QyxPQUFLMzFCLEdBQWxELEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBV2laLGFBQWIsRUFBNEJwWixTQUFTLENBQXJDLEVBRkosRUFHSTt1QkFDYW9aLGtCQUFnQjFDLE1BQU01b0MsS0FBdEIsUUFEYjtxQkFFVyxDQUZYO3FDQUd5QixPQUFLcmpCLFFBQTVCLDRCQUEyRCxPQUFLQSxRQUFoRSxVQUE2RSxPQUFLc1A7V0FOeEYsQ0E3Q0YsRUF1REUrbEMsT0FBTythLHVCQUF1Qi9CLGVBQTlCLEVBQStDLE9BQUs1MUIsR0FBcEQsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosYUFBYixFQUE0QnBaLFNBQVMsQ0FBckMsRUFGSixFQUdJLEVBQUVHLFdBQVdpWixrQkFBZ0IxQyxNQUFNbnBDLEtBQXRCLFFBQWIsRUFBK0N5eUIsU0FBUyxDQUF4RCxFQUhKLENBdkRGLEVBNkRFRixPQUFPK2EsdUJBQXVCOUIsS0FBOUIsRUFBcUMsT0FBSzcxQixHQUExQyxFQUNHZ2QsT0FESCxDQUNZLEVBQUVGLFNBQVMsQ0FBWCxFQURaLEVBQzRCLEVBQUU5akMsS0FBSyxFQUFFOGpDLFNBQVMsQ0FBWCxFQUFQLEVBQXVCam1DLFFBQVEsUUFBL0IsRUFENUIsQ0E3REY7U0FGRixNQW9FTzs7aUJBRUV1RCxNQUFQLENBRUV3aUMsT0FBT2tYLFNBQVAsRUFBa0IsT0FBSzl6QixHQUF2QixFQUNHZ2QsT0FESCxDQUNZLEVBQUVDLFdBQVdpWixZQUFZLE1BQVosQ0FBYixFQURaLEVBQ2lELEVBQUVqWixXQUFXaVosYUFBYixFQURqRCxDQUZGLEVBS0V0WixPQUFPbVgsU0FBUCxFQUFrQixPQUFLL3pCLEdBQXZCLEVBQ0dnZCxPQURILENBQ1ksRUFBRUMsV0FBV2laLGFBQWIsRUFBNEJwWixTQUFTLENBQXJDLEVBRFosRUFDc0QsRUFBRUcsV0FBV2laLFlBQVksTUFBWixDQUFiLEVBQWtDcFosU0FBUyxFQUEzQyxFQUR0RCxFQUVHNWpDLEtBRkgsQ0FFUyxnQkFBUTttQkFDUnc3QyxjQUFMLENBQW9CenFELE1BQXBCOzs7O1dBSEosQ0FMRjs7T0FoRko7Ozs7Ozs7Ozs7O3dCQXdHRTZwRCxXQUFXQyxXQUFXdHhELFVBQVU7OztVQUM5QixLQUFLNnlELFNBQVQsRUFBb0I7ZUFDWCxLQUFLc0MsUUFBTCxDQUFjOUQsU0FBZCxFQUF5QkMsU0FBekIsRUFBb0N0eEQsUUFBcEMsQ0FBUDs7O1dBR0dpeUQsY0FBTCxDQUFvQnpxRCxNQUFwQjtnQkFDVXpFLFVBQVYsQ0FBcUJnUCxZQUFyQixDQUFrQyxLQUFLa2dELGNBQXZDLEVBQXVEWixTQUF2RDs7VUFFTVcscUpBQXNCWCxTQUF0QixDQUFOOztVQUVNMEQsa0JBQWtCbjhELE9BQUtpWCxlQUFMLENBQXFCd2hELFNBQXJCLEtBQW1DQSxTQUEzRDtVQUNNMkQsa0JBQWtCcDhELE9BQUtpWCxlQUFMLENBQXFCeWhELFNBQXJCLEtBQW1DQSxTQUEzRDtVQUNNMkQseUJBQXlCLEtBQUs5QyxVQUFMLENBQWdCNEMsZUFBaEIsQ0FBL0I7VUFDTUcseUJBQXlCLEtBQUsvQyxVQUFMLENBQWdCNkMsZUFBaEIsQ0FBL0I7O1VBRU1qRSxRQUFRLEtBQUt1QixlQUFMLENBQXFCaEIsU0FBckIsRUFBZ0M0RCxzQkFBaEMsQ0FBZDs7VUFFTTNDLHVCQUF1QixLQUFLQyxxQkFBTCxDQUEyQnVDLGVBQTNCLEVBQTRDQyxlQUE1QyxDQUE3Qjs7VUFFSXpDLG9CQUFKLEVBQTBCO2VBQ2pCNTZDLE1BQVAsQ0FFRXdpQyxPQUFPLENBQUM4YSx1QkFBdUI3ekQsT0FBeEIsRUFBaUM2ekQsdUJBQXVCakMsYUFBeEQsRUFBdUVpQyx1QkFBdUJoQyxVQUE5RixDQUFQLEVBQWtILEtBQUsxMUIsR0FBdkgsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosWUFBWSxNQUFaLENBQWIsRUFBa0NwWixTQUFTLEVBQTNDLEVBRkosRUFHSSxFQUFFRyxXQUFXaVosYUFBYixFQUE0QnBaLFNBQVMsQ0FBckMsRUFISixDQUZGLEVBUUVGLE9BQU84YSx1QkFBdUIvQixhQUE5QixFQUE2QyxLQUFLMzFCLEdBQWxELEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBV2laLGtCQUFnQjFDLE1BQU01b0MsS0FBdEIsUUFBYixFQUErQ2t5QixTQUFTLENBQXhELEVBRkosRUFHSTtxQkFDYW9aLGFBRGI7bUJBRVcsQ0FGWDttQ0FHeUIsS0FBSzN1RCxRQUE1Qiw0QkFBMkQsS0FBS0EsUUFBaEUsVUFBNkUsS0FBS3NQO1NBTnhGLENBUkYsRUFrQkUrbEMsT0FBTzhhLHVCQUF1QjlCLGVBQTlCLEVBQStDLEtBQUs1MUIsR0FBcEQsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosa0JBQWdCMUMsTUFBTW5wQyxLQUF0QixRQUFiLEVBRkosRUFHSSxFQUFFNHlCLFdBQVdpWixhQUFiLEVBSEosQ0FsQkYsRUF3QkV0WixPQUFPOGEsdUJBQXVCN0IsS0FBOUIsRUFBcUMsS0FBSzcxQixHQUExQyxFQUNHZ2QsT0FESCxDQUVJLEVBQUVGLFNBQVMsQ0FBWCxFQUZKLEVBR0ksRUFBRTlqQyxLQUFLLEVBQUU4akMsU0FBUyxDQUFYLEVBQVAsRUFBdUJqbUMsUUFBUSxRQUEvQixFQUhKLENBeEJGLEVBOEJFK2xDLE9BQU8sQ0FBQythLHVCQUF1Qjl6RCxPQUF4QixFQUFpQzh6RCx1QkFBdUJsQyxhQUF4RCxFQUF1RWtDLHVCQUF1QmpDLFVBQTlGLENBQVAsRUFBa0gsS0FBSzExQixHQUF2SCxFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVdpWixhQUFiLEVBRkosRUFHSSxFQUFFalosV0FBV2laLFlBQVksTUFBWixDQUFiLEVBSEosRUFLRy84QyxJQUxILENBS1EsQ0FMUixFQU1HRCxLQU5ILENBTVMsZ0JBQVE7aUJBQ1J3N0MsY0FBTCxDQUFvQnpxRCxNQUFwQjs7OztTQVBKLENBOUJGLEVBMkNFMnlDLE9BQU8rYSx1QkFBdUJ6QyxPQUE5QixFQUF1QyxLQUFLbDFCLEdBQTVDLEVBQ0dnZCxPQURILENBRUksRUFBRUYsU0FBUyxDQUFYLEVBRkosRUFHSSxFQUFFQSxTQUFTLENBQVgsRUFISixDQTNDRixFQWlERUYsT0FBTythLHVCQUF1QmhDLGFBQTlCLEVBQTZDLEtBQUszMUIsR0FBbEQsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosYUFBYixFQUZKLEVBR0ksRUFBRWpaLFdBQVdpWixZQUFZLE1BQVosQ0FBYixFQUhKLENBakRGLEVBdURFdFosT0FBTythLHVCQUF1Qi9CLGVBQTlCLEVBQStDLEtBQUs1MUIsR0FBcEQsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosYUFBYixFQUE0QnBaLFNBQVMsQ0FBckMsRUFGSixFQUdJO3FCQUNhb1osWUFBZTFDLE1BQU01b0MsS0FBckIsUUFEYjttQkFFVyxDQUZYO21DQUd5QixLQUFLcmpCLFFBQTVCLDRCQUEyRCxLQUFLQSxRQUFoRSxVQUE2RSxLQUFLc1A7U0FOeEYsQ0F2REY7T0FERixNQWtFTztlQUNFdUQsTUFBUCxDQUVFd2lDLE9BQU9rWCxTQUFQLEVBQWtCLEtBQUs5ekIsR0FBdkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosWUFBWSxNQUFaLENBQWIsRUFBa0NwWixTQUFTLEVBQTNDLEVBRkosRUFHSSxFQUFFRyxXQUFXaVosYUFBYixFQUE0QnBaLFNBQVMsQ0FBckMsRUFISixDQUZGLEVBUUVGLE9BQU9tWCxTQUFQLEVBQWtCLEtBQUsvekIsR0FBdkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXaVosYUFBYixFQUZKLEVBR0ksRUFBRWpaLFdBQVdpWixZQUFZLE1BQVosQ0FBYixFQUhKLEVBS0doOUMsS0FMSCxDQUtTLGdCQUFRO2lCQUNSdzdDLGNBQUwsQ0FBb0J6cUQsTUFBcEI7Ozs7U0FOSixDQVJGOzs7OztFQXBSaUQrcEQ7O0FDM0J2RDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFJQTs7OztJQUdxQjZEOzs7c0NBRW1FO21GQUFKLEVBQUk7MkJBQXpFaGhELE1BQXlFO1FBQXpFQSxNQUF5RSwrQkFBaEUsNkJBQWdFOzBCQUFqQ3JQLEtBQWlDO1FBQWpDQSxLQUFpQyw4QkFBekIsQ0FBeUI7NkJBQXRCRCxRQUFzQjtRQUF0QkEsUUFBc0IsaUNBQVgsR0FBVzs7OzttSkFDOUUsRUFBRXNQLGNBQUYsRUFBVXJQLFlBQVYsRUFBaUJELGtCQUFqQixFQUQ4RTs7VUFHL0VtdEQsY0FBTCxHQUFzQnI1RCxPQUFLMkcsYUFBTCxDQUNwQiwrREFDRSxvREFGa0IsQ0FBdEI7Ozs7Ozs7Ozs7Ozs7eUJBV0c4eEQsV0FBV0MsV0FBV3R4RCxVQUFVOzs7V0FDOUJpeUQsY0FBTCxDQUFvQnpxRCxNQUFwQjtnQkFDVXpFLFVBQVYsQ0FBcUJnUCxZQUFyQixDQUFrQyxLQUFLa2dELGNBQXZDLEVBQXVEWCxTQUF2RDs7VUFFTVUsbUpBQXNCWCxTQUF0QixDQUFOOzthQUVPMTVDLE1BQVAsQ0FFRXdpQyxPQUFPa1gsU0FBUCxFQUFrQixLQUFLOXpCLEdBQXZCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBVyx5QkFBYixFQUZKLEVBR0ksRUFBRUEsV0FBVyxzQkFBYixFQUhKLENBRkYsRUFRRUwsT0FBT21YLFNBQVAsRUFBa0IsS0FBSy96QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsQ0FBOUMsRUFGSixFQUdJLEVBQUVHLFdBQVcseUJBQWIsRUFBd0NILFNBQVMsRUFBakQsRUFISixFQUtHNWpDLEtBTEgsQ0FLUyxnQkFBUTtlQUNSdzdDLGNBQUwsQ0FBb0J6cUQsTUFBcEI7Ozs7T0FOSixDQVJGOzs7Ozs7Ozs7Ozt3QkEyQkU2cEQsV0FBV0MsV0FBV3R4RCxVQUFVOzs7V0FDN0JpeUQsY0FBTCxDQUFvQnpxRCxNQUFwQjtnQkFDVXpFLFVBQVYsQ0FBcUJnUCxZQUFyQixDQUFrQyxLQUFLa2dELGNBQXZDLEVBQXVEWixTQUF2RDs7VUFFTVcsbUpBQXNCWCxTQUF0QixDQUFOOzthQUVPMTVDLE1BQVAsQ0FFRXdpQyxPQUFPa1gsU0FBUCxFQUFrQixLQUFLOXpCLEdBQXZCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBVywwQkFBYixFQUF5Q0gsU0FBUyxFQUFsRCxFQUZKLEVBR0ksRUFBRUcsV0FBVyxzQkFBYixFQUFxQ0gsU0FBUyxDQUE5QyxFQUhKLEVBS0c1akMsS0FMSCxDQUtTLGdCQUFRO2VBQ1J3N0MsY0FBTCxDQUFvQnpxRCxNQUFwQjs7OztPQU5KLENBRkYsRUFjRTJ5QyxPQUFPbVgsU0FBUCxFQUFrQixLQUFLL3pCLEdBQXZCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBVyxzQkFBYixFQUZKLEVBR0ksRUFBRUEsV0FBVyx5QkFBYixFQUhKLENBZEY7Ozs7RUF2RGtENFc7O0FDeEJ0RDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFJQSxJQUFNNVcsWUFBWSxzQkFBbEI7Ozs7OztJQUtxQjZhOzs7c0NBRThDO21GQUFKLEVBQUk7MkJBQXBEamhELE1BQW9EO1FBQXBEQSxNQUFvRCwrQkFBM0MsUUFBMkM7MEJBQWpDclAsS0FBaUM7UUFBakNBLEtBQWlDLDhCQUF6QixDQUF5Qjs2QkFBdEJELFFBQXNCO1FBQXRCQSxRQUFzQixpQ0FBWCxHQUFXOzs7OElBQ3pELEVBQUVzUCxjQUFGLEVBQVVyUCxZQUFWLEVBQWlCRCxrQkFBakIsRUFEeUQ7Ozs7Ozs7Ozs7Ozt5QkFTNUR1c0QsV0FBV0MsV0FBV3R4RCxVQUFVO1VBQzdCZ3lELG1KQUFzQlgsU0FBdEIsQ0FBTjs7YUFFTzE1QyxNQUFQLENBRUV3aUMsT0FBT2tYLFNBQVAsRUFBa0IsS0FBSzl6QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLG9CQUFGLEVBQWFILFNBQVMsQ0FBdEIsRUFGSixFQUdJLEVBQUVHLG9CQUFGLEVBQWFILFNBQVMsQ0FBdEIsRUFISixFQUtHNWpDLEtBTEgsQ0FLUyxnQkFBUTs7OztPQUxqQixDQUZGOzs7Ozs7Ozs7Ozt3QkFxQkU0NkMsV0FBV0MsV0FBV3R4RCxVQUFVO1VBQzVCZ3lELG1KQUFzQlgsU0FBdEIsQ0FBTjs7YUFFTzE1QyxNQUFQLENBRUV3aUMsT0FBT21YLFNBQVAsRUFBa0IsS0FBSy96QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLG9CQUFGLEVBQWFILFNBQVMsQ0FBdEIsRUFGSixFQUdJLEVBQUVHLG9CQUFGLEVBQWFILFNBQVMsQ0FBdEIsRUFISixFQUtHNWpDLEtBTEgsQ0FLUyxnQkFBUTs7OztPQUxqQixDQUZGOzs7O0VBdENrRDI2Qzs7QUMxQnREOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUlBOzs7O0lBR3FCa0U7OztzQ0FFbUU7bUZBQUosRUFBSTsyQkFBekVsaEQsTUFBeUU7UUFBekVBLE1BQXlFLCtCQUFoRSw2QkFBZ0U7MEJBQWpDclAsS0FBaUM7UUFBakNBLEtBQWlDLDhCQUF6QixDQUF5Qjs2QkFBdEJELFFBQXNCO1FBQXRCQSxRQUFzQixpQ0FBWCxHQUFXOzs7O21KQUM5RSxFQUFDc1AsY0FBRCxFQUFTclAsWUFBVCxFQUFnQkQsa0JBQWhCLEVBRDhFOztVQUcvRXl3RCxnQkFBTCxHQUF3QixHQUF4QjtVQUNLdEQsY0FBTCxHQUFzQnI1RCxPQUFLMkcsYUFBTCxDQUNwQiwyRUFDRSw4Q0FGa0IsQ0FBdEI7Ozs7Ozs7Ozs7Ozs7eUJBV0c4eEQsV0FBV0MsV0FBV3R4RCxVQUFVOzs7V0FDOUJpeUQsY0FBTCxDQUFvQnpxRCxNQUFwQjtnQkFDVXlKLGFBQVYsQ0FBd0JjLFlBQXhCLENBQXFDLEtBQUtrZ0QsY0FBMUMsRUFBMERYLFVBQVVscEIsV0FBcEU7O1VBRU00cEIsbUpBQXNCWCxTQUF0QixDQUFOOzthQUVPMTVDLE1BQVAsQ0FFRXdpQyxPQUFPLEtBQUs4WCxjQUFaLEVBQTRCLEtBQUsxMEIsR0FBakMsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLHNCQUFiLEVBQXFDSCxTQUFTLENBQTlDLEVBRkosRUFHSSxFQUFFQSxTQUFTLEtBQUtrYixnQkFBaEIsRUFISixFQUtHOStDLEtBTEgsQ0FLUyxnQkFBUTtlQUNSdzdDLGNBQUwsQ0FBb0J6cUQsTUFBcEI7O09BTkosQ0FGRixFQVlFMnlDLE9BQU9rWCxTQUFQLEVBQWtCLEtBQUs5ekIsR0FBdkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLHlCQUFiLEVBRkosRUFHSSxFQUFFQSxXQUFXLHNCQUFiLEVBSEosQ0FaRixFQWtCRUwsT0FBT21YLFNBQVAsRUFBa0IsS0FBSy96QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsc0JBQWIsRUFGSixFQUdJLEVBQUVBLFdBQVcseUJBQWIsRUFISixFQUtHL2pDLEtBTEgsQ0FLUyxnQkFBUTs7OztPQUxqQixDQWxCRjs7Ozs7Ozs7Ozs7d0JBb0NFNDZDLFdBQVdDLFdBQVd0eEQsVUFBVTs7O1dBQzdCaXlELGNBQUwsQ0FBb0J6cUQsTUFBcEI7Z0JBQ1V6RSxVQUFWLENBQXFCZ1AsWUFBckIsQ0FBa0MsS0FBS2tnRCxjQUF2QyxFQUF1RFosVUFBVWpwQixXQUFqRTs7VUFFTTRwQixtSkFBc0JYLFNBQXRCLENBQU47O2FBRU8xNUMsTUFBUCxDQUVFd2lDLE9BQU8sS0FBSzhYLGNBQVosRUFBNEIsS0FBSzEwQixHQUFqQyxFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsS0FBS2tiLGdCQUFuRCxFQUZKLEVBR0ksRUFBRWxiLFNBQVMsQ0FBWCxFQUhKLEVBS0c1akMsS0FMSCxDQUtTLGdCQUFRO2VBQ1J3N0MsY0FBTCxDQUFvQnpxRCxNQUFwQjs7T0FOSixDQUZGLEVBWUUyeUMsT0FBT2tYLFNBQVAsRUFBa0IsS0FBSzl6QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcseUJBQWIsRUFBd0NILFNBQVMsRUFBakQsRUFGSixFQUdJLEVBQUVHLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsQ0FBOUMsRUFISixDQVpGLEVBa0JFRixPQUFPbVgsU0FBUCxFQUFrQixLQUFLL3pCLEdBQXZCLEVBQ0dnZCxPQURILENBRUksRUFBRUMsV0FBVyxzQkFBYixFQUZKLEVBR0ksRUFBRUEsV0FBVyx5QkFBYixFQUhKLEVBS0cvakMsS0FMSCxDQUtTLGdCQUFROzs7O09BTGpCLENBbEJGOzs7O0VBakVrRDI2Qzs7QUN4QnREOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUlBOzs7O0lBR3FCb0U7OztxQ0FFc0U7bUZBQUosRUFBSTsyQkFBNUVwaEQsTUFBNEU7UUFBNUVBLE1BQTRFLCtCQUFuRSw2QkFBbUU7MEJBQXBDclAsS0FBb0M7UUFBcENBLEtBQW9DLDhCQUE1QixJQUE0Qjs2QkFBdEJELFFBQXNCO1FBQXRCQSxRQUFzQixpQ0FBWCxHQUFXOzs7O2lKQUNqRixFQUFFc1AsY0FBRixFQUFVclAsWUFBVixFQUFpQkQsa0JBQWpCLEVBRGlGOztVQUdsRm10RCxjQUFMLEdBQXNCcjVELE9BQUsyRyxhQUFMLENBQ3BCLCtEQUNFLGtDQUZrQixDQUF0Qjs7Ozs7Ozs7Ozs7Ozt5QkFXRzh4RCxXQUFXQyxXQUFXdHhELFVBQVU7OztXQUM5Qml5RCxjQUFMLENBQW9CenFELE1BQXBCO2dCQUNVekUsVUFBVixDQUFxQmdQLFlBQXJCLENBQWtDLEtBQUtrZ0QsY0FBdkMsRUFBdURYLFNBQXZEOztVQUVNVSxpSkFBc0JYLFNBQXRCLENBQU47O1VBRU1vRSxZQUFZdGIsT0FBTyxLQUFLOFgsY0FBWixFQUNmdjdDLElBRGUsQ0FDVixLQUFLM1IsS0FBTCxHQUFhLEtBQUtELFFBRFIsRUFFZjJSLEtBRmUsQ0FFVCxnQkFBUTtlQUNSdzdDLGNBQUwsQ0FBb0J6cUQsTUFBcEI7O09BSGMsQ0FBbEI7O2FBT09tUSxNQUFQLENBRUU4OUMsU0FGRixFQUlFdGIsT0FBT2tYLFNBQVAsRUFBa0IsS0FBSzl6QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcseUJBQWIsRUFGSixFQUdJLEVBQUVBLFdBQVcsc0JBQWIsRUFISixDQUpGLEVBVUVMLE9BQU9tWCxTQUFQLEVBQWtCLEtBQUsvekIsR0FBdkIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLEVBQVgsRUFEM0IsRUFFRzVqQyxLQUZILENBRVMsZ0JBQVE7Ozs7T0FGakIsQ0FWRjs7Ozs7Ozs7Ozs7d0JBeUJFNDZDLFdBQVdDLFdBQVd0eEQsVUFBVTs7O1dBQzdCaXlELGNBQUwsQ0FBb0J6cUQsTUFBcEI7Z0JBQ1V6RSxVQUFWLENBQXFCZ1AsWUFBckIsQ0FBa0MsS0FBS2tnRCxjQUF2QyxFQUF1RFosU0FBdkQ7O1VBRU1XLGlKQUFzQlgsU0FBdEIsQ0FBTjs7YUFFTzE1QyxNQUFQLENBRUV3aUMsT0FBTyxLQUFLOFgsY0FBWixFQUNHdjdDLElBREgsQ0FDUSxLQUFLM1IsS0FBTCxHQUFhLEtBQUtELFFBRDFCLEVBRUcyUixLQUZILENBRVMsZ0JBQVE7ZUFDUnc3QyxjQUFMLENBQW9CenFELE1BQXBCOztPQUhKLENBRkYsRUFTRTJ5QyxPQUFPa1gsU0FBUCxFQUFrQixLQUFLOXpCLEdBQXZCLEVBQ0dnZCxPQURILENBQ1csRUFBRUYsU0FBUyxFQUFYLEVBRFgsRUFDNEIsRUFBRUEsU0FBUyxDQUFYLEVBRDVCLEVBRUc1akMsS0FGSCxDQUVTLGdCQUFROzs7O09BRmpCLENBVEYsRUFpQkUwakMsT0FBT21YLFNBQVAsRUFBa0IsS0FBSy96QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsc0JBQWIsRUFGSixFQUdJLEVBQUVBLFdBQVcseUJBQWIsRUFISixDQWpCRjs7OztFQTVEaUQ0Vzs7QUN4QnJEOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUlBOzs7O0lBR3FCc0U7OztxQ0FFOEc7bUZBQUosRUFBSTsyQkFBcEh0aEQsTUFBb0g7UUFBcEhBLE1BQW9ILCtCQUEzRyw4QkFBMkc7OEJBQTNFdWhELFNBQTJFO1FBQTNFQSxTQUEyRSxrQ0FBL0QsNEJBQStEOzBCQUFqQzV3RCxLQUFpQztRQUFqQ0EsS0FBaUMsOEJBQXpCLENBQXlCOzZCQUF0QkQsUUFBc0I7UUFBdEJBLFFBQXNCLGlDQUFYLEdBQVc7Ozs7aUpBQ3pILEVBQUNzUCxjQUFELEVBQVNyUCxZQUFULEVBQWdCRCxrQkFBaEIsRUFEeUg7O1VBRTFINndELFNBQUwsR0FBaUJBLFNBQWpCOzs7Ozs7Ozs7Ozs7O3lCQVFHdEUsV0FBV0MsV0FBV3R4RCxVQUFVO1VBQzdCZ3lELGlKQUFzQlgsU0FBdEIsQ0FBTjs7YUFFTzE1QyxNQUFQLENBRUV3aUMsT0FBT2tYLFNBQVAsRUFBa0IsS0FBSzl6QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcseUJBQWIsRUFBd0NILFNBQVMsQ0FBakQsRUFGSixFQUdJLEVBQUVHLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsQ0FBOUMsRUFISixFQUtHNWpDLEtBTEgsQ0FLUyxnQkFBUTs7OztPQUxqQixDQUZGOzs7Ozs7Ozs7Ozt3QkFxQkU0NkMsV0FBV0MsV0FBV3R4RCxVQUFVO1VBQzVCZ3lELGlKQUFzQlgsU0FBdEIsQ0FBTjs7YUFFTzE1QyxNQUFQLENBRUV3aUMsT0FBT21YLFNBQVAsRUFBa0IsS0FBSy96QixHQUF2QixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsQ0FBOUMsRUFGSixFQUdJLEVBQUU5akMsS0FBSyxFQUFFaWtDLFdBQVcseUJBQWIsRUFBd0NILFNBQVMsQ0FBakQsRUFBUCxFQUE2RGptQyxRQUFRLEtBQUt1aEQsU0FBMUUsRUFISixFQUtHbC9DLEtBTEgsQ0FLUyxnQkFBUTs7OztPQUxqQixDQUZGOzs7O0VBdkNpRDI2Qzs7QUN4QnJEOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUVxQndFOzs7aUNBQ1B2eEQsT0FBWixFQUFxQjs7d0lBQ2JBLE9BRGE7Ozs7O3lCQUdoQmd0RCxXQUFXQyxXQUFXdHhELFVBQVU7Ozs7O3dCQUlqQ3F4RCxXQUFXQyxXQUFXdHhELFVBQVU7Ozs7O0VBUmFveEQ7O0FDbkJuRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFtQkEsSUFBTXBWLGtCQUFnQjthQUNUO1dBQU14aEQsU0FBU3lDLFNBQVQsS0FBdUJ5NEQsdUJBQXZCLEdBQWlEaEMseUJBQXZEO0dBRFM7V0FFWDtXQUFNbDVELFNBQVN5QyxTQUFULEtBQXVCcTRELHdCQUF2QixHQUFrRDVCLHlCQUF4RDtHQUZXO1VBR1o7V0FBTWw1RCxTQUFTeUMsU0FBVCxLQUF1QnU0RCx1QkFBdkIsR0FBaURKLHdCQUF2RDtHQUhZO1VBSVo7V0FBTTU2RCxTQUFTeUMsU0FBVCxLQUF1Qnk0RCx1QkFBdkIsR0FBaURMLHdCQUF2RDtHQUpZO2VBS1AzQix5QkFMTztjQU1SNEIsd0JBTlE7Y0FPUkYsd0JBUFE7YUFRVEksdUJBUlM7Y0FTUkgsd0JBVFE7YUFVVEssdUJBVlM7VUFXWkU7Q0FYVjs7QUFjQSxJQUFNQyxjQUFjOzs7OztPQUFBLGlCQUtaQyxnQkFMWSxFQUtNOTFELFFBTE4sRUFLZ0I7OztDQUxwQzs7QUFVQSxJQUFNKzFELG9CQUFvQixTQUFwQkEsaUJBQW9CO1NBQU9yekQsR0FBRzlCLFFBQUgsS0FBZ0IsVUFBakIsSUFBZ0NoSSxPQUFLMEUsS0FBTCxDQUFZLGlEQUFaLENBQXRDO0NBQTFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFxRHFCMDREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQThIRzthQUNiLEtBQUs3YSxnQkFBWjs7Ozs4QkFHWTs7Ozs7VUFHUDhhLFVBQUwsR0FBa0IsS0FBbEI7VUFDS0MsWUFBTCxHQUFvQixLQUFwQjtVQUNLQyxXQUFMLEdBQW1Cem9DLGlCQUFuQjtVQUNLMG9DLFFBQUwsR0FBZ0IsSUFBSTl2QyxPQUFKLEVBQWhCOztVQUVLODBCLHNCQUFMOzs7Ozs7Ozs7Ozs7Ozs7cUNBcUJlO2FBQ1IsS0FBS2liLEtBQUwsSUFBYyxLQUFLcDhELFlBQUwsQ0FBa0IsTUFBbEIsQ0FBckI7Ozs7Ozs7Ozs7Ozs7d0NBa0JrQjs7O1dBQ2IwaEQsa0JBQUwsR0FBMEIsS0FBSzJhLG1CQUFMLENBQXlCMzNELElBQXpCLENBQThCLElBQTlCLENBQTFCOztVQUVJLENBQUNuRSxTQUFTeUMsU0FBVCxFQUFELElBQXlCLEtBQUtoRCxZQUFMLENBQWtCLFdBQWxCLE1BQW1DLE9BQWhFLEVBQXlFO1lBQ25FczhELHNCQUFKOzthQUVLQyxNQUFMLEdBQWMsSUFBSXBHLFdBQUosQ0FBZ0I7bUJBQ25CLElBRG1CO3dCQUVkO21CQUFNaitDLEtBQUttSixHQUFMLENBQVMsR0FBVCxFQUFjb3FDLFdBQVcsT0FBS3pyRCxZQUFMLENBQWtCLGlCQUFsQixDQUFYLEtBQW9ELENBQWxFLENBQU47V0FGYzs7b0JBSWxCLG9CQUFNO21CQUNUb3JELFFBQUwsSUFBaUIsT0FBS0EsUUFBTCxDQUFjLENBQWQsRUFBaUIsRUFBRXZnRCxVQUFVeXhELGNBQWM5RSxhQUExQixFQUF5Q3I5QyxRQUFRbWlELGNBQWM3RSxXQUEvRCxFQUFqQixDQUFqQjttQkFDSyxPQUFLUixRQUFMLEdBQWdCLFVBQWhCLEdBQTZCLFNBQWxDLEVBQTZDLEVBQUUzc0QsVUFBVWd5RCxhQUFaLEVBQTdDOzRCQUNnQixJQUFoQjtXQVAwQjtvQkFTbEIsa0JBQUM5aUQsUUFBRCxFQUFXbFksS0FBWCxFQUFxQjttQkFDeEI4cEQsUUFBTCxJQUFpQixPQUFLQSxRQUFMLENBQWM1eEMsV0FBU2xZLEtBQXZCLENBQWpCOzBCQUNjaXJELFNBQWQsQ0FBd0IveUMsUUFBeEIsRUFBa0NsWSxLQUFsQyxFQUF5QyxPQUFLcVUsT0FBTCxDQUFhNm1ELHNCQUF0RCxFQUE4RSxPQUFLN21ELE9BQW5GO1dBWDBCO29CQWFsQixvQkFBTTttQkFDVHkxQyxRQUFMLElBQWlCLE9BQUtBLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLEVBQUV2Z0QsVUFBVXl4RCxjQUFjL0UsZUFBMUIsRUFBMkNwOUMsUUFBUW1pRCxjQUFjN0UsV0FBakUsRUFBakIsQ0FBakI7MEJBQ2M2QixPQUFkLENBQXNCLE9BQUszakQsT0FBTCxDQUFhNm1ELHNCQUFuQyxFQUEyRCxPQUFLN21ELE9BQWhFOzRCQUNnQixJQUFoQjtXQWhCMEI7O3VCQW1CZixxQkFBQ3RHLEtBQUQsRUFBUW1LLFFBQVIsRUFBcUI7O2dCQUU1QixDQUFDLE9BQUt3aUQsVUFBTixJQUFvQixPQUFLN3JELFFBQUwsQ0FBY3ZRLE1BQWQsR0FBdUIsQ0FBL0MsRUFBa0Q7OztrQkFHMUM2OEQsT0FBTy82RCxTQUFTLE9BQUsxQixZQUFMLENBQWtCLG9CQUFsQixLQUEyQyxFQUFwRCxFQUF3RCxFQUF4RCxDQUFiO2tCQUNJcVAsTUFBTWtLLE9BQU4sQ0FBY21KLFNBQWQsS0FBNkIsT0FBN0IsSUFBd0MrNUMsT0FBT2pqRCxRQUFuRCxFQUE2RDs7O29CQUdyRGtqRCxPQUFPLFNBQVBBLElBQU87NkNBQXlCejdELElBQW5CLENBQXdCd0gsR0FBRzZDLE9BQTNCOztpQkFBbkI7b0JBQ0ksQ0FBQ294RCxLQUFLcnRELE1BQU0zSSxNQUFYLENBQUQsSUFBdUIsQ0FBQy9ILE9BQUtpUCxVQUFMLENBQWdCeUIsTUFBTTNJLE1BQXRCLEVBQThCZzJELElBQTlCLEVBQW9DO3NDQUFpQno3RCxJQUFaLENBQWlCMEIsRUFBRTJJLE9BQW5COztpQkFBekMsQ0FBNUIsRUFBbUc7OztzQkFHM0ZmLFlBQVksQ0FBQyxPQUFLb0wsT0FBTCxDQUFhZ25ELGFBQWIsSUFBOEIsRUFBL0IsRUFBbUNweUQsU0FBbkMsSUFBZ0QsT0FBS3F5RCxlQUFMLENBQXFCNXlELFVBQXZGO3NCQUNNUSxXQUFXdTNDLGdCQUFjeDNDLFNBQWQsYUFBb0NtRixRQUFwQyxHQUNicXlDLGdCQUFjeDNDLFNBQWQsRUFBeUJqTSxJQUF6QixFQURhLEdBRWJ5akQsZ0JBQWN4M0MsU0FBZCxDQUZKOztzQkFJSSxPQUFPQyxRQUFQLEtBQW9CLFdBQXBCLElBQW1DQSxTQUFTKzZDLFNBQWhELEVBQTJEO29DQUN6QyxJQUFJLzZDLFFBQUosRUFBaEIsQ0FEeUQ7MkJBRWxELEtBQVA7Ozs7OzttQkFNRCxJQUFQLENBMUJnQzs7U0FuQnRCLENBQWQ7O2FBaURLOGxDLHdCQUFMLENBQThCLFdBQTlCOzs7VUFHRSxLQUFLMnJCLFlBQVQsRUFBdUI7Ozs7V0FJbEJBLFlBQUwsR0FBb0IsSUFBcEI7O1VBRU01akQsV0FBVzFaLE9BQUt5WixLQUFMLEVBQWpCO1dBQ0t5a0QsTUFBTCxHQUFjeGtELFNBQVNDLE9BQXZCOztrQkFFWThiLEtBQVosQ0FBa0IsSUFBbEIsRUFBd0IsWUFBTTtZQUN0QnZGLE9BQU8sQ0FBQ2x3QixPQUFLc1YsdUJBQUwsUUFBZDtZQUNNN0osVUFBVSxFQUFFRyxXQUFXLE1BQWIsRUFBcUJza0IsVUFBckIsRUFBaEI7O1lBRUksT0FBSzFsQixLQUFMLENBQVd2SixNQUFYLEtBQXNCLENBQXRCLElBQTJCLE9BQUtrOUQsY0FBTCxFQUEvQixFQUFzRDtpQkFDL0NDLFFBQUwsQ0FBYyxPQUFLRCxjQUFMLEVBQWQsRUFBcUMxeUQsT0FBckMsRUFBOEN3aUIsSUFBOUMsQ0FBbUQ7bUJBQU12VSxTQUFTOVEsT0FBVCxFQUFOO1dBQW5EO1NBREYsTUFFTyxJQUFJLE9BQUs0QixLQUFMLENBQVd2SixNQUFYLEdBQW9CLENBQXhCLEVBQTJCO2VBQzNCLElBQUlELElBQUksQ0FBYixFQUFnQkEsSUFBSSxPQUFLd0osS0FBTCxDQUFXdkosTUFBL0IsRUFBdUNELEdBQXZDLEVBQTRDOzhCQUN4QixPQUFLd0osS0FBTCxDQUFXeEosQ0FBWCxDQUFsQjs7O2NBR0UsT0FBS2dXLE9BQVQsRUFBa0I7eUJBQ0gsT0FBS0EsT0FBbEIsRUFBMkI7cUJBQ3pCeUgsV0FBVyxZQUFNO3lCQUNON1YsT0FBVDt3QkFDUSxPQUFLb08sT0FBTCxDQUFhcW5ELEtBQWIsRUFBUjt1QkFDS0MseUJBQUw7ZUFIRixFQUlHLENBSkgsQ0FEeUI7YUFBM0I7O1NBTkcsTUFjQTsrQkFDYyxZQUFNO2dCQUNuQixPQUFLOXpELEtBQUwsQ0FBV3ZKLE1BQVgsS0FBc0IsQ0FBdEIsSUFBMkIsT0FBS2s5RCxjQUFMLEVBQS9CLEVBQXNEO3FCQUMvQ0MsUUFBTCxDQUFjLE9BQUtELGNBQUwsRUFBZCxFQUFxQzF5RCxPQUFyQyxFQUE4Q3dpQixJQUE5QyxDQUFtRDt1QkFBTXZVLFNBQVM5USxPQUFULEVBQU47ZUFBbkQ7YUFERixNQUVPO3VCQUNJQSxPQUFUOztXQUpKOztPQXJCSjs7Ozs2Q0FnQ3VCO1dBQ2xCMjVDLGdCQUFMLEdBQXdCLElBQUkxM0MsZUFBSixDQUFvQjttQkFDL0J1NEMsZUFEK0I7bUJBRS9Cb1YsaUJBRitCO3VCQUczQixtQkFIMkI7MEJBSXhCLEtBQUtuM0QsWUFBTCxDQUFrQixXQUFsQjtPQUpJLENBQXhCOzs7OzJDQVFxQjtXQUNoQjJoRCxrQkFBTCxDQUF3QjN6QixPQUF4QjtXQUNLMnpCLGtCQUFMLEdBQTBCLElBQTFCOztXQUVLNGEsTUFBTCxJQUFlLEtBQUtBLE1BQUwsQ0FBWTl6QyxPQUFaLEVBQWY7V0FDSzh6QyxNQUFMLEdBQWMsSUFBZDs7Ozs2Q0FPdUI3OUQsTUFBTWtPLE1BQU1DLFNBQVM7Y0FDcENuTyxJQUFSO2FBQ08sV0FBTDtlQUNPeWlELHNCQUFMOzthQUVHLFdBQUw7ZUFDT29iLE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVlXLE1BQVosRUFBZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFxQ2dCOzs7VUFBZDl5RCxPQUFjLHVFQUFKLEVBQUk7O2tDQUNQLEtBQUsreUQsc0JBQUwsQ0FBNEIsSUFBNUIsRUFBa0MveUQsT0FBbEMsQ0FETzs7YUFBQSx5QkFDbEJBLE9BRGtCOzs7VUFHaEJ6TCxPQUFLcVosU0FBTCxDQUFlNU4sUUFBUWd6RCxLQUF2QixLQUFpQ2h6RCxRQUFRZ3pELEtBQVIsR0FBZ0IsQ0FBckQsRUFBd0Q7YUFDakRDLFlBQUwsQ0FBa0JqekQsUUFBUWd6RCxLQUExQjs7O1VBR0lFLFlBQVksU0FBWkEsU0FBWTtlQUFNLElBQUloMkQsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBYTtpQkFDMUMyMEQsV0FBTCxDQUFpQnFCLE1BQWpCLENBQXdCLE9BQUtwMEQsS0FBTCxDQUFXLE9BQUtBLEtBQUwsQ0FBV3ZKLE1BQVgsR0FBb0IsQ0FBL0IsQ0FBeEI7O1NBRHNCLENBQU47T0FBbEI7O2FBS08sS0FBSzQ5RCxRQUFMLENBQWNwekQsT0FBZCxFQUF1Qmt6RCxTQUF2QixDQUFQOzs7OzZCQUdPbHpELFNBQTJDOzs7VUFBbEM4eUQsTUFBa0MsdUVBQXpCO2VBQU01MUQsUUFBUUMsT0FBUixFQUFOO09BQXlCOztVQUM5QyxLQUFLeTBELFVBQVQsRUFBcUI7ZUFDWjEwRCxRQUFRRSxNQUFSLENBQWUsNkJBQWYsQ0FBUDs7O1VBR0UsS0FBSzJCLEtBQUwsQ0FBV3ZKLE1BQVgsSUFBcUIsQ0FBekIsRUFBNEI7ZUFDbkIwSCxRQUFRRSxNQUFSLENBQWUsdUNBQWYsQ0FBUDs7O1VBR0UsS0FBS2kyRCxnQkFBTCxFQUFKLEVBQTZCO2VBQ3BCbjJELFFBQVFFLE1BQVIsQ0FBZSwyQkFBZixDQUFQOzs7VUFHSTVILFNBQVMsS0FBS3VKLEtBQUwsQ0FBV3ZKLE1BQTFCOztXQUVLbzhELFVBQUwsR0FBa0IsSUFBbEI7O1dBRUs3eUQsS0FBTCxDQUFXdkosU0FBUyxDQUFwQixFQUF1Qjg5RCxnQkFBdkIsQ0FBeUM5OUQsU0FBUyxDQUFWLEdBQWUsQ0FBdkQ7O2FBRU8sSUFBSTBILE9BQUosQ0FBWSxtQkFBVztZQUN0Qit2RCxZQUFZLE9BQUtsdUQsS0FBTCxDQUFXdkosU0FBUyxDQUFwQixDQUFsQjtZQUNNdzNELFlBQVksT0FBS2p1RCxLQUFMLENBQVd2SixTQUFTLENBQXBCLENBQWxCOztrQkFFVWpCLE9BQUsrTCxNQUFMLENBQVksRUFBWixFQUFnQixPQUFLTixPQUFMLElBQWdCLEVBQWhDLEVBQW9DaXRELFVBQVVzRixhQUFWLElBQTJCLEVBQS9ELEVBQW1FdnlELE9BQW5FLENBQVY7O1lBRUlBLFFBQVEwK0IsSUFBWixFQUFrQjtvQkFDTkEsSUFBVixHQUFpQm5xQyxPQUFLK0wsTUFBTCxDQUFZLEVBQVosRUFBZ0Iwc0QsVUFBVXR1QixJQUFWLElBQWtCLEVBQWxDLEVBQXNDMStCLFFBQVEwK0IsSUFBUixJQUFnQixFQUF0RCxDQUFqQjs7O1lBR0k1c0IsT0FBTyxTQUFQQSxJQUFPLEdBQU07bUJBQ1IwUSxJQUFULENBQWMsWUFBTTttQkFDYm92QyxVQUFMLEdBQWtCLEtBQWxCOztzQkFFVWdCLEtBQVY7bUJBQ0tobkQsbUJBQUwsU0FBK0IsU0FBL0IsRUFBMEMsRUFBQ3FoRCxvQkFBRCxFQUFZRCxvQkFBWixFQUF1QmwyRCxpQkFBdkIsRUFBMUM7O29CQUVRNkUsUUFBUixJQUFvQnFFLFFBQVFyRSxRQUFSLENBQWlCcXhELFNBQWpCLENBQXBCOztvQkFFUUEsU0FBUjtXQVJGO1NBREY7O2tCQWFVdUcsS0FBVjtrQkFDVTUrRCxLQUFWLENBQWdCc1IsT0FBaEIsR0FBMEIsRUFBMUI7O1lBRU0vRixXQUFXRixRQUFRRSxRQUFSLElBQW9CLE9BQUs0MkMsZ0JBQUwsQ0FBc0I1QixXQUF0QixDQUFrQ2wxQyxPQUFsQyxDQUFyQztpQkFDUytsQyxHQUFULENBQWEsT0FBS2huQyxLQUFMLENBQVd2SixTQUFTLENBQXBCLENBQWIsRUFBcUMsT0FBS3VKLEtBQUwsQ0FBV3ZKLFNBQVMsQ0FBcEIsQ0FBckMsRUFBNkRzYyxJQUE3RDtPQTNCSyxFQTRCSjVTLEtBNUJJLENBNEJFO2VBQU0sT0FBSzB5RCxVQUFMLEdBQWtCLEtBQXhCO09BNUJGLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQXNFTzMwRCxNQUFvQjs7O1VBQWQrQyxPQUFjLHVFQUFKLEVBQUk7O21DQUNSLEtBQUsreUQsc0JBQUwsQ0FBNEI5MUQsSUFBNUIsRUFBa0MrQyxPQUFsQyxDQURROztVQUFBLDBCQUN6Qi9DLElBRHlCO2FBQUEsMEJBQ25CK0MsT0FEbUI7OztVQUdyQmtDLFVBQVUsU0FBVkEsT0FBVSxjQUFlOzBCQUNYMG1CLFdBQWxCO2VBQ0ttcEMsUUFBTCxDQUFjdjFELEdBQWQsQ0FBa0Jvc0IsV0FBbEIsRUFBK0IzckIsSUFBL0I7c0JBQ2MxSSxPQUFLK0wsTUFBTCxDQUFZc29CLFdBQVosRUFBeUI7Z0JBQy9CNW9CLFFBQVEwK0I7U0FERixDQUFkO29CQUdZL3BDLEtBQVosQ0FBa0J3d0QsVUFBbEIsR0FBK0IsUUFBL0I7T0FORjs7VUFTSW5sRCxRQUFRd3pELFFBQVosRUFBc0I7ZUFDYixLQUFLQyxTQUFMLENBQWV6ekQsT0FBZixFQUF3QjtpQkFBTSxJQUFJOUMsT0FBSixDQUFZLG1CQUFXOzhCQUN4Q3cyRCxJQUFsQixDQUF1QixFQUFDejJELE1BQU0rQyxRQUFRd3pELFFBQWYsRUFBeUI5dkQsY0FBekIsRUFBdUNtTSxRQUFRN1AsUUFBUTArQixJQUF2RCxFQUF2QixFQUFxRix1QkFBZTtzQkFDMUY5VixXQUFSOzthQURGO1dBRG1DLENBQU47U0FBeEIsQ0FBUDs7O2FBUUssS0FBSzZxQyxTQUFMLENBQWV6ekQsT0FBZixFQUF3QjtlQUFNLElBQUk5QyxPQUFKLENBQVksbUJBQVc7aUJBQ3JENDBELFdBQUwsQ0FBaUI0QixJQUFqQixDQUFzQixFQUFDejJELFVBQUQsRUFBT3lHLGNBQVAsRUFBcUJtTSxRQUFRN1AsUUFBUTArQixJQUFyQyxFQUF0QixFQUFrRSx1QkFBZTtvQkFDdkU5VixXQUFSOztXQURGO1NBRG1DLENBQU47T0FBeEIsQ0FBUDs7OztnQ0FRd0Q7OztVQUFoRDVvQixPQUFnRCx1RUFBdEMsRUFBc0M7VUFBbEM4eUQsTUFBa0MsdUVBQXpCO2VBQU01MUQsUUFBUUMsT0FBUixFQUFOO09BQXlCOztVQUNwRCxLQUFLeTBELFVBQVQsRUFBcUI7ZUFDWjEwRCxRQUFRRSxNQUFSLENBQWUsOEJBQWYsQ0FBUDs7O1VBR0UsS0FBS3UyRCxpQkFBTCxFQUFKLEVBQThCO2VBQ3JCejJELFFBQVFFLE1BQVIsQ0FBZSw0QkFBZixDQUFQOzs7V0FHR3cwRCxVQUFMLEdBQWtCLElBQWxCOztVQUVNcnhELG1CQUFtQm5CLGdCQUFnQjgzQywyQkFBaEIsQ0FBNEMsS0FBS3RoRCxZQUFMLENBQWtCLG1CQUFsQixDQUE1QyxDQUF6QjtnQkFDVXJCLE9BQUsrTCxNQUFMLENBQVksRUFBWixFQUFnQixLQUFLTixPQUFMLElBQWdCLEVBQWhDLEVBQW9DLEVBQUNPLGtDQUFELEVBQXBDLEVBQXdEUCxPQUF4RCxDQUFWOztVQUVNRSxXQUFXLEtBQUs0MkMsZ0JBQUwsQ0FBc0I1QixXQUF0QixDQUFrQ2wxQyxPQUFsQyxDQUFqQjs7YUFFTzh5RCxTQUFTdHdDLElBQVQsQ0FBYyxZQUFNO1lBQ25Cb3hDLGFBQWEsT0FBSzcwRCxLQUFMLENBQVd2SixNQUE5Qjs7WUFFTXczRCxZQUFhLE9BQUtqdUQsS0FBTCxDQUFXNjBELGFBQWEsQ0FBeEIsQ0FBbkI7WUFDTTNHLFlBQVlqdEQsUUFBUWl0RCxTQUFSLElBQXFCLE9BQUtsdUQsS0FBTCxDQUFXNjBELGFBQWEsQ0FBeEIsQ0FBdkM7OzBCQUVrQjVHLFNBQWxCOztrQkFFVXNHLGdCQUFWLENBQTJCTSxjQUFjNXpELFFBQVE2ekQsWUFBUixHQUF1QixDQUF2QixHQUEyQixDQUF6QyxDQUEzQjs7a0JBRVV0QixhQUFWLEdBQTBCaCtELE9BQUsrTCxNQUFMLENBQVksRUFBWixFQUFnQjBzRCxVQUFVdUYsYUFBVixJQUEyQixFQUEzQyxFQUErQ3Z5RCxXQUFXLEVBQTFELENBQTFCO2tCQUNVMCtCLElBQVYsR0FBaUJucUMsT0FBSytMLE1BQUwsQ0FBWSxFQUFaLEVBQWdCMHNELFVBQVV0dUIsSUFBVixJQUFrQixFQUFsQyxFQUFzQzErQixRQUFRMCtCLElBQVIsSUFBZ0IsRUFBdEQsQ0FBakI7a0JBQ1V5MEIsTUFBVixHQUFtQm5HLFVBQVVtRyxNQUFWLElBQW9CbnpELFFBQVFtekQsTUFBL0M7O2VBRU8sSUFBSWoyRCxPQUFKLENBQVksbUJBQVc7Y0FDdEI0VSxPQUFPLFNBQVBBLElBQU8sR0FBTTttQkFDWjgvQyxVQUFMLEdBQWtCLEtBQWxCOztvQkFFUW50QyxJQUFSLEtBQWlCLEtBQWpCLElBQTBCK29CLGFBQWE7cUJBQU13ZixVQUFVNEYsS0FBVixFQUFOO2FBQWIsQ0FBMUI7bUJBQ0tobkQsbUJBQUwsU0FBK0IsVUFBL0IsRUFBMkMsRUFBQ3FoRCxvQkFBRCxFQUFZRCxvQkFBWixFQUF1QmwyRCxpQkFBdkIsRUFBM0M7O2dCQUVJbTJELFNBQUosRUFBZTt3QkFDSHQ0RCxLQUFWLENBQWdCc1IsT0FBaEIsR0FBMEIsTUFBMUI7OztvQkFHTXRLLFFBQVIsSUFBb0JxRSxRQUFRckUsUUFBUixDQUFpQnF4RCxTQUFqQixDQUFwQjs7b0JBRVFBLFNBQVI7V0FaRjs7b0JBZVVyNEQsS0FBVixDQUFnQnd3RCxVQUFoQixHQUE2QixFQUE3QjtjQUNJOEgsU0FBSixFQUFlO3NCQUNIc0csS0FBVjtxQkFDUzU5RCxJQUFULENBQWNxM0QsU0FBZCxFQUF5QkMsU0FBekIsRUFBb0NuN0MsSUFBcEM7V0FGRixNQUdPOzs7U0FwQkYsQ0FBUDtPQWRLLEVBc0NKNVMsS0F0Q0ksQ0FzQ0UsVUFBQ2xHLEtBQUQsRUFBVztlQUNiNDRELFVBQUwsR0FBa0IsS0FBbEI7Y0FDTTU0RCxLQUFOO09BeENLLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBc0RVaUUsTUFBb0I7OztVQUFkK0MsT0FBYyx1RUFBSixFQUFJOzthQUN2QixLQUFLMnlELFFBQUwsQ0FBYzExRCxJQUFkLEVBQW9CK0MsT0FBcEIsRUFDSndpQixJQURJLENBQ0MseUJBQWlCO1lBQ2pCLE9BQUt6akIsS0FBTCxDQUFXdkosTUFBWCxHQUFvQixDQUF4QixFQUEyQjtpQkFDcEJzOEQsV0FBTCxDQUFpQnFCLE1BQWpCLENBQXdCLE9BQUtwMEQsS0FBTCxDQUFXLE9BQUtBLEtBQUwsQ0FBV3ZKLE1BQVgsR0FBb0IsQ0FBL0IsQ0FBeEI7O2VBRUdxOUQseUJBQUw7O2VBRU8zMUQsUUFBUUMsT0FBUixDQUFnQjIyRCxhQUFoQixDQUFQO09BUEcsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkF3QlNod0QsT0FBTzdHLE1BQW9COzs7VUFBZCtDLE9BQWMsdUVBQUosRUFBSTs7bUNBQ2pCLEtBQUsreUQsc0JBQUwsQ0FBNEI5MUQsSUFBNUIsRUFBa0MrQyxPQUFsQyxDQURpQjs7VUFBQSwwQkFDbEMvQyxJQURrQzthQUFBLDBCQUM1QitDLE9BRDRCOztjQUU1QixLQUFLK3pELGVBQUwsQ0FBcUJqd0QsS0FBckIsQ0FBUjs7VUFFSUEsU0FBUyxLQUFLL0UsS0FBTCxDQUFXdkosTUFBeEIsRUFBZ0M7ZUFDdkIsS0FBS205RCxRQUFMLENBQWMxMUQsSUFBZCxFQUFvQitDLE9BQXBCLENBQVA7OzthQUdLLE9BQU9BLFFBQVF3ekQsUUFBZixLQUE0QixRQUE1QixHQUF1Q3h6RCxRQUFRd3pELFFBQS9DLEdBQTBEdjJELElBQWpFO1VBQ00rckIsU0FBUyxPQUFPaHBCLFFBQVF3ekQsUUFBZixLQUE0QixRQUE1QixHQUF1Q2xxQyxpQkFBdkMsR0FBMkQsS0FBS3dvQyxXQUEvRTs7YUFFTyxJQUFJNTBELE9BQUosQ0FBWSxtQkFBVztlQUNyQncyRCxJQUFQLENBQVksRUFBQ3oyRCxVQUFELEVBQU95RyxjQUFQLEVBQVosRUFBa0MsdUJBQWU7NEJBQzdCa2xCLFdBQWxCO2lCQUNLbXBDLFFBQUwsQ0FBY3YxRCxHQUFkLENBQWtCb3NCLFdBQWxCLEVBQStCM3JCLElBQS9CO3dCQUNjMUksT0FBSytMLE1BQUwsQ0FBWXNvQixXQUFaLEVBQXlCO2tCQUMvQjVvQixRQUFRMCtCLElBRHVCOzJCQUV0QjErQjtXQUZILENBQWQ7O2tCQUtRTyxnQkFBUixHQUEyQmhNLE9BQUsrTCxNQUFMLENBQ3pCLEVBRHlCLEVBRXpCbEIsZ0JBQWdCODNDLDJCQUFoQixDQUE0QyxPQUFLdGhELFlBQUwsQ0FBa0IsbUJBQWxCLENBQTVDLENBRnlCLEVBR3pCb0ssUUFBUU8sZ0JBQVIsSUFBNEIsRUFISCxDQUEzQjs7c0JBTVk1TCxLQUFaLENBQWtCc1IsT0FBbEIsR0FBNEIsTUFBNUI7aUJBQ0t5SCxZQUFMLENBQWtCa2IsV0FBbEIsRUFBK0IsT0FBSzdwQixLQUFMLENBQVcrRSxLQUFYLENBQS9CO2lCQUNLeUgsT0FBTCxDQUFhK25ELGdCQUFiLENBQThCLElBQTlCOztxQkFFVyxZQUFNOzBCQUNELElBQWQ7b0JBQ1EsT0FBS3YwRCxLQUFMLENBQVcrRSxLQUFYLENBQVI7V0FGRixFQUdHLE9BQU8sRUFIVjtTQWxCRjtPQURLLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBd0NTQSxPQUFxQjs7O1VBQWQ5RCxPQUFjLHVFQUFKLEVBQUk7O2NBQ3RCLEtBQUsrekQsZUFBTCxDQUFxQmp3RCxLQUFyQixDQUFSOztVQUVJQSxRQUFRLEtBQUsvRSxLQUFMLENBQVd2SixNQUFYLEdBQW9CLENBQWhDLEVBQW1DO2VBQzFCLElBQUkwSCxPQUFKLENBQVksbUJBQVc7Y0FDdEIrdkQsWUFBWSxPQUFLbHVELEtBQUwsQ0FBVytFLEtBQVgsQ0FBbEI7Y0FDTWtwRCxZQUFZLE9BQUt6aEQsT0FBdkI7O2lCQUVLd21ELFFBQUwsQ0FBY2h3QyxNQUFkLENBQXFCa3JDLFNBQXJCO2lCQUNLNkUsV0FBTCxDQUFpQnFCLE1BQWpCLENBQXdCbEcsU0FBeEI7Y0FDSSxPQUFLbHVELEtBQUwsQ0FBV3ZKLE1BQVgsS0FBc0IsQ0FBMUIsRUFBNkI7O21CQUN0QitWLE9BQUwsQ0FBYStuRCxnQkFBYixDQUE4QixLQUE5Qjs7O2tCQUdNdEcsU0FBUjtTQVZLLENBQVA7T0FERixNQWFPO2VBQ0UsS0FBS3JULE9BQUwsQ0FBYTM1QyxPQUFiLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQWlCUS9DLE1BQW9COzs7VUFBZCtDLE9BQWMsdUVBQUosRUFBSTs7bUNBQ1gsS0FBSyt5RCxzQkFBTCxDQUE0QjkxRCxJQUE1QixFQUFrQytDLE9BQWxDLENBRFc7O1VBQUEsMEJBQzVCL0MsSUFENEI7YUFBQSwwQkFDdEIrQyxPQURzQjs7O1VBRzFCLENBQUNBLFFBQVFFLFFBQVQsSUFBcUIsQ0FBQ0YsUUFBUUcsU0FBOUIsSUFBMkMsQ0FBQ0gsUUFBUStsQyxHQUF4RCxFQUE2RDtnQkFDbkQ1bEMsU0FBUixHQUFvQixNQUFwQjs7O1VBR0UsQ0FBQ0gsUUFBUS9DLElBQVQsSUFBaUIsQ0FBQytDLFFBQVF3ekQsUUFBMUIsSUFBc0MsS0FBS2QsY0FBTCxFQUExQyxFQUFpRTtlQUN4RDF5RCxRQUFRL0MsSUFBUixHQUFlLEtBQUt5MUQsY0FBTCxFQUF0Qjs7O1VBR0UxeUQsUUFBUStsQyxHQUFaLEVBQWlCO2FBQ1ZrdEIsWUFBTDtlQUNPLEtBQUtlLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIvMkQsSUFBbkIsRUFBeUIsRUFBRXloQyxNQUFNMStCLFFBQVEwK0IsSUFBaEIsRUFBekIsRUFDSmxjLElBREksQ0FDQztpQkFBTSxRQUFLbTNCLE9BQUwsQ0FBYTM1QyxPQUFiLENBQU47U0FERCxDQUFQOzs7O1VBS0lyRSxXQUFXcUUsUUFBUXJFLFFBQXpCO2NBQ1FBLFFBQVIsR0FBbUIsbUJBQVc7Z0JBQ3ZCczNELFlBQUw7Z0JBQ1FLLGdCQUFSLENBQXlCLEtBQXpCO29CQUNZMzNELFNBQVNzNEQsT0FBVCxDQUFaO09BSEY7O2FBTU8sS0FBS3RCLFFBQUwsQ0FBYzExRCxJQUFkLEVBQW9CK0MsT0FBcEIsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0FnQlc0bEIsTUFBb0I7VUFBZDVsQixPQUFjLHVFQUFKLEVBQUk7O1VBQzNCLENBQUMsUUFBRCxFQUFXLFFBQVgsRUFBcUJ0SyxPQUFyQixRQUFvQ2t3QixJQUFwQyx5Q0FBb0NBLElBQXBDLE9BQThDLENBQUMsQ0FBbkQsRUFBc0Q7ZUFDL0Mzc0IsS0FBTCxDQUFXLHVGQUF1RjJzQixJQUFsRzs7VUFFSTloQixRQUFRLE9BQU84aEIsSUFBUCxLQUFnQixRQUFoQixHQUEyQixLQUFLbXVDLGVBQUwsQ0FBcUJudUMsSUFBckIsQ0FBM0IsR0FBd0QsS0FBS3N1QyxnQkFBTCxDQUFzQnR1QyxJQUF0QixDQUF0RTtVQUNNM29CLE9BQU8sS0FBSzhCLEtBQUwsQ0FBVytFLEtBQVgsQ0FBYjs7VUFFSUEsUUFBUSxDQUFaLEVBQWU7ZUFDTixLQUFLNnVELFFBQUwsQ0FBYy9zQyxJQUFkLEVBQW9CNWxCLE9BQXBCLENBQVA7OzttQ0FFVyxLQUFLK3lELHNCQUFMLENBQTRCOTFELElBQTVCLEVBQWtDK0MsT0FBbEMsQ0FWa0I7O2FBQUEsMEJBVTdCQSxPQVY2Qjs7O1VBWTNCOEQsVUFBVSxLQUFLL0UsS0FBTCxDQUFXdkosTUFBWCxHQUFvQixDQUFsQyxFQUFxQztlQUM1QjBILFFBQVFDLE9BQVIsQ0FBZ0JGLElBQWhCLENBQVA7O1VBRUUsQ0FBQ0EsSUFBTCxFQUFXO2VBQ0poRSxLQUFMLENBQVcseUJBQXlCMnNCLElBQXBDOztVQUVFLEtBQUtnc0MsVUFBVCxFQUFxQjtlQUNaMTBELFFBQVFFLE1BQVIsQ0FBZSw4QkFBZixDQUFQOztVQUVFLEtBQUt1MkQsaUJBQUwsRUFBSixFQUE4QjtlQUNyQnoyRCxRQUFRRSxNQUFSLENBQWUsNEJBQWYsQ0FBUDs7O1dBR0d6SSxLQUFMLENBQVdzUixPQUFYLEdBQXFCLEVBQXJCO1dBQ0t0UixLQUFMLENBQVd3d0QsVUFBWCxHQUF3QixRQUF4QjtXQUNLem1ELFVBQUwsQ0FBZ0JKLFdBQWhCLENBQTRCckIsSUFBNUI7YUFDTyxLQUFLdzJELFNBQUwsQ0FBZXp6RCxPQUFmLENBQVA7Ozs7MkNBR3FCL0MsTUFBb0I7VUFBZCtDLE9BQWMsdUVBQUosRUFBSTs7VUFDckMsUUFBT0EsT0FBUCx5Q0FBT0EsT0FBUCxNQUFrQixRQUF0QixFQUFnQztlQUN6Qi9HLEtBQUwsQ0FBVyw2Q0FBNkMrRyxPQUF4RDs7O1VBR0UsQ0FBQy9DLFNBQVMsSUFBVCxJQUFpQkEsU0FBU3lILFNBQTNCLEtBQXlDMUUsUUFBUS9DLElBQXJELEVBQTJEO2VBQ2xEK0MsUUFBUS9DLElBQWY7OztnQkFHUTFJLE9BQUsrTCxNQUFMLENBQVksRUFBWixFQUFnQixLQUFLTixPQUFMLElBQWdCLEVBQWhDLEVBQW9DQSxPQUFwQyxFQUE2QyxFQUFDL0MsVUFBRCxFQUE3QyxDQUFWOzthQUVPLEVBQUNBLFVBQUQsRUFBTytDLGdCQUFQLEVBQVA7Ozs7aUNBR1dnekQsT0FBTztVQUNaajBELFFBQVEsS0FBS0EsS0FBbkI7VUFDSTJLLFFBQVFzcEQsVUFBVXR1RCxTQUFWLEdBQXNCLENBQXRCLEdBQTBCM0YsTUFBTXZKLE1BQU4sR0FBZXc5RCxLQUFyRDtjQUNRdHBELFFBQVEsQ0FBUixHQUFZLENBQVosR0FBZ0JBLEtBQXhCOztXQUVLLElBQUluVSxJQUFJd0osTUFBTXZKLE1BQU4sR0FBZSxDQUE1QixFQUErQkQsS0FBS21VLEtBQXBDLEVBQTJDblUsR0FBM0MsRUFBZ0Q7YUFDekN3OEQsUUFBTCxDQUFjaHdDLE1BQWQsQ0FBcUJoakIsTUFBTXhKLENBQU4sQ0FBckI7YUFDS3U4RCxXQUFMLENBQWlCcUIsTUFBakIsQ0FBd0JwMEQsTUFBTXhKLENBQU4sQ0FBeEI7Ozs7O2dEQUl3QjtVQUNwQnVPLFFBQVEsS0FBSy9FLEtBQUwsQ0FBV3ZKLE1BQVgsR0FBb0IsQ0FBbEM7VUFDSXNPLFNBQVMsQ0FBYixFQUFnQjthQUNUL0UsS0FBTCxDQUFXK0UsS0FBWCxFQUFrQnd2RCxnQkFBbEIsQ0FBbUN4dkQsUUFBUSxDQUEzQzs7Ozs7b0NBSVlBLE9BQU87YUFDZEEsU0FBUyxDQUFULEdBQWFBLEtBQWIsR0FBcUJnSyxLQUFLd0osR0FBTCxDQUFTLEtBQUt2WSxLQUFMLENBQVd2SixNQUFYLEdBQW9Cc08sS0FBN0IsSUFBc0MsS0FBSy9FLEtBQUwsQ0FBV3ZKLE1BQTdFOzs7O3dDQUdrQnlQLE9BQU87VUFDckIsS0FBS2xHLEtBQUwsQ0FBV3ZKLE1BQVgsR0FBb0IsQ0FBeEIsRUFBMkI7YUFDcEJta0QsT0FBTDtPQURGLE1BRU87Y0FDQzlDLGlCQUFOOzs7OztxQ0FJYXNkLFVBQVU7VUFDckJyd0QsY0FBSjtXQUNLQSxRQUFRLEtBQUsvRSxLQUFMLENBQVd2SixNQUFYLEdBQW9CLENBQWpDLEVBQW9Dc08sU0FBUyxDQUE3QyxFQUFnREEsT0FBaEQsRUFBeUQ7WUFDbkQsQ0FBQyxLQUFLaXVELFFBQUwsQ0FBYzVyRCxHQUFkLENBQWtCLEtBQUtwSCxLQUFMLENBQVcrRSxLQUFYLENBQWxCLENBQUwsRUFBMkM7aUJBQ3BDN0ssS0FBTCxDQUFXLDRCQUFYOzs7WUFHRWs3RCxhQUFhLEtBQUtwQyxRQUFMLENBQWN6MEQsR0FBZCxDQUFrQixLQUFLeUIsS0FBTCxDQUFXK0UsS0FBWCxDQUFsQixDQUFqQixFQUF1RDs7OzthQUlsREEsS0FBUDs7OztrQ0FHWXhQLE1BQWlCO1VBQVhvcUMsSUFBVyx1RUFBSixFQUFJOztVQUN6QjAxQixhQUFhLEtBQWpCOzthQUVLeG9ELG1CQUFMLENBQXlCLElBQXpCLEVBQStCLFFBQVF0WCxJQUF2QyxFQUE2Q0MsT0FBSytMLE1BQUwsQ0FBWTttQkFDNUMsSUFENEM7cUJBRTFDLEtBQUt2QixLQUFMLENBQVcsS0FBS0EsS0FBTCxDQUFXdkosTUFBWCxHQUFvQixDQUEvQixDQUYwQztnQkFHL0M7aUJBQU00K0QsYUFBYSxJQUFuQjs7T0FIbUMsRUFJMUMxMUIsSUFKMEMsQ0FBN0M7O2FBTU8wMUIsVUFBUDs7Ozt3Q0FHa0I7YUFDWCxLQUFLQyxhQUFMLENBQW1CLE1BQW5CLENBQVA7Ozs7dUNBR2lCO1VBQ1gvcEQsSUFBSSxLQUFLdkwsS0FBTCxDQUFXdkosTUFBckI7YUFDTyxLQUFLNitELGFBQUwsQ0FBbUIsS0FBbkIsRUFBMEI7bUJBQ3BCLEtBQUt0MUQsS0FBTCxDQUFXdUwsSUFBSSxDQUFmLENBRG9CO21CQUVwQixLQUFLdkwsS0FBTCxDQUFXdUwsSUFBSSxDQUFmO09BRk4sQ0FBUDs7Ozs7Ozt1Q0FPaUJncUQsY0FBYztVQUN6QjFyQyxjQUFjcjBCLE9BQUsyRyxhQUFMLENBQW1CSCxXQUFTTSxpQkFBVCxDQUEyQmk1RCxZQUEzQixDQUFuQixDQUFwQjt3QkFDa0IxckMsV0FBbEI7YUFDT0EsV0FBUDs7Ozs7Ozs7Ozs7Ozs0QkFvSE07OztXQUNENnBDLE1BQUwsQ0FBWWp3QyxJQUFaLENBQWlCO2VBQU0sUUFBS2pYLE9BQUwsSUFBZ0IsUUFBS0EsT0FBTCxDQUFhcW5ELEtBQWIsRUFBdEI7T0FBakI7Ozs7NEJBR007V0FDRHJuRCxPQUFMLElBQWdCLEtBQUtBLE9BQUwsQ0FBYWdvRCxLQUFiLEVBQWhCOzs7OytCQUdTO1dBQ0osSUFBSWgrRCxJQUFJLEtBQUt3SixLQUFMLENBQVd2SixNQUFYLEdBQW9CLENBQWpDLEVBQW9DRCxLQUFLLENBQXpDLEVBQTRDQSxHQUE1QyxFQUFpRDthQUMxQ3U4RCxXQUFMLENBQWlCcUIsTUFBakIsQ0FBd0IsS0FBS3AwRCxLQUFMLENBQVd4SixDQUFYLENBQXhCOzs7V0FHRzROLE1BQUw7Ozs7Ozs7Ozs7MkJBenhCZTthQUNSLEtBQUsydUQsV0FBWjs7eUJBR2F5QyxZQUFZO1VBQ3JCLEVBQUVBLHNCQUFzQnhyQyxVQUF4QixDQUFKLEVBQXlDO2VBQ2xDemEsZUFBTDs7V0FFR3dqRCxXQUFMLEdBQW1CeUMsVUFBbkI7Ozs7MkJBY1M7YUFDRixLQUFLdkMsS0FBWjs7eUJBR08vMEQsTUFBTTtXQUNSKzBELEtBQUwsR0FBYS8wRCxJQUFiOzs7OzJCQXVvQnVCO2FBQ2hCLEtBQUtzNkMsa0JBQVo7O3lCQUdxQjU3QyxVQUFVO1VBQzNCLEtBQUs0N0Msa0JBQVQsRUFBNkI7YUFDdEJBLGtCQUFMLENBQXdCM3pCLE9BQXhCOzs7V0FHRzJ6QixrQkFBTCxHQUEwQnh3QywyQkFBMkJpdEMsYUFBM0IsQ0FBeUMsSUFBekMsRUFBK0NyNEMsUUFBL0MsQ0FBMUI7Ozs7Ozs7Ozs7Ozs7OzJCQVdZO1VBQ1I2RyxPQUFPLEtBQUtneUQsZ0JBQWhCO2FBQ09oeUQsUUFBUUEsS0FBS3RCLE9BQUwsS0FBaUIsVUFBaEMsRUFBNEM7ZUFBU3NCLEtBQUs0dkQsc0JBQVo7O2FBQ3ZDNXZELElBQVA7Ozs7Ozs7Ozs7Ozs7OzJCQVdVO2FBQ0hqTyxPQUFLMkosU0FBTCxDQUFlLEtBQUs2SCxRQUFwQixFQUNKeEMsTUFESSxDQUNHO2VBQVc3TyxRQUFRd00sT0FBUixLQUFvQixVQUEvQjtPQURILENBQVA7Ozs7Ozs7Ozs7Ozs7MkJBV1k7YUFDTCxLQUFLOC9DLFFBQVo7O3lCQUdVNW5ELE9BQU87VUFDYkEsU0FBUyxFQUFFQSxpQkFBaUJrTSxRQUFuQixDQUFiLEVBQTJDO2VBQ3BDck0sS0FBTCxDQUFXLDhCQUFYOztXQUVHK25ELFFBQUwsR0FBZ0I1bkQsS0FBaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBc0NZO2FBQ0wsS0FBS2tnRCxRQUFaOzt5QkFFVXJ4QyxRQUFRO1dBQ2JxeEMsUUFBTCxHQUFnQnJ4QyxNQUFoQjs7Ozt5QkFHYTdPLE9BQU87V0FDZm1JLFlBQUwsQ0FBa0IsYUFBbEIsRUFBaUNuSSxRQUFRLE1BQVIsR0FBaUIsT0FBbEQ7OzJCQUVlO2FBQ1Q4UixLQUFLN0MsS0FBTCxDQUFXLEtBQUt6UyxZQUFMLENBQWtCLGFBQWxCLENBQVgsQ0FBUDs7OztxQ0F1QnVCdEIsTUFBTThMLFVBQVU7VUFDbEMsRUFBRUEsU0FBU3BNLFNBQVQsWUFBOEIrNEQsaUJBQWhDLENBQUosRUFBd0Q7ZUFDakR4K0MsYUFBTCxDQUFtQixXQUFuQjs7O3NCQUdZamEsSUFBZCxJQUFzQjhMLFFBQXRCOzs7OzJCQW5wQjhCO2FBQ3ZCLENBQUMsV0FBRCxFQUFjLFdBQWQsQ0FBUDs7OzsyQkFxcEJxQjthQUNkdTNDLGVBQVA7Ozs7MkJBRzZCO2FBQ3RCb1YsaUJBQVA7Ozs7MkJBR2tCO2FBQ1gsQ0FBQyxTQUFELEVBQVksVUFBWixFQUF3QixRQUF4QixFQUFrQyxTQUFsQyxDQUFQOzs7OzJCQUd1QjthQUNoQnlFLFdBQVA7Ozs7RUF6OEIwQ25kOztBQTY4QjlDN2tDLFlBQVlpbEQsU0FBWixHQUF3QjlDLGdCQUF4QjtBQUNBci9CLGVBQWVMLE1BQWYsQ0FBc0IsZUFBdEIsRUFBdUMwL0IsZ0JBQXZDOztBQy9qQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBUUEsSUFBTXZZLHNCQUFtQixTQUF6Qjs7QUFFQSxJQUFNaDJDLFlBQVM7TUFDVCxZQURTO29CQUVLLGtCQUZMO3NCQUdPLG9CQUhQO3FCQUlNO0NBSnJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBK0RxQnN4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkF3Qkw7Ozs7O3dCQUdPLFlBQU07WUFDbEI3YyxRQUFMO0tBREY7Ozs7Ozs2Q0FTdUJ2akQsTUFBTWtPLE1BQU1DLFNBQVM7Y0FDcENuTyxJQUFSO2FBQ08sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I2c0MsbUJBQXhCLEVBQTBDaDJDLFNBQTFDOzthQUVHLFVBQUw7dUJBQ2VvMEMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxTQUFwRDs7Ozs7Ozs7Ozs7a0RBUXdCO2FBQ3JCLEtBQUtuSCxhQUFMLENBQW1CLE9BQW5CLEtBQStCbEIsV0FBU0UsV0FBL0M7Ozs7Ozs7OztvREFNOEI7YUFDdkIsS0FBS2dCLGFBQUwsQ0FBbUIsU0FBbkIsS0FBaUNsQixXQUFTRSxXQUFqRDs7Ozs7Ozs7O21EQU02QjthQUN0QixLQUFLZ0IsYUFBTCxDQUFtQixRQUFuQixLQUFnQ2xCLFdBQVNFLFdBQWhEOzs7Ozs7Ozs7d0RBTWtDO2FBQzNCLEtBQUtnQixhQUFMLENBQW1CLHFDQUFuQixLQUE2RGxCLFdBQVNFLFdBQTdFOzs7Ozs7Ozs7dURBTWlDO2FBQzFCLEtBQUtnQixhQUFMLENBQW1CLG9DQUFuQixLQUE0RGxCLFdBQVNFLFdBQTVFOzs7OytCQUdTO2dCQUNDaUgsT0FBVixDQUFrQixJQUFsQjtXQUNLYSxTQUFMLENBQWVFLEdBQWYsQ0FBbUJtMkMsbUJBQW5CO1dBQ0t1YiwwQkFBTDttQkFDYTFjLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsU0FBaEM7Ozs7aURBRzJCO1dBQ3RCLElBQUk3TixJQUFJLEtBQUsrVCxVQUFMLENBQWdCOVQsTUFBaEIsR0FBeUIsQ0FBdEMsRUFBeUNELEtBQUssQ0FBOUMsRUFBa0RBLEdBQWxELEVBQXVEOztZQUVqRCxLQUFLK1QsVUFBTCxDQUFnQi9ULENBQWhCLEVBQW1CZ1UsUUFBbkIsSUFBK0IsQ0FBbkMsRUFBc0M7ZUFDL0JnakIsV0FBTCxDQUFpQixLQUFLampCLFVBQUwsQ0FBZ0IvVCxDQUFoQixDQUFqQjs7OztVQUlFaW5CLFNBQVMsS0FBS280QyxxQkFBTCxDQUEyQixRQUEzQixDQUFmO2FBQ083eEQsU0FBUCxDQUFpQkUsR0FBakIsQ0FBcUIsZ0JBQXJCOztVQUVJLEtBQUs4QyxRQUFMLENBQWN2USxNQUFkLEtBQXlCLENBQXpCLElBQThCLENBQUMsS0FBS3VRLFFBQUwsQ0FBYyxDQUFkLEVBQWlCaEQsU0FBakIsQ0FBMkI2RyxRQUEzQixDQUFvQyxRQUFwQyxDQUFuQyxFQUFrRjtZQUMxRXBELE9BQU8sS0FBS291RCxxQkFBTCxDQUEyQixNQUEzQixDQUFiO1lBQ01udUQsUUFBUSxLQUFLbXVELHFCQUFMLENBQTJCLE9BQTNCLENBQWQ7O1lBRUksS0FBSzd1RCxRQUFMLENBQWMsQ0FBZCxNQUFxQlMsSUFBckIsSUFBNkIsS0FBS1QsUUFBTCxDQUFjLENBQWQsTUFBcUJ5VyxNQUFsRCxJQUE0RCxLQUFLelcsUUFBTCxDQUFjLENBQWQsTUFBcUJVLEtBQXJGLEVBQTRGO2VBQ3JGbkksV0FBTCxDQUFpQmtJLElBQWpCO2VBQ0tsSSxXQUFMLENBQWlCa2UsTUFBakI7ZUFDS2xlLFdBQUwsQ0FBaUJtSSxLQUFqQjs7Ozs7OzBDQUtnQm5TLE1BQU07VUFDdEJDLE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixlQUFlL1UsSUFBcEMsQ0FBSixFQUErQztZQUN2Q0ksV0FBVUgsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGVBQWUvVSxJQUFwQyxDQUFoQjtpQkFDUXlPLFNBQVIsQ0FBa0JFLEdBQWxCLENBQXNCM08sSUFBdEI7ZUFDT0ksUUFBUDs7O1VBR0lBLFVBQVVILE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixNQUFNL1UsSUFBM0IsS0FBb0NDLE9BQUtpVyxNQUFMLENBQVksTUFBTWxXLElBQWxCLENBQXBEO2NBQ1F5TyxTQUFSLENBQWtCRSxHQUFsQixDQUFzQixjQUFjM08sSUFBcEM7O2FBRU9JLE9BQVA7Ozs7MkJBMUY4QjthQUN2QixDQUFDLFVBQUQsRUFBYSxPQUFiLENBQVA7Ozs7RUFqQ3dDMi9DOztBQThINUM3a0MsWUFBWXFsRCxPQUFaLEdBQXNCSCxjQUF0QjtBQUNBcGlDLGVBQWVMLE1BQWYsQ0FBc0IsYUFBdEIsRUFBcUN5aUMsY0FBckM7O0FDek5BOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQVdBLElBQU10YixxQkFBbUIsTUFBekI7QUFDQSxJQUFNaDJDLFlBQVM7TUFDVCxTQURTO29CQUVLLGtCQUZMO3VCQUdRO0NBSHZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBbUVxQjB4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQWtETDs7Ozs7VUFHUEMsWUFBTDs7VUFFSzFjLGlCQUFMLEdBQXlCZSxrQkFBekI7VUFDS3IyQyxTQUFMLENBQWVFLEdBQWYsQ0FBbUJtMkMsa0JBQW5COztVQUVLeVksWUFBTCxHQUFvQixLQUFwQjs7d0JBRW1CLFlBQU07WUFDbEJoYSxRQUFMOztZQUVLM3hDLFFBQUwsR0FBZ0IsS0FBaEI7WUFDS3dGLGVBQUwsR0FBdUIsTUFBS21rRCxrQkFBTCxFQUF2QjtZQUNLbUYsa0JBQUwsR0FBMEIsTUFBS2xGLHFCQUFMLEVBQTFCO0tBTEY7Ozs7OzsrQkFTUzs7O2dCQUNDNXRELE9BQVYsQ0FBa0IsSUFBbEI7O1VBRU1rc0QsVUFBVTc1RCxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsYUFBckIsQ0FBaEI7O1VBRU11bEQsYUFBYXI2RCxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsbUJBQXJCLEtBQTZDOVUsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGFBQXJCLENBQTdDLElBQW9GeFYsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBdkc7aUJBQ1c2SCxTQUFYLENBQXFCRSxHQUFyQixDQUF5QixrQkFBekI7V0FDS3lLLFlBQUwsQ0FBa0JraEQsVUFBbEIsRUFBOEIsQ0FBQ1IsT0FBRCxJQUFZLEtBQUt6Z0QsVUFBakIsSUFBK0J5Z0QsV0FBV0EsUUFBUXJxQixXQUFoRjs7VUFFTWhuQyxVQUFVeEksT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGdCQUFyQixLQUEwQzlVLE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixVQUFyQixDQUExQyxJQUE4RXhWLFNBQVNxSCxhQUFULENBQXVCLEtBQXZCLENBQTlGO2NBQ1E2SCxTQUFSLENBQWtCRSxHQUFsQixDQUFzQixlQUF0QjtVQUNJLENBQUNsRyxRQUFRNlAsYUFBYixFQUE0QjtlQUNyQjFPLFNBQUwsQ0FBZSxLQUFLb0wsVUFBcEIsRUFBZ0N6VSxPQUFoQyxDQUF3QyxnQkFBUTtjQUMxQ3lSLEtBQUtpRCxRQUFMLEtBQWtCLENBQWxCLElBQXVCLE9BQUswckQscUJBQUwsQ0FBMkIzdUQsSUFBM0IsQ0FBM0IsRUFBNkQ7b0JBQ25EaEksV0FBUixDQUFvQmdJLElBQXBCLEVBRDJEOztTQUQvRDs7O1dBT0c0dUQsbUJBQUwsQ0FBeUJuNEQsT0FBekIsRUFuQlM7V0FvQkoyUSxZQUFMLENBQWtCM1EsT0FBbEIsRUFBMkI2eEQsV0FBVzdxQixXQUF0QyxFQXBCUzs7VUFzQkwsQ0FBQyxDQUFDcXFCLE9BQUQsSUFBWSxDQUFDNzVELE9BQUs0TSxXQUFMLENBQWlCaXRELE9BQWpCLEVBQTBCLGFBQTFCLENBQWQsS0FDQ3J4RCxRQUFRZ0osUUFBUixDQUFpQnZRLE1BQWpCLEtBQTRCLENBRDdCLElBRUNqQixPQUFLMFYsYUFBTCxDQUFtQmxOLFFBQVFnSixRQUFSLENBQWlCLENBQWpCLENBQW5CLENBRkwsRUFHRTthQUNLc3lDLGlCQUFMLElBQTBCLGdCQUExQjthQUNLblMsd0JBQUwsQ0FBOEIsT0FBOUI7OztVQUdJeW9CLGdCQUFnQnA2RCxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsb0JBQXJCLENBQXRCO1VBQ0lzbEQsYUFBSixFQUFtQjthQUNadFcsaUJBQUwsSUFBMEIsMkJBQTFCO2FBQ0tuUyx3QkFBTCxDQUE4QixPQUE5Qjs7O21CQUdXK1IsWUFBYixDQUEwQixJQUExQixFQUFnQzcwQyxTQUFoQzs7OzswQ0FHb0IvRSxJQUFJO1VBQ3BCQSxHQUFHMEUsU0FBSCxDQUFhNkcsUUFBYixDQUFzQixrQkFBdEIsQ0FBSixFQUErQztlQUN0QyxLQUFQOztVQUVJMUksVUFBVTdDLEdBQUc2QyxPQUFILENBQVc3SyxXQUFYLEVBQWhCO1VBQ0k2SyxZQUFZLFNBQWhCLEVBQTJCO2VBQ2xCLENBQUM3QyxHQUFHb0QsWUFBSCxDQUFnQixVQUFoQixDQUFSOztVQUVJMHpELGdCQUFnQixDQUFDLFFBQUQsRUFBVyxhQUFYLEVBQTBCLG9CQUExQixFQUFnRCxXQUFoRCxFQUE2RCxnQkFBN0QsRUFBK0UsWUFBL0UsRUFBNkYsa0JBQTdGLEVBQWlILGFBQWpILEVBQWdJLGtCQUFoSSxDQUF0QjthQUNPOTJELEdBQUdvRCxZQUFILENBQWdCLFFBQWhCLEtBQTZCMHpELGNBQWN6L0QsT0FBZCxDQUFzQndMLE9BQXRCLE1BQW1DLENBQUMsQ0FBeEU7Ozs7MENBR2tEOzs7VUFBaENuRSxPQUFnQyx1RUFBdEIsS0FBSzJPLGVBQWlCOztpQkFDekN0USxpQkFBVCxDQUEyQixZQUFNO2VBQzFCMlIsZUFBTCxTQUEyQixpQkFBM0IsRUFDRSxDQUFDeFksT0FBS2lQLFVBQUwsU0FBc0I7aUJBQUtuSCxFQUFFb0YsWUFBRixDQUFlLGlCQUFmLENBQUw7U0FBdEIsQ0FBRDtZQUNJLE9BQUtnSyxrQkFBTCxDQUF3QjFPLE9BQXhCLEtBQW9DLENBQUN4SSxPQUFLOFUsU0FBTCxDQUFldE0sT0FBZixFQUF3QnhJLE9BQUswVixhQUE3QixDQUR6QyxDQURGOztPQURGOzs7O3lDQVFpRDtVQUFoQ2xOLE9BQWdDLHVFQUF0QixLQUFLMk8sZUFBaUI7O1VBQzdDblgsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGFBQXJCLENBQUosRUFBeUM7ZUFDaEMsSUFBUDs7O2FBR0ssQ0FBQyxDQUFDOVUsT0FBSzhVLFNBQUwsQ0FBZXRNLE9BQWYsRUFBd0IsY0FBTTtlQUM5QnhJLE9BQUtILEtBQUwsQ0FBV2lLLEVBQVgsRUFBZSxhQUFmLEtBQWlDLENBQUNBLEdBQUdvRCxZQUFILENBQWdCLFFBQWhCLENBQXpDO09BRE8sQ0FBVDs7Ozt3Q0FLa0I7OztVQUNkLENBQUNsTixPQUFLb1YsVUFBTCxDQUFnQixJQUFoQixDQUFMLEVBQTRCOzs7OzttQkFJZixJQUFiLEVBQW1CLFlBQU07ZUFDbEJ1ckQsbUJBQUwsR0FEdUI7O1lBR25CLE9BQUt6ekQsWUFBTCxDQUFrQixvQkFBbEIsQ0FBSixFQUE2QztpQkFDdEN5a0Msd0JBQUwsQ0FBOEIsb0JBQTlCLEVBQW9ELElBQXBELEVBQTBELE9BQUt0d0MsWUFBTCxDQUFrQixvQkFBbEIsQ0FBMUQ7OztZQUdFLENBQUMsT0FBS2k4RCxZQUFWLEVBQXdCO2lCQUNqQkEsWUFBTCxHQUFvQixJQUFwQjs7dUJBRWEsWUFBTTttQkFDWnVELE1BQUwsSUFBZSxPQUFLQSxNQUFMLEVBQWY7bUJBQ0t4cEQsbUJBQUwsU0FBK0IsTUFBL0I7V0FGRjs7Y0FLSSxDQUFDclgsT0FBS3NWLHVCQUFMLFFBQUwsRUFBeUM7eUJBQzFCO3FCQUFNLE9BQUsrb0QsS0FBTCxFQUFOO2FBQWI7OztPQWhCTjs7OztxQ0FzQmVudUMsTUFBTTtVQUNqQixLQUFLNHdDLFVBQVQsRUFBcUI7ZUFDWixLQUFLQSxVQUFMLENBQWdCNXdDLElBQWhCLEVBQVAsR0FBZ0MsS0FBSzR3QyxVQUFMLENBQWdCbHhDLElBQWhCLEVBQWhDOzs7OztnQ0EyQ1E7OztVQUNKMXFCLElBQUksS0FBS2lTLGVBQWY7VUFDRTRwRCxZQUFZLENBQUM3N0QsRUFBRXUyQixTQUFGLEdBQWN2MkIsRUFBRTY4QyxZQUFqQixJQUFpQzc4QyxFQUFFcTJCLFlBQW5DLElBQW1ELEtBQUt5bEMsb0JBRHRFOztVQUdJLEtBQUtDLGlCQUFMLElBQTBCLENBQUMsS0FBS0MsZUFBaEMsSUFBbURILFNBQXZELEVBQWtFO2FBQzNERyxlQUFMLEdBQXVCLElBQXZCO2FBQ0tELGlCQUFMLENBQXVCO2lCQUFNLE9BQUtDLGVBQUwsR0FBdUIsS0FBN0I7U0FBdkI7Ozs7Ozs7Ozs7Ozs7O3lDQStCaUI7VUFDYmwvRCxTQUFTaEMsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGdCQUFyQixDQUFmO1VBQ0k5UyxNQUFKLEVBQVk7ZUFDSEEsTUFBUDs7YUFFRzBDLEtBQUwsQ0FBVyxzQ0FBWDs7Ozs0Q0FHc0I7VUFDaEIxQyxTQUFTaEMsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLG1CQUFyQixDQUFmO1VBQ0k5UyxNQUFKLEVBQVk7ZUFDSEEsTUFBUDs7YUFFRzBDLEtBQUwsQ0FBVyx5Q0FBWDs7OzsrQ0FHeUI7YUFDbEIxRSxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsb0JBQXJCLEtBQThDdE8sV0FBU0UsV0FBOUQ7Ozs7eUNBR21CO2FBQ1oxRyxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsYUFBckIsS0FBdUN4VixTQUFTcUgsYUFBVCxDQUF1QixhQUF2QixDQUE5Qzs7Ozs2Q0FPdUI1RyxNQUFNa08sTUFBTUMsU0FBUzs7O2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCLEtBQUs4ckMsaUJBQTdCLEVBQWdEajFDLFNBQWhEOzthQUVHLFVBQUw7dUJBQ2VvMEMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxTQUFwRDs7YUFFRyxvQkFBTDtjQUNNWCxZQUFZLElBQWhCLEVBQXNCO2lCQUNmaXpELGdCQUFMLEdBQXdCLElBQXhCO1dBREYsTUFFTztpQkFDQUEsZ0JBQUwsR0FBd0IsVUFBQzVqRCxJQUFELEVBQVU7a0JBQzFCekUsSUFBSTlZLE9BQUs0VyxZQUFMLENBQWtCMUksT0FBbEIsQ0FBVjtxQkFDS2l6RCxnQkFBTCxHQUF3QnJvRCxDQUF4QjtnQkFDRXlFLElBQUY7YUFIRjs7Ozs7Ozs0QkFVQTtVQUNGLENBQUMsS0FBSzVMLFFBQU4sSUFBa0IzUixPQUFLb1YsVUFBTCxDQUFnQixJQUFoQixDQUF0QixFQUE2QzthQUN0Q3pELFFBQUwsR0FBZ0IsSUFBaEI7YUFDSzNFLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkIsRUFBM0I7YUFDS2ltQixNQUFMLElBQWUsS0FBS0EsTUFBTCxFQUFmO2VBQ0s1YixtQkFBTCxDQUF5QixJQUF6QixFQUErQixNQUEvQjtlQUNLMUIsZUFBTCxDQUFxQixJQUFyQixFQUEyQixPQUEzQjs7Ozs7NEJBSUk7VUFDRixLQUFLaEUsUUFBVCxFQUFtQjthQUNaQSxRQUFMLEdBQWdCLEtBQWhCO2FBQ0tyUSxlQUFMLENBQXFCLE9BQXJCO2FBQ0s0eEIsTUFBTCxJQUFlLEtBQUtBLE1BQUwsRUFBZjtlQUNLN2IsbUJBQUwsQ0FBeUIsSUFBekIsRUFBK0IsTUFBL0I7ZUFDSzFCLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsT0FBM0I7Ozs7OytCQUlPO1dBQ0pxcEQsS0FBTDs7V0FFS29DLFNBQUwsSUFBa0IsS0FBS0EsU0FBTCxFQUFsQjthQUNLL3BELG1CQUFMLENBQXlCLElBQXpCLEVBQStCLFNBQS9COztVQUVJLEtBQUswckMsa0JBQVQsRUFBNkI7YUFDdEJBLGtCQUFMLENBQXdCMXpCLE9BQXhCOzs7YUFHRzFaLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsVUFBM0I7O1dBRUsvRyxNQUFMOzs7O21DQUdhOzs7V0FDUjIyQixXQUFMLENBQWlCODdCLE1BQWpCLENBQXdCL2dFLE9BQXhCLENBQWdDLGlCQUFTO1lBQ2pDQyxNQUFNLE9BQU9tUSxNQUFNcEwsTUFBTixDQUFhLENBQWIsRUFBZ0IwUSxXQUFoQixFQUFQLEdBQXVDdEYsTUFBTWhSLEtBQU4sQ0FBWSxDQUFaLENBQW5EO2VBQ08wVSxjQUFQLFNBQTRCN1QsR0FBNUIsRUFBaUM7d0JBQ2pCLElBRGlCO3NCQUVuQixJQUZtQjtlQUcxQjttQkFBTSxhQUFTQSxHQUFULENBQU47V0FIMEI7ZUFJMUIsdUJBQVM7Z0JBQ1IsRUFBRXNFLGlCQUFpQmtNLFFBQW5CLENBQUosRUFBa0M7cUJBQzNCck0sS0FBTCxPQUFlbkUsR0FBZjs7eUJBRU9BLEdBQVQsSUFBa0JzRSxNQUFNa0IsSUFBTixRQUFsQjs7U0FSSjtPQUZGOzs7O3lCQWxLT3FWLEtBQUs7V0FDUHBPLFlBQUwsQ0FBa0IsTUFBbEIsRUFBMEJvTyxHQUExQjs7MkJBR1M7YUFDRixLQUFLL1osWUFBTCxDQUFrQixNQUFsQixDQUFQOzs7OzJCQUdlO2FBQ1IsS0FBS3FHLGFBQUwsQ0FBbUIsaUJBQW5CLENBQVA7Ozs7Ozs7Ozs7Ozt5QkFTbUI3QyxPQUFPOzs7VUFDdEJBLFNBQVMsRUFBRUEsaUJBQWlCa00sUUFBbkIsQ0FBYixFQUEyQztlQUNwQ3JNLEtBQUwsQ0FBVyw2Q0FBWDs7O21CQUdXLElBQWIsRUFBbUIsWUFBTTtZQUNuQixDQUFDRyxLQUFMLEVBQVk7aUJBQ0xzUyxlQUFMLENBQXFCalEsbUJBQXJCLENBQXlDLFFBQXpDLEVBQW1ELE9BQUtvNkQsY0FBeEQ7U0FERixNQUVPLElBQUksQ0FBQyxPQUFLTCxpQkFBVixFQUE2QjtpQkFDN0JELG9CQUFMLEdBQTRCLEdBQTVCO2lCQUNLTSxjQUFMLEdBQXNCLE9BQUtDLFNBQUwsQ0FBZXg3RCxJQUFmLFFBQXRCO3VCQUNhO21CQUFNLE9BQUtvUixlQUFMLENBQXFCaFEsZ0JBQXJCLENBQXNDLFFBQXRDLEVBQWdELE9BQUttNkQsY0FBckQsQ0FBTjtXQUFiOztlQUVHTCxpQkFBTCxHQUF5QnA4RCxLQUF6QjtPQVJGOzsyQkFZcUI7YUFDZCxLQUFLbzhELGlCQUFaOzs7OzJCQW9CdUI7YUFDaEIsS0FBS2plLGtCQUFaOzt5QkFHcUI1N0MsVUFBVTtVQUMzQixLQUFLNDdDLGtCQUFULEVBQTZCO2FBQ3RCQSxrQkFBTCxDQUF3QjN6QixPQUF4Qjs7O1dBR0cyekIsa0JBQUwsR0FBMEJ4d0MsMkJBQTJCaXRDLGFBQTNCLENBQXlDLElBQXpDLEVBQStDcjRDLFFBQS9DLENBQTFCOzs7OzJCQUdjO2FBQ1AsS0FBSytQLGVBQUwsQ0FBcUJza0IsU0FBNUI7O3lCQUdZc1csVUFBVTtXQUNqQjU2QixlQUFMLENBQXFCc2tCLFNBQXJCLEdBQWlDc1csUUFBakM7Ozs7MkJBMkI4QjthQUN2QixDQUFDLFVBQUQsRUFBYSxvQkFBYixFQUFtQyxPQUFuQyxDQUFQOzs7OzJCQTZFa0I7YUFDWCxDQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLE1BQWpCLEVBQXlCLFNBQXpCLENBQVA7Ozs7Ozs7Ozs7Ozs7RUEvVnFDK047O0FBMld6QzdrQyxZQUFZdW1ELElBQVosR0FBbUJqQixXQUFuQjtBQUNBeGlDLGVBQWVMLE1BQWYsQ0FBc0IsVUFBdEIsRUFBa0M2aUMsV0FBbEM7O0FDNWNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLElBSWFrQixlQUFiOzs7Ozs7Ozs7NkJBUXdGO21GQUFKLEVBQUk7MkJBQXpFam1ELE1BQXlFO1FBQXpFQSxNQUF5RSwrQkFBaEUsNkJBQWdFOzBCQUFqQ3JQLEtBQWlDO1FBQWpDQSxLQUFpQyw4QkFBekIsQ0FBeUI7NkJBQXRCRCxRQUFzQjtRQUF0QkEsUUFBc0IsaUNBQVgsR0FBVzs7OzRIQUM5RSxFQUFFc1AsY0FBRixFQUFVclAsWUFBVixFQUFpQkQsa0JBQWpCLEVBRDhFOzs7Ozt5QkFJakZ3MUQsT0FaUCxFQVlnQnQ2RCxRQVpoQixFQVkwQjs7Ozs7eUJBSW5CczZELE9BaEJQLEVBZ0JnQnQ2RCxRQWhCaEIsRUFnQjBCOzs7Ozs2QkFJZmpILE9BcEJYLFNBb0IrRTtVQUExRHFWLElBQTBELFNBQTFEQSxJQUEwRDtVQUFwRGlJLEVBQW9ELFNBQXBEQSxFQUFvRDtVQUFoRGhTLE9BQWdELFNBQWhEQSxPQUFnRDtVQUF2Q3JFLFFBQXVDLFNBQXZDQSxRQUF1QztnQ0FBN0J1ekQsT0FBNkI7VUFBN0JBLE9BQTZCLGlDQUFuQixLQUFtQjtVQUFaL3VELFNBQVksU0FBWkEsU0FBWTs7Z0JBQ2pFNUwsT0FBSytMLE1BQUwsQ0FBWSxFQUFaLEVBQWdCLEtBQUtOLE9BQXJCLEVBQThCQSxPQUE5QixDQUFWOztVQUVJRyxTQUFKLEVBQWU7ZUFDTkEsVUFBVTRKLElBQWpCO2FBQ0s1SixVQUFVNlIsRUFBZjs7O2tCQUdVOGpDLE9BQU9waEQsT0FBUCxDQUFaO1VBQ0l3NkQsT0FBSixFQUFhO29CQUNDL3VELFVBQVVnUyxTQUFWLEVBQVo7O2tCQUVVaFMsVUFBVWlTLEtBQVYsQ0FBZ0JySSxJQUFoQixFQUFzQnNJLElBQXRCLENBQTJCLEtBQUszUixLQUFoQyxFQUF1QzBSLEtBQXZDLENBQTZDO2FBQ2xESixFQURrRDtrQkFFN0MsS0FBS3ZSLFFBRndDO2dCQUcvQyxLQUFLc1A7T0FISCxDQUFaO1VBS0ltL0MsT0FBSixFQUFhO29CQUNDL3VELFVBQVVtUyxZQUFWLEVBQVo7O1VBRUUzVyxRQUFKLEVBQWM7b0JBQ0F3RSxVQUFVaVMsS0FBVixDQUFnQixVQUFDTixJQUFELEVBQVU7OztTQUExQixDQUFaOzthQUtLM1IsU0FBUDs7OztnQ0FHVXpMLE9BakRkLEVBaUR1QndoRSxVQWpEdkIsRUFpRG1DOzs7YUFDeEJ0aEUsSUFBUCxDQUFZc2hFLFVBQVosRUFBd0JyaEUsT0FBeEIsQ0FBZ0M7ZUFBTyxPQUFLc2hFLFFBQUwsQ0FBY3poRSxRQUFRSSxHQUFSLENBQWQsRUFBNEJvaEUsV0FBV3BoRSxHQUFYLENBQTVCLEVBQTZDMGUsSUFBN0MsRUFBUDtPQUFoQzs7OztFQWxEaUN1aEMsWUFBckM7O0FBdURBLElBQU1xaEIsT0FBTztPQUNOO1VBQ0csRUFBQ3BnQixTQUFTLEdBQVYsRUFESDtRQUVDLEVBQUNBLFNBQVMsQ0FBVjtHQUhLO01BS1A7VUFDSSxFQUFDQSxTQUFTLENBQVYsRUFESjtRQUVFLEVBQUNBLFNBQVMsR0FBVjs7Q0FQUjs7QUFXQSxJQUFhcWdCLHFCQUFiOzs7Ozs7Ozs7O3lCQUNPSixPQURQLEVBQ2dCdDZELFFBRGhCLEVBQzBCO1dBQ2pCMjZELFdBQUwsQ0FBaUJMLE9BQWpCLEVBQTBCO2VBQ2pCRyxLQUFLRyxFQURZO2tCQUVkLEVBQUNwMkQsV0FBV2kyRCxLQUFLRyxFQUFqQixFQUFxQnJILFNBQVMsSUFBOUIsRUFBb0N2ekQsa0JBQXBDO09BRlo7Ozs7eUJBTUdzNkQsT0FSUCxFQVFnQnQ2RCxRQVJoQixFQVEwQjtXQUNqQjI2RCxXQUFMLENBQWlCTCxPQUFqQixFQUEwQjtlQUNqQkcsS0FBSzlnQyxHQURZO2tCQUVkLEVBQUNuMUIsV0FBV2kyRCxLQUFLOWdDLEdBQWpCLEVBQXNCNDVCLFNBQVMsSUFBL0IsRUFBcUN2ekQsa0JBQXJDO09BRlo7Ozs7RUFUdUNxNkQsZUFBM0M7O0FBZ0JBLElBQWFRLHNCQUFiOzs7Ozs7Ozs7O3lCQUNPUCxPQURQLEVBQ2dCdDZELFFBRGhCLEVBQzBCO1dBQ2pCMjZELFdBQUwsQ0FBaUJMLE9BQWpCLEVBQTBCO2VBQ2pCRyxLQUFLRyxFQURZO2tCQUVkO2dCQUNGO3VCQUNPLHdCQURQO3FCQUVLO1dBSEg7Y0FLSjt1QkFDUyx5QkFEVDtxQkFFTztXQVBIO21CQVNDLElBVEQ7OztPQUZaOzs7O0VBRndDRixxQkFBNUM7O0FDdEdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQVdBLElBQU1qekQsWUFBUztjQUNELFlBREM7bUJBRUksaUJBRko7dUJBR1EscUJBSFI7cUJBSU07Q0FKckI7O0FBT0EsSUFBTXUwQyxrQkFBZ0I7YUFDVDtXQUFNeGhELFNBQVN5QyxTQUFULEtBQXVCeTlELHFCQUF2QixHQUErQ0csc0JBQXJEO0dBRFM7VUFFWlIsZUFGWTtjQUdSUSxzQkFIUTthQUlUSDtDQUpiOztBQU9BLElBQU1JLFlBQVk7TUFDWixRQURZO1FBRVYsT0FGVTtRQUdWLEtBSFU7U0FJVDtDQUpUOztBQU9BLEFBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBK0JxQkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkFpSEw7Ozs7O1VBR1AzUCxjQUFMLEdBQXNCLE1BQUtqRyxTQUFMLENBQWV4bUQsSUFBZixPQUF0Qjs7d0JBRW1CLFlBQU07WUFDbEJ1OUMsUUFBTDtZQUNLbGpELEtBQUwsQ0FBV3NSLE9BQVgsR0FBcUIsTUFBckI7S0FGRjs7Ozs7OzZDQTBCdUI7YUFDaEIsSUFBSTdHLGVBQUosQ0FBb0I7bUJBQ2R1NEMsZUFEYzttQkFFZHFlLGVBRmM7dUJBR1YsaUJBSFU7MEJBSVAsS0FBS3BnRSxZQUFMLENBQWtCLFdBQWxCLEtBQWtDO09BSi9DLENBQVA7Ozs7aUNBUVc0Z0QsWUFBMEI7VUFBZHgyQyxPQUFjLHVFQUFKLEVBQUk7O1VBQ2pDdzJDLFVBQUosRUFBZ0I7YUFDVDdoRCxLQUFMLENBQVdzUixPQUFYLEdBQXFCLE9BQXJCO2FBQ0swd0QsY0FBTCxHQUFzQjMyRCxRQUFRMUQsTUFBOUI7YUFDS3M2RCxnQkFBTCxDQUFzQjUyRCxRQUFRMUQsTUFBOUI7T0FIRixNQUlPO2FBQ0EzSCxLQUFMLENBQVdzUixPQUFYLEdBQXFCLE1BQXJCO2FBQ0s0d0QsWUFBTDs7Ozs7cUNBSWF2NkQsUUFBUTtVQUNQdzZELE1BRE8sR0FDOEMsSUFEOUMsQ0FDaEJDLE9BRGdCO1VBQ1dDLGNBRFgsR0FDOEMsSUFEOUMsQ0FDQ0MsUUFERDtVQUNvQ0MsTUFEcEMsR0FDOEMsSUFEOUMsQ0FDMkJDLE9BRDNCOztVQUVqQjVoQixrQkFBa0JKLGFBQWFHLGtCQUFiLEVBQXhCO1VBQ01HLGVBQWVOLGFBQWFLLGtCQUFiLEVBQXJCO1VBQ000aEIsYUFBYTk2RCxPQUFPMnBELHFCQUFQLEVBQW5CO1VBQ01vUixPQUFPOWlFLE9BQUs0TSxXQUFMLENBQWlCLElBQWpCLEVBQXVCLFVBQXZCLENBQWI7VUFDTW0yRCxRQUFRRCxRQUFRLEtBQUs1MUQsWUFBTCxDQUFrQixjQUFsQixDQUF0QjtVQUNNaUMsU0FBU25QLE9BQUtpUCxVQUFMLENBQWdCLElBQWhCLEVBQXNCLFVBQXRCLEtBQXFDM1AsU0FBU21JLElBQTdEO1VBQ011N0QsbUJBQW1CN3pELE9BQU91aUQscUJBQVAsRUFBekI7VUFDTXVSLGVBQWU7YUFDZDFwRCxLQUFLbUosR0FBTCxDQUFTc2dELGlCQUFpQm5tQyxHQUExQixFQUErQnFrQixhQUFhcmtCLEdBQTVDLENBRGM7Y0FFYnRqQixLQUFLbUosR0FBTCxDQUFTc2dELGlCQUFpQi93RCxJQUExQixFQUFnQ2l2QyxhQUFhanZDLElBQTdDLENBRmE7Z0JBR1hzSCxLQUFLa0osR0FBTCxDQUFTdWdELGlCQUFpQkUsTUFBMUIsRUFBa0NoaUIsYUFBYWdpQixNQUEvQyxDQUhXO2VBSVozcEQsS0FBS2tKLEdBQUwsQ0FBU3VnRCxpQkFBaUI5d0QsS0FBMUIsRUFBaUNndkMsYUFBYWh2QyxLQUE5QztPQUpUOzs7VUFRTWl4RCxpQkFBaUI7YUFDaEJOLFdBQVdobUMsR0FBWCxJQUFrQm9tQyxhQUFhcG1DLEdBQWIsR0FBbUI4bEMsTUFBckMsQ0FEZ0I7Y0FFZkUsV0FBVzV3RCxJQUFYLElBQW1CZ3hELGFBQWFoeEQsSUFBYixHQUFvQjB3RCxNQUF2QyxDQUZlO2dCQUdaTSxhQUFhQyxNQUFiLEdBQXNCUCxNQUF2QixHQUFpQ0UsV0FBV0ssTUFIL0I7ZUFJYkQsYUFBYS93RCxLQUFiLEdBQXFCeXdELE1BQXRCLEdBQWdDRSxXQUFXM3dEO09BSnBEOzs7VUFRTWt4RCwyQkFBMkI7YUFDMUJQLFdBQVdobUMsR0FBWCxHQUFpQnRqQixLQUFLcXVDLEtBQUwsQ0FBV2liLFdBQVdqZ0UsTUFBWCxHQUFvQixDQUEvQixDQUFqQixJQUFzRHFnRSxhQUFhcG1DLEdBQWIsR0FBbUI4bEMsTUFBekUsQ0FEMEI7Y0FFekJFLFdBQVc1d0QsSUFBWCxHQUFrQnNILEtBQUtxdUMsS0FBTCxDQUFXaWIsV0FBV2xnRSxLQUFYLEdBQW1CLENBQTlCLENBQWxCLElBQXNEc2dFLGFBQWFoeEQsSUFBYixHQUFvQjB3RCxNQUExRSxDQUZ5QjtnQkFHdEJNLGFBQWFDLE1BQWIsR0FBc0JQLE1BQXZCLEdBQWlDRSxXQUFXSyxNQUE1QyxHQUFxRDNwRCxLQUFLcXVDLEtBQUwsQ0FBV2liLFdBQVdqZ0UsTUFBWCxHQUFvQixDQUEvQixDQUg5QjtlQUl2QnFnRSxhQUFhL3dELEtBQWIsR0FBcUJ5d0QsTUFBdEIsR0FBZ0NFLFdBQVczd0QsS0FBM0MsR0FBbURxSCxLQUFLcXVDLEtBQUwsQ0FBV2liLFdBQVdsZ0UsS0FBWCxHQUFtQixDQUE5QjtPQUo1RDs7a0NBTzZFLEtBQUswZ0Usb0JBQUwsQ0FBMEJGLGNBQTFCLENBaEN0RDtVQWdDaEJqWCxRQWhDZ0IseUJBZ0NoQkEsUUFoQ2dCO1VBZ0NHb1gsZ0JBaENILHlCQWdDTkMsT0FoQ007VUFnQ2dDQyxrQkFoQ2hDLHlCQWdDcUJDLFNBaENyQjs7V0FpQ2xCQyxpQkFBTCxHQUF5QkosZ0JBQXpCO2FBQ0tqMkQsV0FBTCxDQUFpQixJQUFqQixFQUF1QmkyRCxnQkFBdkI7O1VBRU1LLFdBQVd6WCxXQUFXLE9BQVgsR0FBcUIsUUFBdEM7O1VBRU0wWCxjQUFlO2VBQVU7aUJBQ3RCN2dFLFNBQVMzQyxNQUFNa1ksZ0JBQU4sQ0FBdUIsT0FBdkIsQ0FBVCxFQUEwQyxFQUExQyxDQURzQjtrQkFFckJ2VixTQUFTM0MsTUFBTWtZLGdCQUFOLENBQXVCLFFBQXZCLENBQVQsRUFBMkMsRUFBM0M7U0FGVztPQUFELENBR2hCbFosT0FBT0MsZ0JBQVAsQ0FBd0JvakUsY0FBeEIsQ0FIZ0IsQ0FBcEI7OztVQU1Nb0IsdUJBQXVCZCxRQUFRLENBQVIsR0FBWSxDQUFDN1csV0FBVzJXLFdBQVdqZ0UsTUFBdEIsR0FBK0JpZ0UsV0FBV2xnRSxLQUEzQyxLQUFxRG1nRSxPQUFPLENBQVAsR0FBVyxFQUFoRSxDQUF6QztVQUNNZ0IsZ0JBQWdCdnFELEtBQUttSixHQUFMLENBQ3BCcytCLGdCQUFnQnNpQixnQkFBaEIsSUFBb0NYLE1BRGhCLEVBRXBCM2hCLGdCQUFnQnNpQixnQkFBaEIsSUFBb0NYLE1BQXBDLEdBQTZDUSxlQUFlRyxnQkFBZixDQUE3QyxHQUFnRk8sb0JBRjVELENBQXRCO1VBSU1FLGtCQUFrQnhxRCxLQUFLbUosR0FBTCxDQUN0QnMrQixnQkFBZ0J3aUIsa0JBQWhCLElBQXNDYixNQURoQixFQUV0QjNoQixnQkFBZ0J3aUIsa0JBQWhCLElBQXNDYixNQUF0QyxHQUErQ1MseUJBQXlCSSxrQkFBekIsQ0FBL0MsR0FBK0ZJLFlBQVlELFFBQVosSUFBd0IsQ0FGakcsQ0FBeEI7V0FJS0ssUUFBTCxDQUFjNWpFLEtBQWQsQ0FBb0JrakUsZ0JBQXBCLElBQXdDUSxnQkFBZ0IsSUFBeEQ7V0FDS0UsUUFBTCxDQUFjNWpFLEtBQWQsQ0FBb0JvakUsa0JBQXBCLElBQTBDTyxrQkFBa0IsSUFBNUQ7OztXQUdLRSxNQUFMLENBQVk3akUsS0FBWixDQUFrQm9qRSxrQkFBbEIsSUFBd0NqcUQsS0FBS21KLEdBQUwsQ0FDdEM2L0MsTUFEc0MsRUFFckN2aEIsZ0JBQWdCd2lCLGtCQUFoQixJQUFzQ2IsTUFBdkMsR0FBaURTLHlCQUF5Qkksa0JBQXpCLENBQWpELEdBQWdHTyxlQUYxRCxJQUdwQyxJQUhKOzs7O3lDQU1tQmxwRCxVQUFVO1VBQ3ZCcFAsVUFBVSxDQUFDLEtBQUtwSyxZQUFMLENBQWtCLFdBQWxCLEtBQWtDLG9CQUFuQyxFQUF5RFYsS0FBekQsQ0FBK0QsS0FBL0QsRUFBc0VrRixHQUF0RSxDQUEwRTtlQUFLcThELFVBQVVwNkQsQ0FBVixDQUFMO09BQTFFLENBQWhCO1VBQ015N0QsVUFBVTkzRCxRQUFRMGQsSUFBUixDQUFhLFVBQUNsTixDQUFELEVBQUltTixDQUFKO2VBQVV2TyxTQUFTb0IsQ0FBVCxJQUFjcEIsU0FBU3VPLENBQVQsQ0FBeEI7T0FBYixFQUFrRCxDQUFsRCxDQUFoQjtVQUNNOGlDLFdBQVcsU0FBU3FYLE9BQVQsSUFBb0IsWUFBWUEsT0FBakQ7VUFDSUUsa0JBQUo7O1VBRUl2WCxRQUFKLEVBQWM7b0JBQ0FyeEMsU0FBUzVJLElBQVQsR0FBZ0I0SSxTQUFTM0ksS0FBekIsR0FBaUMsTUFBakMsR0FBMEMsT0FBdEQ7T0FERixNQUVPO29CQUNPMkksU0FBU2dpQixHQUFULEdBQWVoaUIsU0FBU3FvRCxNQUF4QixHQUFpQyxLQUFqQyxHQUF5QyxRQUFyRDs7O2FBR0ssRUFBQ2hYLGtCQUFELEVBQVdxWCxnQkFBWCxFQUFvQkUsb0JBQXBCLEVBQVA7Ozs7bUNBR2E7OztXQUNSQyxpQkFBTCxHQUF5QixJQUF6QjtPQUNDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLE1BQWxCLEVBQTBCLE9BQTFCLEVBQW1DcGpFLE9BQW5DLENBQTJDLGFBQUs7ZUFDekMyakUsTUFBTCxDQUFZN2pFLEtBQVosQ0FBa0IwSCxDQUFsQixJQUF1QixPQUFLNDZELFFBQUwsQ0FBY3RpRSxLQUFkLENBQW9CMEgsQ0FBcEIsSUFBeUIsT0FBS2s4RCxRQUFMLENBQWM1akUsS0FBZCxDQUFvQjBILENBQXBCLElBQXlCLEVBQXpFO2VBQ0tzRixjQUFMLFNBQTBCdEYsQ0FBMUI7T0FGRjs7OztnQ0FNVTs7O21CQUNHLFlBQU07WUFDYixPQUFLczZELGNBQVQsRUFBeUI7aUJBQ2xCQyxnQkFBTCxDQUFzQixPQUFLRCxjQUEzQjs7T0FGSjs7OzsrQkFPUztnQkFDQ3owRCxPQUFWLENBQWtCLElBQWxCOztVQUVJLEtBQUtxMkQsUUFBTCxJQUFpQixLQUFLeGlCLEtBQTFCLEVBQWlDOzs7O1VBSTNCMGlCLHNCQUFzQixLQUFLRixRQUFMLElBQWlCLEtBQUt0QixRQUFsRDs7VUFFSXdCLG1CQUFKLEVBQXlCOztZQUVuQixDQUFDLEtBQUsxaUIsS0FBVixFQUFpQjtjQUNUaUMsT0FBT25rRCxTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFiO2VBQ0s2SCxTQUFMLENBQWVFLEdBQWYsQ0FBbUIsY0FBbkI7ZUFDS3lLLFlBQUwsQ0FBa0JzcUMsSUFBbEIsRUFBd0IsS0FBS3JxQyxVQUE3Qjs7O1lBR0UsQ0FBQyxLQUFLNnFELE1BQVYsRUFBa0I7Y0FDVkUsUUFBUTdrRSxTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFkO2dCQUNNNkgsU0FBTixDQUFnQkUsR0FBaEIsQ0FBb0IsZ0JBQXBCO2VBQ0tzMUQsUUFBTCxDQUFjajZELFdBQWQsQ0FBMEJvNkQsS0FBMUI7O09BWEosTUFjTzs7WUFFQ3Q4RCxXQUFXN0gsT0FBSzBKLGNBQUwsbU1BQWpCO1lBT01sQixVQUFVWCxTQUFTSCxhQUFULENBQXVCLG1CQUF2QixDQUFoQjs7ZUFFTyxLQUFLcU4sVUFBTCxDQUFnQixDQUFoQixDQUFQLEVBQTJCO2tCQUNqQmhMLFdBQVIsQ0FBb0IsS0FBS2dMLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBcEI7OzthQUdHaEwsV0FBTCxDQUFpQmxDLFFBQWpCOzs7O1VBSUUsS0FBS3FGLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBSixFQUFnQzthQUN6QjgyRCxRQUFMLENBQWNoM0QsWUFBZCxDQUEyQixPQUEzQixFQUFvQyxLQUFLM0wsWUFBTCxDQUFrQixPQUFsQixDQUFwQzthQUNLQyxlQUFMLENBQXFCLE9BQXJCOzs7bUJBR1dvaUQsWUFBYixDQUEwQixJQUExQixFQUFnQyxLQUFLUixPQUFyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkE0QkduN0MsUUFBc0I7VUFBZDBELE9BQWMsdUVBQUosRUFBSTs7O1VBRXJCMUQsVUFBVSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQTVCLElBQXdDLEVBQUVBLGtCQUFrQnNYLEtBQXBCLENBQXhDLElBQXNFLEVBQUV0WCxrQkFBa0J2RyxXQUFwQixDQUExRSxFQUE0RzsrQkFDM0Z1RyxNQUFmO09BREYsTUFFTzsrQkFDVTBELE9BQWYsSUFBd0IxRCxjQUF4Qjs7O1VBR0UsT0FBTzBELFFBQVExRCxNQUFmLEtBQTBCLFFBQTlCLEVBQXdDO2dCQUM5QkEsTUFBUixHQUFpQnpJLFNBQVNvSSxhQUFULENBQXVCK0QsUUFBUTFELE1BQS9CLENBQWpCO09BREYsTUFFTyxJQUFJMEQsUUFBUTFELE1BQVIsWUFBMEJzWCxLQUE5QixFQUFxQztnQkFDbEN0WCxNQUFSLEdBQWlCMEQsUUFBUTFELE1BQVIsQ0FBZUEsTUFBaEM7OztVQUdFLEVBQUUwRCxRQUFRMUQsTUFBUixZQUEwQnZHLFdBQTVCLENBQUosRUFBOEM7ZUFDeENrRCxLQUFMLENBQVcsa0NBQVg7OztpSUFHaUIrRyxPQUFsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQXVEa0I7Ozs7O2FBR1h0RSxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxLQUFLcXJELGNBQXZDLEVBQXVELEtBQXZEO1dBQ0tvUSxPQUFMLEdBQWUsS0FBS0EsT0FBTCxJQUFnQjcvRCxTQUFTM0QsT0FBT0MsZ0JBQVAsQ0FBd0IsSUFBeEIsRUFBOEJpWixnQkFBOUIsQ0FBK0MsS0FBL0MsQ0FBVCxDQUEvQjtXQUNLc3FELE9BQUwsR0FBZSxLQUFLQSxPQUFMLElBQWdCLENBQS9CLENBTGtCOzttQkFPTCxJQUFiLEVBQW1CLFlBQU07ZUFDbEJKLE9BQUwsR0FBZXovRCxTQUFTM0QsT0FBT0MsZ0JBQVAsQ0FBd0IsT0FBS3FqRSxRQUE3QixFQUF1Q3BxRCxnQkFBdkMsQ0FBd0Qsd0JBQXhELENBQVQsQ0FBZjtPQURGOzs7OzJDQUtxQjs7YUFFZHBSLG1CQUFQLENBQTJCLFFBQTNCLEVBQXFDLEtBQUtzckQsY0FBMUMsRUFBMEQsS0FBMUQ7Ozs7NkNBT3VCenlELE1BQU1rTyxNQUFNQyxTQUFTO1VBQ3hDbk8sU0FBUyxXQUFiLEVBQTBCO2VBQ2pCLEtBQUt5eUQsY0FBTCxFQUFQO09BREYsTUFFTyxJQUFJenlELFNBQVMsVUFBYixFQUF5QjthQUN6QjJqRSxpQkFBTCxJQUEwQjFqRSxPQUFLcU4sV0FBTCxDQUFpQixJQUFqQixFQUF1QixLQUFLcTJELGlCQUE1QixDQUExQjs7OElBRTZCM2pFLElBQS9CLEVBQXFDa08sSUFBckMsRUFBMkNDLE9BQTNDOzs7Ozs7Ozs7OzJCQXJUWTthQUNMVyxTQUFQOzs7OzJCQUdVO2FBQ0g3TyxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsZUFBckIsQ0FBUDs7OzsyQkFHYTthQUNOOVUsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLFVBQXJCLENBQVA7Ozs7MkJBR2E7YUFDTjlVLE9BQUs4VSxTQUFMLENBQWUsS0FBS2t2RCxRQUFwQixFQUE4QixtQkFBOUIsQ0FBUDs7OzsyQkFHVzthQUNKaGtFLE9BQUs4VSxTQUFMLENBQWUsS0FBS2t2RCxRQUFwQixFQUE4QixpQkFBOUIsQ0FBUDs7OztxQ0EyU3NCamtFLE1BQU04TCxVQUFVO1VBQ2xDLEVBQUVBLFNBQVNwTSxTQUFULFlBQThCZ2lFLGVBQWhDLENBQUosRUFBc0Q7ZUFDL0N6bkQsYUFBTCxDQUFtQixTQUFuQjs7c0JBRVlqYSxJQUFkLElBQXNCOEwsUUFBdEI7Ozs7MkJBckI4QjsrSUFDTyxXQUFyQzs7OzsyQkF1QnFCO2FBQ2R1M0MsZUFBUDs7OzsyQkFHMkI7YUFDcEJxZSxlQUFQOzs7O0VBcGN3Q3pmOztBQXdjNUMvbUMsWUFBWW1wRCxPQUFaLEdBQXNCakMsY0FBdEI7QUFDQXBrQyxlQUFlTCxNQUFmLENBQXNCLGFBQXRCLEVBQXFDeWtDLGNBQXJDOztBQzFoQkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBT0EsSUFBTXR6RCxZQUFTO21CQUNJLGlCQURKOzRCQUVhLDBCQUZiOzhCQUdlO0NBSDlCOztBQU1BLElBQU1oSCxXQUFXN0gsT0FBSzJHLGFBQUwsOElBQWpCOztBQU9BLElBQU0wOUQsUUFBUSxlQUFkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTRCcUJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dDQWlDTDs7Ozs7d0JBR087YUFBTSxNQUFLaGhCLFFBQUwsRUFBTjtLQUFuQjs7Ozs7OytCQUdTO1VBQ0wsQ0FBQyxLQUFLaWhCLFdBQUwsRUFBTCxFQUF5QjthQUNsQjVPLFNBQUwsR0FBaUI5dEQsU0FBU3VzQyxTQUFULENBQW1CLElBQW5CLENBQWpCO09BREYsTUFFTzthQUNBdWhCLFNBQUwsR0FBaUIzMUQsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGVBQXJCLENBQWpCOzs7V0FHRzB2RCxRQUFMLEdBQWdCeGtFLE9BQUs4VSxTQUFMLENBQWUsS0FBSzZnRCxTQUFwQixFQUErQix3QkFBL0IsQ0FBaEI7V0FDSzhPLFVBQUwsR0FBa0J6a0UsT0FBSzhVLFNBQUwsQ0FBZSxLQUFLNmdELFNBQXBCLEVBQStCLDBCQUEvQixDQUFsQjs7V0FFSytPLGtCQUFMO1dBQ0tDLFlBQUw7O1dBRUs1NkQsV0FBTCxDQUFpQixLQUFLNHJELFNBQXRCOztnQkFFVWhvRCxPQUFWLENBQWtCLElBQWxCO21CQUNhKzFDLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsU0FBaEM7Ozs7a0NBR1k7VUFDUixDQUFDN08sT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGVBQXJCLENBQUwsRUFBNEM7ZUFDbkMsS0FBUDs7O1VBR0k4dkQsYUFBYTVrRSxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsZUFBckIsQ0FBbkI7O1VBRUksQ0FBQzlVLE9BQUs4VSxTQUFMLENBQWU4dkQsVUFBZixFQUEyQiwwQkFBM0IsQ0FBTCxFQUE2RDtlQUNwRCxLQUFQOzs7VUFHRSxDQUFDNWtFLE9BQUs4VSxTQUFMLENBQWU4dkQsVUFBZixFQUEyQix3QkFBM0IsQ0FBTCxFQUEyRDtlQUNsRCxLQUFQOzs7YUFHSyxJQUFQOzs7OzZDQU91QjdrRSxNQUFNa08sTUFBTUMsU0FBUztVQUN4Q25PLFNBQVMsVUFBYixFQUF5QjtxQkFDVmtqRCxpQkFBYixDQUErQmgxQyxJQUEvQixFQUFxQ0MsT0FBckMsRUFBOEMsSUFBOUMsRUFBb0RXLFNBQXBEO2FBQ0szQixZQUFMLENBQWtCbTNELEtBQWxCLEtBQTRCLEtBQUtLLGtCQUFMLEVBQTVCO09BRkYsTUFHTyxJQUFJM2tFLFNBQVMsT0FBVCxJQUFvQkEsU0FBUyxpQkFBakMsRUFBb0Q7YUFDcEQ0a0UsWUFBTDtPQURLLE1BRUEsSUFBSTVrRSxTQUFTc2tFLEtBQWIsRUFBb0I7YUFDcEJLLGtCQUFMOzs7Ozt5Q0FJaUI7OzttQkFDTixJQUFiLEVBQW1CO2VBQU0xa0UsT0FBSzhYLGNBQUwsU0FBMEJ1c0QsS0FBMUIsRUFBaUMsRUFBRTcyRCxPQUFPLE9BQUtOLFlBQUwsQ0FBa0JtM0QsS0FBbEIsQ0FBVCxFQUFqQyxDQUFOO09BQW5COzs7O21DQUdhOzs7bUJBQ0EsSUFBYixFQUFtQixZQUFNO2VBQ2xCRyxRQUFMLENBQWNwa0UsS0FBZCxDQUFvQnVDLEtBQXBCLEdBQTZCLE9BQUt1SyxZQUFMLENBQWtCLE9BQWxCLENBQUQsR0FBK0IsT0FBSzdMLFlBQUwsQ0FBa0IsT0FBbEIsSUFBNkIsR0FBNUQsR0FBa0UsSUFBOUY7ZUFDS29qRSxVQUFMLENBQWdCcmtFLEtBQWhCLENBQXNCdUMsS0FBdEIsR0FBOEIsT0FBS3VLLFlBQUwsQ0FBa0IsaUJBQWxCLElBQXVDLE9BQUs3TCxZQUFMLENBQWtCLGlCQUFsQixJQUF1QyxHQUE5RSxHQUFvRixJQUFsSDtPQUZGOzs7Ozs7Ozs7Ozs7O3lCQWFRd0QsT0FBTztVQUNYLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLFFBQVEsQ0FBckMsSUFBMENBLFFBQVEsR0FBdEQsRUFBMkQ7ZUFDcERILEtBQUwsQ0FBVyxlQUFYOzs7V0FHR3NJLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkJ1TSxLQUFLQyxLQUFMLENBQVczVSxLQUFYLENBQTNCOzsyQkFHVTthQUNIOUIsU0FBUyxLQUFLMUIsWUFBTCxDQUFrQixPQUFsQixLQUE4QixHQUF2QyxDQUFQOzs7Ozs7Ozs7Ozs7O3lCQVVpQndELE9BQU87VUFDcEIsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsUUFBUSxDQUFyQyxJQUEwQ0EsUUFBUSxHQUF0RCxFQUEyRDtlQUNwREgsS0FBTCxDQUFXLGVBQVg7OztXQUdHc0ksWUFBTCxDQUFrQixpQkFBbEIsRUFBcUN1TSxLQUFLQyxLQUFMLENBQVczVSxLQUFYLENBQXJDOzsyQkFHbUI7YUFDWjlCLFNBQVMsS0FBSzFCLFlBQUwsQ0FBa0IsaUJBQWxCLEtBQXdDLEdBQWpELENBQVA7Ozs7Ozs7Ozs7Ozs7eUJBVWdCd0QsT0FBTztVQUNuQkEsS0FBSixFQUFXO2FBQ0ptSSxZQUFMLENBQWtCcTNELEtBQWxCLEVBQXlCLEVBQXpCO09BREYsTUFHSzthQUNFL2lFLGVBQUwsQ0FBcUIraUUsS0FBckI7OzsyQkFJZ0I7YUFDWCxLQUFLbjNELFlBQUwsQ0FBa0JtM0QsS0FBbEIsQ0FBUDs7OzsyQkFqRjhCO2FBQ3ZCLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0IsaUJBQXRCLEVBQXlDQSxLQUF6QyxDQUFQOzs7O0VBN0U0Q3ZrQjs7QUFpS2hEN2tDLFlBQVk0cEQsV0FBWixHQUEwQlAsa0JBQTFCO0FBQ0F2bUMsZUFBZUwsTUFBZixDQUFzQixrQkFBdEIsRUFBMEM0bUMsa0JBQTFDOztBQ25PQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFPQSxJQUFNejFELFlBQVM7d0JBQ1Msc0JBRFQ7b0NBRXFCLGtDQUZyQjtpQ0FHa0IsK0JBSGxCO21DQUlvQjtDQUpuQzs7QUFPQSxJQUFNaEgsYUFBVzdILE9BQUsyRyxhQUFMLHFRQUFqQjs7QUFRQSxJQUFNMDlELFVBQVEsZUFBZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5QnFCUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0FpQ0w7Ozs7O3dCQUdPO2FBQU0sTUFBS3hoQixRQUFMLEVBQU47S0FBbkI7Ozs7Ozs2Q0FPdUJ2akQsTUFBTWtPLE1BQU1DLFNBQVM7VUFDeENuTyxTQUFTLFVBQWIsRUFBeUI7cUJBQ1ZrakQsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxTQUFwRDthQUNLM0IsWUFBTCxDQUFrQm0zRCxPQUFsQixLQUE0QixLQUFLSyxrQkFBTCxFQUE1QjtPQUZGLE1BR08sSUFBSTNrRSxTQUFTLE9BQVQsSUFBb0JBLFNBQVMsaUJBQWpDLEVBQW9EO2FBQ3BENGtFLFlBQUw7T0FESyxNQUVBLElBQUk1a0UsU0FBU3NrRSxPQUFiLEVBQW9CO2FBQ3BCSyxrQkFBTDs7Ozs7eUNBSWlCOzs7bUJBQ04sSUFBYixFQUFtQjtlQUFNMWtFLE9BQUs4WCxjQUFMLFNBQTBCdXNELE9BQTFCLEVBQWlDLEVBQUU3MkQsT0FBTyxPQUFLTixZQUFMLENBQWtCbTNELE9BQWxCLENBQVQsRUFBakMsQ0FBTjtPQUFuQjs7OzttQ0FHYTs7O1VBQ1QsS0FBS24zRCxZQUFMLENBQWtCLE9BQWxCLENBQUosRUFBZ0M7cUJBQ2pCLElBQWIsRUFBbUIsWUFBTTtjQUNqQjYzRCxNQUFNeHJELEtBQUt3cEIsSUFBTCxDQUFVLE9BQUsxaEMsWUFBTCxDQUFrQixPQUFsQixJQUE2QixNQUE3QixHQUFzQyxJQUFoRCxDQUFaO2lCQUNLbWpFLFFBQUwsQ0FBY3BrRSxLQUFkLENBQW9CLGtCQUFwQixJQUEwQzJrRSxNQUFNLFlBQWhEO1NBRkY7O1VBS0UsS0FBSzczRCxZQUFMLENBQWtCLGlCQUFsQixDQUFKLEVBQTBDO3FCQUMzQixJQUFiLEVBQW1CLFlBQU07Y0FDakI2M0QsTUFBT3hyRCxLQUFLd3BCLElBQUwsQ0FBVSxPQUFLMWhDLFlBQUwsQ0FBa0IsaUJBQWxCLElBQXVDLE1BQXZDLEdBQWdELElBQTFELENBQWI7aUJBQ0tvakUsVUFBTCxDQUFnQnJrRSxLQUFoQixDQUFzQnNSLE9BQXRCLEdBQWdDLElBQWhDO2lCQUNLK3lELFVBQUwsQ0FBZ0Jya0UsS0FBaEIsQ0FBc0Isa0JBQXRCLElBQTRDMmtFLE1BQU0sWUFBbEQ7U0FIRjtPQURGLE1BTU87cUJBQ1EsSUFBYixFQUFtQixZQUFNO2lCQUNsQk4sVUFBTCxDQUFnQnJrRSxLQUFoQixDQUFzQnNSLE9BQXRCLEdBQWdDLE1BQWhDO1NBREY7Ozs7Ozs7Ozs7Ozs7OytCQWdFTztVQUNMLEtBQUs2eUQsV0FBTCxFQUFKLEVBQXdCO2FBQ2pCNU8sU0FBTCxHQUFpQjMxRCxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsb0JBQXJCLENBQWpCO09BREYsTUFFTzthQUNBNmdELFNBQUwsR0FBaUI5dEQsV0FBU3VzQyxTQUFULENBQW1CLElBQW5CLENBQWpCOzs7V0FHR293QixRQUFMLEdBQWdCeGtFLE9BQUs4VSxTQUFMLENBQWUsS0FBSzZnRCxTQUFwQixFQUErQiw2QkFBL0IsQ0FBaEI7V0FDSzhPLFVBQUwsR0FBa0J6a0UsT0FBSzhVLFNBQUwsQ0FBZSxLQUFLNmdELFNBQXBCLEVBQStCLCtCQUEvQixDQUFsQjs7V0FFSytPLGtCQUFMO1dBQ0tDLFlBQUw7O1dBRUs1NkQsV0FBTCxDQUFpQixLQUFLNHJELFNBQXRCOztnQkFFVWhvRCxPQUFWLENBQWtCLElBQWxCO21CQUNhKzFDLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsU0FBaEM7Ozs7a0NBR1k7VUFDUixDQUFDN08sT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLG9CQUFyQixDQUFMLEVBQWlEO2VBQ3hDLEtBQVA7OztVQUdJa3dELE1BQU1obEUsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLG9CQUFyQixDQUFaOztVQUVJLENBQUM5VSxPQUFLOFUsU0FBTCxDQUFla3dELEdBQWYsRUFBb0IsK0JBQXBCLENBQUwsRUFBMkQ7ZUFDbEQsS0FBUDs7O1VBR0UsQ0FBQ2hsRSxPQUFLOFUsU0FBTCxDQUFla3dELEdBQWYsRUFBb0IsNkJBQXBCLENBQUwsRUFBeUQ7ZUFDaEQsS0FBUDs7O2FBR0ssSUFBUDs7Ozt5QkFyRlFuZ0UsT0FBTztVQUNYLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLFFBQVEsQ0FBckMsSUFBMENBLFFBQVEsR0FBdEQsRUFBMkQ7ZUFDcERILEtBQUwsQ0FBVyxlQUFYOzs7V0FHR3NJLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkJ1TSxLQUFLQyxLQUFMLENBQVczVSxLQUFYLENBQTNCOzsyQkFHVTthQUNIOUIsU0FBUyxLQUFLMUIsWUFBTCxDQUFrQixPQUFsQixLQUE4QixHQUF2QyxDQUFQOzs7Ozs7Ozs7Ozs7O3lCQVVpQndELE9BQU87VUFDcEIsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsUUFBUSxDQUFyQyxJQUEwQ0EsUUFBUSxHQUF0RCxFQUEyRDtlQUNwREgsS0FBTCxDQUFXLGVBQVg7OztXQUdHc0ksWUFBTCxDQUFrQixpQkFBbEIsRUFBcUN1TSxLQUFLQyxLQUFMLENBQVczVSxLQUFYLENBQXJDOzsyQkFHbUI7YUFDWjlCLFNBQVMsS0FBSzFCLFlBQUwsQ0FBa0IsaUJBQWxCLEtBQXdDLEdBQWpELENBQVA7Ozs7Ozs7Ozs7Ozs7eUJBVWdCd0QsT0FBTztVQUNuQkEsS0FBSixFQUFXO2FBQ0ptSSxZQUFMLENBQWtCcTNELE9BQWxCLEVBQXlCLEVBQXpCO09BREYsTUFHSzthQUNFL2lFLGVBQUwsQ0FBcUIraUUsT0FBckI7OzsyQkFJZ0I7YUFDWCxLQUFLbjNELFlBQUwsQ0FBa0JtM0QsT0FBbEIsQ0FBUDs7OzsyQkE5RjhCO2FBQ3ZCLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0IsaUJBQXRCLEVBQXlDQSxPQUF6QyxDQUFQOzs7O0VBeENpRHZrQjs7QUE4S3JEN2tDLFlBQVlncUQsZ0JBQVosR0FBK0JILHVCQUEvQjtBQUNBL21DLGVBQWVMLE1BQWYsQ0FBc0IsdUJBQXRCLEVBQStDb25DLHVCQUEvQzs7QUMvT0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBUUEsSUFBTUksZ0JBQWdCLFNBQXRCO0FBQ0EsSUFBTUMsa0JBQWtCLFdBQXhCO0FBQ0EsSUFBTUMsZUFBZSxRQUFyQjs7QUFFQSxJQUFNQyxZQUFZLFNBQVpBLFNBQVksQ0FBQ3Y3RCxFQUFELEVBQUtELElBQUw7U0FBYzdKLE9BQUswRSxLQUFMLE9BQWVvRixFQUFmLGtCQUE4QkQsSUFBOUIsQ0FBZDtDQUFsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTJCcUJ5N0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBZ0RMOzs7OztVQUdQM2UsZ0JBQUwsR0FBd0IzbUQsT0FBS2dVLE9BQUwsQ0FBYUcsV0FBckM7O1VBRUs4Z0QsT0FBTCxHQUFlLE1BQUtBLE9BQUwsQ0FBYWx2RCxJQUFiLE9BQWY7VUFDS3cvRCxZQUFMLEdBQW9CLE1BQUtBLFlBQUwsQ0FBa0J4L0QsSUFBbEIsT0FBcEI7VUFDS3kvRCxVQUFMLEdBQWtCLE1BQUtBLFVBQUwsQ0FBZ0J6L0QsSUFBaEIsT0FBbEI7VUFDS3c3RCxTQUFMLEdBQWlCLE1BQUtBLFNBQUwsQ0FBZXg3RCxJQUFmLE9BQWpCOztVQUVLMC9ELFNBQUwsQ0FBZVAsYUFBZixFQUE4QixJQUE5QjtVQUNLbEcsS0FBTCxHQVhZOzs7Ozs7Z0NBY0Y7VUFDSnA4RCxTQUFTLEtBQUtBLE1BQUwsR0FBYyxJQUE3QjthQUNPLElBQVAsRUFBYSxFQUFFQSxjQUFGLEVBQVU4aUUsWUFBWTlpRSxNQUF0QixFQUFiO1dBQ0t4QyxLQUFMLENBQVdzUixPQUFYLEtBQXVCLEVBQXZCLElBQTZCLEtBQUsyc0QsS0FBTCxFQUE3Qjs7Ozs4QkFHUTN0RCxPQUFPO1VBQ1R2USxVQUFVLEtBQUt3bEUsWUFBckI7O1VBRUl4bEUsUUFBUXM3QixTQUFSLEdBQW9CLENBQXhCLEVBQTJCO2dCQUNqQkEsU0FBUixHQUFvQixDQUFwQjs7Ozs7dUNBSWU3Z0IsU0FBUzthQUNuQkEsUUFBUW1KLFNBQVIsS0FBc0IsSUFBdEIsSUFBOEJuSixRQUFRbUosU0FBUixLQUFzQixNQUEzRDs7OztpQ0FHV3JULE9BQU87OztVQUNkLENBQUNBLE1BQU1rSyxPQUFQLElBQWtCLEtBQUs0ZixRQUEzQixFQUFxQzs7OztVQUkvQm9yQyxPQUFPbDFELE1BQU1rSyxPQUFOLENBQWNxTixNQUFkLENBQXFCekYsT0FBckIsR0FBK0IsS0FBS21qRCxZQUFMLENBQWtCbHFDLFNBQTlEO1VBQ01vcUMsT0FBT3ptRSxPQUFPK3lCLFdBQXBCOztVQUVNMnpDLHFCQUFxQixLQUFLbmYsZ0JBQUwsR0FBd0IsRUFBeEIsR0FBNkIsQ0FBeEQ7O1dBRUt1QyxXQUFMLEdBQW1CeDRDLE1BQU15NEMsUUFBTixJQUFtQnljLE9BQU9DLE9BQU9DLGtCQUFwRDs7VUFFSSxDQUFDLEtBQUs1YyxXQUFWLEVBQXVCO1lBQ2ZFLFVBQVUxNEMsTUFBTTA0QyxPQUF0QjtjQUNNQSxPQUFOLEdBQWdCLFlBQU07cUJBQ1RBLFNBQVg7aUJBQ0tGLFdBQUwsR0FBbUIsSUFBbkI7OztpQkFHSzhWLEtBQUw7U0FMRjs7WUFRSSxLQUFLM1Ysa0JBQUwsQ0FBd0IzNEMsTUFBTWtLLE9BQTlCLENBQUosRUFBNEM7cUJBQy9Cd3VDLFNBQVg7Z0JBQ01ELFFBQU4sR0FBaUIsSUFBakI7ZUFDS2tWLEtBQUwsR0FIMEM7Ozs7V0FPekMwSCxZQUFMLEdBQW9CLEtBQUtKLFlBQUwsQ0FBa0JscUMsU0FBdEM7Ozs7NEJBR00vcUIsT0FBTzs7O1VBQ1QsQ0FBQ0EsTUFBTWtLLE9BQVAsSUFBa0IsS0FBSzRmLFFBQXZCLElBQW1DLEtBQUswdUIsV0FBeEMsSUFBdUQsQ0FBQyxLQUFLRyxrQkFBTCxDQUF3QjM0QyxNQUFNa0ssT0FBOUIsQ0FBNUQsRUFBb0c7Ozs7O1VBS2hHLEtBQUt4YSxLQUFMLENBQVdzUixPQUFYLEtBQXVCLE1BQTNCLEVBQW1DO2FBQzVCMnNELEtBQUw7OztZQUdJemlELGVBQU47O1VBRU1ncUQsT0FBT2wxRCxNQUFNa0ssT0FBTixDQUFjcU4sTUFBZCxDQUFxQnpGLE9BQXJCLEdBQStCLEtBQUttakQsWUFBTCxDQUFrQmxxQyxTQUE5RDtVQUNNb3FDLE9BQU96bUUsT0FBTyt5QixXQUFwQjs7Ozs7VUFLSSxLQUFLdzBCLGdCQUFULEVBQTJCO2FBQ3BCZ2YsWUFBTCxDQUFrQmxxQyxTQUFsQixHQUE4QixLQUFLc3FDLFlBQUwsR0FBb0JyMUQsTUFBTWtLLE9BQU4sQ0FBY2tJLE1BQWhFOztZQUVJcFMsTUFBTWtLLE9BQU4sQ0FBY21PLGdCQUFkLEtBQW1DLElBQW5DLElBQTRDNjhDLFFBQVFDLE9BQU8sRUFBL0QsRUFBb0U7Z0JBQzVEanJELE9BQU4sQ0FBY1QsY0FBZDs7OztVQUlFZ3VDLFNBQVM1dUMsS0FBS21KLEdBQUwsQ0FBU2hTLE1BQU1rSyxPQUFOLENBQWNrSSxNQUFkLEdBQXVCLEtBQUtpakQsWUFBckMsRUFBbUQsQ0FBbkQsQ0FBZjtVQUNJNWQsV0FBVyxLQUFLNmQsbUJBQXBCLEVBQXlDOztZQUVqQ0MsS0FBSyxLQUFLQyxlQUFoQjtZQUNJRCxLQUFLLENBQUwsSUFBVTlkLFVBQVU4ZCxFQUF4QixFQUE0QjtnQkFDcEJyckQsT0FBTixDQUFjOEwsVUFBZDt1QkFDYTttQkFBTSxPQUFLeS9DLE9BQUwsRUFBTjtXQUFiO1NBRkYsTUFJTyxJQUFJaGUsVUFBVSxLQUFLdmxELE1BQW5CLEVBQTJCO2VBQzNCNmlFLFNBQUwsQ0FBZU4sZUFBZjtTQURLLE1BR0E7ZUFDQU0sU0FBTCxDQUFlUCxhQUFmOzs7YUFHR2tCLFlBQUwsQ0FBa0JqZSxNQUFsQjs7Ozs7K0JBSU96M0MsT0FBTztVQUNaLENBQUNBLE1BQU1rSyxPQUFQLElBQWtCLEtBQUs0ZixRQUF2QixJQUFtQyxLQUFLMHVCLFdBQTVDLEVBQXlEOzs7O1lBSW5EdHRDLGVBQU47O1VBRUksS0FBS29xRCxtQkFBTCxHQUEyQixDQUEvQixFQUFrQztZQUMxQjdkLFNBQVMsS0FBSzZkLG1CQUFwQjs7WUFFSTdkLFNBQVMsS0FBS3ZsRCxNQUFsQixFQUEwQjtlQUNuQnVqRSxPQUFMO1NBREYsTUFFTztlQUNBQyxZQUFMLENBQWtCLENBQWxCLEVBQXFCLEVBQUNDLFNBQVMsSUFBVixFQUFyQjs7Ozs7Ozs7Ozs7Ozs7OzhCQXlDSTs7O1dBQ0haLFNBQUwsQ0FBZUwsWUFBZjtXQUNLZ0IsWUFBTCxDQUFrQixLQUFLeGpFLE1BQXZCLEVBQStCLEVBQUN5akUsU0FBUyxJQUFWLEVBQS9CO1VBQ016d0QsU0FBUyxLQUFLMHdELFFBQUwsSUFBa0I7ZUFBUS9vRCxNQUFSO09BQWpDO2FBQ08sWUFBTTtlQUNONm9ELFlBQUwsQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBQ0MsU0FBUyxJQUFWLEVBQXJCO2VBQ0taLFNBQUwsQ0FBZVAsYUFBZjtPQUZGOzs7Ozs7Ozs7Ozs7OzhCQTRDUXI3QyxPQUFPMDhDLFNBQVM7VUFDbEJDLFlBQVksS0FBSzM4QyxLQUF2Qjs7V0FFSzdjLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkI2YyxLQUEzQjs7VUFFSSxDQUFDMDhDLE9BQUQsSUFBWUMsY0FBYyxLQUFLMzhDLEtBQW5DLEVBQTBDO2VBQ25DeFMsbUJBQUwsQ0FBeUIsSUFBekIsRUFBK0IsYUFBL0IsRUFBOEM7b0JBQ2xDLElBRGtDO2lCQUVyQ3dTLEtBRnFDO3FCQUdqQzI4QztTQUhiOzs7Ozs7Ozs7Ozs7Ozs7NEJBK0NJOzs7O21CQUVPLFlBQU07ZUFDWnBtRSxLQUFMLENBQVdzUixPQUFYLEdBQXFCLEVBQXJCO1lBQ0ksT0FBS2kwRCxZQUFULEVBQXVCO2lCQUNoQkEsWUFBTCxDQUFrQnZsRSxLQUFsQixDQUF3QnFtRSxTQUF4QixTQUF3QyxPQUFLN2pFLE1BQTdDOztPQUhKOzs7OzRCQVFNO1dBQ0R4QyxLQUFMLENBQVdzUixPQUFYLEdBQXFCLE1BQXJCO1VBQ0ksS0FBS2kwRCxZQUFULEVBQXVCO2FBQ2hCQSxZQUFMLENBQWtCdmxFLEtBQWxCLENBQXdCcW1FLFNBQXhCLEdBQW9DLEVBQXBDOzs7Ozs7Ozs7Ozs7aUNBU1N0ZSxRQUFzQjtVQUFkMThDLE9BQWMsdUVBQUosRUFBSTs7VUFDN0IsS0FBS3U2RCxtQkFBTCxJQUE0QixDQUE1QixJQUFpQzdkLFVBQVUsQ0FBL0MsRUFBa0Q7Ozs7V0FJN0M2ZCxtQkFBTCxHQUEyQjdkLE1BQTNCO1VBQ003ekMsTUFBTTdJLFFBQVE0NkQsT0FBUixHQUFrQixFQUFFbjZELFVBQVUsRUFBWixFQUFnQnNQLFFBQVEsNkJBQXhCLEVBQWxCLEdBQTRFLEVBQXhGO1dBQ0trckQsT0FBTCxJQUFnQixLQUFLQSxPQUFMLENBQWEsQ0FBQ3ZlLFNBQVMsS0FBS3ZsRCxNQUFmLEVBQXVCcW9ELE9BQXZCLENBQStCLENBQS9CLENBQWIsRUFBZ0QzMkMsR0FBaEQsQ0FBaEI7VUFDTXF5RCxnQkFBaUIsS0FBS3o1RCxZQUFMLENBQWtCLGVBQWxCLElBQXFDLElBQXJDLEdBQTRDLEtBQUt5NEQsWUFBeEU7O2FBRU9nQixhQUFQLEVBQ0c5b0QsS0FESCxDQUNTLEVBQUUrakMsaUNBQStCdUcsTUFBL0IsYUFBRixFQURULEVBQzhEN3pDLEdBRDlELEVBRUcySyxJQUZILENBRVEsWUFBTTttQkFDQyxDQUFYLElBQWdCL2UsT0FBT08sS0FBUCxDQUFha21FLGFBQWIsRUFBNEIsc0JBQTVCLENBQWhCO2dCQUNRdi9ELFFBQVIsWUFBNEIySixRQUE1QixJQUF3Q3RGLFFBQVFyRSxRQUFSLEVBQXhDO09BSko7Ozs7dUNBUWlCOztXQUNady9ELGlCQUFMLEdBQXlCLElBQXpCO1dBQ0toUyxlQUFMLENBQXFCLElBQXJCOzs7O29DQUdjbG1ELEtBQUs7OztVQUNibTRELGVBQWUsU0FBZkEsWUFBZTtlQUFVLE9BQUtsQixZQUFMLENBQXFCL3ZELE1BQXJCLG9CQUE0QyxRQUE1QyxFQUFzRCxPQUFLMnJELFNBQTNELEVBQXNFLEtBQXRFLENBQVY7T0FBckI7VUFDTXVGLFdBQVcsU0FBWEEsUUFBVyxTQUFVO1lBQ25CeDlDLFVBQVUsRUFBRUEsU0FBUyxJQUFYLEVBQWhCO2VBQ0tzMkIsZ0JBQUwsQ0FBc0JocUMsTUFBdEIsRUFBOEIsTUFBOUIsRUFBc0MsT0FBS3EvQyxPQUEzQyxFQUFvRDNyQyxPQUFwRDtlQUNLczJCLGdCQUFMLENBQXNCaHFDLE1BQXRCLEVBQThCLFdBQTlCLEVBQTJDLE9BQUsydkQsWUFBaEQsRUFBOERqOEMsT0FBOUQ7ZUFDS3MyQixnQkFBTCxDQUFzQmhxQyxNQUF0QixFQUE4QixTQUE5QixFQUF5QyxPQUFLNHZELFVBQTlDLEVBQTBEbDhDLE9BQTFEO09BSkY7O1VBT0ksS0FBS3MyQixnQkFBVCxFQUEyQjtpQkFDaEIsS0FBVDthQUNLQSxnQkFBTCxDQUFzQjkxQixPQUF0QjthQUNLODFCLGdCQUFMLEdBQXdCLElBQXhCOzttQkFFVyxRQUFiOztVQUVJbHhDLEdBQUosRUFBUzthQUNGa3hDLGdCQUFMLEdBQXdCLElBQUluZ0MsZUFBSixDQUFvQixLQUFLa21ELFlBQXpCLEVBQXVDOzJCQUM1QyxDQUQ0QztrQ0FFckMsS0FGcUM7MEJBRzdDLENBQUMsS0FBS2lCLGlCQUh1QzttQkFJcEQsQ0FBQyxLQUFLamdCO1NBSk8sQ0FBeEI7O2lCQU9TLElBQVQ7cUJBQ2EsS0FBYjs7Ozs7d0NBSWdCO1dBQ2JxZixtQkFBTCxHQUEyQixDQUEzQjtXQUNLTCxZQUFMLEdBQW9CLEtBQUt4N0QsVUFBekI7O1dBRUt5cUQsZUFBTCxDQUFxQixJQUFyQjtXQUNLbVMsU0FBTDs7OzsyQ0FHcUI7V0FDaEIvSCxLQUFMO1dBQ0twSyxlQUFMLENBQXFCLEtBQXJCOzs7OzZDQU91QjcwRCxNQUFNa08sTUFBTUMsU0FBUztVQUN4Q25PLFNBQVMsUUFBVCxJQUFxQixLQUFLNGxFLFlBQTlCLEVBQTRDO2FBQ3JDb0IsU0FBTDs7Ozs7MkJBL05XO2FBQ04sS0FBS0MsU0FBWjs7eUJBR1duaUUsT0FBTztVQUNkQSxTQUFTLEVBQUVBLGlCQUFpQmtNLFFBQW5CLENBQWIsRUFBMkM7a0JBQy9CLFVBQVYsRUFBc0Isa0JBQXRCOztXQUVHaTJELFNBQUwsR0FBaUJuaUUsS0FBakI7Ozs7Ozs7Ozs7Ozs7MkJBVVc7YUFDSixLQUFLNmhFLE9BQVo7O3lCQUdTN2hFLE9BQU87VUFDWkEsU0FBUyxFQUFFQSxpQkFBaUJrTSxRQUFuQixDQUFiLEVBQTJDO2tCQUMvQixRQUFWLEVBQW9CLGtCQUFwQjs7V0FFRzIxRCxPQUFMLEdBQWU3aEUsS0FBZjs7Ozt5QkFvQlNBLE9BQU87VUFDWixDQUFDN0UsT0FBS3FaLFNBQUwsQ0FBZXhVLEtBQWYsQ0FBTCxFQUE0QjtrQkFDaEIsUUFBVixFQUFvQixTQUFwQjs7O1dBR0dtSSxZQUFMLENBQWtCLFFBQWxCLEVBQStCbkksS0FBL0I7OzJCQUdXO2FBQ0o5QixTQUFTLEtBQUsxQixZQUFMLENBQWtCLFFBQWxCLEtBQStCLElBQXhDLEVBQThDLEVBQTlDLENBQVA7Ozs7Ozs7Ozs7Ozs7eUJBVWtCd0QsT0FBTztVQUNyQixDQUFDN0UsT0FBS3FaLFNBQUwsQ0FBZXhVLEtBQWYsQ0FBTCxFQUE0QjtrQkFDaEIsaUJBQVYsRUFBNkIsU0FBN0I7OztXQUdHbUksWUFBTCxDQUFrQixrQkFBbEIsRUFBeUNuSSxLQUF6Qzs7MkJBR29CO2FBQ2I5QixTQUFTLEtBQUsxQixZQUFMLENBQWtCLGtCQUFsQixLQUF5QyxJQUFsRCxFQUF3RCxFQUF4RCxDQUFQOzs7OzJCQXlCVTthQUNILEtBQUtBLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7MkJBV2lCO2FBQ1YsS0FBSzJrRSxtQkFBWjs7Ozs7Ozs7Ozs7Ozt5QkFVV25oRSxPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7OzJCQUdhO2FBQ04sS0FBS3FJLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7OzsyQkEwRjhCO2FBQ3ZCLENBQUMsUUFBRCxDQUFQOzs7OzJCQVNrQjthQUNYLENBQUMsYUFBRCxDQUFQOzs7O0VBMVp5QzR5Qzs7QUE4WjdDN2tDLFlBQVlnc0QsUUFBWixHQUF1QjNCLGVBQXZCO0FBQ0F2bkMsZUFBZUwsTUFBZixDQUFzQixlQUF0QixFQUF1QzRuQyxlQUF2Qzs7QUN2ZEE7Ozs7Ozs7Ozs7Ozs7QUFhQSxBQUlBLElBQU16MkQsWUFBUztNQUNULFVBRFM7bUJBRUksaUJBRko7d0JBR1M7Q0FIeEI7O0FBTUEsSUFBTXE0RCxtQkFBbUIsc0JBQXpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTBCcUJDOzs7MEJBRUw7Ozs7O1VBR1BDLFlBQUwsR0FBb0IsTUFBS0EsWUFBTCxDQUFrQnJoRSxJQUFsQixPQUFwQjtVQUNLc2hFLFVBQUwsR0FBa0IsTUFBS0EsVUFBTCxDQUFnQnRoRSxJQUFoQixPQUFsQjtVQUNLdWhFLGFBQUwsR0FBcUIsTUFBS0EsYUFBTCxDQUFtQnZoRSxJQUFuQixPQUFyQjtVQUNLd2hFLFdBQUwsR0FBbUIsTUFBS0EsV0FBTCxDQUFpQnhoRSxJQUFqQixPQUFuQjtVQUNLeWhFLFFBQUwsR0FBZ0IsTUFBS3JaLE9BQUwsQ0FBYXBvRCxJQUFiLE9BQWhCO1VBQ0swaEUsWUFBTCxHQUFvQixNQUFLQSxZQUFMLENBQWtCMWhFLElBQWxCLE9BQXBCO1VBQ0syaEUsVUFBTCxHQUFrQixNQUFLQSxVQUFMLENBQWdCM2hFLElBQWhCLE9BQWxCOzs7Ozs7K0JBR1M7O1dBRUo0aEUsZUFBTCxDQUFxQixLQUFLejZELFlBQUwsQ0FBa0IsVUFBbEIsQ0FBckI7Ozs7Ozs7OEJBS1E7VUFDRnVpQixRQUFRLEtBQUtxbUMsTUFBbkI7VUFDTThSLFlBQVksS0FBS0MsVUFBdkI7O1lBRU16bkUsS0FBTixDQUFZMG5FLGNBQVosR0FBZ0MsTUFBTSxLQUFLQyxNQUEzQztnQkFDVWxqRSxLQUFWLEdBQWtCLEtBQUtBLEtBQXZCOzs7VUFHSzRxQixNQUFNaE4sR0FBTixLQUFjLEVBQWQsSUFBb0JnTixNQUFNNXFCLEtBQU4sS0FBZ0IsR0FBckMsSUFBNkM0cUIsTUFBTWhOLEdBQU4sS0FBY2dOLE1BQU01cUIsS0FBckUsRUFBNEU7Y0FDcEVtSSxZQUFOLENBQW1CLE9BQW5CLEVBQTRCLEVBQTVCO09BREYsTUFFTztjQUNDMUwsZUFBTixDQUFzQixPQUF0Qjs7O09BR0QsS0FBRCxFQUFRLEtBQVIsRUFBZWhCLE9BQWYsQ0FBdUI7ZUFBUXNuRSxVQUFVdFosSUFBVixJQUFrQjcrQixNQUFNNitCLElBQU4sQ0FBMUI7T0FBdkI7Ozs7Ozs7O2lDQXdCV3htRCxHQUFHOzs7V0FDVGd1RCxNQUFMLENBQVl0bkQsU0FBWixDQUFzQkUsR0FBdEIsQ0FBMEJ3NEQsZ0JBQTFCO21CQUNhO2VBQU0sT0FBS3BSLE1BQUwsQ0FBWXpsQyxLQUFaLEVBQU47T0FBYjs7OztrQ0FHWXZvQixHQUFHO1dBQ1ZzL0QsWUFBTDs7OzsrQkFHU3QvRCxHQUFHO1dBQ1BndUQsTUFBTCxDQUFZdG5ELFNBQVosQ0FBc0JJLE1BQXRCLENBQTZCczRELGdCQUE3Qjs7OztnQ0FHVXAvRCxHQUFHO1dBQ1J1L0QsVUFBTCxDQUFnQnYvRCxDQUFoQjs7OztpQ0FHV0EsR0FBRztRQUNacWhELFFBQUYsR0FBYSxJQUFiO1FBQ0V2dUMsT0FBRixDQUFVZ0IsZUFBVjtXQUNLazZDLE1BQUwsQ0FBWXRuRCxTQUFaLENBQXNCRSxHQUF0QixDQUEwQnc0RCxnQkFBMUI7V0FDSy8vRCxnQkFBTCxDQUFzQixNQUF0QixFQUE4QixLQUFLOHRELE9BQW5DOzs7OzRCQUdNbnRELEdBQUc7UUFDUDhULGVBQUY7Ozs7K0JBR1M5VCxHQUFHO1dBQ1BndUQsTUFBTCxDQUFZdG5ELFNBQVosQ0FBc0JJLE1BQXRCLENBQTZCczRELGdCQUE3QjtXQUNLaGdFLG1CQUFMLENBQXlCLE1BQXpCLEVBQWlDLEtBQUsrdEQsT0FBdEM7Ozs7NkNBbUJ1QmwxRCxNQUFNa08sTUFBTUMsU0FBUztVQUN4Q25PLFNBQVMsVUFBYixFQUF5QjthQUNsQjRuRSxlQUFMLENBQXFCejVELE9BQXJCOzswSUFFNkJuTyxJQUEvQixFQUFxQ2tPLElBQXJDLEVBQTJDQyxPQUEzQzs7Ozs7Ozs7O29DQU1jc3NCLFVBQVU7VUFDcEJBLFFBQUosRUFBYzthQUNQaHNCLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixpQkFBbkI7T0FERixNQUVPO2FBQ0FGLFNBQUwsQ0FBZUksTUFBZixDQUFzQixpQkFBdEI7Ozs7O3dDQUlnQjtXQUNiZ21ELGVBQUwsQ0FBcUIsSUFBckI7Ozs7MkNBR3FCO1dBQ2hCQSxlQUFMLENBQXFCLEtBQXJCOzs7O29DQUdjbG1ELEtBQUs7VUFDYmtILFNBQVMsQ0FBQ2xILE1BQU0sS0FBTixHQUFjLFFBQWYsSUFBMkIsZUFBMUM7YUFDS2tILE1BQUwsRUFBYSxJQUFiLEVBQW1CLFlBQW5CLEVBQWlDLEtBQUsweEQsYUFBdEMsRUFBcUQsRUFBRWgrQyxTQUFTLElBQVgsRUFBckQ7V0FDSzFULE1BQUwsRUFBYSxXQUFiLEVBQTBCLEtBQUt3eEQsWUFBL0I7V0FDS3h4RCxNQUFMLEVBQWEsU0FBYixFQUF3QixLQUFLeXhELFVBQTdCO1dBQ0t6eEQsTUFBTCxFQUFhLFVBQWIsRUFBeUIsS0FBSzJ4RCxXQUE5QjtXQUNLM3hELE1BQUwsRUFBYSxXQUFiLEVBQTBCLEtBQUs2eEQsWUFBL0I7V0FDSzd4RCxNQUFMLEVBQWEsU0FBYixFQUF3QixLQUFLOHhELFVBQTdCO1dBQ0s5eEQsTUFBTCxFQUFhLE9BQWIsRUFBc0IsS0FBSzR4RCxRQUEzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkF4R1k7YUFDTDM0RCxTQUFQOzs7OzJCQUdjO3VDQUVHLEtBQUtoRixJQUR0QixpQkFDc0MsS0FBS2k2QyxpQkFEM0M7Ozs7MkJBTXNCO2FBQ2YsT0FBUDs7OzsyQkFHUzthQUNGLE9BQVA7Ozs7MkJBc0NlO2FBQ1IsS0FBS3R5QyxRQUFMLENBQWMsQ0FBZCxDQUFQOzs7OzJCQUdXOztVQUVMaVIsTUFBTSxLQUFLcXpDLE1BQUwsQ0FBWXJ6QyxHQUFaLEtBQW9CLEVBQXBCLEdBQXlCLENBQXpCLEdBQTZCMWYsU0FBUyxLQUFLK3lELE1BQUwsQ0FBWXJ6QyxHQUFyQixDQUF6QztVQUNNQyxNQUFNLEtBQUtvekMsTUFBTCxDQUFZcHpDLEdBQVosS0FBb0IsRUFBcEIsR0FBeUIsR0FBekIsR0FBK0IzZixTQUFTLEtBQUsreUQsTUFBTCxDQUFZcHpDLEdBQXJCLENBQTNDOzthQUVPLENBQUMsS0FBSzdkLEtBQUwsR0FBYTRkLEdBQWQsS0FBc0JDLE1BQU1ELEdBQTVCLENBQVA7Ozs7MkJBRzhCO2NBQ3RCLFVBQVIsMkJBQXVCK3lDLGlCQUFpQjVqQixrQkFBeEM7Ozs7RUF6R3NDNGpCOztBQXlLMUN2NkMsWUFBWStzRCxLQUFaLEdBQW9CYixZQUFwQjtBQUNBcHBDLGVBQWVMLE1BQWYsQ0FBc0IsV0FBdEIsRUFBbUN5cEMsWUFBbkM7O0FDM05BOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQUVBOzs7O0lBR01jOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBd0JJbitELElBQUlvK0QsT0FBdUI7VUFBaEJoOEQsUUFBZ0IsdUVBQUwsR0FBSzs7VUFDN0J5WCxRQUFTLElBQUkyQyxJQUFKLEVBQUQsQ0FBYTZoRCxPQUFiLEVBQVo7VUFDSUMsVUFBVSxFQURkO1VBRUkzZ0QsVUFBVSxLQUZkO1VBR0l5ZCxPQUFPLEtBSFg7VUFJSS9sQixVQUFVLEtBSmQ7VUFLSXNoQyxhQUFhMzhDLE9BQU96RCxJQUFQLENBQVk2bkUsS0FBWixDQUxqQjs7VUFPSUcsZUFBZSxTQUFmQSxZQUFlLEdBQU07WUFDbkJ2bkUsSUFBSTFCLE9BQU9DLGdCQUFQLENBQXdCeUssRUFBeEIsQ0FBUjttQkFDV3hKLE9BQVgsQ0FBbUJRLEVBQUV3WCxnQkFBRixDQUFtQnZTLElBQW5CLENBQXdCakYsQ0FBeEIsQ0FBbkI7WUFDSWdKLEdBQUcwUyxZQUFQO09BSEY7O1VBTUl4YSxTQUFTO2NBQ0wsZ0JBQWtCO2NBQWpCeUosT0FBaUIsdUVBQVAsRUFBTzs7cUJBQ1g2OEQsYUFBYW5wRCxPQUFiLENBQVg7Y0FDSXhRLElBQUk0SyxLQUFLa0osR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFFLElBQUk2RCxJQUFKLEVBQUQsQ0FBYTZoRCxPQUFiLEtBQXlCeGtELEtBQTFCLElBQW1DelgsUUFBL0MsQ0FBUjtxQkFDVzVMLE9BQVgsQ0FBbUIsYUFBSztlQUNuQkYsS0FBSCxDQUFTWSxDQUFULElBQWMsQ0FBQyxJQUFJMk4sQ0FBTCxJQUFVeTVELFFBQVFwbkUsQ0FBUixDQUFWLEdBQXVCMk4sSUFBSXU1RCxNQUFNbG5FLENBQU4sQ0FBM0IsSUFBdUNBLEtBQUssU0FBTCxHQUFpQixFQUFqQixHQUFzQixJQUE3RCxDQUFkO1dBREY7YUFHR1osS0FBSCxDQUFTbW9FLGtCQUFULEdBQThCLElBQTlCOztjQUVJOThELFFBQVErOEQsUUFBWixFQUFzQjttQkFDYixLQUFQO1dBREYsTUFFTyxJQUFJLENBQUMvZ0QsT0FBTCxFQUFjO3NCQUNULElBQVY7b0JBQ1F5ZCxNQUFSOztpQkFFS2xqQyxNQUFQO1NBZlM7Y0FpQkwsY0FBQ2d2QixFQUFELEVBQVE7aUJBQ0xBLEVBQVA7Y0FDSXZKLE9BQUosRUFBYTtvQkFDSHlkLE1BQVI7O2lCQUVLbGpDLE1BQVA7U0F0QlM7ZUF3QkosZUFBQ3ltRSxXQUFELEVBQWlCO2NBQ2xCamlFLFdBQVNDLE1BQVQsQ0FBZ0J3RixrQkFBcEIsRUFBd0M7MEJBQ3hCLENBQWQ7O2NBRUUsQ0FBQ3diLE9BQUwsRUFBYzt1QkFDRDZnRCxhQUFhbnBELE9BQWIsQ0FBWDs7Z0JBRU11cEQsU0FBVSxJQUFJcGlELElBQUosRUFBRCxDQUFhNmhELE9BQWIsS0FBeUJ4a0QsS0FBeEM7Z0JBQ09oVixJQUFJKzVELFNBQVN4OEQsUUFBcEI7Z0JBQ015OEQsWUFBWUYsZUFBZSxJQUFJOTVELENBQW5CLENBQWxCOzt1QkFFV3JPLE9BQVgsQ0FBbUIsYUFBSztpQkFDbkJGLEtBQUgsQ0FBU1ksQ0FBVCxJQUFjLENBQUMsSUFBSTJOLENBQUwsSUFBVXk1RCxRQUFRcG5FLENBQVIsQ0FBVixHQUF1QjJOLElBQUl1NUQsTUFBTWxuRSxDQUFOLENBQTNCLElBQXVDQSxLQUFLLFNBQUwsR0FBaUIsRUFBakIsR0FBc0IsSUFBN0QsQ0FBZDthQURGOzs7O29CQU1ROEksR0FBRzgrRCxXQUFYO3VCQUNXRCxTQUFYOztlQUVHdm9FLEtBQUgsQ0FBU21vRSxrQkFBVCxHQUE4QnI4RCxXQUFXLElBQVgsR0FBa0IsR0FBaEQ7O3VCQUVXNUwsT0FBWCxDQUFtQixhQUFLO2lCQUNuQkYsS0FBSCxDQUFTWSxDQUFULElBQWNrbkUsTUFBTWxuRSxDQUFOLEtBQVlBLEtBQUssU0FBTCxHQUFpQixFQUFqQixHQUFzQixJQUFsQyxDQUFkO2FBREY7O3NCQUlVeWQsV0FBV3pjLE9BQU82bUUsSUFBbEIsRUFBd0JGLFNBQXhCLENBQVY7O2lCQUVLM21FLE1BQVA7U0FwRFM7Z0JBc0RILGtCQUF1QjtjQUF0QjhtRSxZQUFzQix1RUFBUCxFQUFPOztjQUN6Qm42RCxJQUFJLENBQUUsSUFBSTJYLElBQUosRUFBRCxDQUFhNmhELE9BQWIsS0FBeUJ4a0QsS0FBMUIsSUFBbUN6WCxRQUEzQzs7aUJBRU82OEQsS0FBUCxDQUFhRCxnQkFBZ0IsSUFBSW42RCxDQUFwQixDQUFiO2lCQUNPM00sTUFBUDs7T0ExREo7O1VBOERJOEgsR0FBR29ELFlBQUgsQ0FBZ0IsVUFBaEIsS0FBK0J1YSxPQUEvQixJQUEwQ2poQixXQUFTQyxNQUFULENBQWdCd0Ysa0JBQTlELEVBQWtGO2VBQ3pFakssTUFBUDs7O1VBR0U1QixRQUFRaEIsT0FBT0MsZ0JBQVAsQ0FBd0J5SyxFQUF4QixDQUFaO2lCQUNXeEosT0FBWCxDQUFtQixhQUFLO1lBQ2hCK3BDLElBQUl5aUIsV0FBVzFzRCxNQUFNa1ksZ0JBQU4sQ0FBdUJ4USxDQUF2QixDQUFYLENBQVY7Z0JBQ1FBLENBQVIsSUFBYXdLLE1BQU0rM0IsQ0FBTixJQUFXLENBQVgsR0FBZUEsQ0FBNUI7T0FGRjs7VUFNSSxDQUFDNWlCLE9BQUwsRUFBYztXQUNUcm5CLEtBQUgsQ0FBUzRvRSxrQkFBVCxHQUE4QnZvQixXQUFXN2dELElBQVgsQ0FBZ0IsR0FBaEIsQ0FBOUI7V0FDR1EsS0FBSCxDQUFTbW9FLGtCQUFULEdBQThCcjhELFdBQVcsSUFBWCxHQUFrQixHQUFoRDs7bUJBRVc1TCxPQUFYLENBQW1CLGFBQUs7YUFDbkJGLEtBQUgsQ0FBUzBILENBQVQsSUFBY29nRSxNQUFNcGdFLENBQU4sS0FBWUEsS0FBSyxTQUFMLEdBQWlCLEVBQWpCLEdBQXNCLElBQWxDLENBQWQ7U0FERjs7O2dCQUtRMlcsV0FBV3pjLE9BQU82bUUsSUFBbEIsRUFBd0IzOEQsUUFBeEIsQ0FBVjtXQUNLKzhELGlCQUFMLENBQXVCbi9ELEVBQXZCLEVBQTJCOUgsT0FBTzZtRSxJQUFsQzs7YUFFTzdtRSxNQUFQOzs7O3lCQUdZOzs7U0FDUGtuRSxNQUFMLEdBQWMsRUFBZDtTQUNLQyxNQUFMLEdBQWMsQ0FBZDs7Ozs7c0NBR2dCci9ELElBQUk4ckIsVUFBVTtVQUMxQi9YLFFBQVEsS0FBS3FyRCxNQUFqQjtVQUNJbG9FLElBQUksS0FBS21vRSxNQUFMLEVBQVI7WUFDTXIvRCxFQUFOLElBQVkrVCxNQUFNL1QsRUFBTixLQUFhLEVBQXpCO1lBQ01BLEVBQU4sRUFBVTlJLENBQVYsSUFBZSxVQUFDeUssT0FBRCxFQUFhO2VBQ25Cb1MsTUFBTS9ULEVBQU4sRUFBVTlJLENBQVYsQ0FBUDtZQUNJNmMsTUFBTS9ULEVBQU4sS0FBYStULE1BQU0vVCxFQUFOLEVBQVU3SSxNQUFWLElBQW9CLENBQXJDLEVBQXdDO2lCQUMvQjRjLE1BQU0vVCxFQUFOLENBQVA7O2VBRUs4ckIsU0FBU25xQixPQUFULENBQVA7T0FMRjs7Ozs7Ozs7Ozs7OzttQ0FnQmEzQixJQUFrQjs7O1VBQWQyQixPQUFjLHVFQUFKLEVBQUk7O1VBQzNCak0sTUFBTSt1QixPQUFOLENBQWN6a0IsRUFBZCxDQUFKLEVBQXVCO2VBQ2RBLEdBQUd4SixPQUFILENBQVcsY0FBTTtnQkFDakI4b0UsY0FBTCxDQUFvQnQvRCxFQUFwQixFQUF3QjJCLE9BQXhCO1NBREssQ0FBUDs7O09BS0QsS0FBS3k5RCxNQUFMLENBQVlwL0QsRUFBWixLQUFtQixFQUFwQixFQUF3QnhKLE9BQXhCLENBQWdDLGFBQUs7VUFBSW1MLFdBQVcsRUFBYjtPQUF2Qzs7Ozs7Ozs7Ozs7OzhCQVNvQjtVQUFkQSxPQUFjLHVFQUFKLEVBQUk7O1dBQ2YyOUQsY0FBTCxDQUFvQnRsRSxPQUFPekQsSUFBUCxDQUFZLEtBQUs2b0UsTUFBakIsQ0FBcEIsRUFBOEN6OUQsT0FBOUM7Ozs7Ozs7Ozs7Ozt5QkFTRzNCLElBQW9CO1VBQWhCb0MsUUFBZ0IsdUVBQUwsR0FBSzs7YUFDaEIsS0FBS202RCxPQUFMLENBQWF2OEQsRUFBYixFQUFpQixFQUFDMjNDLFNBQVMsQ0FBVixFQUFqQixFQUErQnYxQyxRQUEvQixDQUFQOzs7Ozs7QUN4TUo7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBUUEsSUFBTTI0QyxzQkFBbUIsUUFBekI7QUFDQSxJQUFNaDJDLFlBQVM7TUFDVCxXQURTO21CQUVJLGlCQUZKO3lCQUdVO0NBSHpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdDcUJ3NkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQWlETDs7Ozs7VUFHUEMsTUFBTCxHQUFjLE1BQUtBLE1BQUwsQ0FBWXZqRSxJQUFaLE9BQWQ7VUFDS3dqRSxPQUFMLEdBQWUsTUFBS0EsT0FBTCxDQUFheGpFLElBQWIsT0FBZjtVQUNLdy9ELFlBQUwsR0FBb0IsTUFBS0EsWUFBTCxDQUFrQngvRCxJQUFsQixPQUFwQjtVQUNLaXZELFVBQUwsR0FBa0IsTUFBS0EsVUFBTCxDQUFnQmp2RCxJQUFoQixPQUFsQjs7d0JBRW1CO2FBQU0sTUFBS3U5QyxRQUFMLEVBQU47S0FBbkI7O1VBRUtrbUIsU0FBTCxHQUFpQixJQUFJMzlELFdBQUosRUFBakI7O0tBRUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsY0FBcEIsRUFBb0MsWUFBcEMsRUFBa0QsVUFBbEQsRUFBOER2TCxPQUE5RCxDQUFzRSxhQUFLO1lBQ3BFcXhDLHdCQUFMLENBQThCN3BDLENBQTlCLEVBQWlDLElBQWpDLEVBQXVDLE1BQUt6RyxZQUFMLENBQWtCeUcsQ0FBbEIsQ0FBdkM7S0FERjs7Ozs7OytCQUtTO1dBQ0owRyxTQUFMLENBQWVFLEdBQWYsQ0FBbUJtMkMsbUJBQW5COztXQUVLNGtCLEtBQUwsR0FBYSxLQUFLQyxzQkFBTCxDQUE0QixjQUE1QixFQUE0QyxDQUE1QyxDQUFiO1dBQ0tDLFdBQUwsR0FBbUIsS0FBS0Qsc0JBQUwsQ0FBNEIsb0JBQTVCLEVBQWtELENBQWxELENBQW5COztVQUVJLEVBQUUsS0FBS0MsV0FBTCxJQUFvQixLQUFLRixLQUEzQixDQUFKLEVBQXVDO2FBQ2hDQSxLQUFMLEdBQWF6cEUsT0FBS2lXLE1BQUwsQ0FBWSxlQUFaLENBQWI7YUFDSzB6RCxXQUFMLEdBQW1CM3BFLE9BQUtpVyxNQUFMLENBQVkscUJBQVosQ0FBbkI7O2FBRUtsTSxXQUFMLENBQWlCLEtBQUswL0QsS0FBdEI7YUFDSzEvRCxXQUFMLENBQWlCLEtBQUs0L0QsV0FBdEI7OzttQkFHV2ptQixZQUFiLENBQTBCLElBQTFCLEVBQWdDNzBDLFNBQWhDOzs7O3FDQUdlO1VBQ1QrNkQsUUFBUSxDQUFDLE9BQUQsRUFBVSxTQUFWLENBQWQ7VUFDSSxLQUFLMThELFlBQUwsQ0FBa0IsTUFBbEIsQ0FBSixFQUErQjtZQUN2QnU3QyxPQUFPLEtBQUtwbkQsWUFBTCxDQUFrQixNQUFsQixDQUFiO1lBQ0l1b0UsTUFBTXpvRSxPQUFOLENBQWNzbkQsSUFBZCxNQUF3QixDQUFDLENBQTdCLEVBQWdDO2lCQUN2QkEsSUFBUDs7OzthQUlHLE9BQVA7Ozs7cUNBR2UzZ0QsR0FBRztVQUNkcWIsVUFBSjtVQUFPQyxVQUFQO1VBQVV3UCxVQUFWO1VBQWFELFVBQWI7VUFBZ0I5eEIsVUFBaEI7VUFDTXVvQixJQUFJLEtBQUtzb0MscUJBQUwsRUFBVjtVQUNNakosT0FBTyxLQUFLb2hCLGNBQUwsRUFBYjtVQUNNcGxFLFFBQVEsU0FBUkEsS0FBUTtlQUFNekUsT0FBSzBFLEtBQUwsQ0FBVyxzQkFBWCxDQUFOO09BQWQ7O1VBRUksS0FBS29sRSxPQUFULEVBQWtCO1lBQ1oxZ0QsRUFBRXptQixLQUFGLEdBQVUsQ0FBZDtZQUNJeW1CLEVBQUV4bUIsTUFBRixHQUFXLENBQWY7O1lBRUk2bEQsU0FBUyxPQUFiLEVBQXNCO2NBQ2hCbHZDLEtBQUtrSyxJQUFMLENBQVVOLElBQUlBLENBQUosR0FBUUMsSUFBSUEsQ0FBdEIsQ0FBSjtTQURGLE1BRU8sSUFBSXFsQyxTQUFTLFNBQWIsRUFBd0I7Y0FDekJsdkMsS0FBS2tKLEdBQUwsQ0FBU1UsQ0FBVCxFQUFZQyxDQUFaLENBQUo7U0FESyxNQUVBOzs7T0FSVCxNQVdPO1lBQ0QsQ0FBQyxPQUFPdGIsRUFBRXlhLE9BQVQsS0FBcUIsUUFBckIsR0FBZ0N6YSxFQUFFeWEsT0FBbEMsR0FBNEN6YSxFQUFFaWUsY0FBRixDQUFpQixDQUFqQixFQUFvQnhELE9BQWpFLElBQTRFNkcsRUFBRW5YLElBQWxGO1lBQ0ksQ0FBQyxPQUFPbkssRUFBRTBhLE9BQVQsS0FBcUIsUUFBckIsR0FBZ0MxYSxFQUFFMGEsT0FBbEMsR0FBNEMxYSxFQUFFaWUsY0FBRixDQUFpQixDQUFqQixFQUFvQnZELE9BQWpFLElBQTRFNEcsRUFBRXlULEdBQWxGO1lBQ0l0akIsS0FBS21KLEdBQUwsQ0FBU1UsQ0FBVCxFQUFZZ0csRUFBRXhtQixNQUFGLEdBQVd3Z0IsQ0FBdkIsQ0FBSjtZQUNJN0osS0FBS21KLEdBQUwsQ0FBU1MsQ0FBVCxFQUFZaUcsRUFBRXptQixLQUFGLEdBQVV3Z0IsQ0FBdEIsQ0FBSjs7WUFFSXNsQyxTQUFTLE9BQWIsRUFBc0I7Y0FDaEJsdkMsS0FBS2tLLElBQUwsQ0FBVW1QLElBQUlBLENBQUosR0FBUUQsSUFBSUEsQ0FBdEIsQ0FBSjtTQURGLE1BRU8sSUFBSTgxQixTQUFTLFNBQWIsRUFBd0I7Y0FDekJsdkMsS0FBS2tKLEdBQUwsQ0FBU2xKLEtBQUtxdUMsS0FBTCxDQUFXaDFCLElBQUksQ0FBZixDQUFULEVBQTRCclosS0FBS3F1QyxLQUFMLENBQVdqMUIsSUFBSSxDQUFmLENBQTVCLENBQUo7U0FESyxNQUVBOzs7OzthQUtGLEVBQUN4UCxJQUFELEVBQUlDLElBQUosRUFBT3ZpQixJQUFQLEVBQVA7Ozs7cUNBR2VpSCxHQUFtQjtVQUFoQm9FLFFBQWdCLHVFQUFMLEdBQUs7VUFDM0JzOUQsU0FEMkIsR0FDYSxJQURiLENBQzNCQSxTQUQyQjtVQUNoQkMsS0FEZ0IsR0FDYSxJQURiLENBQ2hCQSxLQURnQjtVQUNURSxXQURTLEdBQ2EsSUFEYixDQUNUQSxXQURTO1VBQ0lJLEtBREosR0FDYSxJQURiLENBQ0lBLEtBREo7OzhCQUVoQixLQUFLQyxnQkFBTCxDQUFzQmxpRSxDQUF0QixDQUZnQjtVQUUzQnFiLENBRjJCLHFCQUUzQkEsQ0FGMkI7VUFFeEJDLENBRndCLHFCQUV4QkEsQ0FGd0I7VUFFckJ2aUIsQ0FGcUIscUJBRXJCQSxDQUZxQjs7Z0JBSXhCb3BFLE9BQVYsQ0FBa0IsRUFBQ3pCLFVBQVUsQ0FBWCxFQUFsQjtnQkFDVW5DLE9BQVYsQ0FBa0JzRCxXQUFsQixFQUErQixFQUFDbG9CLFNBQVMsQ0FBVixFQUEvQixFQUE2Q3YxQyxRQUE3Qzs7YUFFS0gsTUFBTCxDQUFZMDlELE1BQU1ycEUsS0FBbEIsRUFBeUI7aUJBQ2QsQ0FEYzthQUVsQmdqQixJQUFJMm1ELEtBQUosR0FBWSxJQUZNO2NBR2pCNW1ELElBQUk0bUQsS0FBSixHQUFZLElBSEs7ZUFJaEIsSUFBSUEsS0FBSixHQUFZLElBSkk7Z0JBS2YsSUFBSUEsS0FBSixHQUFZO09BTHRCOzthQVFPUCxVQUFVbkQsT0FBVixDQUFrQm9ELEtBQWxCLEVBQXlCO2FBQ3pCcm1ELElBQUl2aUIsQ0FEcUI7Y0FFeEJzaUIsSUFBSXRpQixDQUZvQjtnQkFHdEIsSUFBSUEsQ0FIa0I7ZUFJdkIsSUFBSUE7T0FKTixFQUtKcUwsUUFMSSxDQUFQOzs7O29DQVFjO1VBQ1YsQ0FBQyxLQUFLa00sY0FBTixJQUF3QixLQUFLak8sVUFBakMsRUFBNkM7WUFDckN5cEQsZ0JBQWdCeDBELE9BQU9DLGdCQUFQLENBQXdCLEtBQUs4SyxVQUE3QixDQUF0QjtZQUNJeXBELGNBQWN0N0MsZ0JBQWQsQ0FBK0IsVUFBL0IsTUFBK0MsUUFBbkQsRUFBNkQ7ZUFDdERuTyxVQUFMLENBQWdCL0osS0FBaEIsQ0FBc0JtWSxRQUF0QixHQUFpQyxVQUFqQzs7YUFFR0gsY0FBTCxHQUFzQixJQUF0Qjs7Ozs7MkJBSUd0USxHQUFHOzs7VUFDSixDQUFDLEtBQUsweUIsUUFBTixJQUFrQixDQUFDMXlCLEVBQUVvaUUsTUFBekIsRUFBaUM7VUFDN0JBLE1BQUYsR0FBVyxJQUFYO2FBQ0tDLGFBQUw7YUFDS0MsZ0JBQUwsQ0FBc0J0aUUsRUFBRThTLE9BQUYsQ0FBVTRMLFFBQWhDLEVBQTBDeUgsSUFBMUMsQ0FBK0MsWUFBTTtpQkFDOUN1N0MsU0FBTCxDQUFlM0gsSUFBZixDQUFvQixPQUFLNEgsS0FBekI7aUJBQ0tELFNBQUwsQ0FBZTNILElBQWYsQ0FBb0IsT0FBSzhILFdBQXpCO1NBRkY7Ozs7OzRCQU9JN2hFLEdBQUc7VUFDTCxDQUFDLEtBQUsweUIsUUFBTixJQUFrQixDQUFDMXlCLEVBQUVvaUUsTUFBekIsRUFBaUM7VUFDN0JBLE1BQUYsR0FBVyxJQUFYO2FBQ0tDLGFBQUw7YUFDS0UsUUFBTCxHQUFnQixLQUFLRCxnQkFBTCxDQUFzQnRpRSxFQUFFOFMsT0FBRixDQUFVNEwsUUFBaEMsRUFBMEMsSUFBMUMsQ0FBaEI7aUJBQ1NyZixnQkFBVCxDQUEwQixTQUExQixFQUFxQyxLQUFLNnRELFVBQTFDOzs7OzsrQkFJT2x0RCxHQUFHOzs7VUFDUixLQUFLdWlFLFFBQUwsSUFBaUIsQ0FBQ3ZpRSxFQUFFb2lFLE1BQXhCLEVBQWdDO1VBQzVCQSxNQUFGLEdBQVcsSUFBWDthQUNLRyxRQUFMLENBQWN0QixLQUFkLENBQW9CLEdBQXBCLEVBQXlCOTZDLElBQXpCLENBQThCLFlBQU07aUJBQzdCdTdDLFNBQUwsQ0FBZVMsT0FBZixDQUF1QixFQUFDekIsVUFBVSxJQUFYLEVBQXZCO2lCQUNLZ0IsU0FBTCxDQUFlM0gsSUFBZixDQUFvQixPQUFLNEgsS0FBekI7aUJBQ0tELFNBQUwsQ0FBZTNILElBQWYsQ0FBb0IsT0FBSzhILFdBQXpCO1NBSEY7O2FBTUtVLFFBQUwsR0FBZ0IsS0FBaEI7OztlQUdPbmpFLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDLEtBQUs4dEQsVUFBN0M7Ozs7aUNBR1dsdEQsR0FBRztVQUNWLEtBQUt1aUUsUUFBVCxFQUFtQjtlQUNWLEtBQUtyVixVQUFMLENBQWdCbHRELENBQWhCLENBQVA7O1VBRUUsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQjNHLE9BQWxCLENBQTBCMkcsRUFBRThTLE9BQUYsQ0FBVW1KLFNBQXBDLEtBQWtELENBQUMsQ0FBdkQsRUFBMEQ7YUFDbkR1bEQsTUFBTCxDQUFZeGhFLENBQVo7Ozs7O3dDQUlnQjtXQUNid2lFLFdBQUwsR0FBbUIsS0FBS25nRSxVQUF4Qjs7VUFFSTNELFdBQVNDLE1BQVQsQ0FBZ0J3RixrQkFBcEIsRUFBd0M7YUFDakN1dUIsUUFBTCxHQUFnQixJQUFoQjtPQURGLE1BRU87YUFDQTh2QyxXQUFMLENBQWlCbmpFLGdCQUFqQixDQUFrQyxLQUFsQyxFQUF5QyxLQUFLbWlFLE1BQTlDO2FBQ0tnQixXQUFMLENBQWlCbmpFLGdCQUFqQixDQUFrQyxNQUFsQyxFQUEwQyxLQUFLb2lFLE9BQS9DO2FBQ0tlLFdBQUwsQ0FBaUJuakUsZ0JBQWpCLENBQWtDLFdBQWxDLEVBQStDLEtBQUtvK0QsWUFBcEQ7Ozs7OzJDQUltQjtVQUNmZ0YsS0FBSyxLQUFLRCxXQUFMLElBQW9CLEtBQUtuZ0UsVUFBcEM7U0FDR2pELG1CQUFILENBQXVCLEtBQXZCLEVBQThCLEtBQUtvaUUsTUFBbkM7U0FDR3BpRSxtQkFBSCxDQUF1QixNQUF2QixFQUErQixLQUFLcWlFLE9BQXBDO1NBQ0dyaUUsbUJBQUgsQ0FBdUIsV0FBdkIsRUFBb0MsS0FBS3ErRCxZQUF6Qzs7Ozs2Q0FPdUJ4bEUsTUFBTWtPLE1BQU1DLFNBQVM7OztjQUNwQ25PLElBQVI7O2FBRU8sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I2c0MsbUJBQXhCLEVBQTBDaDJDLFNBQTFDOzs7YUFHRyxVQUFMO3VCQUNlbzBDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsU0FBcEQ7OzthQUdHLGNBQUw7ZUFDT2s3RCxLQUFMLEdBQWF4d0QsS0FBS21KLEdBQUwsQ0FBUyxDQUFULEVBQVlvcUMsV0FBVzUrQyxPQUFYLEtBQXVCLENBQW5DLENBQWI7OzthQUdHLE9BQUw7Y0FDTUEsT0FBSixFQUFhO3lCQUNFLElBQWIsRUFBbUIsWUFBTTtxQkFDbEJ1N0QsS0FBTCxDQUFXcnBFLEtBQVgsQ0FBaUJpNkQsVUFBakIsR0FBOEJuc0QsT0FBOUI7a0JBQ0ksQ0FBQyxPQUFLaEIsWUFBTCxDQUFrQixZQUFsQixDQUFMLEVBQXNDO3VCQUMvQnk4RCxXQUFMLENBQWlCdnBFLEtBQWpCLENBQXVCaTZELFVBQXZCLEdBQW9DbnNELE9BQXBDOzthQUhKOzs7O2FBU0MsWUFBTDtjQUNNQSxXQUFXRCxJQUFmLEVBQXFCO2dCQUNmQyxZQUFZLE1BQWhCLEVBQXdCOzJCQUNULElBQWIsRUFBbUIsWUFBTTt1QkFDbEJ5N0QsV0FBTCxDQUFpQjM4RCxZQUFqQixDQUE4QixVQUE5QixFQUEwQyxVQUExQzt1QkFDSzI4RCxXQUFMLENBQWlCdnBFLEtBQWpCLENBQXVCaTZELFVBQXZCLEdBQW9DLGFBQXBDO2VBRkY7YUFERixNQUtPOzJCQUNRLElBQWIsRUFBbUIsWUFBTTtvQkFDbkIsT0FBS3NQLFdBQUwsQ0FBaUJ6OEQsWUFBakIsQ0FBOEIsVUFBOUIsQ0FBSixFQUErQzt5QkFDeEN5OEQsV0FBTCxDQUFpQnJvRSxlQUFqQixDQUFpQyxVQUFqQzs7dUJBRUdxb0UsV0FBTCxDQUFpQnZwRSxLQUFqQixDQUF1Qmk2RCxVQUF2QixHQUFvQ25zRCxPQUFwQztlQUpGOzs7OzthQVVELFFBQUw7Y0FDTW5PLFNBQVMsUUFBYixFQUF1QjtpQkFDaEIrcEUsT0FBTCxHQUFlNTdELFdBQVcsSUFBWCxJQUFtQkEsV0FBVyxPQUE3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBY0tySixPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7OzJCQUdhO2FBQ04sS0FBS3FJLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7OzsyQkFyRThCO2FBQ3ZCLENBQUMsY0FBRCxFQUFpQixPQUFqQixFQUEwQixZQUExQixFQUF3QyxRQUF4QyxFQUFrRCxPQUFsRCxFQUEyRCxVQUEzRCxDQUFQOzs7O0VBbk91QzR5Qzs7QUEyUzNDN2tDLFlBQVl1dkQsTUFBWixHQUFxQm5CLGFBQXJCO0FBQ0F0ckMsZUFBZUwsTUFBZixDQUFzQixZQUF0QixFQUFvQzJyQyxhQUFwQzs7QUN0V0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUErQnFCb0I7Ozs7Ozs7OztFQUFtQjNxQjs7QUFHeEM3a0MsWUFBWXl2RCxHQUFaLEdBQWtCRCxVQUFsQjtBQUNBMXNDLGVBQWVMLE1BQWYsQ0FBc0IsU0FBdEIsRUFBaUMrc0MsVUFBakM7O0FDdkRBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQU9BLElBQU01bEIsc0JBQW1CLFNBQXpCO0FBQ0EsSUFBTWgyQyxZQUFTO01BQ1QsWUFEUztvQkFFSyxrQkFGTDtxQkFHTSxtQkFITjtzQkFJTztDQUp0Qjs7QUFPQSxJQUFNNmtCLGVBQWMsWUFBTTtNQUNwQjF5QixJQUFJLENBQVI7U0FDTztXQUFNLHFCQUFzQkEsR0FBNUI7R0FBUDtDQUZpQixFQUFuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBOEJxQjJwRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBcURMOzs7OztVQUdQQyxVQUFMLEdBQWtCbDNDLGNBQWxCO1VBQ0ttM0MsT0FBTCxHQUFlLElBQWY7VUFDS3RlLFNBQUwsR0FBaUIsTUFBS0EsU0FBTCxDQUFleG1ELElBQWYsT0FBakI7VUFDSytrRSxrQkFBTCxHQUEwQixNQUFLQSxrQkFBTCxDQUF3Qi9rRSxJQUF4QixPQUExQjs7d0JBRW1CLFlBQU07WUFDbEJ1OUMsUUFBTDttQkFDYTtlQUFNLE1BQUsrRCxnQkFBTCxHQUF3QixNQUFLd2pCLE9BQUwsR0FBZSxNQUFLQSxPQUFMLENBQWFFLGlCQUFiLEVBQWYsR0FBa0QsTUFBS0Msb0JBQUwsRUFBaEY7T0FBYjtLQUZGOzs7Ozs7K0JBTVM7Z0JBQ0NyOUQsT0FBVixDQUFrQixJQUFsQjtXQUNLYSxTQUFMLENBQWVFLEdBQWYsQ0FBbUJtMkMsbUJBQW5COztXQUVLLElBQUl0MUMsUUFBUSxLQUFLaUMsUUFBTCxDQUFjdlEsTUFBZCxHQUF1QixDQUF4QyxFQUEyQ3NPLFNBQVMsQ0FBcEQsRUFBdURBLE9BQXZELEVBQWdFO1lBQ3hEOGhCLE9BQU8sS0FBSzdmLFFBQUwsQ0FBY2pDLEtBQWQsQ0FBYjthQUNLZixTQUFMLENBQWVFLEdBQWYsQ0FBbUIsZUFBbkI7O1lBRU0rZ0IsUUFBUXp2QixPQUFLOFUsU0FBTCxDQUFldWMsSUFBZixFQUFxQixpQkFBckIsS0FBMkNyeEIsT0FBS2lXLE1BQUwsQ0FBWSxzQkFBWixDQUF6RDtjQUNNcE0sSUFBTixHQUFhLE9BQWI7Y0FDTWhGLEtBQU4sR0FBYzBLLEtBQWQ7Y0FDTXhQLElBQU4sR0FBYTB2QixNQUFNMXZCLElBQU4sSUFBYyxLQUFLNnFFLFVBQWhDO2NBQ01uVSxPQUFOLEdBQWdCLENBQUMsS0FBS3ZwRCxZQUFMLENBQWtCLFdBQWxCLENBQUQsSUFBbUNxQyxXQUFXeE0sU0FBUyxLQUFLMUIsWUFBTCxDQUFrQixjQUFsQixDQUFULEtBQStDLENBQTFELENBQW5EOztZQUVNOGpCLFNBQVNubEIsT0FBSzhVLFNBQUwsQ0FBZXVjLElBQWYsRUFBcUIsa0JBQXJCLEtBQTRDcnhCLE9BQUtpVyxNQUFMLENBQVksa0JBQVosQ0FBM0Q7WUFDSWtQLE9BQU85TSxhQUFQLEtBQXlCZ1osSUFBN0IsRUFBbUM7aUJBQzFCQSxLQUFLalksVUFBWixFQUF3QjttQkFDZnJQLFdBQVAsQ0FBbUJzbkIsS0FBS2pZLFVBQXhCOzs7O2FBSUNyUCxXQUFMLENBQWlCMGxCLEtBQWpCO2FBQ0sxbEIsV0FBTCxDQUFpQm9iLE1BQWpCOzs7bUJBR1d1K0IsWUFBYixDQUEwQixJQUExQixFQUFnQzcwQyxTQUFoQzs7Ozt3Q0FHa0I7OztVQUNkLEtBQUszQixZQUFMLENBQWtCLFdBQWxCLENBQUosRUFBb0M7cUJBQ3JCLElBQWIsRUFBbUIsWUFBTTtjQUNqQnhFLE9BQU8xSSxPQUFLaVAsVUFBTCxTQUFzQixVQUF0QixDQUFiO2lCQUNLNDdELE9BQUwsR0FBZW5pRSxRQUFRQSxLQUFLaEIsYUFBTCxDQUFtQixNQUFNLE9BQUtyRyxZQUFMLENBQWtCLFdBQWxCLENBQXpCLENBQXZCO2NBQ0ksQ0FBQyxPQUFLd3BFLE9BQU4sSUFBaUIsT0FBS0EsT0FBTCxDQUFhbCtELE9BQWIsS0FBeUIsWUFBOUMsRUFBNEQ7bUJBQ3JEakksS0FBTCx3QkFBZ0MsT0FBS3JELFlBQUwsQ0FBa0IsV0FBbEIsQ0FBaEM7OztpQkFHR3dwRSxPQUFMLENBQWE3OUQsWUFBYixDQUEwQixXQUExQixFQUF1QyxFQUF2Qzt1QkFDYTttQkFBTSxPQUFLaStELFdBQUwsQ0FBaUIsT0FBS0osT0FBTCxDQUFhRSxpQkFBYixFQUFqQixDQUFOO1dBQWI7O2lCQUVLRixPQUFMLENBQWExakUsZ0JBQWIsQ0FBOEIsV0FBOUIsRUFBMkMsT0FBSzJqRSxrQkFBaEQ7U0FWRjs7O1dBY0czakUsZ0JBQUwsQ0FBc0IsUUFBdEIsRUFBZ0MsS0FBS29sRCxTQUFyQzs7OzsyQ0FHcUI7OzttQkFDUixJQUFiLEVBQW1CLFlBQU07WUFDbkIsT0FBS3NlLE9BQVQsRUFBa0I7aUJBQ1hBLE9BQUwsQ0FBYTNqRSxtQkFBYixDQUFpQyxXQUFqQyxFQUE4QyxPQUFLNGpFLGtCQUFuRDtpQkFDS0QsT0FBTCxHQUFlLElBQWY7O09BSEo7V0FNSzNqRSxtQkFBTCxDQUF5QixRQUF6QixFQUFtQyxLQUFLcWxELFNBQXhDOzs7O2dDQUdVaDlDLE9BQU87V0FDWmlDLFFBQUwsQ0FBY2pDLEtBQWQsRUFBcUIyN0QsaUJBQXJCLENBQXVDelUsT0FBdkMsR0FBaUQsSUFBakQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBbUJjbG5ELE9BQU85RCxTQUFTO1VBQzFCLEtBQUtvL0QsT0FBVCxFQUFrQjtlQUNULEtBQUtBLE9BQUwsQ0FBYU0sWUFBYixDQUEwQjU3RCxLQUExQixFQUFpQzlELE9BQWpDLENBQVA7OztXQUdHdy9ELFdBQUwsQ0FBaUIxN0QsS0FBakI7V0FDSzY3RCxXQUFMLENBQWlCNzdELEtBQWpCO2FBQ081RyxRQUFRQyxPQUFSLENBQWdCMkcsS0FBaEIsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7OzsyQ0FhcUI7V0FDaEIsSUFBSXZPLElBQUksS0FBS3dRLFFBQUwsQ0FBY3ZRLE1BQWQsR0FBdUIsQ0FBcEMsRUFBdUNELEtBQUssQ0FBNUMsRUFBK0NBLEdBQS9DLEVBQW9EOztZQUM5QyxLQUFLd1EsUUFBTCxDQUFjeFEsQ0FBZCxFQUFpQmtxRSxpQkFBakIsQ0FBbUN6VSxPQUF2QyxFQUFnRDtpQkFDdkN6MUQsQ0FBUDs7O2FBR0csQ0FBQyxDQUFSOzs7OzhCQUdRMFAsT0FBTztZQUNUa0wsZUFBTjtXQUNLaXZELE9BQUwsR0FDSSxLQUFLQSxPQUFMLENBQWFNLFlBQWIsQ0FBMEIsS0FBS0gsb0JBQUwsRUFBMUIsRUFBdUQsRUFBRW5pRSxRQUFRLEtBQVYsRUFBdkQsQ0FESixHQUVJLEtBQUt1aUUsV0FBTCxDQUFpQixLQUFLSixvQkFBTCxFQUFqQixDQUZKOzs7O3VDQUtpQnQ2RCxPQUFPOzs7bUJBQ1gsWUFBTTtZQUNiLENBQUNBLE1BQU02RyxNQUFOLENBQWFxckMsUUFBbEIsRUFBNEI7aUJBQ3JCcW9CLFdBQUwsQ0FBaUJ2NkQsTUFBTW5CLEtBQXZCO2lCQUNLNjdELFdBQUwsQ0FBaUIxNkQsTUFBTW5CLEtBQXZCOztPQUhKOzs7O2dDQVFVQSxPQUFPO2FBQ1o4SCxtQkFBTCxDQUF5QixJQUF6QixFQUErQixZQUEvQixFQUE2QztvQkFBQTtxQkFFOUI5SCxLQUY4Qjt5QkFHMUIsS0FBSzgzQyxnQkFIcUI7cUJBSTlCLEtBQUs3MUMsUUFBTCxDQUFjakMsS0FBZDtPQUpmO1dBTUs4M0MsZ0JBQUwsR0FBd0I5M0MsS0FBeEI7Ozs7Ozs7Ozs7Ozs7NkNBc0J1QnhQLE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCNnNDLG1CQUF4QixFQUEwQ2gyQyxTQUExQzs7YUFFRyxVQUFMO3VCQUNlbzBDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsU0FBcEQ7Ozs7Ozt5QkFsQk9oSyxPQUFPO2FBQ1g3RSxPQUFLd1ksZUFBTCxDQUFxQixJQUFyQixFQUEyQixVQUEzQixFQUF1QzNULEtBQXZDLENBQVA7OzJCQUdhO2FBQ04sS0FBS3FJLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBUDs7OzsyQkFHOEI7YUFDdkIsQ0FBQyxPQUFELEVBQVUsVUFBVixDQUFQOzs7OzJCQWNrQjthQUNYLENBQUMsWUFBRCxDQUFQOzs7O0VBdE93QzR5Qzs7QUEwTzVDN2tDLFlBQVlvd0QsT0FBWixHQUFzQlYsY0FBdEI7QUFDQTVzQyxlQUFlTCxNQUFmLENBQXNCLGFBQXRCLEVBQXFDaXRDLGNBQXJDOztBQ3pTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFPQSxJQUFNOTdELFlBQVM7TUFDVCxvQkFEUzttQkFFSTtDQUZuQjs7QUFLQSxJQUFNZzJDLHNCQUFtQixRQUF6Qjs7QUFFQSxJQUFNMFEscUJBQW1CLENBQ3ZCLFdBRHVCLEVBRXZCLFVBRnVCLEVBR3ZCLE1BSHVCLEVBSXZCLFVBSnVCLEVBS3ZCLE1BTHVCLEVBTXZCLFVBTnVCLEVBT3ZCLE1BUHVCLENBQXpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdDcUIrVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBc0VMOzs7Ozt3QkFHTzthQUFNLE1BQUtob0IsUUFBTCxFQUFOO0tBQW5COztVQUVLaW9CLGNBQUw7Ozs7Ozs2Q0FPdUJ4ckUsTUFBTWtPLE1BQU1DLFNBQVM7OztjQUNwQ25PLElBQVI7YUFDTyxPQUFMO2lCQUNPaVksWUFBTCxDQUFrQixJQUFsQixFQUF3QjZzQyxtQkFBeEIsRUFBMENoMkMsU0FBMUM7O2FBRUcsVUFBTDt1QkFDZW8wQyxpQkFBYixDQUErQmgxQyxJQUEvQixFQUFxQ0MsT0FBckMsRUFBOEMsSUFBOUMsRUFBb0RXLFNBQXBEOzs7O1VBSUEwbUQsbUJBQWlCcDBELE9BQWpCLENBQXlCcEIsSUFBekIsS0FBa0MsQ0FBdEMsRUFBeUM7cUJBQzFCLElBQWIsRUFBbUI7aUJBQU0sT0FBSzgxRCxzQkFBTCxFQUFOO1NBQW5COzs7Ozs2Q0FRcUI7Ozt5QkFDTnYxRCxPQUFqQixDQUF5QixVQUFDZ3VELElBQUQsRUFBVTtZQUM3QixPQUFLcGhELFlBQUwsQ0FBa0JvaEQsSUFBbEIsQ0FBSixFQUE2QjtpQkFDdEJrZCxPQUFMLENBQWF4K0QsWUFBYixDQUEwQnNoRCxJQUExQixFQUFnQyxPQUFLanRELFlBQUwsQ0FBa0JpdEQsSUFBbEIsQ0FBaEM7U0FERixNQUdLO2lCQUNFa2QsT0FBTCxDQUFhbHFFLGVBQWIsQ0FBNkJndEQsSUFBN0I7O09BTEo7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFxQ1M7Z0JBQ0MzZ0QsT0FBVixDQUFrQixJQUFsQjs7V0FFS2EsU0FBTCxDQUFlRSxHQUFmLENBQW1CbTJDLG1CQUFuQjtVQUNNNG1CLE1BQU0sS0FBS0QsT0FBTCxJQUFnQmxzRSxTQUFTcUgsYUFBVCxDQUF1QixRQUF2QixDQUE1QjtVQUNJLENBQUM4a0UsSUFBSXo3RCxFQUFMLElBQVcsS0FBSzlDLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBZixFQUErQztZQUN6QzhDLEVBQUosR0FBUyxLQUFLM08sWUFBTCxDQUFrQixXQUFsQixDQUFUOztVQUVFbU4sU0FBSixDQUFjRSxHQUFkLENBQWtCLGNBQWxCO1VBQ0ksQ0FBQyxLQUFLODhELE9BQVYsRUFBbUI7ZUFDWjdoRSxTQUFMLENBQWUsS0FBS29MLFVBQXBCLEVBQWdDelUsT0FBaEMsQ0FBd0M7aUJBQVdtckUsSUFBSTFoRSxXQUFKLENBQWdCNUosT0FBaEIsQ0FBWDtTQUF4QzthQUNLNEosV0FBTCxDQUFpQjBoRSxHQUFqQjs7O21CQUdXL25CLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsU0FBaEM7Ozs7cUNBR2U7OztPQUNkLFVBQUQsRUFBYSxRQUFiLEVBQXVCLFVBQXZCLEVBQW1DLE1BQW5DLEVBQTJDLFNBQTNDLEVBQXNELGVBQXRELEVBQXVFLE1BQXZFLEVBQStFLE9BQS9FLEVBQXdGLE1BQXhGLEVBQWdHLE1BQWhHLEVBQ0d2TyxPQURILENBQ1csZUFBTztlQUNQOFQsY0FBUCxTQUE0QjdULEdBQTVCLEVBQWlDO3dCQUNqQixJQURpQjtzQkFFbkIsSUFGbUI7ZUFHMUI7bUJBQU0sT0FBS2lyRSxPQUFMLENBQWFqckUsR0FBYixDQUFOO1dBSDBCO2VBSTFCLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUJZLE9BQWpCLENBQXlCWixHQUF6QixNQUFrQyxDQUFDLENBQW5DLEdBQ0Q7bUJBQVNrdEIscUJBQW1CO3FCQUFNLE9BQUsrOUMsT0FBTCxDQUFhanJFLEdBQWIsSUFBb0JzRSxLQUExQjthQUFuQixDQUFUO1dBREMsR0FFRHNMO1NBTk47T0FGSjs7Ozt3QkFhRXU3RCxRQUFzQjtVQUFkbjhELEtBQWMsdUVBQU4sSUFBTTs7V0FDbkJpOEQsT0FBTCxDQUFhOThELEdBQWIsQ0FBaUJnOUQsTUFBakIsRUFBeUJuOEQsS0FBekI7Ozs7MkJBR0tBLE9BQU87V0FDUGk4RCxPQUFMLENBQWE1OEQsTUFBYixDQUFvQlcsS0FBcEI7Ozs7MkJBOUVZO2FBQ0wsS0FBSzdILGFBQUwsQ0FBbUIsUUFBbkIsQ0FBUDs7OzsyQkFwQjhCO2NBQ3RCLFVBQVIsRUFBb0IsT0FBcEIsU0FBZ0M2dEQsa0JBQWhDOzs7O0VBL0V1Q3pWOztBQW1MM0M3a0MsWUFBWTB3RCxNQUFaLEdBQXFCTCxhQUFyQjtBQUNBdnRDLGVBQWVMLE1BQWYsQ0FBc0IsWUFBdEIsRUFBb0M0dEMsYUFBcEM7O0FDM1BBOzs7Ozs7Ozs7Ozs7O0FBYUEsQUFNQSxJQUFNem1CLHNCQUFtQixnQ0FBekI7O0FBRUEsSUFBTWgyQyxZQUFTO01BQ1Q7Q0FETjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdDcUIrOEQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FpQkw7Ozs7O1VBR1B0b0IsUUFBTDtVQUNLMEIsYUFBTCxHQUFxQixNQUFLQyxRQUFMLENBQWNsL0MsSUFBZCxPQUFyQjs7Ozs7OzZDQU91QmhHLE1BQU1rTyxNQUFNQyxTQUFTO2NBQ3BDbk8sSUFBUjthQUNPLE9BQUw7aUJBQ09pWSxZQUFMLENBQWtCLElBQWxCLEVBQXdCNnNDLG1CQUF4QixFQUEwQ2gyQyxTQUExQzs7YUFFRyxVQUFMO3VCQUNlbzBDLGlCQUFiLENBQStCaDFDLElBQS9CLEVBQXFDQyxPQUFyQyxFQUE4QyxJQUE5QyxFQUFvRFcsU0FBcEQ7aUJBQ0t4QixXQUFMLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCOzthQUVHLFFBQUw7ZUFDTzIyQyxhQUFMOzs7Ozt3Q0FJYztXQUNiNzhDLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLEtBQUs2OUMsYUFBcEMsRUFBbUQsS0FBbkQ7Ozs7MkNBR3FCO1dBQ2hCOTlDLG1CQUFMLENBQXlCLE9BQXpCLEVBQWtDLEtBQUs4OUMsYUFBdkMsRUFBc0QsS0FBdEQ7Ozs7b0NBR2M7YUFDVGpzQyxZQUFMLENBQWtCLElBQWxCOzs7OzZCQUdPalIsR0FBRztRQUNSOFQsZUFBRjs7OzsrQkFHUzs7O2dCQUNDak8sT0FBVixDQUFrQixJQUFsQjs7MEJBRWlCaE4sS0FBakIsQ0FBdUIsS0FBdkIsRUFBOEJMLE9BQTlCLENBQXNDO2VBQVMsT0FBS2tPLFNBQUwsQ0FBZUUsR0FBZixDQUFtQm5KLEtBQW5CLENBQVQ7T0FBdEM7O2FBRUs4SCxXQUFMLENBQWlCLElBQWpCLEVBQXVCLE1BQXZCO1dBQ0syMkMsYUFBTDs7bUJBRWFOLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsU0FBaEM7Ozs7MkJBMUM4QjthQUN2QixDQUFDLFVBQUQsRUFBYSxRQUFiLEVBQXVCLE9BQXZCLENBQVA7Ozs7RUF6QjhDaXhDOztBQXNFbEQ3a0MsWUFBWTR3RCxhQUFaLEdBQTRCRCxvQkFBNUI7QUFDQTd0QyxlQUFlTCxNQUFmLENBQXNCLHFCQUF0QixFQUE2Q2t1QyxvQkFBN0M7O0FDNUhBOzs7Ozs7Ozs7Ozs7O0FBYUEsQUFRQSxJQUFNL21CLHNCQUFtQixZQUF6QjtBQUNBLElBQU1oMkMsWUFBUztNQUNUO0NBRE47Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQ3FCaTlEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFnRUw7Ozs7O3dCQUdPLFlBQU07WUFDbEJ4b0IsUUFBTDtLQURGOztVQUlLeW9CLFVBQUwsR0FBa0IsS0FBbEI7VUFDSy9tQixhQUFMLEdBQXFCLE1BQUtDLFFBQUwsQ0FBY2wvQyxJQUFkLE9BQXJCOzs7Ozs7K0JBR1M7V0FDSnlJLFNBQUwsQ0FBZUUsR0FBZixDQUFtQm0yQyxtQkFBbkI7Z0JBQ1VsM0MsT0FBVixDQUFrQixJQUFsQjtXQUNLcTJDLGFBQUw7bUJBQ2FOLFlBQWIsQ0FBMEIsSUFBMUIsRUFBZ0M3MEMsU0FBaEM7O1VBRUksS0FBSzNCLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBSixFQUFvQzthQUM3QjgrRCxnQkFBTCxDQUFzQixLQUFLM3FFLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBdEI7T0FERixNQUVPO2FBQ0EycUUsZ0JBQUwsQ0FBc0IsSUFBdEI7OztXQUdHNTBDLGVBQUw7Ozs7NkNBT3VCcjNCLE1BQU1rTyxNQUFNQyxTQUFTOzs7Y0FDcENuTyxJQUFSO2FBQ08sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I2c0MsbUJBQXhCLEVBQTBDaDJDLFNBQTFDOzthQUVHLFVBQUw7dUJBQ2VvMEMsaUJBQWIsQ0FBK0JoMUMsSUFBL0IsRUFBcUNDLE9BQXJDLEVBQThDLElBQTlDLEVBQW9EVyxTQUFwRDs7YUFFRyxRQUFMO3VCQUNlLElBQWIsRUFBbUI7bUJBQU0sT0FBS20xQyxhQUFMLEVBQU47V0FBbkI7O2FBRUcsV0FBTDt1QkFDZSxJQUFiLEVBQW1CO21CQUFNLE9BQUtnb0IsZ0JBQUwsQ0FBc0I5OUQsT0FBdEIsQ0FBTjtXQUFuQjs7YUFFRyxVQUFMO3VCQUNlLElBQWIsRUFBbUI7bUJBQU0sT0FBS2twQixlQUFMLEVBQU47V0FBbkI7Ozs7Ozt3Q0FLYztXQUNiandCLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLEtBQUs2OUMsYUFBcEMsRUFBbUQsS0FBbkQ7Ozs7MkNBR3FCO1dBQ2hCOTlDLG1CQUFMLENBQXlCLE9BQXpCLEVBQWtDLEtBQUs4OUMsYUFBdkMsRUFBc0QsS0FBdEQ7Ozs7NkJBV09sOUMsR0FBRztVQUNOLEtBQUt5eEIsT0FBVCxFQUFrQjthQUNYQSxPQUFMLENBQWFqb0IsS0FBYixDQUFtQixJQUFuQjtlQUNPM0ksUUFBUUMsT0FBUixFQUFQO09BRkYsTUFHTyxJQUFJLENBQUMsS0FBSzR4QixRQUFOLElBQWtCLEtBQUtqSCxPQUEzQixFQUFvQztlQUNsQyxLQUFLMDRDLFdBQUwsRUFBUDs7Ozs7NEJBSUk7VUFDRixDQUFDLEtBQUtDLE1BQVYsRUFBa0I7ZUFDVCxLQUFLaDhDLElBQUwsRUFBUDs7YUFFS3ZuQixRQUFRQyxPQUFSLEVBQVA7Ozs7NEJBR007OzthQUNDLElBQUlELE9BQUosQ0FBWSxtQkFBVztZQUN4QixDQUFDLE9BQUt1akUsTUFBVixFQUFrQjt1QkFDSDttQkFBTSxPQUFLdDhDLElBQUwsR0FBWTNCLElBQVosQ0FBaUJybEIsT0FBakIsQ0FBTjtXQUFiO1NBREYsTUFFTzs7O09BSEYsQ0FBUDs7OztvQ0FTYztVQUNWLEtBQUt1akUsSUFBVCxFQUFlO2FBQ1JqL0QsWUFBTCxDQUFrQixRQUFsQixJQUE4QixLQUFLaS9ELElBQUwsQ0FBVW4vRCxZQUFWLENBQXVCLFFBQXZCLEVBQWlDLEVBQWpDLENBQTlCLEdBQXFFLEtBQUttL0QsSUFBTCxDQUFVN3FFLGVBQVYsQ0FBMEIsUUFBMUIsQ0FBckU7Ozs7O3FDQUlheWlCLFdBQVc7VUFDcEJ2UyxXQUFXLEtBQUs0NkQsS0FBdEI7V0FDSyxJQUFJcHJFLElBQUksQ0FBYixFQUFnQkEsSUFBSXdRLFNBQVN2USxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7ZUFDakN3USxTQUFTeFEsQ0FBVCxDQUFQLEVBQW9COzJCQUNELEtBQUtBLENBQUwsR0FBUyxJQURSO2tCQUVWLE1BRlU7aUJBR1gsTUFIVztlQUliLE1BSmE7Z0JBS1o7U0FMUjs7Y0FRTStpQixTQUFSO2FBQ08sSUFBTDtlQUNPLElBQUkvaUIsS0FBSSxDQUFiLEVBQWdCQSxLQUFJd1EsU0FBU3ZRLE1BQTdCLEVBQXFDRCxJQUFyQyxFQUEwQztxQkFDL0JBLEVBQVQsRUFBWVosS0FBWixDQUFrQjhpRSxNQUFsQixHQUEyQixLQUFLLEtBQUtsaUUsRUFBVixHQUFjLElBQXpDO3FCQUNTQSxFQUFULEVBQVlaLEtBQVosQ0FBa0I4UixLQUFsQixHQUEwQixLQUExQjs7O2FBR0MsTUFBTDtlQUNPLElBQUlsUixNQUFJLENBQWIsRUFBZ0JBLE1BQUl3USxTQUFTdlEsTUFBN0IsRUFBcUNELEtBQXJDLEVBQTBDO3FCQUMvQkEsR0FBVCxFQUFZWixLQUFaLENBQWtCeThCLEdBQWxCLEdBQXdCLEtBQUssS0FBSzc3QixHQUFWLEdBQWMsSUFBdEM7cUJBQ1NBLEdBQVQsRUFBWVosS0FBWixDQUFrQjZSLElBQWxCLEdBQXlCLEtBQXpCOzs7YUFHQyxNQUFMO2VBQ08sSUFBSWpSLE1BQUksQ0FBYixFQUFnQkEsTUFBSXdRLFNBQVN2USxNQUE3QixFQUFxQ0QsS0FBckMsRUFBMEM7cUJBQy9CQSxHQUFULEVBQVlaLEtBQVosQ0FBa0J5OEIsR0FBbEIsR0FBd0IsS0FBeEI7cUJBQ1M3N0IsR0FBVCxFQUFZWixLQUFaLENBQWtCOFIsS0FBbEIsR0FBMEIsS0FBSyxLQUFLbFIsR0FBVixHQUFjLElBQXhDOzs7YUFHQyxPQUFMO2VBQ08sSUFBSUEsTUFBSSxDQUFiLEVBQWdCQSxNQUFJd1EsU0FBU3ZRLE1BQTdCLEVBQXFDRCxLQUFyQyxFQUEwQztxQkFDL0JBLEdBQVQsRUFBWVosS0FBWixDQUFrQnk4QixHQUFsQixHQUF3QixLQUF4QjtxQkFDUzc3QixHQUFULEVBQVlaLEtBQVosQ0FBa0I2UixJQUFsQixHQUF5QixLQUFLLEtBQUtqUixHQUFWLEdBQWMsSUFBdkM7Ozs7aUJBSUcwRCxLQUFMLENBQVcsa0RBQVg7Ozs7O3NDQUlZO1VBQ1Y2VCxXQUFXLEtBQUtsWCxZQUFMLENBQWtCLFVBQWxCLENBQWpCO1dBQ0ttTixTQUFMLENBQWVJLE1BQWYsQ0FDRSxnQkFERixFQUVFLG9CQUZGLEVBR0UsbUJBSEYsRUFJRSxpQkFKRixFQUtFLGtCQUxGLEVBTUUscUJBTkY7Y0FPUTJKLFFBQVI7YUFDTyxXQUFMO2FBQ0ssV0FBTDtlQUNPL0osU0FBTCxDQUFlRSxHQUFmLENBQW1CLGlCQUFuQjs7YUFFRyxVQUFMO2FBQ0ssVUFBTDtlQUNPRixTQUFMLENBQWVFLEdBQWYsQ0FBbUIsZ0JBQW5COzthQUVHLGNBQUw7YUFDSyxjQUFMO2VBQ09GLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixvQkFBbkI7O2FBRUcsYUFBTDthQUNLLGFBQUw7ZUFDT0YsU0FBTCxDQUFlRSxHQUFmLENBQW1CLG1CQUFuQjs7YUFFRyxZQUFMO2FBQ0ssWUFBTDtlQUNPRixTQUFMLENBQWVFLEdBQWYsQ0FBbUIsa0JBQW5COzthQUVHLGVBQUw7YUFDSyxlQUFMO2VBQ09GLFNBQUwsQ0FBZUUsR0FBZixDQUFtQixxQkFBbkI7Ozs7Ozs7O29DQU9VO1VBQ1JpL0MsV0FBVyxDQUFDLEtBQUt0c0QsWUFBTCxDQUFrQixVQUFsQixLQUFpQyxFQUFsQyxFQUFzQ0YsT0FBdEMsQ0FBOEMsUUFBOUMsS0FBMkQsQ0FBNUU7VUFDTXlzRCxZQUFZRCxtQ0FBZ0MzdEQsT0FBS2dVLE9BQUwsQ0FBYTY1QyxTQUFiLElBQTBCLENBQTFELGtCQUF5RSxFQUEzRjthQUNPRCxTQUFQOzs7Ozs7Ozs7Ozs7OzJCQVVLO1dBQ0F1ZSxJQUFMLENBQVVqOEMsSUFBVjthQUNPLElBQVAsRUFBYSxFQUFFMHhCLFdBQVcsS0FBS3lxQixhQUFsQixFQUFiO2FBQ08xakUsUUFBUUMsT0FBUixFQUFQOzs7Ozs7Ozs7Ozs7OzJCQVVLOzs7YUFDRSxLQUFLMGpFLFNBQUwsR0FBaUJyK0MsSUFBakIsQ0FBc0I7ZUFBSyxPQUFLaytDLElBQUwsQ0FBVXY4QyxJQUFWLEVBQUw7T0FBdEIsQ0FBUDs7Ozs7Ozs7Ozs7OztnQ0FVVTtVQUNOLEtBQUsxaUIsWUFBTCxDQUFrQixXQUFsQixDQUFKLEVBQW9DO2FBQzdCOCtELGdCQUFMLENBQXNCLEtBQUszcUUsWUFBTCxDQUFrQixXQUFsQixDQUF0QjtPQURGLE1BRU87YUFDQTJxRSxnQkFBTCxDQUFzQixJQUF0Qjs7O1VBR0VPLGFBQWEsQ0FBakI7VUFDSSxDQUFDLEtBQUtSLFVBQVYsRUFBc0I7WUFDZHY2RCxXQUFXLEtBQUs0NkQsS0FBdEI7YUFDSyxJQUFJcHJFLElBQUksQ0FBYixFQUFnQkEsSUFBSXdRLFNBQVN2USxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7Y0FDbENtTCxRQUFRLEtBQUtuTCxDQUFuQjt3QkFDY21MLEtBQWQ7aUJBQ09xRixTQUFTeFEsQ0FBVCxDQUFQLEVBQW9CO3VCQUNQLFVBRE87NkJBRURtTCxRQUFRO1dBRjNCOztzQkFLWSxFQUFkOzthQUVLNC9ELFVBQUwsR0FBa0IsSUFBbEI7ZUFDSzEwRCxtQkFBTCxDQUF5QixJQUF6QixFQUErQixNQUEvQjs7O1VBR0lxQyxXQUFXMVosT0FBS3laLEtBQUwsRUFBakI7aUJBQ1dDLFNBQVM5USxPQUFwQixFQUE2QjJqRSxVQUE3QjthQUNPN3lELFNBQVNDLE9BQWhCOzs7Ozs7Ozs7Ozs7O2dDQVVVO1VBQ040eUQsYUFBYSxDQUFqQjtVQUNJLEtBQUtSLFVBQVQsRUFBcUI7WUFDYnY2RCxXQUFXLEtBQUs0NkQsS0FBdEI7YUFDSyxJQUFJcHJFLElBQUksQ0FBYixFQUFnQkEsSUFBSXdRLFNBQVN2USxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7Y0FDbENtTCxRQUFRLE1BQU1xRixTQUFTdlEsTUFBVCxHQUFrQkQsQ0FBeEIsQ0FBZDt3QkFDY21MLEtBQWQ7aUJBQ09xRixTQUFTeFEsQ0FBVCxDQUFQLEVBQW9CO3VCQUNQLFVBRE87NkJBRURtTCxRQUFRO1dBRjNCOztzQkFLWSxFQUFkOzthQUVLNC9ELFVBQUwsR0FBa0IsS0FBbEI7ZUFDSzEwRCxtQkFBTCxDQUF5QixJQUF6QixFQUErQixPQUEvQjs7O1VBR0lxQyxXQUFXMVosT0FBS3laLEtBQUwsRUFBakI7aUJBQ1dDLFNBQVM5USxPQUFwQixFQUE2QjJqRSxVQUE3QjthQUNPN3lELFNBQVNDLE9BQWhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQXdETzthQUNBLEtBQUtveUQsVUFBWjs7Ozs7Ozs7Ozs7Ozs2QkFVTzthQUNBLEtBQUt4NEMsT0FBTCxHQUFlLEtBQUszRCxJQUFMLEVBQWYsR0FBNkIsS0FBS00sSUFBTCxFQUFwQzs7Ozs7Ozs7Ozs7OztrQ0FVWTthQUNMLEtBQUtzOEMsTUFBTCxLQUFnQixLQUFLRixTQUFMLEVBQWhCLEdBQW1DLEtBQUtHLFNBQUwsRUFBMUM7Ozs7MkJBcFNVO2FBQ0h6c0UsT0FBSzJKLFNBQUwsQ0FBZSxLQUFLckIsZ0JBQUwsQ0FBc0IscUJBQXRCLENBQWYsQ0FBUDs7OzsyQkFHUzthQUNGdEksT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLFNBQXJCLENBQVA7Ozs7eUJBME5XalEsT0FBTztVQUNkQSxLQUFKLEVBQVc7YUFDSnluRSxTQUFMOzthQUVHM2lFLFNBQUwsQ0FBZSxLQUFLNkgsUUFBcEIsRUFBOEJsUixPQUE5QixDQUFzQyxhQUFLO2VBQ3BDVCxLQUFMLENBQVdpSSxDQUFYLEVBQWMsTUFBZCxLQUF5QjlILE9BQUt3WSxlQUFMLENBQXFCMVEsQ0FBckIsRUFBd0IsVUFBeEIsRUFBb0NqRCxLQUFwQyxDQUF6QjtPQURGOzthQUlPN0UsT0FBS3dZLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsVUFBM0IsRUFBdUMzVCxLQUF2QyxDQUFQOzsyQkFHYTthQUNOLEtBQUtxSSxZQUFMLENBQWtCLFVBQWxCLENBQVA7Ozs7Ozs7Ozs7Ozs7OzJCQVdXO2FBQ0osS0FBS0EsWUFBTCxDQUFrQixRQUFsQixDQUFQOzs7Ozs7Ozs7Ozs7OzsyQkFXWTthQUNMLEtBQUtpL0QsSUFBTCxDQUFVNTRDLE9BQVYsSUFBcUIsS0FBS256QixLQUFMLENBQVdzUixPQUFYLEtBQXVCLE1BQW5EOzs7OzJCQW5TOEI7YUFDdkIsQ0FBQyxPQUFELEVBQVUsVUFBVixFQUFzQixRQUF0QixFQUFnQyxXQUFoQyxFQUE2QyxVQUE3QyxDQUFQOzs7OzJCQXNVa0I7YUFDWCxDQUFDLE1BQUQsRUFBUyxPQUFULENBQVA7Ozs7RUFsYTBDb3VDOztBQXNhOUM3a0MsWUFBWXl4RCxTQUFaLEdBQXdCWixnQkFBeEI7QUFDQS90QyxlQUFlTCxNQUFmLENBQXNCLGdCQUF0QixFQUF3Q291QyxnQkFBeEM7O0FDN2RBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQVFBLElBQU03TyxnQkFBYzs7Ozs7T0FBQSxpQkFLWjk4RCxPQUxZLEVBS0hpSCxRQUxHLEVBS087aUJBQ1ZBLFFBQWI7O0NBTko7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMENxQnVsRTs7Ozs7Ozs7Ozs7Ozs7O29DQWNMOzs7OztVQUdQbFAsS0FBTCxHQUFhLElBQWI7VUFDS0YsV0FBTCxHQUFtQnpvQyxpQkFBbkI7O3dCQUVtQixZQUFNO29CQUNYVyxLQUFaLFFBQXdCLFlBQU07WUFDdEIvc0IsT0FBTyxNQUFLeTFELGNBQUwsRUFBYjs7WUFFSXoxRCxJQUFKLEVBQVU7Z0JBQ0h5MkQsSUFBTCxDQUFVejJELElBQVY7O09BSko7S0FERjs7Ozs7O3dDQVdrQjtVQUNkLENBQUMxSSxPQUFLSCxLQUFMLENBQVcsS0FBS3NLLFVBQWhCLEVBQTRCLGNBQTVCLENBQUwsRUFBa0Q7ZUFDM0N6RixLQUFMLENBQVcsMkRBQVg7Ozs7O3FDQUlhO2FBQ1IsS0FBSys0RCxLQUFMLElBQWMsS0FBS3A4RCxZQUFMLENBQWtCLE1BQWxCLENBQXJCOzs7OzJDQUdxQjs7OzZDQU1FdEIsTUFBTWtPLE1BQU1DLFNBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQTBEekN4RixNQUFvQjs7O1VBQWQrQyxPQUFjLHVFQUFKLEVBQUk7O1dBQ2xCZ3lELEtBQUwsR0FBYS8wRCxJQUFiO1VBQ010QixXQUFXcUUsUUFBUXJFLFFBQVIsSUFBb0IsWUFBVyxFQUFoRDs7YUFFTyxJQUFJdUIsT0FBSixDQUFZLG1CQUFXO1lBQ3hCaWtFLGFBQWEsT0FBS2xLLFFBQUwsSUFBaUIsSUFBbEM7O2VBRUtuRixXQUFMLENBQWlCNEIsSUFBakIsQ0FBc0IsRUFBQ3oyRCxVQUFELEVBQU95RyxjQUFQLEVBQXRCLEVBQTRDLHVCQUFlO2NBQ3JEeTlELFVBQUosRUFBZ0I7bUJBQ1RyUCxXQUFMLENBQWlCcUIsTUFBakIsQ0FBd0JnTyxVQUF4Qjt5QkFDYSxJQUFiOzs7dUJBR1c7bUJBQU0sT0FBS3ZPLEtBQUwsRUFBTjtXQUFiOzttQkFFU2hxQyxXQUFUO2tCQUNRQSxXQUFSO1NBVEY7T0FISyxDQUFQOzs7OzRCQWlCTTtVQUNGLEtBQUtxdUMsUUFBVCxFQUFtQjthQUNaQSxRQUFMLENBQWNyRSxLQUFkOzs7Ozs0QkFJSTtVQUNGLEtBQUtxRSxRQUFULEVBQW1CO2FBQ1pBLFFBQUwsQ0FBYzFELEtBQWQ7Ozs7OytCQUlPO1VBQ0wsS0FBSzBELFFBQVQsRUFBbUI7YUFDWm5GLFdBQUwsQ0FBaUJxQixNQUFqQixDQUF3QixLQUFLOEQsUUFBN0I7O1dBRUc5ekQsTUFBTDs7OzsyQkFyRlM7YUFDRixLQUFLNnVELEtBQVo7Ozs7Ozs7eUJBTU8vMEQsTUFBTTtXQUNSKzBELEtBQUwsR0FBYS8wRCxJQUFiOzs7OzJCQUdhO2FBQ04sS0FBSzhJLFFBQUwsQ0FBYyxDQUFkLENBQVA7Ozs7Ozs7Ozs7Ozs7MkJBVWU7YUFDUixLQUFLK3JELFdBQVo7O3lCQUdhOW9DLFFBQVE7VUFDakIsRUFBRUEsa0JBQWtCRCxVQUFwQixDQUFKLEVBQXFDO2VBQzlCemEsZUFBTDs7V0FFR3dqRCxXQUFMLEdBQW1COW9DLE1BQW5COzs7OzJCQTVDOEI7YUFDdkIsRUFBUDs7OzsyQkFxR3VCO2FBQ2hCd29DLGFBQVA7Ozs7RUFsSmdEbmQ7O0FBc0pwRDdrQyxZQUFZNHhELGVBQVosR0FBOEJGLHNCQUE5QjtBQUNBNXVDLGVBQWVMLE1BQWYsQ0FBc0Isc0JBQXRCLEVBQThDaXZDLHNCQUE5Qzs7QUMxTkE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBS3FCRzs7O2lDQUVMOzs7OztVQUdQOW5CLGFBQUwsR0FBcUIsTUFBS0MsUUFBTCxDQUFjbC9DLElBQWQsT0FBckI7d0JBQ21CLFlBQU07VUFDbkIsTUFBS29FLFVBQUwsQ0FBZ0I0aUUsTUFBaEIsQ0FBdUIvcUQsS0FBdkIsQ0FBNkI7ZUFBUWdyRCxLQUFLQyxJQUFMLEtBQWMsT0FBdEI7T0FBN0IsQ0FBSixFQUFpRTtjQUMxRGpnRSxZQUFMLENBQWtCLE9BQWxCLEVBQTJCLDBCQUEzQjs7S0FGSjs7Ozs7OzZCQU9PMEQsT0FBTztVQUNWLEtBQUs2b0IsT0FBTCxZQUF3QnhvQixRQUE1QixFQUFzQzthQUMvQndvQixPQUFMO09BREYsTUFFTyxJQUFJdjVCLE9BQUtILEtBQUwsQ0FBVyxLQUFLc0ssVUFBaEIsRUFBNEIsY0FBNUIsQ0FBSixFQUFpRDthQUNqREEsVUFBTCxDQUFnQjRpRSxNQUFoQixDQUF1QnpzRSxPQUF2QixDQUErQjtpQkFBUTBzRSxLQUFLeG9DLEtBQUwsQ0FBVyxNQUFYLEVBQW1CNzVCLEtBQW5CLENBQXlCLFlBQU0sRUFBL0IsQ0FBUjtTQUEvQjs7WUFFSWlSLGVBQU47Ozs7NkNBT3VCN2IsTUFBTWtPLE1BQU1DLFNBQVM7Ozt3Q0FHMUI7V0FDYi9HLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLEtBQUs2OUMsYUFBcEM7YUFDS3RxQyxnQkFBTCxDQUFzQixJQUF0QixFQUE0QixJQUE1Qjs7OzsyQ0FHcUI7V0FDaEJ4VCxtQkFBTCxDQUF5QixPQUF6QixFQUFrQyxLQUFLODlDLGFBQXZDO2FBQ0t0cUMsZ0JBQUwsQ0FBc0IsSUFBdEIsRUFBNEIsS0FBNUI7Ozs7MkJBZDhCO2FBQ3ZCLEVBQVA7Ozs7RUF2QjZDb2xDOztBQXdDakQ3a0MsWUFBWWl5RCxZQUFaLEdBQTJCSixtQkFBM0I7QUFDQS91QyxlQUFlTCxNQUFmLENBQXNCLG1CQUF0QixFQUEyQ292QyxtQkFBM0M7O0FDL0RBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUtxQks7Ozs4QkFFbUU7bUZBQUosRUFBSTsyQkFBekUzeEQsTUFBeUU7UUFBekVBLE1BQXlFLCtCQUFoRSw2QkFBZ0U7NkJBQWpDdFAsUUFBaUM7UUFBakNBLFFBQWlDLGlDQUF0QixHQUFzQjswQkFBakJDLEtBQWlCO1FBQWpCQSxLQUFpQiw4QkFBVCxDQUFTOzs7OEhBQzlFLEVBQUVxUCxjQUFGLEVBQVV0UCxrQkFBVixFQUFvQkMsWUFBcEIsRUFEOEU7Ozs7O29DQUkxRDtVQUFkVixPQUFjLHVFQUFKLEVBQUk7O2FBQ3JCTSxNQUFMLENBQVksSUFBWixFQUFrQjtnQkFDUixLQUFLeVAsTUFERyxFQUNLdFAsVUFBVSxLQUFLQSxRQURwQixFQUM4QkMsT0FBTyxLQUFLQTtPQUQ1RCxFQUVHVixPQUZIOzs7Ozs7Ozs7NkJBUU8yaEUsYUFBYTs7O1VBQ2RDLFdBQVdELFlBQVlqakUsVUFBN0I7O21CQUVha2pFLFFBQWIsRUFBdUIsWUFBTTtlQUN0QkMsS0FBTCxHQUFhRixXQUFiO2VBQ0tHLGFBQUwsR0FBcUJGLFNBQVNuN0QsS0FBVCxLQUFtQms3RCxXQUFuQixJQUFrQ0MsU0FBU243RCxLQUEzQyxJQUFvRG03RCxTQUFTcDdELElBQVQsS0FBa0JtN0QsV0FBbEIsSUFBaUNDLFNBQVNwN0QsSUFBbkg7ZUFDS3l3RCxRQUFMLEdBQWdCMkssU0FBUzdrRSxPQUF6QjtlQUNLZzVDLEtBQUwsR0FBYTZyQixTQUFTNXBCLElBQXRCO09BSkY7Ozs7aUNBUVc7V0FDTmpsQyxlQUFMO1dBQ0tnakMsS0FBTCxJQUFjLEtBQUtnc0IsU0FBTCxFQUFkO1dBQ0s5SyxRQUFMLEdBQWdCLEtBQUs0SyxLQUFMLEdBQWEsS0FBS0MsYUFBTCxHQUFxQixLQUFLL3JCLEtBQUwsR0FBYSxJQUEvRDs7OztzQ0FPZ0I7OzswQkFDSTdnRCxLQUFwQixDQUEwQixLQUExQixFQUNHTCxPQURILENBQ1c7ZUFBSyxPQUFLLE1BQU13SCxDQUFYLEtBQWlCNUgsT0FBT08sS0FBUCxDQUFhLE9BQUssTUFBTXFILENBQVgsQ0FBYixFQUE0QixzQkFBNUIsQ0FBdEI7T0FEWDs7OztnQ0FJVTs7VUFFTixDQUFDLEtBQUt5bEUsYUFBTixJQUF1QixLQUFLQSxhQUFMLENBQW1CTixJQUFuQixLQUE0QixPQUFuRCxJQUE4RCxDQUFDLEtBQUtNLGFBQUwsQ0FBbUJmLE1BQXRGLEVBQThGO2FBQ3ZGaHJCLEtBQUwsQ0FBV3BoRCxLQUFYLENBQWlCcWhELE9BQWpCLEdBQTJCLEVBQTNCO2FBQ0tELEtBQUwsQ0FBV3BoRCxLQUFYLENBQWlCc1IsT0FBakIsR0FBMkIsTUFBM0I7Ozs7Ozs7Ozs7OEJBT01tSixVQUFVOzs7Ozs7Ozt5QkFPZjBDLE1BQU07Ozs7Ozs7Ozs7MEJBT0xBLE1BQU07Ozs7OzJCQWxDQTthQUNILEtBQUsrdkQsS0FBTCxDQUFXTixJQUFYLEtBQW9CLE9BQXBCLEdBQThCLEdBQTlCLEdBQW9DLEVBQTNDOzs7O0VBakMwQ3hzQjs7QUN0QjlDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUdxQml0Qjs7Ozs7Ozs7Ozs4QkFFVDV5RCxVQUFVO1dBQ2IybUMsS0FBTCxDQUFXcGhELEtBQVgsQ0FBaUJzUixPQUFqQixHQUEyQixPQUEzQixDQURrQjs7YUFHWCxLQUFLNDdELEtBQVosRUFDR3p2RCxLQURILENBQ1M7cUNBQ3FCLEtBQUs2dkQsS0FBTCxHQUFhN3lELFFBQXZDO09BRkosRUFJR29FLElBSkg7Ozs7Ozs7Ozt5QkFVRzFCLE1BQU07YUFDRndCLE1BQVAsQ0FDRXdpQyxPQUFPLEtBQUsrckIsS0FBWixFQUNHeHZELElBREgsQ0FDUSxLQUFLM1IsS0FEYixFQUVHMFIsS0FGSCxDQUVTO29DQUNxQixLQUFLNnZELEtBQS9CO09BSEosRUFJSyxLQUFLL29DLEdBSlYsRUFLRzltQixLQUxILENBS1Msb0JBQVk7O2dCQUVUTixNQUFSO09BUEosQ0FERixFQVdFZ2tDLE9BQU8sS0FBS0MsS0FBWixFQUNHMWpDLElBREgsQ0FDUSxLQUFLM1IsS0FEYixFQUVHMFIsS0FGSCxDQUVTO2lCQUNJO09BSGIsRUFLR0EsS0FMSCxDQUtTO2lCQUNJO09BTmIsRUFPSztrQkFDUyxLQUFLM1IsUUFEZDtnQkFFTztPQVRaLENBWEY7Ozs7Ozs7OzswQkE0QklxUixNQUFNOzthQUVId0IsTUFBUCxDQUNFd2lDLE9BQU8sS0FBSytyQixLQUFaLEVBQ0d4dkQsSUFESCxDQUNRLEtBQUszUixLQURiLEVBRUcwUixLQUZILENBRVM7bUJBQ007T0FIZixFQUlLLEtBQUs4bUIsR0FKVixFQUtHOW1CLEtBTEgsQ0FLUyxvQkFBWTtnQkFDVE4sTUFBUjs7T0FOSixDQURGLEVBV0Vna0MsT0FBTyxLQUFLQyxLQUFaLEVBQ0cxakMsSUFESCxDQUNRLEtBQUszUixLQURiLEVBRUcwUixLQUZILENBRVM7aUJBQ0k7T0FIYixFQUlLO2tCQUNTLEtBQUszUixRQURkO2dCQUVPO09BTlosRUFRRzJSLEtBUkgsQ0FRUztpQkFDSTtPQVRiLENBWEY7Ozs7RUE5Q2lEc3ZEOztBQ3BCckQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBR3FCUTs7Ozs7Ozs7OzswQ0FFRztVQUNkQyxrQkFBa0IsQ0FBQyxLQUFLTixLQUFOLEVBQWEsS0FBSzVLLFFBQWxCLENBQXhCO1VBQ0ksS0FBSzZLLGFBQUwsSUFBc0IsS0FBS0EsYUFBTCxDQUFtQk4sSUFBbkIsS0FBNEIsT0FBdEQsRUFBK0Q7d0JBQzdDN3JFLElBQWhCLENBQXFCLEtBQUttc0UsYUFBMUI7OzthQUdLSyxlQUFQOzs7OzhCQUdRL3lELFVBQVU7VUFDZCxDQUFDLEtBQUtnekQsZ0JBQVYsRUFBNEI7YUFDckJBLGdCQUFMLEdBQXdCLEtBQUtDLG1CQUFMLEVBQXhCOzs7V0FHR3RzQixLQUFMLENBQVdwaEQsS0FBWCxDQUFpQnNSLE9BQWpCLEdBQTJCLE9BQTNCLENBTGtCOzthQU9YLEtBQUttOEQsZ0JBQVosRUFDR2h3RCxLQURILENBQ1M7cUNBQ3FCLEtBQUs2dkQsS0FBTCxHQUFhN3lELFFBQXZDO09BRkosRUFJR29FLElBSkg7Ozs7Ozs7Ozt5QkFVRzFCLE1BQU07OztVQUNIbUYsTUFBTSxLQUFLNHFELEtBQUwsQ0FBVy9WLFdBQXZCO1dBQ0tzVyxnQkFBTCxHQUF3QixLQUFLQyxtQkFBTCxFQUF4Qjs7YUFFTy91RCxNQUFQLENBQ0V3aUMsT0FBTyxLQUFLc3NCLGdCQUFaLEVBQ0cvdkQsSUFESCxDQUNRLEtBQUszUixLQURiLEVBRUcwUixLQUZILENBRVM7cUNBQ3FCLEtBQUs2dkQsS0FBTCxHQUFhaHJELEdBQXZDO09BSEosRUFJSyxLQUFLaWlCLEdBSlYsRUFLRzltQixLQUxILENBS1Msb0JBQVk7ZUFDWmd3RCxnQkFBTCxHQUF3QixJQUF4Qjs7Z0JBRVF0d0QsTUFBUjtPQVJKLENBREYsRUFZRWdrQyxPQUFPLEtBQUtDLEtBQVosRUFDRzFqQyxJQURILENBQ1EsS0FBSzNSLEtBRGIsRUFFRzBSLEtBRkgsQ0FFUztpQkFDSTtPQUhiLENBWkY7Ozs7Ozs7OzswQkF1QklOLE1BQU07OztXQUNMc3dELGdCQUFMLEdBQXdCLEtBQUtDLG1CQUFMLEVBQXhCOzthQUVPL3VELE1BQVAsQ0FDRXdpQyxPQUFPLEtBQUtzc0IsZ0JBQVosRUFDRy92RCxJQURILENBQ1EsS0FBSzNSLEtBRGIsRUFFRzBSLEtBRkgsQ0FFUzttQkFDTTtPQUhmLEVBSUssS0FBSzhtQixHQUpWLEVBS0c5bUIsS0FMSCxDQUtTLG9CQUFZO2VBQ1pnd0QsZ0JBQUwsR0FBd0IsSUFBeEI7O2dCQUVRdHdELE1BQVI7O09BUkosQ0FERixFQWFFZ2tDLE9BQU8sS0FBS0MsS0FBWixFQUNHMWpDLElBREgsQ0FDUSxLQUFLM1IsS0FEYixFQUVHMFIsS0FGSCxDQUVTO2lCQUNJO09BSGIsQ0FiRjs7OztFQTFEOENzdkQ7O0FDcEJsRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsSUFLcUJZOzs7Ozs7Ozs7OzBDQUVHO1VBQ2RILGtCQUFrQixDQUFDLEtBQUtsTCxRQUFOLEVBQWdCLEtBQUtsaEIsS0FBckIsQ0FBeEI7VUFDSSxLQUFLK3JCLGFBQUwsSUFBc0IsS0FBS0EsYUFBTCxDQUFtQk4sSUFBbkIsS0FBNEIsT0FBdEQsRUFBK0Q7d0JBQzdDN3JFLElBQWhCLENBQXFCLEtBQUttc0UsYUFBMUI7OzthQUdLSyxlQUFQOzs7OzZCQUdPUixhQUFhOzhJQUNMQSxXQUFmO1VBQ0lBLFlBQVlILElBQVosS0FBcUIsVUFBekIsRUFBcUM7YUFDOUJlLFVBQUwsQ0FBZ0JaLFdBQWhCOzs7OztpQ0FJUztXQUNORSxLQUFMLElBQWMsS0FBS1csWUFBTCxDQUFrQixLQUFLWCxLQUF2QixDQUFkOzs7OzsrQkFJU0YsYUFBYTthQUNmQSxXQUFQLEVBQW9CO2NBQ1pBLFlBQVlKLElBQVosS0FBcUIsT0FBckIsR0FBK0IsTUFBL0IsR0FBd0MsQ0FENUI7ZUFFWEksWUFBWUosSUFBWixLQUFxQixPQUFyQixHQUFnQyxDQUFoQyxHQUFvQyxNQUZ6QjtnQkFHVixDQUhVO3lCQUlELE9BSkM7bUJBS1AsS0FBS2tCLHdCQUFMLENBQThCLENBQTlCLEVBQWlDbjNELFNBQWpDLENBQTJDNnFDLFNBTHBDO2lCQU1UO09BTlg7O1VBU015ckIsV0FBV0QsWUFBWS8wRCxhQUE3QjttQkFDYWcxRCxRQUFiLEVBQXVCO2VBQU1BLFNBQVM3a0UsT0FBVCxJQUFvQnRJLE9BQU9tdEUsU0FBUzdrRSxPQUFoQixFQUF5QixFQUFFMnNELFdBQVcsK0JBQWIsRUFBekIsQ0FBMUI7T0FBdkI7Ozs7aUNBR1dpWSxhQUFhO2FBQ2pCM3NFLEtBQVAsQ0FBYTJzRSxXQUFiLEVBQTBCLDJDQUExQjtVQUNJQSxZQUFZMUssUUFBaEIsRUFBMEI7b0JBQ1pBLFFBQVosQ0FBcUJ0aUUsS0FBckIsQ0FBMkJxaEQsT0FBM0IsR0FBcUMsRUFBckM7Ozs7VUFJRSxDQUFDLEtBQUs4ckIsYUFBTixJQUF1QixLQUFLQSxhQUFMLENBQW1CTixJQUFuQixLQUE0QixPQUF2RCxFQUFnRTtvQkFDbEQ1MEQsYUFBWixDQUEwQjdQLE9BQTFCLElBQXFDdEksT0FBT08sS0FBUCxDQUFhMnNFLFlBQVkvMEQsYUFBWixDQUEwQjdQLE9BQXZDLEVBQWdELFdBQWhELENBQXJDOzs7Ozs2Q0FJcUJxUyxVQUFVO1VBQzNCNkgsTUFBTSxLQUFLczNDLFFBQWpCOztVQUVJbVUsaUJBQWlCLENBQUN0ekQsV0FBVzZILEdBQVosSUFBbUJBLEdBQW5CLEdBQXlCLEVBQTlDO3VCQUNpQnBRLE1BQU02N0QsY0FBTixJQUF3QixDQUF4QixHQUE0QjUwRCxLQUFLbUosR0FBTCxDQUFTbkosS0FBS2tKLEdBQUwsQ0FBUzByRCxjQUFULEVBQXlCLENBQXpCLENBQVQsRUFBc0MsQ0FBQyxFQUF2QyxDQUE3Qzs7VUFFTUMsbUNBQWlDLENBQUMsS0FBS1YsS0FBTCxHQUFhLENBQUMsQ0FBZCxHQUFrQixDQUFuQixJQUF3QlMsY0FBekQsYUFBTjtVQUNNMXNCLFVBQVUsSUFBSTBzQixpQkFBaUIsR0FBckM7O2FBRU87aUJBQ0k7O1NBREo7bUJBSU07cUJBQ0VDOztPQUxmOzs7OzhCQVVRdnpELFVBQVU7V0FDYnl5RCxLQUFMLENBQVdsdEUsS0FBWCxDQUFpQnNSLE9BQWpCLEdBQTJCLEVBQTNCO1dBQ0s0N0QsS0FBTCxDQUFXbHRFLEtBQVgsQ0FBaUJnUyxNQUFqQixHQUEwQixDQUExQjtXQUNLNG5ELFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxJQUFpQixLQUFLcVUsWUFBTCxFQUFqQztVQUNNQyxZQUFZLEtBQUtKLHdCQUFMLENBQThCMzBELEtBQUtrSixHQUFMLENBQVM1SCxRQUFULEVBQW1CLEtBQUttL0MsUUFBeEIsQ0FBOUIsQ0FBbEI7O1VBRUksQ0FBQyxLQUFLNlQsZ0JBQVYsRUFBNEI7YUFDckJBLGdCQUFMLEdBQXdCLEtBQUtDLG1CQUFMLEVBQXhCOzs7V0FHR3RzQixLQUFMLENBQVdwaEQsS0FBWCxDQUFpQnNSLE9BQWpCLEdBQTJCLE9BQTNCLENBVmtCOzthQVlYcU4sTUFBUCxDQUNFd2lDLE9BQU8sS0FBS3NzQixnQkFBWixFQUNHaHdELEtBREgsQ0FDUztxQ0FDcUIsS0FBSzZ2RCxLQUFMLEdBQWE3eUQsUUFBdkM7T0FGSixDQURGLEVBS0UwbUMsT0FBTyxLQUFLK3JCLEtBQUwsQ0FBVzVLLFFBQWxCLEVBQ0c3a0QsS0FESCxDQUNTeXdELFVBQVU5bEUsT0FEbkIsQ0FMRixFQU9FKzRDLE9BQU8sS0FBSytyQixLQUFaLEVBQ0d6dkQsS0FESCxDQUNTeXdELFVBQVV2M0QsU0FEbkIsQ0FQRjs7Ozs7Ozs7O3lCQWVHd0csTUFBTTs7O1dBQ0ordkQsS0FBTCxDQUFXbHRFLEtBQVgsQ0FBaUJzUixPQUFqQixHQUEyQixFQUEzQjtXQUNLNDdELEtBQUwsQ0FBV2x0RSxLQUFYLENBQWlCZ1MsTUFBakIsR0FBMEIsQ0FBMUI7V0FDSzRuRCxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsSUFBaUIsS0FBS3FVLFlBQUwsRUFBakM7VUFDTUMsWUFBWSxLQUFLSix3QkFBTCxDQUE4QixLQUFLbFUsUUFBbkMsQ0FBbEI7V0FDSzZULGdCQUFMLEdBQXdCLEtBQUtDLG1CQUFMLEVBQXhCOztpQkFFVyxZQUFNOztlQUNSL3VELE1BQVAsQ0FDRXdpQyxPQUFPLE9BQUtzc0IsZ0JBQVosRUFDRy92RCxJQURILENBQ1EsT0FBSzNSLEtBRGIsRUFFRzBSLEtBRkgsQ0FFUzt1Q0FDcUIsT0FBSzZ2RCxLQUFMLEdBQWEsT0FBSzFULFFBQTVDO1NBSEosRUFJSyxPQUFLcjFCLEdBSlYsQ0FERixFQU9FNGMsT0FBTyxPQUFLQyxLQUFaLEVBQ0cxakMsSUFESCxDQUNRLE9BQUszUixLQURiLEVBRUcwUixLQUZILENBRVM7bUJBQ0k7U0FIYixDQVBGLEVBYUUwakMsT0FBTyxPQUFLK3JCLEtBQUwsQ0FBVzVLLFFBQWxCLEVBQ0c1a0QsSUFESCxDQUNRLE9BQUszUixLQURiLEVBRUcwUixLQUZILENBRVN5d0QsVUFBVTlsRSxPQUZuQixFQUU0QixPQUFLbThCLEdBRmpDLENBYkYsRUFpQkU0YyxPQUFPLE9BQUsrckIsS0FBWixFQUNHeHZELElBREgsQ0FDUSxPQUFLM1IsS0FEYixFQUVHMFIsS0FGSCxDQUVTeXdELFVBQVV2M0QsU0FGbkIsRUFFOEIsT0FBSzR0QixHQUZuQyxFQUdHOW1CLEtBSEgsQ0FHUyxvQkFBWTtpQkFDWmd3RCxnQkFBTCxHQUF3QixJQUF4Qjs7a0JBRVF0d0QsTUFBUjtTQU5KLENBakJGO09BREYsRUEyQkcsT0FBSyxFQTNCUjs7Ozs7Ozs7OzBCQWlDSUEsTUFBTTs7O1VBQ0ord0QsWUFBWSxLQUFLSix3QkFBTCxDQUE4QixDQUE5QixDQUFsQjtXQUNLTCxnQkFBTCxHQUF3QixLQUFLQyxtQkFBTCxFQUF4Qjs7YUFFTy91RCxNQUFQLENBQ0V3aUMsT0FBTyxLQUFLc3NCLGdCQUFaLEVBQ0cvdkQsSUFESCxDQUNRLEtBQUszUixLQURiLEVBRUcwUixLQUZILENBRVM7bUJBQ007T0FIZixFQUlLLEtBQUs4bUIsR0FKVixDQURGLEVBT0U0YyxPQUFPLEtBQUtDLEtBQVosRUFDRzFqQyxJQURILENBQ1EsS0FBSzNSLEtBRGIsRUFFRzBSLEtBRkgsQ0FFUztpQkFDSTtPQUhiLENBUEYsRUFhRTBqQyxPQUFPLEtBQUsrckIsS0FBTCxDQUFXNUssUUFBbEIsRUFDRzVrRCxJQURILENBQ1EsS0FBSzNSLEtBRGIsRUFFRzBSLEtBRkgsQ0FFU3l3RCxVQUFVOWxFLE9BRm5CLEVBRTRCLEtBQUttOEIsR0FGakMsQ0FiRixFQWlCRTRjLE9BQU8sS0FBSytyQixLQUFaLEVBQ0d4dkQsSUFESCxDQUNRLEtBQUszUixLQURiLEVBRUcwUixLQUZILENBRVN5d0QsVUFBVXYzRCxTQUZuQixFQUU4QixLQUFLNHRCLEdBRm5DLEVBR0c5bUIsS0FISCxDQUdTLG9CQUFZO2VBQ1pnd0QsZ0JBQUwsR0FBd0IsSUFBeEI7ZUFDS1AsS0FBTCxDQUFXbHRFLEtBQVgsQ0FBaUJnUyxNQUFqQixHQUEwQixDQUExQjtlQUNLazdELEtBQUwsQ0FBV2x0RSxLQUFYLENBQWlCc1IsT0FBakIsR0FBMkIsTUFBM0I7ZUFDSzQ3RCxLQUFMLENBQVc1SyxRQUFYLENBQW9CdGlFLEtBQXBCLENBQTBCcWhELE9BQTFCLEdBQW9DLEVBQXBDO2dCQUNRbGtDLE1BQVI7O09BUkosQ0FqQkY7Ozs7bUNBK0JhO2FBQ04sS0FBSyt2RCxLQUFMLENBQVcvVixXQUFsQjs7OztFQTNLZ0Q0Vjs7QUN0QnBEOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQVdBLElBQU0vcEIsa0JBQWdCO1dBQ1hxcUIsdUJBRFc7V0FFWEEsdUJBRlc7UUFHZEUsb0JBSGM7VUFJWkk7Q0FKVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTRDcUJROzs7OzZCQUVWdkIsTUFBTTtVQUNQN3NFLFVBQVVILE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixhQUFLO2VBQ2pDOVUsT0FBS0gsS0FBTCxDQUFXaUksQ0FBWCxFQUFjLG1CQUFkLEtBQXNDQSxFQUFFekcsWUFBRixDQUFlLE1BQWYsTUFBMkIyckUsSUFBeEU7T0FEYyxDQUFoQjthQUdPN3NFLE9BQVA7Ozs7Ozs7Ozs7Ozs7O3dDQWdGa0J1USxPQUFPO1dBQ3BCcThELE1BQUwsQ0FBWTdyRSxJQUFaLENBQWlCO2VBQUtKLEVBQUUwckUsTUFBRixHQUFXMXJFLEVBQUUwakMsS0FBRixFQUFYLEdBQXVCLEtBQTVCO09BQWpCLEtBQXVEOXpCLE1BQU00eEMsaUJBQU4sRUFBdkQ7Ozs7a0NBR1l4NkMsR0FBRzs7O1VBQ1hBLEVBQUVDLE1BQUYsQ0FBU29DLFVBQWIsRUFBeUI7cUJBQ1YsSUFBYixFQUFtQixZQUFNO2lCQUNsQnFrRSxPQUFMO1NBREY7Ozs7OzhCQU1NOzs7V0FDSHpCLE1BQUwsQ0FBWXpzRSxPQUFaLENBQW9CLGdCQUFRO1lBQ3RCLE9BQUtrSSxPQUFULEVBQWtCO2lCQUNYQSxPQUFMLENBQWFwSSxLQUFiLENBQW1CNHNFLEtBQUtBLElBQXhCLElBQWdDQSxLQUFLQyxJQUFMLEtBQWMsT0FBZCxHQUF3QkQsS0FBSzVzRSxLQUFMLENBQVd1QyxLQUFuQyxHQUEyQyxDQUEzRTs7T0FGSjs7OzsyQkFsRlM7YUFDRixLQUFLOHJFLFFBQUwsQ0FBYyxNQUFkLENBQVA7Ozs7Ozs7Ozs7Ozs7MkJBVVU7YUFDSCxLQUFLQSxRQUFMLENBQWMsT0FBZCxDQUFQOzs7Ozs7Ozs7Ozs7OzsyQkFXUzthQUNGenVFLE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixtQkFBckIsQ0FBUDs7OzsyQkFHVzthQUNKLENBQUMsS0FBSzdDLElBQU4sRUFBWSxLQUFLQyxLQUFqQixFQUF3QmxELE1BQXhCLENBQStCO2VBQUtsSCxDQUFMO09BQS9CLENBQVA7Ozs7Ozs7Ozs7Ozs7MkJBVVk7YUFDTDlILE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixzQkFBckIsQ0FBUDs7OzsyQkFHWTthQUNMLEtBQUt0TSxPQUFMLENBQWFrNkQsUUFBcEI7Ozs7MkJBR1M7YUFDRjFpRSxPQUFLOFUsU0FBTCxDQUFlLElBQWYsRUFBcUIsbUJBQXJCLENBQVA7Ozs7Ozs7Ozs7Ozs7MkJBVXVCO2FBQ2hCLEtBQUtrdUMsa0JBQVo7O3lCQUdxQjU3QyxVQUFVO1VBQzNCLEtBQUs0N0Msa0JBQVQsRUFBNkI7YUFDdEJBLGtCQUFMLENBQXdCM3pCLE9BQXhCOzs7V0FHRzJ6QixrQkFBTCxHQUEwQnh3QywyQkFBMkJpdEMsYUFBM0IsQ0FBeUMsSUFBekMsRUFBK0NyNEMsUUFBL0MsQ0FBMUI7Ozs7NkJBdUJZOzs7OztVQUdQc25FLGFBQUwsR0FBcUIsTUFBS0EsYUFBTCxDQUFtQjNvRSxJQUFuQixPQUFyQjs7d0JBRW1CLFlBQU07T0FDdEIsTUFBSzA5QyxJQUFOLElBQWMsTUFBSzE1QyxXQUFMLENBQWlCekssU0FBU3FILGFBQVQsQ0FBdUIsbUJBQXZCLENBQWpCLENBQWQ7WUFDSzZuRSxPQUFMO0tBRkY7Ozs7Ozt3Q0FNa0I7V0FDYnpyQixrQkFBTCxHQUEwQixLQUFLMmEsbUJBQUwsQ0FBeUIzM0QsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBMUI7V0FDS29CLGdCQUFMLENBQXNCLFlBQXRCLEVBQW9DLEtBQUt1bkUsYUFBekMsRUFBd0QsS0FBeEQ7Ozs7MkNBR3FCO1dBQ2hCMXJCLGtCQUFMLENBQXdCM3pCLE9BQXhCO1dBQ0syekIsa0JBQUwsR0FBMEIsSUFBMUI7V0FDSzk3QyxtQkFBTCxDQUF5QixZQUF6QixFQUF1QyxLQUFLd25FLGFBQTVDLEVBQTJELEtBQTNEOzs7OzZDQUd1QjN1RSxNQUFNa08sTUFBTUMsU0FBUzs7OzRCQUV0QzthQUNEeUgsZUFBTCxDQUFxQixJQUFyQixFQUEyQixPQUEzQjs7Ozs0QkFHTTthQUNEQSxlQUFMLENBQXFCLElBQXJCLEVBQTJCLE9BQTNCOzs7OytCQUdTO2FBQ0pBLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsVUFBM0I7V0FDSy9HLE1BQUw7Ozs7cUNBR3NCN08sTUFBTThMLFVBQVU7VUFDbEMsRUFBRUEsb0JBQW9Cc2hFLGdCQUF0QixDQUFKLEVBQTZDO2VBQ3RDbnpELGFBQUwsQ0FBbUIsVUFBbkI7O3NCQUVZamEsSUFBZCxJQUFzQjhMLFFBQXRCOzs7OzJCQUc0QjthQUNyQnNoRSxnQkFBUDs7OzsyQkFHcUI7YUFDZC9wQixlQUFQOzs7O0VBM0p5Q3REOztBQStKN0M3a0MsWUFBWTB6RCxRQUFaLEdBQXVCSixlQUF2QjtBQUNBeHdDLGVBQWVMLE1BQWYsQ0FBc0IsY0FBdEIsRUFBc0M2d0MsZUFBdEM7O0FDeE9BOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQWNBLElBQU1LLGFBQWEsT0FBbkI7QUFDQSxJQUFNQyxnQkFBZ0IsVUFBdEI7QUFDQSxJQUFNQyxlQUFlLFFBQXJCO0FBQ0EsSUFBTUMsYUFBYSxNQUFuQjtBQUNBLElBQU1DLGlCQUFpQixVQUF2Qjs7QUFFQSxJQUFNL1IsZ0JBQWM7Ozs7O09BQUEsaUJBS1pnUyxtQkFMWSxFQUtTN25FLFFBTFQsRUFLbUI7aUJBQ3RCQSxRQUFiOztDQU5KOztJQVVNOG5FOzZCQUNRL3VFLE9BQVosRUFBcUI0SCxNQUFyQixFQUE2Qjs7O1NBQ3RCaUosUUFBTCxHQUFnQjdRLE9BQWhCO1NBQ0tvc0QsU0FBTCxHQUFpQixLQUFLQSxTQUFMLENBQWV4bUQsSUFBZixDQUFvQixJQUFwQixDQUFqQjtjQUNVLEtBQUtvcEUsWUFBTCxDQUFrQnBuRSxNQUFsQixDQUFWOzs7OztpQ0FHV0EsUUFBUTtXQUNkaXVCLE9BQUw7V0FDS281QyxPQUFMLEdBQWVybkUsTUFBZjtVQUNJQSxNQUFKLEVBQVk7YUFDTHNuRSxZQUFMLEdBQW9CLENBQUMsVUFBRCxFQUFhLFdBQWIsRUFBMEJsdUUsT0FBMUIsQ0FBa0M0RyxNQUFsQyxNQUE4QyxDQUFDLENBQW5FO2FBQ0t1bkUsUUFBTDs7Ozs7MkJBSUd6cUUsT0FBTztVQUNSLEtBQUt3cUUsWUFBVCxFQUF1QjtlQUNkLEtBQUtELE9BQUwsTUFBa0J2cUUsTUFBTW10QixVQUFOLEdBQW1CLFVBQW5CLEdBQWdDLFdBQWxELENBQVA7O2FBRUtudEIsTUFBTTZQLE9BQWI7Ozs7OEJBR1E3UCxPQUFPO1dBQ1ZtTSxRQUFMLENBQWN1K0QsV0FBZCxDQUEwQixLQUFLQyxNQUFMLENBQVkzcUUsS0FBWixJQUFxQmdxRSxhQUFyQixHQUFxQ0QsVUFBL0Q7Ozs7K0JBR1M7VUFDTCxLQUFLUyxZQUFULEVBQXVCO29CQUNUOTBELEVBQVosQ0FBZSxRQUFmLEVBQXlCLEtBQUtneUMsU0FBOUI7YUFDS0EsU0FBTCxDQUFlLEVBQUN2NkIsWUFBWU8sWUFBWVAsVUFBWixFQUFiLEVBQWY7T0FGRixNQUdPO2FBQ0F5OUMsWUFBTCxHQUFvQnJ3RSxPQUFPc3dFLFVBQVAsQ0FBa0IsS0FBS04sT0FBdkIsQ0FBcEI7YUFDS0ssWUFBTCxDQUFrQkUsV0FBbEIsQ0FBOEIsS0FBS3BqQixTQUFuQzthQUNLQSxTQUFMLENBQWUsS0FBS2tqQixZQUFwQjs7Ozs7OEJBSU07VUFDSixLQUFLSixZQUFULEVBQXVCO29CQUNULzBELEdBQVosQ0FBZ0IsUUFBaEIsRUFBMEIsS0FBS2l5QyxTQUEvQjtPQURGLE1BRU8sSUFBSSxLQUFLa2pCLFlBQVQsRUFBdUI7YUFDdkJBLFlBQUwsQ0FBa0JHLGNBQWxCLENBQWlDLEtBQUtyakIsU0FBdEM7YUFDS2tqQixZQUFMLEdBQW9CLElBQXBCOzs7Ozs7O0FBS04sQUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQ3FCSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQTBLTDs7Ozs7VUFHUHBTLEtBQUwsR0FBYSxJQUFiO1VBQ0txUyxNQUFMLEdBQWNoQixZQUFkO1VBQ0tpQixLQUFMLEdBQWEsSUFBSXA4QyxRQUFKLEVBQWI7VUFDSzRwQyxXQUFMLEdBQW1Cem9DLGlCQUFuQjtVQUNLazdDLGtCQUFMLEdBQTBCLElBQUlkLGlCQUFKLE9BQTFCOztVQUVLM3NCLGdCQUFMLEdBQXdCLElBQUkxM0MsZUFBSixDQUFvQjtpQkFDL0IwakUsZ0JBQWdCdmpFLFNBRGU7aUJBRS9CbWlFLGtCQUYrQjtxQkFHM0Isa0JBSDJCO3dCQUl4QixNQUFLOXJFLFlBQUwsQ0FBa0IsV0FBbEI7S0FKSSxDQUF4Qjs7d0JBT21CLFlBQU07O1lBRWxCc3dDLHdCQUFMLENBQThCLE9BQTlCO1VBQ0ksQ0FBQyxNQUFLemtDLFlBQUwsQ0FBa0IsTUFBbEIsQ0FBTCxFQUFnQztjQUN6QkYsWUFBTCxDQUFrQixNQUFsQixFQUEwQixNQUExQjs7O29CQUdVeW9CLEtBQVosUUFBd0IsWUFBTTtZQUN0Qi9zQixPQUFPLE1BQUsrMEQsS0FBTCxJQUFjLE1BQUtwOEQsWUFBTCxDQUFrQixNQUFsQixDQUEzQjtnQkFDUSxNQUFLODlELElBQUwsQ0FBVXoyRCxJQUFWLENBQVI7T0FGRjtLQVBGOzs7Ozs7d0NBY2tCOzs7VUFDZCxDQUFDMUksT0FBS0gsS0FBTCxDQUFXLEtBQUtzSyxVQUFoQixFQUE0QixjQUE1QixDQUFMLEVBQWtEO2VBQzNDekYsS0FBTCxDQUFXLHdDQUFYOzs7V0FHR2s1RCxNQUFMLEdBQWMsSUFBSXBHLFdBQUosQ0FBZ0I7aUJBQ25CLElBRG1CO3dCQUVaLEtBQUtuL0MsYUFGTztrQkFHbEIsb0JBQU07aUJBQ1RvMEMsUUFBTCxJQUFpQixPQUFLQSxRQUFMLENBQWMsQ0FBZCxFQUFpQixPQUFLd2pCLGFBQXRCLENBQWpCO2lCQUNLNW1FLElBQUw7U0FMMEI7a0JBT2xCLGtCQUFDd1IsUUFBRCxFQUFXbFksS0FBWCxFQUFxQjtpQkFDeEI4cEQsUUFBTCxJQUFpQixPQUFLQSxRQUFMLENBQWM1eEMsV0FBU2xZLEtBQXZCLENBQWpCO2lCQUNLNm1FLFNBQUwsQ0FBZTViLFNBQWYsQ0FBeUIveUMsUUFBekI7U0FUMEI7a0JBV2xCLG9CQUFNO2lCQUNUNHhDLFFBQUwsSUFBaUIsT0FBS0EsUUFBTCxDQUFjLENBQWQsRUFBaUIsT0FBS3dqQixhQUF0QixDQUFqQjtpQkFDS3pyQyxLQUFMO1NBYjBCO3NCQWVkO2lCQUFNanJCLEtBQUttSixHQUFMLENBQVMsQ0FBVCxFQUFZbkosS0FBS2tKLEdBQUwsQ0FBUyxDQUFULEVBQVlxcUMsV0FBVyxPQUFLenJELFlBQUwsQ0FBa0IsZ0JBQWxCLENBQVgsS0FBbUQsR0FBL0QsQ0FBWixDQUFOO1NBZmM7aUJBZ0JuQjtpQkFBTSxPQUFLMnJFLElBQVg7U0FoQm1CO3dCQWlCWiwwQkFBTTtjQUNka0QsU0FBUyxPQUFLSixNQUFMLEtBQWdCaEIsWUFBL0I7aUJBQ0tnQixNQUFMLEdBQWNkLGNBQWQ7aUJBQ09rQixNQUFQO1NBcEIwQjtxQkFzQmYscUJBQUN4L0QsS0FBRCxFQUFRbUssUUFBUixFQUFxQjtjQUMxQjJ4RCxTQUFTLE9BQUtBLE1BQXBCO2NBQ00yRCxZQUFZLFNBQVpBLFNBQVk7bUJBQUssT0FBS25ELElBQUwsS0FBYyxNQUFkLEdBQ2pCLzdDLE1BQU0sTUFBTixJQUFnQnU3QyxNQUFqQixJQUE2QnY3QyxNQUFNLE9BQU4sSUFBaUIsQ0FBQ3U3QyxNQUQ3QixHQUVqQnY3QyxNQUFNLE1BQU4sSUFBZ0IsQ0FBQ3U3QyxNQUFsQixJQUE4QnY3QyxNQUFNLE9BQU4sSUFBaUJ1N0MsTUFGbEM7V0FBbEI7O2NBSU0xTyxPQUFPdmtELEtBQUttSixHQUFMLENBQVMsQ0FBVCxFQUFZM2YsU0FBUyxPQUFLMUIsWUFBTCxDQUFrQixvQkFBbEIsQ0FBVCxFQUFrRCxFQUFsRCxLQUF5RCxDQUFyRSxDQUFiOztpQkFFTyxPQUFLK3VFLEtBQUwsS0FBZXhCLFVBQWYsSUFBNkIsT0FBS21CLEtBQUwsQ0FBVzU3QyxRQUFYLEVBQTdCLElBQXNELE9BQUtrOEMsZ0JBQUwsRUFBdEQsSUFDRixDQUFDRixVQUFVei9ELE1BQU1rSyxPQUFOLENBQWNtSixTQUF4QixDQURDLElBRUQsQ0FBQ3lvRCxNQUFELElBQVcxTyxTQUFTLENBQXBCLElBQXlCampELFdBQVdpakQsSUFGMUM7O09BOUJVLENBQWQ7O1dBb0NLbnNCLHdCQUFMLENBQThCLFdBQTlCOzttQkFFYSxJQUFiLEVBQW1CLFlBQU07ZUFDbEJwTSxXQUFMLENBQWlCcU0sa0JBQWpCLENBQW9DdHhDLE9BQXBDLENBQTRDO2lCQUFRLE9BQUtxeEMsd0JBQUwsQ0FBOEIyYyxJQUE5QixFQUFvQyxJQUFwQyxFQUEwQyxPQUFLanRELFlBQUwsQ0FBa0JpdEQsSUFBbEIsQ0FBMUMsQ0FBUjtTQUE1QztPQURGOzs7OzJDQVNxQjtXQUNoQnNQLE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVk5ekMsT0FBWixFQUFmO1dBQ0swL0MsU0FBTCxHQUFpQixLQUFLeUcsYUFBTCxHQUFxQixLQUFLclMsTUFBTCxHQUFjLElBQXBEOzs7OzZDQU91Qjc5RCxNQUFNa08sTUFBTUMsU0FBUztjQUNwQ25PLElBQVI7YUFDTyxXQUFMO2VBQ082OUQsTUFBTCxJQUFlLEtBQUtBLE1BQUwsQ0FBWVcsTUFBWixFQUFmOzthQUVHLE9BQUw7b0JBQ1ksS0FBS2w5RCxZQUFMLENBQWtCLE9BQWxCLENBQVYsQ0FERjtlQUVPakIsS0FBTCxDQUFXdUMsS0FBWCxHQUFtQixjQUFjTCxJQUFkLENBQW1CNEwsT0FBbkIsSUFBOEJBLE9BQTlCLEdBQXdDLEtBQTNEOzs7ZUFHS2xPLE9BQUs4VixRQUFMLGNBQXlCL1YsSUFBekIsQ0FBTCxFQUF1Q21PLE9BQXZDOzs7OzsrQkFJS25PLE1BQU07VUFDWEEsS0FBS0wsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFkLE1BQXFCLEtBQXpCLEVBQWdDO2VBQ3ZCTSxPQUFLcVgsbUJBQUwsQ0FBeUIsSUFBekIsRUFBK0J0WCxJQUEvQixFQUFxQyxFQUFDaXRFLE1BQU0sSUFBUCxFQUFyQyxDQUFQOztVQUVFbk4sYUFBYSxLQUFqQjs7YUFFS3hvRCxtQkFBTCxDQUF5QixJQUF6QixFQUErQnRYLElBQS9CLEVBQXFDO2NBQzdCLElBRDZCO2dCQUUzQjtpQkFBTTgvRCxhQUFhLElBQW5COztPQUZWOzthQUtPQSxVQUFQOzs7O3VDQUdpQjs7O2FBQ1YsQ0FBQyxDQUFDNy9ELE9BQUs4VSxTQUFMLENBQWUsS0FBS3VELGFBQXBCLEVBQ1A7ZUFBTXZPLGNBQWMsT0FBS3k3QixXQUFuQixJQUFrQ3o3QixhQUFsQyxJQUFpREEsR0FBR3NtRSxLQUFILEtBQWF2QixhQUE5RCxJQUErRS9rRSxHQUFHMGlFLE1BQXhGO09BRE8sQ0FBVDs7OztzQ0FLcUQ7VUFBdkMzbkUsS0FBdUMsdUVBQS9CLEtBQUt4RCxZQUFMLENBQWtCLFVBQWxCLENBQStCOztVQUNqRHdELFVBQVUsSUFBVixJQUFrQkEsVUFBVSxPQUFoQyxFQUF5QzthQUNsQ21yRSxrQkFBTCxDQUF3Qmg2QyxPQUF4QjtlQUNPLEtBQUt1NUMsV0FBTCxDQUFpQlgsVUFBakIsQ0FBUDs7VUFFRS9wRSxVQUFVLEVBQVYsSUFBZ0JBLFVBQVUsVUFBOUIsRUFBMEM7YUFDbkNtckUsa0JBQUwsQ0FBd0JoNkMsT0FBeEI7ZUFDTyxLQUFLdTVDLFdBQUwsQ0FBaUJWLGFBQWpCLENBQVA7OztXQUdHbUIsa0JBQUwsQ0FBd0JiLFlBQXhCLENBQXFDdHFFLEtBQXJDOzs7O2dDQUdVb29FLE1BQU07VUFDWkEsU0FBUyxLQUFLbUQsS0FBbEIsRUFBeUI7YUFDbEJBLEtBQUwsR0FBYW5ELElBQWI7YUFDS2pnRSxZQUFMLENBQWtCLE1BQWxCLEVBQTBCaWdFLElBQTFCLEVBRnVCOztZQUluQkEsU0FBUzJCLFVBQWIsRUFBeUI7ZUFDbEJwRixTQUFMLElBQWtCLEtBQUtBLFNBQUwsQ0FBZThHLFVBQWYsRUFBbEI7ZUFDS1IsTUFBTCxHQUFjaEIsWUFBZDtTQUZGLE1BR087ZUFDQXRGLFNBQUwsSUFBa0IsS0FBS0EsU0FBTCxDQUFlOEYsUUFBZixDQUF3QixJQUF4QixDQUFsQjtlQUNLUSxNQUFMLEtBQWdCZixVQUFoQixJQUE4QixLQUFLdkYsU0FBTCxDQUFlbmdFLElBQWYsRUFBOUI7OztlQUdHZ08sbUJBQUwsQ0FBeUIsSUFBekIsRUFBK0IsWUFBL0IsRUFBNkMsRUFBRTIxRCxNQUFNLElBQVIsRUFBY0MsVUFBZCxFQUE3Qzs7Ozs7dUNBSXlEO1VBQTVDcmhFLFNBQTRDLHVFQUFoQyxLQUFLdkssWUFBTCxDQUFrQixXQUFsQixDQUFnQzs7VUFDdkQsS0FBSzhJLFVBQVQsRUFBcUI7YUFDZHEvRCxTQUFMLElBQWtCLEtBQUtBLFNBQUwsQ0FBZThHLFVBQWYsRUFBbEI7YUFDSzlHLFNBQUwsR0FBaUIsS0FBS2puQixnQkFBTCxDQUFzQjVCLFdBQXRCLENBQWtDLEVBQUMvMEMsb0JBQUQsRUFBbEMsQ0FBakI7YUFDSzQ5RCxTQUFMLENBQWU4RixRQUFmLENBQXdCLElBQXhCO2FBQ0tXLGFBQUwsR0FBcUI7a0JBQ1gsS0FBS3pHLFNBQUwsQ0FBZXQ5RCxRQURKO29CQUVULEtBQUtzOUQsU0FBTCxDQUFldDlEO1NBRjNCOzs7Ozs4Q0FPb0U7VUFBaERySCxLQUFnRCx1RUFBeEMsS0FBS3hELFlBQUwsQ0FBa0IsbUJBQWxCLENBQXdDOztXQUNqRW1vRSxTQUFMLENBQWUrRyxhQUFmLENBQTZCMWxFLGdCQUFnQjgzQywyQkFBaEIsQ0FBNEM5OUMsS0FBNUMsQ0FBN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBb0dHNEcsU0FBUzthQUNMLEtBQUtzTSxNQUFMLENBQVl0TSxPQUFaLEVBQXFCLElBQXJCLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBbUJJQSxTQUFTO2FBQ04sS0FBS3NNLE1BQUwsQ0FBWXRNLE9BQVosRUFBcUIsS0FBckIsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBYzBCOzs7VUFBckJBLE9BQXFCLHVFQUFYLEVBQVc7VUFBUCtCLEtBQU87O1VBQ3BCZ21ELGFBQWEsT0FBT2htRCxLQUFQLEtBQWlCLFNBQWpCLEdBQTZCQSxLQUE3QixHQUFxQyxDQUFDLEtBQUtnL0QsTUFBOUQ7VUFDTTUyRCxTQUFTNDlDLGFBQWEsTUFBYixHQUFzQixPQUFyQztVQUNFZ2QsY0FBY2hkLGFBQWF1YixVQUFiLEdBQTBCRCxZQUQxQzs7VUFHSSxLQUFLc0IsS0FBTCxLQUFleEIsVUFBbkIsRUFBK0I7ZUFDdEJqbUUsUUFBUUMsT0FBUixDQUFnQixLQUFoQixDQUFQOztVQUVFLEtBQUtrbkUsTUFBTCxLQUFnQlUsV0FBcEIsRUFBaUM7ZUFDeEI3bkUsUUFBUUMsT0FBUixDQUFnQixJQUFoQixDQUFQOztVQUVFLEtBQUttbkUsS0FBTCxDQUFXNTdDLFFBQVgsRUFBSixFQUEyQjtlQUNsQnhyQixRQUFRRSxNQUFSLENBQWUsa0RBQWYsQ0FBUDs7VUFFRTJxRCxjQUFjLEtBQUs2YyxnQkFBTCxFQUFsQixFQUEyQztlQUNsQzFuRSxRQUFRRSxNQUFSLENBQWUsK0JBQWYsQ0FBUDs7VUFFRSxLQUFLNG5FLFVBQUwsU0FBc0I3NkQsTUFBdEIsQ0FBSixFQUFxQztlQUM1QmpOLFFBQVFFLE1BQVIscUJBQWlDK00sTUFBakMsYUFBUDs7O1VBR0lvZSxTQUFTLEtBQUsrN0MsS0FBTCxDQUFXNzNDLElBQVgsRUFBZjtXQUNLNDNDLE1BQUwsR0FBY2QsY0FBZDs7YUFFTyxJQUFJcm1FLE9BQUosQ0FBWSxtQkFBVztlQUN2QjZnRSxTQUFMLENBQWU1ekQsTUFBZixFQUF1QixZQUFNO2lCQUN0QjRFLGdCQUFMLENBQXNCZzVDLFVBQXRCO2lCQUNLc2MsTUFBTCxHQUFjVSxXQUFkOztpQkFFS0MsVUFBTCxVQUF1Qjc2RCxNQUF2QjtrQkFDUXhPLFFBQVIsWUFBNEIySixRQUE1QixJQUF3Q3RGLFFBQVFyRSxRQUFSLFFBQXhDOztTQUxGO09BREssQ0FBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQTJCR3NCLE1BQW9COzs7VUFBZCtDLE9BQWMsdUVBQUosRUFBSTs7V0FDbEJneUQsS0FBTCxHQUFhLzBELElBQWI7VUFDTXRCLFdBQVdxRSxRQUFRckUsUUFBUixJQUFxQixZQUFNLEVBQTVDOzthQUVPLElBQUl1QixPQUFKLENBQVksbUJBQVc7WUFDeEJpa0UsYUFBYSxPQUFLbEssUUFBTCxJQUFpQixJQUFsQzs7ZUFFS25GLFdBQUwsQ0FBaUI0QixJQUFqQixDQUFzQixFQUFDejJELFVBQUQsRUFBT3lHLGNBQVAsRUFBdEIsRUFBNEMsdUJBQWU7Y0FDckR5OUQsVUFBSixFQUFnQjttQkFDVHJQLFdBQUwsQ0FBaUJxQixNQUFqQixDQUF3QmdPLFVBQXhCO3lCQUNhLElBQWI7Ozt1QkFHVzttQkFBTSxPQUFLdk8sS0FBTCxFQUFOO1dBQWI7O21CQUVTaHFDLFdBQVQ7a0JBQ1FBLFdBQVI7U0FURjtPQUhLLENBQVA7Ozs7NEJBaUJNO1VBQ0YsS0FBS3F1QyxRQUFULEVBQW1CO2FBQ1pBLFFBQUwsQ0FBY3JFLEtBQWQ7Ozs7OzRCQUlJO1VBQ0YsS0FBS3FFLFFBQVQsRUFBbUI7YUFDWkEsUUFBTCxDQUFjMUQsS0FBZDs7Ozs7K0JBSU87VUFDTCxLQUFLMEQsUUFBVCxFQUFtQjthQUNabkYsV0FBTCxDQUFpQnFCLE1BQWpCLENBQXdCLEtBQUs4RCxRQUE3Qjs7V0FFRzl6RCxNQUFMOzs7OzJCQXpUUzthQUNGLEtBQUt2TixZQUFMLENBQWtCLE1BQWxCLE1BQThCLE9BQTlCLEdBQXdDLE9BQXhDLEdBQWtELE1BQXpEOzs7OzJCQW1HUzthQUNGLEtBQUtvOEQsS0FBWjs7Ozs7Ozt5QkFNTy8wRCxNQUFNO1dBQ1IrMEQsS0FBTCxHQUFhLzBELElBQWI7Ozs7MkJBR2E7YUFDTixLQUFLOEksUUFBTCxDQUFjLENBQWQsQ0FBUDs7Ozs7Ozs7Ozs7OzJCQVNlO2FBQ1IsS0FBSytyRCxXQUFaOzt5QkFHYTlvQyxRQUFRO1VBQ2pCLEVBQUVBLGtCQUFrQkQsVUFBcEIsQ0FBSixFQUFxQztlQUM5QnphLGVBQUw7O1dBRUd3akQsV0FBTCxHQUFtQjlvQyxNQUFuQjs7Ozs7Ozs7Ozs7Ozs7MkJBV1M7YUFDRixLQUFLMjdDLEtBQVo7Ozs7Ozs7Ozs7Ozs7MkJBVVk7YUFDTCxLQUFLM2pCLFFBQVo7O3lCQUdVNW5ELE9BQU87VUFDYkEsU0FBUyxFQUFFQSxpQkFBaUJrTSxRQUFuQixDQUFiLEVBQTJDO2VBQ3BDck0sS0FBTCxDQUFXLDhCQUFYOztXQUVHK25ELFFBQUwsR0FBZ0I1bkQsS0FBaEI7Ozs7Ozs7Ozs7Ozs7OzJCQVdXO2FBQ0osS0FBS3VyRSxLQUFMLEtBQWV2QixhQUFmLElBQWdDLEtBQUtpQixNQUFMLEtBQWdCaEIsWUFBdkQ7Ozs7MkJBbEs4QjthQUN2QixDQUFDLFdBQUQsRUFBYyxPQUFkLEVBQXVCLFVBQXZCLEVBQW1DLFdBQW5DLEVBQWdELG1CQUFoRCxDQUFQOzs7OzJCQWtUa0I7YUFDWCxDQUFDLFNBQUQsRUFBWSxVQUFaLEVBQXdCLFVBQXhCLEVBQW9DLFdBQXBDLEVBQWlELFlBQWpELENBQVA7Ozs7MkJBR3VCO2FBQ2hCN1IsYUFBUDs7OztFQXpqQjZDbmQ7O0FBNmpCakQ3a0MsWUFBWXkxRCxZQUFaLEdBQTJCYixtQkFBM0I7QUFDQTl4QyxlQUFlTCxNQUFmLENBQXNCLG1CQUF0QixFQUEyQ215QyxtQkFBM0M7O0FDcHNCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFRQSxJQUFNaGhFLFlBQVM7TUFDVCxXQURTO29CQUVLLGtCQUZMO3FCQUdNLG1CQUhOO3FCQUlNO0NBSnJCOztBQU9BLElBQU04aEUsWUFBWTtPQUNYLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FEVztZQUVOLENBQUMsQ0FBRCxFQUFJLEVBQUo7Q0FGWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkJxQkM7OzsyQkFFTDs7Ozs7d0JBR08sWUFBTTtZQUNsQmovQix3QkFBTCxDQUE4QixVQUE5QixFQUEwQyxJQUExQyxFQUFnRCxNQUFLdHdDLFlBQUwsQ0FBa0IsVUFBbEIsQ0FBaEQ7S0FERjs7VUFJS2tyRCxTQUFMLEdBQWlCLE1BQUtBLFNBQUwsQ0FBZXhtRCxJQUFmLE9BQWpCO1VBQ0tpdkQsVUFBTCxHQUFrQixNQUFLQSxVQUFMLENBQWdCanZELElBQWhCLE9BQWxCO1VBQ0s4cUUsY0FBTCxHQUFzQixDQUF0Qjs7Ozs7Ozs7OztpQ0E0Qlcvb0UsR0FBRztVQUNSaU8sSUFBSSxLQUFLKzZELFVBQWY7YUFDT3YzRCxLQUFLa0osR0FBTCxDQUFTMU0sRUFBRSxDQUFGLENBQVQsRUFBZXdELEtBQUttSixHQUFMLENBQVMzTSxFQUFFLENBQUYsQ0FBVCxFQUFlLEtBQUtnN0QsT0FBTCxHQUFlanBFLEVBQUU4UyxPQUFGLENBQVVpSSxNQUF4QyxDQUFmLENBQVA7Ozs7dUNBR2lCO2FBQ1p4TCxtQkFBTCxDQUF5QixJQUF6QixFQUErQixRQUEvQixFQUF5QztlQUNoQyxLQUFLby9DLE9BRDJCO2dCQUUvQixJQUYrQjt1QkFHeEI7T0FIakI7Ozs7OEJBT1EvbEQsT0FBTztVQUNYQSxTQUFTQSxNQUFNa0wsZUFBbkIsRUFBb0M7Y0FDNUJBLGVBQU47OztXQUdHbzFELGdCQUFMOzs7OzZCQUdPbnNELElBQUk7VUFDUEEsR0FBRzljLE1BQUgsQ0FBVXlHLFNBQVYsQ0FBb0I2RyxRQUFwQixDQUFnQyxLQUFLNDdELG1CQUFyQyxpQkFDRXBzRCxHQUFHMkQsU0FBSCxHQUFlLEtBQUtxb0QsY0FBcEIsR0FBcUMsRUFEM0M7UUFFRTthQUNHMTJELGNBQUg7O1dBRUcwMkQsY0FBTCxHQUFzQmhzRCxHQUFHMkQsU0FBekI7Ozs7NEJBR00xZ0IsR0FBRztVQUNMLENBQUMsS0FBSzB5QixRQUFWLEVBQW9CO3FCQUNMbnRCLFdBQWIsQ0FBeUIsSUFBekIsRUFBK0IsUUFBL0I7aUJBQ1NsRyxnQkFBVCxDQUEwQixTQUExQixFQUFxQyxLQUFLNnRELFVBQTFDOzs7OztpQ0FJU2x0RCxHQUFHO1VBQ1YsS0FBSzB5QixRQUFMLElBQWlCLENBQUMsTUFBRCxFQUFTLE9BQVQsRUFBa0JyNUIsT0FBbEIsQ0FBMEIyRyxFQUFFOFMsT0FBRixDQUFVbUosU0FBcEMsTUFBbUQsQ0FBQyxDQUF6RSxFQUE0RTtxQkFDN0QzVyxjQUFiLENBQTRCLElBQTVCLEVBQWtDLFFBQWxDOzs7O1FBSUErN0MsUUFBRixHQUFhLElBQWI7O21CQUVhOTdDLFdBQWIsQ0FBeUIsSUFBekIsRUFBK0IsUUFBL0I7V0FDSzBqRSxPQUFMLEdBQWUsS0FBS0QsVUFBTCxDQUFnQixLQUFLcmEsT0FBTCxHQUFlLENBQWYsR0FBbUIsQ0FBbkMsQ0FBZixDQVRjOztXQVdUdHZELGdCQUFMLENBQXNCLE1BQXRCLEVBQThCLEtBQUs4dEQsT0FBbkM7ZUFDUzl0RCxnQkFBVCxDQUEwQixTQUExQixFQUFxQyxLQUFLNnRELFVBQTFDOzs7OzRCQUdNbHRELEdBQUc7UUFDUDhULGVBQUY7V0FDS3MxRCxPQUFMLENBQWE5d0UsS0FBYixDQUFtQjZSLElBQW5CLEdBQTBCLEtBQUtrL0QsWUFBTCxDQUFrQnJwRSxDQUFsQixJQUF1QixJQUFqRDs7OzsrQkFHU0EsR0FBRztVQUNOaU8sSUFBSSxLQUFLKzZELFVBQWY7VUFDTXY0RCxXQUFXLEtBQUs0NEQsWUFBTCxDQUFrQnJwRSxDQUFsQixDQUFqQjtVQUNNc3BFLGdCQUFnQixLQUFLM2EsT0FBM0I7O1dBRUtBLE9BQUwsR0FBZWwrQyxZQUFZLENBQUN4QyxFQUFFLENBQUYsSUFBT0EsRUFBRSxDQUFGLENBQVIsSUFBZ0IsQ0FBM0M7O1VBRUksS0FBSzBnRCxPQUFMLEtBQWlCMmEsYUFBckIsRUFBb0M7YUFDN0JKLGdCQUFMOzs7V0FHRzlwRSxtQkFBTCxDQUF5QixNQUF6QixFQUFpQyxLQUFLK3RELE9BQXRDO2VBQ1MvdEQsbUJBQVQsQ0FBNkIsU0FBN0IsRUFBd0MsS0FBSzh0RCxVQUE3Qzs7V0FFS2tjLE9BQUwsQ0FBYTl3RSxLQUFiLENBQW1CNlIsSUFBbkIsR0FBMEIsRUFBMUI7bUJBQ2E3RSxjQUFiLENBQTRCLElBQTVCLEVBQWtDLFFBQWxDOzs7OzRCQUdhO1VBQVR5WCxFQUFTLHVFQUFKLEVBQUk7O1VBQ1QsQ0FBQyxLQUFLMlYsUUFBVixFQUFvQjthQUNiaThCLE9BQUwsR0FBZSxDQUFDLEtBQUtBLE9BQXJCO2FBQ0t1YSxnQkFBTDthQUNLSCxjQUFMLEdBQXNCaHNELEdBQUcyRCxTQUFILElBQWdCLENBQXRDOzs7Ozt3Q0FZZ0I7OzttQkFDTCxJQUFiLEVBQW1CLFlBQU07ZUFDbEJzdEMsTUFBTCxDQUFZM3VELGdCQUFaLENBQTZCLFFBQTdCLEVBQXVDLE9BQUtvbEQsU0FBNUM7T0FERjs7V0FJS3BsRCxnQkFBTCxDQUFzQixXQUF0QixFQUFtQyxLQUFLbytELFlBQXhDO1dBQ0twK0QsZ0JBQUwsQ0FBc0IsTUFBdEIsRUFBOEIsS0FBS29pRSxPQUFuQztXQUNLcGlFLGdCQUFMLENBQXNCLEtBQXRCLEVBQTZCLEtBQUtrcUUsS0FBbEM7V0FDS2xxRSxnQkFBTCxDQUFzQixPQUF0QixFQUErQixLQUFLODlDLFFBQXBDO1dBQ0tyRixnQkFBTCxHQUF3QixJQUFJbmdDLGVBQUosQ0FBb0IsSUFBcEIsRUFBMEIsRUFBRTBLLGlCQUFpQixDQUFuQixFQUFzQmMsYUFBYSxHQUFuQyxFQUF3QzNCLFNBQVMsSUFBakQsRUFBMUIsQ0FBeEI7Ozs7MkNBR3FCOzs7bUJBQ1IsSUFBYixFQUFtQixZQUFNO2VBQ2xCd3NDLE1BQUwsQ0FBWTV1RCxtQkFBWixDQUFnQyxRQUFoQyxFQUEwQyxPQUFLcWxELFNBQS9DO09BREY7O1dBSUtybEQsbUJBQUwsQ0FBeUIsV0FBekIsRUFBc0MsS0FBS3ErRCxZQUEzQztXQUNLcitELG1CQUFMLENBQXlCLE1BQXpCLEVBQWlDLEtBQUtxaUUsT0FBdEM7V0FDS3JpRSxtQkFBTCxDQUF5QixLQUF6QixFQUFnQyxLQUFLbXFFLEtBQXJDO1dBQ0tucUUsbUJBQUwsQ0FBeUIsT0FBekIsRUFBa0MsS0FBSys5QyxRQUF2QztVQUNJLEtBQUtyRixnQkFBVCxFQUEyQjthQUNwQkEsZ0JBQUwsQ0FBc0I5MUIsT0FBdEI7Ozs7OzZDQVFxQi9wQixNQUFNa08sTUFBTUMsU0FBUztVQUN4Q25PLFNBQVMsVUFBYixFQUF5QjtZQUNqQnd1RCxLQUFLLENBQUNyZ0QsV0FBVyxFQUFaLEVBQWdCL00sT0FBaEIsQ0FBd0IsVUFBeEIsTUFBd0MsQ0FBQyxDQUFwRDthQUNLMnZFLFVBQUwsR0FBa0JILFVBQVVwaUIsS0FBSyxVQUFMLEdBQWtCLEtBQTVCLENBQWxCOzs7NElBRzZCeHVELElBQS9CLEVBQXFDa08sSUFBckMsRUFBMkNDLE9BQTNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBeEpZO2FBQ0xXLFNBQVA7Ozs7MkJBR3NCO2FBQ2YsUUFBUDs7OzsyQkFHYzt1Q0FFRyxLQUFLaEYsSUFEdEIsaUJBQ3NDLEtBQUtpNkMsaUJBRDNDLHFDQUVnQixLQUFLQSxpQkFGckIsd0NBR2tCLEtBQUtBLGlCQUh2QiwwQ0FJb0IsS0FBS0EsaUJBSnpCOzs7OzJCQVVTO2FBQ0YsVUFBUDs7OzsyQkF3Rlk7YUFDTCxLQUFLcDhDLGFBQUwsT0FBdUIsS0FBS284QyxpQkFBNUIsY0FBUDs7OzsyQkFHYTthQUNOLEtBQUtnUyxNQUFaOzs7OzJCQTZCOEI7NklBQ08sVUFBckM7Ozs7RUE3SnVDVTs7QUE2UDNDdjdDLFlBQVlxMkQsTUFBWixHQUFxQlYsYUFBckI7QUFDQTd5QyxlQUFlTCxNQUFmLENBQXNCLFlBQXRCLEVBQW9Da3pDLGFBQXBDOztBQ3pUQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFTQSxJQUFNL2hFLFlBQVM7c0JBQ08sb0JBRFA7cUJBRU0sbUJBRk47YUFHRjtDQUhiOztBQU1BLElBQU1vdUQsZ0JBQWM7Ozs7O09BQUEsaUJBS1pzVSxhQUxZLEVBS0ducUUsUUFMSCxFQUthOzs7Q0FMakM7O0FBVUEsQUFDQSxJQUFNb3FFLE9BQU8sU0FBUEEsSUFBTyxDQUFDQyxFQUFELEVBQUtDLEVBQUwsRUFBU0MsQ0FBVDtTQUFlLENBQUMsSUFBSUEsQ0FBTCxJQUFVRixFQUFWLEdBQWVFLElBQUlELEVBQWxDO0NBQWI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWtEcUJFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkFzSEw7Ozs7O1VBRVBDLGFBQUwsR0FBcUI3eEUsT0FBS3laLEtBQUwsRUFBckIsQ0FGWTt3QkFHTzthQUFNLE1BQUs2cEMsUUFBTCxFQUFOO0tBQW5COzs7Ozs7d0NBR2tCOzs7VUFDZCxDQUFDLEtBQUswSSxPQUFWLEVBQW1CO2FBQ1pBLE9BQUwsR0FBZSxJQUFJakcsTUFBSixDQUFXO3NCQUNaO21CQUFNLE9BQUs1dUMsZUFBWDtXQURZOzJCQUVQO21CQUFNLE9BQUs5VixZQUFMLENBQWtCLGFBQWxCLEtBQW9DLE9BQUtBLFlBQUwsQ0FBa0IsY0FBbEIsQ0FBMUM7V0FGTzs4QkFHSixLQUFLeXdFLG1CQUFMLENBQXlCL3JFLElBQXpCLENBQThCLElBQTlCLENBSEk7MEJBSVI7bUJBQU1oRCxTQUFTLE9BQUsxQixZQUFMLENBQWtCLG1CQUFsQixLQUEwQyxFQUFuRCxFQUF1RCxFQUF2RCxDQUFOO1dBSlE7NEJBS047bUJBQU0sSUFBTjtXQUxNO3lCQU1ULEtBQUswd0UsWUFBTCxDQUFrQmhzRSxJQUFsQixDQUF1QixJQUF2QixDQU5TOzBCQU9SLEtBQUtpc0UsYUFBTCxDQUFtQmpzRSxJQUFuQixDQUF3QixJQUF4QixDQVBRO3VCQVFYLEtBQUt5bUQsVUFBTCxDQUFnQnptRCxJQUFoQixDQUFxQixJQUFyQixDQVJXO3NCQVNaLEtBQUt3N0QsU0FBTCxDQUFleDdELElBQWYsQ0FBb0IsSUFBcEI7U0FUQyxDQUFmOztxQkFZYSxJQUFiLEVBQW1CLFlBQU07aUJBQ2xCa3NFLGFBQUwsR0FBcUJqeUUsT0FBSzhVLFNBQUwsQ0FBZSxPQUFLbzlELGNBQXBCLEVBQW9DLGlCQUFwQyxDQUFyQjtpQkFDS2xtQixPQUFMLENBQWEzVSxJQUFiLENBQWtCLEVBQUV1UCxXQUFXLE9BQUsxNUMsWUFBTCxDQUFrQixXQUFsQixDQUFiLEVBQWxCO1NBRkY7OzttQkFNVyxJQUFiLEVBQW1CLFlBQU07ZUFDbEJrcUIsZUFBTDs7WUFFSSxDQUFDcDNCLE9BQUtpUCxVQUFMLFNBQXNCLFVBQXRCLEVBQWtDO2lCQUFLakwsTUFBTTFFLFNBQVNtSSxJQUFwQjtTQUFsQyxDQUFMLEVBQWtFO2lCQUMzRDQyRCxLQUFMLEdBRGdFOztPQUhwRTs7OzsyQ0FTcUI7VUFDakIsS0FBS3JTLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhbEYsV0FBakMsRUFBOEM7YUFDdkNrRixPQUFMLENBQWFsaUMsT0FBYjthQUNLa2lDLE9BQUwsR0FBZSxJQUFmO2FBQ0tpbUIsYUFBTCxHQUFxQixJQUFyQjthQUNLRSxTQUFMLEdBQWlCLElBQWpCOzs7OztvQ0FJWXpoRSxPQUFPOzBCQUNUQSxLQUFaLElBQW1CbkIsT0FBT21CLE1BQU1pNkMsV0FBaEMsRUFBNkN5bkIsU0FBUyxLQUFLQyxJQUFMLENBQVUzaEUsTUFBTWk2QyxXQUFoQixDQUF0RDs7OztrQ0FHWWo2QyxPQUFPO2NBQ1gsS0FBSzRoRSxlQUFMLENBQXFCNWhFLEtBQXJCLENBQVI7YUFDSzJHLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLFlBQS9CLEVBQTZDM0csS0FBN0M7VUFDTWhJLE9BQU9nSSxNQUFNMGhFLE9BQU4sQ0FBYy85QyxXQUEzQjtjQUNRM3JCLEtBQUsyMUQsS0FBTCxFQUFSOzs7O2lDQUdXM3RELE9BQU87Y0FDVixLQUFLNGhFLGVBQUwsQ0FBcUI1aEUsS0FBckIsQ0FBUjtZQUNNNmhFLE1BQU4sR0FBZTtlQUFNN2hFLE1BQU1reUMsUUFBTixHQUFpQixJQUF2QjtPQUFmOzthQUVLdnJDLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLFdBQS9CLEVBQTRDM0csS0FBNUM7O1VBRUksQ0FBQ0EsTUFBTWt5QyxRQUFYLEVBQXFCO3FCQUNzQmx5QyxLQUR0QjtZQUNYaTZDLFdBRFcsVUFDWEEsV0FEVztZQUNFRSxlQURGLFVBQ0VBLGVBREY7O1lBRWJ3bkIsT0FBTyxLQUFLQSxJQUFsQjs7YUFFSzFuQixXQUFMLEVBQWtCNm5CLFNBQWxCLENBQTRCLElBQTVCO1lBQ0kzbkIsbUJBQW1CLENBQXZCLEVBQTBCO2NBQ2xCNG5CLFVBQVVKLEtBQUt4bkIsZUFBTCxDQUFoQjtrQkFDUTJuQixTQUFSLENBQWtCLEtBQWxCO2tCQUNRbitDLFdBQVIsSUFBdUJvK0MsUUFBUXArQyxXQUFSLENBQW9CMnFDLEtBQXBCLEVBQXZCOzs7O2FBSUd0dUQsTUFBTWt5QyxRQUFiOzs7OzhCQUdRcnpDLE9BQXFCO1VBQWQ5RCxPQUFjLHVFQUFKLEVBQUk7O1VBQ3pCLEtBQUt3bUUsYUFBVCxFQUF3QjthQUNqQkEsYUFBTCxDQUFtQjd4RSxLQUFuQixDQUF5QjRkLFVBQXpCLGFBQTZDdlMsUUFBUVMsUUFBUixJQUFvQixDQUFqRSxZQUF1RVQsUUFBUStQLE1BQVIsSUFBa0IsRUFBekY7O1lBRUksS0FBS2szRCxTQUFMLElBQWtCLEtBQUtQLFNBQUwsQ0FBZWx4RSxNQUFmLEdBQXdCLENBQTlDLEVBQWlEO2NBQ3pDZ2IsSUFBSTFDLEtBQUtDLEtBQUwsQ0FBV2pLLEtBQVgsQ0FBVjtjQUE2QjZaLElBQUk3UCxLQUFLd3BCLElBQUwsQ0FBVXh6QixLQUFWLENBQWpDO2NBQW1EMU8sSUFBSTBPLFFBQVEsQ0FBL0Q7ZUFDSzBpRSxhQUFMLENBQW1CN3hFLEtBQW5CLENBQXlCdUMsS0FBekIsR0FBaUM2dUUsS0FBSyxLQUFLVyxTQUFMLENBQWVsMkQsQ0FBZixFQUFrQnRaLEtBQXZCLEVBQThCLEtBQUt3dkUsU0FBTCxDQUFlL29ELENBQWYsRUFBa0J6bUIsS0FBaEQsRUFBdUQ5QixDQUF2RCxJQUE0RCxJQUE3RjtlQUNLb3hFLGFBQUwsQ0FBbUI3eEUsS0FBbkIsQ0FBeUJ3aEQsU0FBekIsb0JBQW9ENHZCLEtBQUssS0FBS1csU0FBTCxDQUFlbDJELENBQWYsRUFBa0JoSyxJQUF2QixFQUE2QixLQUFLa2dFLFNBQUwsQ0FBZS9vRCxDQUFmLEVBQWtCblgsSUFBL0MsRUFBcURwUixDQUFyRCxDQUFwRDtTQUhGLE1BSU87ZUFDQW94RSxhQUFMLENBQW1CN3hFLEtBQW5CLENBQXlCd2hELFNBQXpCLG9CQUFvRHJ5QyxRQUFRLEdBQTVEOzs7O1dBSUNrOUMsUUFBTCxJQUFpQixLQUFLQSxRQUFMLENBQWNsOUMsS0FBZCxFQUFxQjlELE9BQXJCLENBQWpCOzs7O2lDQUdXO1dBQ05pbkUsU0FBTCxHQUFpQjF5RSxPQUFLNE0sV0FBTCxDQUFpQixJQUFqQixFQUF1QixVQUF2QixDQUFqQjtXQUNLdWxFLFNBQUwsR0FBaUIsS0FBS0UsSUFBTCxDQUFVeHNFLEdBQVYsQ0FBYztlQUFPOHNFLElBQUlqaEIscUJBQUosRUFBUDtPQUFkLENBQWpCO1VBQ0ksS0FBS3VnQixhQUFULEVBQXdCO2FBQ2pCQSxhQUFMLENBQW1CN3hFLEtBQW5CLENBQXlCc1IsT0FBekIsR0FBbUMsS0FBS3hFLFlBQUwsQ0FBa0IsWUFBbEIsS0FBbUNsTixPQUFLNE0sV0FBTCxDQUFpQixJQUFqQixFQUF1QixVQUF2QixDQUFuQyxHQUF3RSxPQUF4RSxHQUFrRixNQUFySDtZQUNNMkMsUUFBUSxLQUFLdzdELGlCQUFMLEVBQWQ7WUFDSSxLQUFLb0gsU0FBTCxDQUFlbHhFLE1BQWYsR0FBd0IsQ0FBeEIsSUFBNkJzTyxTQUFTLENBQTFDLEVBQTZDO2VBQ3RDMGlFLGFBQUwsQ0FBbUI3eEUsS0FBbkIsQ0FBeUJ1QyxLQUF6QixHQUFpQyxLQUFLd3ZFLFNBQUwsQ0FBZTVpRSxLQUFmLEVBQXNCNU0sS0FBdEIsR0FBOEIsSUFBL0Q7Ozs7Ozt3Q0FLYytSLFNBQVNnVSxVQUFVKy9CLE1BQU07VUFDckNwQyxRQUFRLEVBQWQsQ0FEMkM7VUFFckN4NEMsV0FBVzQ2QyxPQUFPLEdBQVAsSUFBYy96QyxVQUFVLENBQUMsQ0FBWCxHQUFlLENBQTdCLENBQWpCLENBRjJDO2FBR3BDNkUsS0FBS2tKLEdBQUwsQ0FBUyxDQUFULEVBQVlsSixLQUFLbUosR0FBTCxDQUFTLENBQVQsRUFBWTJqQyxRQUFRMzlCLFdBQVc3YSxRQUEvQixDQUFaLENBQVA7Ozs7K0JBZ0JTO2dCQUNDRixPQUFWLENBQWtCLElBQWxCOztVQUVNbkYsVUFBVSxLQUFLMk8sZUFBTCxJQUF3Qm5YLE9BQUtpVyxNQUFMLENBQVksa0JBQVosQ0FBeEM7Y0FDUXpILFNBQVIsQ0FBa0JFLEdBQWxCLENBQXNCLHFCQUF0QjtVQUNNa2tFLFNBQVMsS0FBS1YsY0FBTCxJQUF1Qmx5RSxPQUFLaVcsTUFBTCxDQUFZLFNBQVosQ0FBdEM7YUFDT3pILFNBQVAsQ0FBaUJFLEdBQWpCLENBQXFCLG9CQUFyQjs7VUFFSSxDQUFDa2tFLE9BQU96b0UsVUFBWixFQUF3QjtlQUNmLEtBQUtpUCxVQUFaLEVBQXdCO2lCQUNmclAsV0FBUCxDQUFtQixLQUFLcVAsVUFBeEI7Ozs7VUFJRXV4QyxjQUFjOUMsT0FBTyxLQUFLeG1ELFlBQUwsQ0FBa0IsYUFBbEIsQ0FBUCxDQUFwQixDQWRTO1VBZUx1eEUsT0FBT3BoRSxRQUFQLENBQWdCdlEsTUFBaEIsR0FBeUIwcEQsV0FBekIsSUFBd0MsQ0FBQzNxRCxPQUFLOFUsU0FBTCxDQUFlODlELE1BQWYsRUFBdUIsVUFBdkIsQ0FBN0MsRUFBaUY7ZUFDeEVwaEUsUUFBUCxDQUFnQm01QyxXQUFoQixFQUE2QjM5QyxZQUE3QixDQUEwQyxRQUExQyxFQUFvRCxFQUFwRDs7O1dBR0dpbEUsYUFBTCxHQUFxQmp5RSxPQUFLOFUsU0FBTCxDQUFlODlELE1BQWYsRUFBdUIsaUJBQXZCLEtBQTZDNXlFLE9BQUtpVyxNQUFMLENBQVksaUJBQVosQ0FBbEU7YUFDT2xNLFdBQVAsQ0FBbUIsS0FBS2tvRSxhQUF4QjthQUNPempFLFNBQVAsQ0FBaUJFLEdBQWpCLENBQXFCLG1CQUFyQixFQXJCUzs7T0F1QlJsRyxRQUFRZ0osUUFBUixDQUFpQixDQUFqQixDQUFELElBQXdCaEosUUFBUXVCLFdBQVIsQ0FBb0J6SyxTQUFTcUgsYUFBVCxDQUF1QixLQUF2QixDQUFwQixDQUF4QjtPQUNDNkIsUUFBUWdKLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBRCxJQUF3QmhKLFFBQVF1QixXQUFSLENBQW9CekssU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBcEIsQ0FBeEI7Y0FDUW9ELFdBQVIsR0FBc0J2QixRQUFRdUIsV0FBUixDQUFvQmhFLElBQXBCLENBQXlCeUMsUUFBUWdKLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBekIsQ0FBdEI7Y0FDUTJILFlBQVIsR0FBdUIzUSxRQUFRMlEsWUFBUixDQUFxQnBULElBQXJCLENBQTBCeUMsUUFBUWdKLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBMUIsQ0FBdkI7O1dBRUt6SCxXQUFMLENBQWlCdkIsT0FBakI7V0FDS3VCLFdBQUwsQ0FBaUI2b0UsTUFBakIsRUE3QlM7O21CQStCSWx2QixZQUFiLENBQTBCLElBQTFCLEVBQWdDNzBDLFNBQWhDOzs7O3NDQUd3RDs7O1VBQTFDMEosUUFBMEMsdUVBQS9CLEtBQUtsWCxZQUFMLENBQWtCLFVBQWxCLENBQStCOztVQUNsRHc3QixNQUFNLEtBQUs0M0IsSUFBTCxHQUFZbDhDLGFBQWEsS0FBYixJQUF1QkEsYUFBYSxNQUFiLElBQXVCdlksT0FBSzRNLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsVUFBdkIsQ0FBdEU7VUFDTWdKLFNBQVNpbkIsTUFBTTc4QixPQUFLcU4sV0FBWCxHQUF5QnJOLE9BQUtvTixjQUE3Qzs7YUFFTyxJQUFQLEVBQWEsS0FBYjs7VUFFTTFFLE9BQU8xSSxPQUFLaVAsVUFBTCxDQUFnQixJQUFoQixFQUFzQixVQUF0QixDQUFiO1VBQ0l2RyxJQUFKLEVBQVU7cUJBQ0tBLElBQWIsRUFBbUIsWUFBTTtjQUNuQjFFLElBQUksQ0FBUjtjQUNJMEUsS0FBSzhJLFFBQUwsQ0FBYyxDQUFkLEtBQW9CeFIsT0FBS0gsS0FBTCxDQUFXNkksS0FBSzhJLFFBQUwsQ0FBYyxDQUFkLENBQVgsRUFBNkIsYUFBN0IsQ0FBeEIsRUFBcUU7bUJBQzVEOUksS0FBSzhJLFFBQUwsQ0FBYyxDQUFkLENBQVAsRUFBeUIsVUFBekI7Z0JBQ0ksQ0FBSixDQUZtRTs7O2NBSy9EaEosVUFBVUUsS0FBSzR5RCxrQkFBTCxFQUFoQjtjQUNNdVgsS0FBS3p6RSxPQUFPQyxnQkFBUCxDQUF3QnFKLEtBQUs0eUQsa0JBQUwsRUFBeEIsRUFBbUQsSUFBbkQsQ0FBWDs7aUJBRUtsN0QsS0FBTCxDQUFXeThCLEdBQVgsR0FBaUJBLE1BQU05NUIsU0FBUzh2RSxHQUFHdjZELGdCQUFILENBQW9CLGFBQXBCLENBQVQsRUFBNkMsRUFBN0MsSUFBbUR0VSxDQUFuRCxHQUF1RCxJQUE3RCxHQUFvRSxFQUFyRjs7O2tCQUdRNUQsS0FBUixDQUFjeThCLEdBQWQsR0FBb0JnMkMsR0FBR2gyQyxHQUF2QjtrQkFDUXo4QixLQUFSLENBQWN5OEIsR0FBZCxHQUFvQixFQUFwQjtTQWRGOzs7aUJBa0JPaDJCLGlCQUFULENBQTJCLFlBQU07WUFDekJpc0UsU0FBUzl5RSxPQUFLaVAsVUFBTCxTQUFzQjtpQkFBS25ILEVBQUVvRixZQUFGLENBQWUsaUJBQWYsQ0FBTDtTQUF0QixDQUFmO2VBQ0tzTCxlQUFMLFNBQTJCLGlCQUEzQixFQUE4Q3FrQixPQUFPLENBQUNpMkMsTUFBdEQ7T0FGRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0ErQ1dDLFdBQXlCOzs7VUFBZHRuRSxPQUFjLHVFQUFKLEVBQUk7O1VBQzlCdW5FLFlBQVksS0FBS2pJLGlCQUFMLEVBQWxCO1VBQ00wSCxVQUFVLEtBQUtKLElBQUwsQ0FBVVcsU0FBVixDQUFoQjtVQUNFQyxVQUFVLEtBQUtaLElBQUwsQ0FBVVUsU0FBVixDQURaOztVQUdJLENBQUNFLE9BQUwsRUFBYztlQUNMdHFFLFFBQVFFLE1BQVIsQ0FBZSx5Q0FBZixDQUFQOzs7VUFHRWtxRSxjQUFjQyxTQUFsQixFQUE2QjtlQUN0QjM3RCxtQkFBTCxDQUF5QixJQUF6QixFQUErQixVQUEvQixFQUEyQyxFQUFFOUgsT0FBT3dqRSxTQUFULEVBQW9CcG9CLGFBQWFvb0IsU0FBakMsRUFBNENYLFNBQVNhLE9BQXJELEVBQTNDO2VBQ090cUUsUUFBUUMsT0FBUixDQUFnQnFxRSxRQUFRNStDLFdBQXhCLENBQVA7Ozs7VUFJSWpkLFdBQVc2N0QsUUFBUTUrQyxXQUF6QjthQUNPLENBQUNqZCxXQUFXek8sUUFBUUMsT0FBUixDQUFnQndPLFFBQWhCLENBQVgsR0FBdUM2N0QsUUFBUS9VLE1BQWhELEVBQ0pqd0MsSUFESSxDQUNDO2VBQVksT0FBSys5QixPQUFMLENBQWFyRSxjQUFiLENBQTRCb3JCLFNBQTVCO2tCQUNSO1dBQ0x0bkUsT0FGYTtxQkFHTGduRSxXQUFXcjdELFFBQVgsR0FBc0IzTCxRQUFRRyxTQUFSLElBQXFCLE9BQUt2SyxZQUFMLENBQWtCLFdBQWxCLENBQTNDLEdBQTRFLE1BSHZFOzRCQUlFckIsT0FBSytMLE1BQUwsQ0FDaEIsRUFBRUcsVUFBVSxFQUFaLEVBQWdCc1AsUUFBUSw2QkFBeEIsRUFEZ0IsRUFFaEIsT0FBS3RPLFlBQUwsQ0FBa0IsbUJBQWxCLElBQXlDbE4sT0FBS3FNLHFCQUFMLENBQTJCLE9BQUtoTCxZQUFMLENBQWtCLG1CQUFsQixDQUEzQixDQUF6QyxHQUE4RyxFQUY5RixFQUdoQm9LLFFBQVFPLGdCQUFSLElBQTRCLEVBSFo7WUFLakJpaUIsSUFUZSxDQVNWLFlBQU07a0JBQ0o3bUIsUUFBUixZQUE0QjJKLFFBQTVCLElBQXdDdEYsUUFBUXJFLFFBQVIsQ0FBaUJnUSxRQUFqQixDQUF4QztpQkFDT0EsUUFBUDtTQVhnQixDQUFaO09BREQsQ0FBUDs7Ozs7Ozs7Ozs7Ozs7d0NBd0JrQm1jLFNBQVM7OzttQkFDZCxJQUFiLEVBQW1CLFlBQU07ZUFDbEJwYyxlQUFMLENBQXFCL1csS0FBckIsQ0FBMkIsT0FBS3EwRCxJQUFMLEdBQVksS0FBWixHQUFvQixRQUEvQyxJQUEyRGxoQyxVQUFVLEVBQVYsR0FBZSxLQUExRTtlQUNLMitDLGNBQUwsQ0FBb0I5eEUsS0FBcEIsQ0FBMEJzUixPQUExQixHQUFvQzZoQixVQUFVLEVBQVYsR0FBZSxNQUFuRDttQkFDVyxPQUFLaTVCLFVBQUwsRUFBWDtPQUhGOzs7OzJCQU9LO1dBQ0EwbUIsbUJBQUwsQ0FBeUIsSUFBekI7Ozs7MkJBR0s7V0FDQUEsbUJBQUwsQ0FBeUIsS0FBekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQTBEa0M7VUFBbEJiLElBQWtCLHVFQUFYLEtBQUtBLElBQU07O1dBQzdCLElBQUlyeEUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJcXhFLEtBQUtweEUsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDO1lBQ2hDcXhFLEtBQUtyeEUsQ0FBTCxLQUFXcXhFLEtBQUtyeEUsQ0FBTCxFQUFRMkwsT0FBUixLQUFvQixTQUEvQixJQUE0QzBsRSxLQUFLcnhFLENBQUwsRUFBUW15RSxRQUFSLEVBQWhELEVBQW9FO2lCQUMzRG55RSxDQUFQOzs7YUFHRyxDQUFDLENBQVI7Ozs7NEJBR007OztXQUNEZ3JELE9BQUwsQ0FBYTk3QixJQUFiOzttQkFFYSxZQUFNO1lBQ1htaUQsT0FBTyxPQUFLQSxJQUFsQjtZQUNNMW5CLGNBQWMsT0FBS29nQixpQkFBTCxDQUF1QnNILElBQXZCLENBQXBCO2VBQ0tSLGFBQUwsQ0FBbUJqcEUsT0FBbkI7WUFDSXlwRSxLQUFLcHhFLE1BQUwsR0FBYyxDQUFkLElBQW1CMHBELGVBQWUsQ0FBdEMsRUFBeUM7ZUFDbENBLFdBQUwsRUFBa0J1VCxNQUFsQixDQUF5Qmp3QyxJQUF6QixDQUE4QjttQkFBTW5rQixNQUFNbXZDLGFBQWE7cUJBQU1udkMsR0FBR3UwRCxLQUFILEVBQU47YUFBYixDQUFaO1dBQTlCOztPQUxKOzs7OzRCQVVNO1dBQ0RyUyxPQUFMLENBQWFwOEIsSUFBYjtVQUNNNVksVUFBVSxLQUFLQSxPQUFyQjtpQkFDV0EsUUFBUWdvRCxLQUFSLEVBQVg7Ozs7K0JBR1M7V0FDSnFULElBQUwsQ0FBVS94RSxPQUFWLENBQWtCO2VBQU9xeUUsSUFBSS9qRSxNQUFKLEVBQVA7T0FBbEI7V0FDS0EsTUFBTDs7Ozs2Q0FPdUI3TyxNQUFNa08sTUFBTUMsU0FBUztVQUN4Q25PLFNBQVMsVUFBYixFQUF5QjtxQkFDVmtqRCxpQkFBYixDQUErQmgxQyxJQUEvQixFQUFxQ0MsT0FBckMsRUFBOEMsSUFBOUMsRUFBb0RXLFNBQXBEO1lBQ011a0UsUUFBUSxTQUFSQSxLQUFRO3VDQUEwQjl3RSxJQUFyQixDQUEwQndMLENBQTFCOztTQUFuQjtjQUNNRyxJQUFOLE1BQWdCbWxFLE1BQU1sbEUsT0FBTixDQUFoQixJQUFrQyxLQUFLa3BCLGVBQUwsRUFBbEM7T0FIRixNQUlPLElBQUlyM0IsU0FBUyxVQUFiLEVBQXlCO2VBQ3pCcVYsVUFBTCxDQUFnQixJQUFoQixLQUF5QixLQUFLZ2lCLGVBQUwsRUFBekI7T0FESyxNQUVBLElBQUlyM0IsU0FBUyxXQUFiLEVBQTBCO2FBQzFCaXNELE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhL0UsZUFBYixDQUE2QixLQUFLLzVDLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBN0IsQ0FBaEI7T0FESyxNQUVBLElBQUluTixTQUFTLFdBQWIsRUFBMEI7YUFDMUJtekUsbUJBQUwsQ0FBeUIsQ0FBQyxLQUFLaG1FLFlBQUwsQ0FBa0IsV0FBbEIsQ0FBRCxJQUFtQ2dCLFlBQVksT0FBeEU7Ozs7OzJCQXRSaUI7YUFDWmxPLE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixTQUFyQixDQUFQOzs7OzJCQUdvQjthQUNiOVUsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLGtCQUFyQixDQUFQOzs7OzJCQUdtQjtVQUNidE0sVUFBVSxLQUFLMk8sZUFBckI7YUFDTzNPLFdBQVdBLFFBQVFnSixRQUFSLENBQWlCLENBQWpCLENBQVgsSUFBa0MsSUFBekM7Ozs7MkJBcUVZO1VBQ042Z0UsT0FBTyxLQUFLQSxJQUFsQjtVQUNFOWlFLFFBQVEsS0FBS3c3RCxpQkFBTCxFQURWO2FBRU9zSCxLQUFLOWlFLEtBQUwsSUFDSDhpRSxLQUFLOWlFLEtBQUwsRUFBWThrQixXQUFaLElBQTJCLEtBQUs3cEIsS0FBTCxDQUFXLENBQVgsQ0FBM0IsSUFBNEMsSUFEekMsR0FFSCxJQUZKOzs7OzJCQUtVO2FBQ0h4SyxPQUFLMkosU0FBTCxDQUFlLEtBQUswcEUsY0FBTCxDQUFvQjdoRSxRQUFuQyxDQUFQOzs7OzJCQUdTO2FBQ0ZoUyxNQUFNQyxTQUFOLENBQWdCdVAsTUFBaEIsQ0FBdUJyUCxJQUF2QixDQUE0QixLQUFLdXlFLGNBQUwsQ0FBb0IxZ0UsUUFBaEQsRUFBMEQ7ZUFBSzFKLEVBQUU2RSxPQUFGLEtBQWMsU0FBbkI7T0FBMUQsQ0FBUDs7OzsyQkE0Rlk7YUFDTCxLQUFLdWxFLGNBQUwsQ0FBb0I5eEUsS0FBcEIsQ0FBMEJzUixPQUExQixLQUFzQyxNQUE3Qzs7Ozs7Ozs7Ozs7OzsyQkFVYzthQUNQLEtBQUt4RSxZQUFMLENBQWtCLFdBQWxCLENBQVA7O3lCQUdZckksT0FBTzthQUNaN0UsT0FBS3dZLGVBQUwsQ0FBcUIsSUFBckIsRUFBMkIsV0FBM0IsRUFBd0MzVCxLQUF4QyxDQUFQOzs7Ozs7Ozs7Ozs7OzJCQVVZO2FBQ0wsS0FBSzRuRCxRQUFaOzt5QkFHVTVuRCxPQUFPO1VBQ2JBLFNBQVMsRUFBRUEsaUJBQWlCa00sUUFBbkIsQ0FBYixFQUEyQztlQUNwQ3JNLEtBQUw7O1dBRUcrbkQsUUFBTCxHQUFnQjVuRCxLQUFoQjs7OzsyQkE4QzhCO2FBQ3ZCLENBQUMsVUFBRCxFQUFhLFVBQWIsRUFBeUIsV0FBekIsRUFBc0MsWUFBdEMsRUFBb0QsV0FBcEQsQ0FBUDs7OzsyQkFpQnVCO2FBQ2hCbzRELGFBQVA7Ozs7MkJBR2tCO2FBQ1gsQ0FBQyxXQUFELEVBQWMsWUFBZCxFQUE0QixVQUE1QixDQUFQOzs7O0VBbmdCdUNuZDs7QUF1Z0IzQzdrQyxZQUFZcTRELE1BQVosR0FBcUIxQixhQUFyQjtBQUNBN3pDLGVBQWVMLE1BQWYsQ0FBc0IsWUFBdEIsRUFBb0NrMEMsYUFBcEM7O0FDcm1CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFTQSxJQUFNL3NCLHNCQUFtQixjQUF6Qjs7QUFFQSxJQUFNaDJDLFlBQVM7TUFDVCxpQkFEUztxQkFFTTtDQUZyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBcURxQjBrRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBdURMOzs7OztRQUdSLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0IsT0FBbEIsRUFBMkJyeUUsSUFBM0IsQ0FBZ0MsTUFBS2dNLFlBQUwsQ0FBa0JuSCxJQUFsQixPQUFoQyxDQUFKLEVBQW1FO1lBQzVEdTlDLFFBQUw7S0FERixNQUVPOzBCQUNjO2VBQU0sTUFBS0EsUUFBTCxFQUFOO09BQW5COzs7VUFHR2lhLFdBQUwsR0FBbUJ6b0MsaUJBQW5CO1VBQ0ttd0IsUUFBTCxHQUFnQixNQUFLQSxRQUFMLENBQWNsL0MsSUFBZCxPQUFoQjs7Ozs7OytCQWNTO2dCQUNDNEgsT0FBVixDQUFrQixJQUFsQjtXQUNLYSxTQUFMLENBQWVFLEdBQWYsQ0FBbUJtMkMsbUJBQW5COztVQUVJLEtBQUsydUIsT0FBVCxFQUFrQjs7OztVQUlacnVELFNBQVNubEIsT0FBS2lXLE1BQUwsQ0FBWSx1QkFBWixDQUFmO2FBQ08sS0FBS2xCLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBUCxFQUEyQjtlQUNsQmhMLFdBQVAsQ0FBbUIsS0FBS2dMLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBbkI7OztVQUdJMGEsUUFBUXp2QixPQUFLaVcsTUFBTCxDQUFZLE9BQVosRUFBcUIsRUFBRXZFLFNBQVMsTUFBWCxFQUFyQixDQUFkO1lBQ003SCxJQUFOLEdBQWEsT0FBYjs7V0FFS0UsV0FBTCxDQUFpQjBsQixLQUFqQjtXQUNLMWxCLFdBQUwsQ0FBaUJvYixNQUFqQjs7V0FFS3N1RCxvQkFBTDttQkFDYS92QixZQUFiLENBQTBCLElBQTFCLEVBQWdDNzBDLFNBQWhDO1dBQ0ttMUMsYUFBTDs7OztvQ0FHYztXQUNUd3ZCLE9BQUwsSUFBZ0J4ekUsT0FBSytZLFlBQUwsQ0FBa0IsS0FBS3k2RCxPQUF2QixFQUFnQyxLQUFLdG1FLFlBQUwsQ0FBa0IsUUFBbEIsQ0FBaEMsQ0FBaEI7Ozs7MkNBR3FCOzs7VUFDZmlZLFNBQVMsS0FBS3F1RCxPQUFwQjs7VUFFSUUsY0FBYyxLQUFLM3ZCLEtBQXZCO1VBQ0ksS0FBSzcyQyxZQUFMLENBQWtCLE1BQWxCLENBQUosRUFBK0I7c0JBQ2Z3bUUsZUFBZTF6RSxPQUFLMkcsYUFBTCxDQUFtQix1REFBbkIsQ0FBN0I7WUFDTTZxQixPQUFPa2lELFlBQVlsaUUsUUFBWixDQUFxQixDQUFyQixDQUFiO1lBQ01taUUsTUFBTztpQkFBUTttQkFBTW5pRCxLQUFLbWdCLHdCQUFMLENBQThCLE1BQTlCLEVBQXNDMWpDLElBQXRDLEVBQTRDLE9BQUs1TSxZQUFMLENBQWtCLE1BQWxCLENBQTVDLENBQU47V0FBUjtTQUFELENBQXVGbXdCLEtBQUtud0IsWUFBTCxDQUFrQixNQUFsQixDQUF2RixDQUFaO2FBQ0syTCxZQUFMLENBQWtCLE1BQWxCLEVBQTBCLEtBQUszTCxZQUFMLENBQWtCLE1BQWxCLENBQTFCO29CQUNZZ1gsYUFBWixLQUE4QjhNLE1BQTlCLElBQXdDQSxPQUFPaE0sWUFBUCxDQUFvQnU2RCxXQUFwQixFQUFpQ3Z1RCxPQUFPL0wsVUFBeEMsQ0FBeEM7OzthQUdLdTRCLHdCQUFMLFlBQXlDNWdDLFFBQXpDLEdBQ0k0aUUsS0FESixHQUVJMTZCLGFBQWE7aUJBQU16bkIsS0FBS21nQix3QkFBTCxZQUF5QzVnQyxRQUF6QyxJQUFxRDRpRSxLQUEzRDtTQUFiLENBRko7T0FSRixNQVdPO3VCQUNVRCxZQUFZOWtFLE1BQVosRUFBZjs7O09BR0QsT0FBRCxFQUFVLE9BQVYsRUFBbUJ0TyxPQUFuQixDQUEyQixVQUFDZ3VELElBQUQsRUFBTy8rQyxLQUFQLEVBQWlCO1lBQ3RDbU0sT0FBTyxPQUFLaFUsYUFBTCxlQUErQjRtRCxJQUEvQixDQUFYO1lBQ0ksT0FBS3BoRCxZQUFMLENBQWtCb2hELElBQWxCLENBQUosRUFBNkI7aUJBQ3BCNXlDLFFBQVExYixPQUFLaVcsTUFBTCxDQUFZLGNBQVlxNEMsSUFBWixJQUFzQkEsU0FBUyxPQUFULEdBQW1CLGVBQW5CLEdBQXFDLEVBQTNELENBQVosQ0FBZjtlQUNLL2xELFdBQUwsR0FBbUIsT0FBS2xILFlBQUwsQ0FBa0JpdEQsSUFBbEIsQ0FBbkI7ZUFDS2oyQyxhQUFMLEtBQXVCOE0sTUFBdkIsSUFBaUNBLE9BQU9wYixXQUFQLENBQW1CMlIsSUFBbkIsQ0FBakM7U0FIRixNQUlPO2tCQUNHQSxLQUFLOU0sTUFBTCxFQUFSOztPQVBKOzs7OytCQWdDUztVQUNMLEtBQUsycUIsT0FBTCxZQUF3QnhvQixRQUE1QixFQUFzQzthQUMvQndvQixPQUFMO09BREYsTUFFTzthQUNBc3hDLE9BQUwsQ0FBYU0sWUFBYixDQUEwQixLQUFLNTdELEtBQS9CLEVBQXNDLEVBQUUxRyxRQUFRLEtBQVYsRUFBdEM7Ozs7O2dDQUlxQjtVQUFmK3FFLE1BQWUsdUVBQU4sSUFBTTs7V0FDbEI5ZCxNQUFMLENBQVlXLE9BQVosR0FBc0JtZCxNQUF0QjtXQUNLcGxFLFNBQUwsQ0FBZXVKLE1BQWYsQ0FBc0IsUUFBdEIsRUFBZ0M2N0QsTUFBaEM7YUFDS3A3RCxlQUFMLENBQXFCLElBQXJCLEVBQTJCLFFBQTNCLEVBQXFDbzdELE1BQXJDOztVQUVJLEtBQUsxbUUsWUFBTCxDQUFrQixNQUFsQixLQUE2QixLQUFLQSxZQUFMLENBQWtCLGFBQWxCLENBQWpDLEVBQW1FO2FBQzVENjJDLEtBQUwsQ0FBV3Z5QyxRQUFYLENBQW9CLENBQXBCLEVBQXVCeEUsWUFBdkIsQ0FBb0MsTUFBcEMsRUFBNEMsS0FBSzNMLFlBQUwsQ0FBa0J1eUUsU0FBUyxhQUFULEdBQXlCLE1BQTNDLENBQTVDOzs7OztxQ0FJYXprRSxRQUFRekcsTUFBTTs7O1dBQ3hCbXJFLFVBQUwsR0FBa0IsSUFBbEI7O2FBRU8sSUFBSWxyRSxPQUFKLENBQVksbUJBQVc7ZUFDdkI0MEQsV0FBTCxDQUFpQjRCLElBQWpCLENBQXNCLEVBQUVod0QsY0FBRixFQUFVekcsVUFBVixFQUF0QixFQUF3Qyx1QkFBZTtpQkFDOUMwQixZQUFQLENBQW9CaXFCLFdBQXBCLEVBQWlDbGxCLE9BQU9xQyxRQUFQLENBQWdCLE9BQUtqQyxLQUFyQixDQUFqQyxFQURxRDtpQkFFaER1a0UsV0FBTCxHQUFtQnovQyxXQUFuQjtrQkFDUUEsV0FBUjtTQUhGO09BREssQ0FBUDs7Ozs7Ozs7OytCQTBCUzthQUNGLEtBQUs3bEIsU0FBTCxDQUFlNkcsUUFBZixDQUF3QixRQUF4QixDQUFQOzs7OzJDQUdxQjtXQUNoQm5PLG1CQUFMLENBQXlCLE9BQXpCLEVBQWtDLEtBQUsrOUMsUUFBdkMsRUFBaUQsS0FBakQ7VUFDSSxLQUFLNnVCLFdBQVQsRUFBc0I7YUFDZnZXLFdBQUwsQ0FBaUJxQixNQUFqQixDQUF3QixLQUFLa1YsV0FBN0I7YUFDS0EsV0FBTCxHQUFtQixJQUFuQjthQUNLRCxVQUFMLEdBQWtCLEtBQWxCO2FBQ0szVixNQUFMLEdBQWMsSUFBZDs7Ozs7d0NBSWdCOzs7V0FDYi8yRCxnQkFBTCxDQUFzQixPQUF0QixFQUErQixLQUFLODlDLFFBQXBDLEVBQThDLEtBQTlDOztVQUVJLENBQUNqbEQsT0FBS29WLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBRCxJQUEwQixLQUFLOG9ELE1BQW5DLEVBQTJDO2VBQUE7OztVQUlyQ3hrRCxXQUFXMVosT0FBS3laLEtBQUwsRUFBakI7V0FDS3lrRCxNQUFMLEdBQWN4a0QsU0FBU0MsT0FBdkI7O21CQUVhLElBQWIsRUFBbUIsWUFBTTtZQUNqQnBLLFFBQVEsT0FBS0EsS0FBbkI7WUFDTXFqRSxTQUFTLE9BQUsvSCxPQUFwQjtZQUNJLENBQUMrSCxNQUFMLEVBQWE7aUJBQ05sdUUsS0FBTCxDQUFXLHlDQUFYOzs7WUFHRWt1RSxPQUFPMWxFLFlBQVAsQ0FBb0IsVUFBcEIsQ0FBSixFQUFxQztpQkFDOUJHLFdBQUwsU0FBdUJ1bEUsT0FBT3Z4RSxZQUFQLENBQW9CLFVBQXBCLENBQXZCOzs7WUFHRSxDQUFDLE9BQUt3eUUsVUFBVixFQUFzQjtjQUNoQixPQUFLM21FLFlBQUwsQ0FBa0IsUUFBbEIsQ0FBSixFQUFpQzttQkFDMUJzbEUsU0FBTCxDQUFlLElBQWY7bUJBQ094bEUsWUFBUCxDQUFvQixhQUFwQixFQUFtQ3VDLEtBQW5DOzs7Y0FHRUEsVUFBVXFqRSxPQUFPUCxJQUFQLENBQVlweEUsTUFBWixHQUFxQixDQUFuQyxFQUFzQzttQkFDN0J1ckQsVUFBUDt5QkFDYTtxQkFBTW9tQixPQUFPcG1CLFVBQVAsRUFBTjthQUFiOzs7d0JBR1l5USxXQUFkLENBQTBCeG5DLEtBQTFCLENBQWdDbTlDLE1BQWhDLEVBQXdDLFlBQU07Z0JBQ3RDbUIsYUFBYSxPQUFLcnJFLElBQUwsSUFBYSxPQUFLckgsWUFBTCxDQUFrQixNQUFsQixDQUFoQztnQkFDSSxDQUFDLE9BQUtnekIsV0FBTixJQUFxQjAvQyxVQUF6QixFQUFxQztrQkFDN0JDLGVBQWVwQixPQUFPUyxjQUE1QjtrQkFDTVksWUFBWWowRSxPQUFLaVcsTUFBTCxDQUFZLEtBQVosRUFBbUIsRUFBRXJULFFBQVEsTUFBVixFQUFrQkQsT0FBTyxNQUF6QixFQUFpQ2l1RCxZQUFZLFFBQTdDLEVBQW5CLENBQWxCOzJCQUNhejNDLFlBQWIsQ0FBMEI4NkQsU0FBMUIsRUFBcUNELGFBQWF4aUUsUUFBYixDQUFzQmpDLEtBQXRCLENBQXJDLEVBSG1DOztrQkFLN0I0dkQsT0FBTyxTQUFQQSxJQUFPO3VCQUFNLE9BQUsrVSxnQkFBTCxDQUFzQkYsWUFBdEIsRUFBb0NELFVBQXBDLEVBQWdEOWxELElBQWhELENBQXFEdlUsU0FBUzlRLE9BQTlELENBQU47ZUFBYjtxQkFDTyxPQUFLdXFFLFFBQUwsS0FBa0JoVSxNQUFsQixHQUEyQnlULE9BQU9mLGFBQVAsQ0FBcUJsNEQsT0FBckIsQ0FBNkJzVSxJQUE3QixDQUFrQ2t4QyxJQUFsQyxDQUFsQzs7O21CQUdLemxELFNBQVM5USxPQUFULENBQWlCLE9BQUt5ckIsV0FBdEIsQ0FBUDtXQVhGOztPQXRCSjs7Ozs2Q0EyQ3VCdDBCLE1BQU1rTyxNQUFNQyxTQUFTOzs7Y0FDcENuTyxJQUFSO2FBQ08sT0FBTDtpQkFDT2lZLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I2c0MsbUJBQXhCLEVBQTBDaDJDLFNBQTFDOzthQUVHLFVBQUw7dUJBQ2UsSUFBYixFQUFtQjttQkFBTWIsYUFBYWkxQyxpQkFBYixDQUErQmgxQyxJQUEvQixFQUFxQ0MsT0FBckMsVUFBb0RXLFNBQXBELENBQU47V0FBbkI7O2FBRUcsUUFBTDt1QkFDZSxJQUFiLEVBQW1CO21CQUFNLE9BQUttMUMsYUFBTCxFQUFOO1dBQW5COzthQUVHLE1BQUw7YUFDSyxPQUFMO2FBQ0ssT0FBTDt1QkFDZSxJQUFiLEVBQW1CO21CQUFNLE9BQUt5dkIsb0JBQUwsRUFBTjtXQUFuQjs7YUFFRyxNQUFMO2VBQ08vcUUsSUFBTCxHQUFZd0YsV0FBVyxFQUF2Qjs7Ozs7O3lCQTdOU3VtQixRQUFRO1VBQ2pCLEVBQUVBLGtCQUFrQkQsVUFBcEIsQ0FBSixFQUFxQztlQUM5QnphLGVBQUw7O1dBRUd3akQsV0FBTCxHQUFtQjlvQyxNQUFuQjs7MkJBR2U7YUFDUixLQUFLOG9DLFdBQVo7Ozs7MkJBOERXO2FBQ0p2OUQsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLEVBQXFCLE9BQXJCLENBQVA7Ozs7MkJBR1k7YUFDTDlVLE9BQUs4VSxTQUFMLENBQWUsSUFBZixFQUFxQixpQkFBckIsQ0FBUDs7OzsyQkFHVTthQUNILEtBQUtwTixhQUFMLENBQW1CLGVBQW5CLENBQVA7Ozs7MkJBR1k7YUFDTDFILE9BQUtpUCxVQUFMLENBQWdCLElBQWhCLEVBQXNCLFlBQXRCLENBQVA7Ozs7MkJBR1U7YUFDSHpQLE1BQU1DLFNBQU4sQ0FBZ0IwQixPQUFoQixDQUF3QnhCLElBQXhCLENBQTZCLEtBQUswWSxhQUFMLENBQW1CN0csUUFBaEQsRUFBMEQsSUFBMUQsQ0FBUDs7OzsyQkFpQ2dCOztVQUVaLEtBQUtzaUUsV0FBVCxFQUFzQjtlQUNiLEtBQUtBLFdBQVo7OztVQUdJbEIsU0FBUyxLQUFLL0gsT0FBcEI7VUFDSStILE9BQU9wb0UsS0FBUCxDQUFhdkosTUFBYixLQUF3QjJ4RSxPQUFPUCxJQUFQLENBQVlweEUsTUFBeEMsRUFBZ0Q7ZUFDdkMyeEUsT0FBT3BvRSxLQUFQLENBQWEsS0FBSytFLEtBQWxCLENBQVA7OzthQUdLLElBQVA7Ozs7MkJBcUU4QjthQUN2QixDQUFDLFVBQUQsRUFBYSxRQUFiLEVBQXVCLE1BQXZCLEVBQStCLE9BQS9CLEVBQXdDLE1BQXhDLEVBQWdELE9BQWhELEVBQXlELE9BQXpELENBQVA7Ozs7RUE3UW9DdXdDOztBQXVTeEM3a0MsWUFBWWs1RCxHQUFaLEdBQWtCWixVQUFsQjtBQUNBeDFDLGVBQWVMLE1BQWYsQ0FBc0IsU0FBdEIsRUFBaUM2MUMsVUFBakM7O0FDelhBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxJQUVxQmE7Ozs7Ozs7OzsyQkFROEM7bUZBQUosRUFBSTsyQkFBcEQ1NEQsTUFBb0Q7UUFBcERBLE1BQW9ELCtCQUEzQyxRQUEyQzswQkFBakNyUCxLQUFpQztRQUFqQ0EsS0FBaUMsOEJBQXpCLENBQXlCOzZCQUF0QkQsUUFBc0I7UUFBdEJBLFFBQXNCLGlDQUFYLEdBQVc7Ozt3SEFDekQsRUFBRXNQLGNBQUYsRUFBVXJQLFlBQVYsRUFBaUJELGtCQUFqQixFQUR5RDs7Ozs7Ozs7Ozs7eUJBUTVEK3FELE9BQU83dkQsVUFBVTs7Ozs7Ozs7Ozs7eUJBUWpCNnZELE9BQU83dkQsVUFBVTs7Ozs7RUF4Qm1CbzVDOztBQ2xCM0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBR0E7Ozs7SUFHcUI2ekI7OzsrQkFFOEM7bUZBQUosRUFBSTsyQkFBcEQ3NEQsTUFBb0Q7UUFBcERBLE1BQW9ELCtCQUEzQyxRQUEyQzswQkFBakNyUCxLQUFpQztRQUFqQ0EsS0FBaUMsOEJBQXpCLENBQXlCOzZCQUF0QkQsUUFBc0I7UUFBdEJBLFFBQXNCLGlDQUFYLEdBQVc7OztnSUFDekQsRUFBRXNQLGNBQUYsRUFBVXJQLFlBQVYsRUFBaUJELGtCQUFqQixFQUR5RDs7Ozs7Ozs7Ozs7eUJBUTVEd2tCLE9BQU90cEIsVUFBVTtpQkFDVEEsV0FBV0EsUUFBWCxHQUFzQixZQUFXLEVBQTVDOzthQUVPc3BCLEtBQVAsRUFBYyxLQUFLaVUsR0FBbkIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLENBQVgsRUFEM0IsRUFFRzVqQyxLQUZILENBRVMsZ0JBQVE7OztPQUZqQixFQU1Hb0IsSUFOSDs7Ozs7Ozs7Ozt5QkFhR3lSLE9BQU90cEIsVUFBVTtpQkFDVEEsV0FBV0EsUUFBWCxHQUFzQixZQUFXLEVBQTVDOzthQUVPc3BCLEtBQVAsRUFBYyxLQUFLaVUsR0FBbkIsRUFDR2dkLE9BREgsQ0FDVyxFQUFFRixTQUFTLENBQVgsRUFEWCxFQUMyQixFQUFFQSxTQUFTLENBQVgsRUFEM0IsRUFFRzVqQyxLQUZILENBRVMsZ0JBQVE7OztPQUZqQixFQU1Hb0IsSUFOSDs7OztFQTdCMkNtMUQ7O0FDdkIvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFNQTs7OztJQUdxQkU7OztpQ0FFK0M7bUZBQUosRUFBSTsyQkFBcEQ5NEQsTUFBb0Q7UUFBcERBLE1BQW9ELCtCQUEzQyxNQUEyQzswQkFBbkNyUCxLQUFtQztRQUFuQ0EsS0FBbUMsOEJBQTNCLENBQTJCOzZCQUF4QkQsUUFBd0I7UUFBeEJBLFFBQXdCLGlDQUFiLElBQWE7Ozs7eUlBQzFELEVBQUVzUCxjQUFGLEVBQVVyUCxZQUFWLEVBQWlCRCxrQkFBakIsRUFEMEQ7O1VBRzNEcW9FLFlBQUwsR0FBb0IsTUFBS3JvRSxRQUFMLEdBQWdCLEdBQWhCLEdBQXNCLE1BQUtDLEtBQS9DLENBSGdFO1FBSTVEdkssU0FBU3lDLFNBQVQsRUFBSixFQUEwQjtZQUNuQm13RSxTQUFMLEdBQWlCLEVBQWpCLENBRHdCO0tBQTFCLE1BRU87VUFDRDV6QixhQUFhQyw0QkFBYixFQUFKLEVBQWlEO2NBQzFDMnpCLFNBQUwsR0FBaUIsRUFBakIsQ0FEK0M7T0FBakQsTUFFTyxJQUFJNXpCLGFBQWFFLDZCQUFiLEVBQUosRUFBa0Q7Y0FDbEQwekIsU0FBTCxHQUFpQixFQUFqQixDQUR1RDtPQUFsRCxNQUVBO2NBQ0FBLFNBQUwsR0FBaUIsRUFBakI7Ozs7Ozs7Ozs7Ozs7O3lCQVNEOWpELE9BQU90cEIsVUFBVTtjQUNac3BCLE1BQU1FLE1BQWQ7YUFDSzVjLE9BQUwsQ0FBYTY1QyxTQUFiLEdBQXlCLEtBQUsybUIsU0FBOUI7O2FBRU96MUQsTUFBUCxDQUNFd2lDLE9BQU83d0IsS0FBUCxFQUFjLEtBQUtpVSxHQUFuQixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLCtCQUE2QixLQUFLNHlCLFNBQWxDLFdBQUYsRUFGSixFQUdJLEVBQUU1eUIsV0FBVyxzQkFBYixFQUhKLEVBS0cvakMsS0FMSCxDQUtTLGdCQUFRO29CQUNEelcsVUFBWjs7T0FOSixDQURGLEVBV0VtNkMsT0FBTyxLQUFLa3pCLFFBQUwsRUFBUCxFQUNHMzJELElBREgsQ0FDUSxLQUFLM1IsS0FEYixFQUVHMFIsS0FGSCxDQUVTLEVBQUUrakMsZ0NBQThCLEtBQUs0eUIsU0FBbkMsb0JBQUYsRUFGVCxFQUU0RSxLQUFLN3ZDLEdBRmpGLENBWEYsRUFlRTRjLE9BQU92aEQsT0FBSzJKLFNBQUwsQ0FBZSttQixNQUFNbGYsUUFBckIsQ0FBUCxFQUF1QyxLQUFLbXpCLEdBQTVDLEVBQ0dnZCxPQURILENBQ1csRUFBRUYsU0FBUyxDQUFYLEVBRFgsRUFDMkIsRUFBRUEsU0FBUyxDQUFYLEVBRDNCLENBZkY7Ozs7Ozs7Ozs7eUJBd0JHL3dCLE9BQU90cEIsVUFBVTtjQUNac3BCLE1BQU1FLE1BQWQ7YUFDSzVjLE9BQUwsQ0FBYTY1QyxTQUFiLEdBQXlCLENBQXpCOzthQUVPOXVDLE1BQVAsQ0FDRXdpQyxPQUFPN3dCLEtBQVAsRUFBYyxLQUFLaVUsR0FBbkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLHNCQUFiLEVBRkosRUFHSSxFQUFFQSwrQkFBNkIsS0FBSzR5QixTQUFsQyxXQUFGLEVBSEosRUFLRzMyRCxLQUxILENBS1MsZ0JBQVE7b0JBQ0R6VyxVQUFaOztPQU5KLENBREYsRUFXRW02QyxPQUFPLEtBQUtrekIsUUFBTCxFQUFQLEVBQXdCLEtBQUs5dkMsR0FBN0IsRUFDRzdtQixJQURILENBQ1EsS0FBSzNSLEtBRGIsRUFFRzBSLEtBRkgsQ0FFUyxFQUFFK2pDLDBDQUFGLEVBRlQsRUFFeUQsS0FBS2pkLEdBRjlELENBWEYsRUFlRTRjLE9BQU92aEQsT0FBSzJKLFNBQUwsQ0FBZSttQixNQUFNbGYsUUFBckIsQ0FBUCxFQUF1QyxLQUFLbXpCLEdBQTVDLEVBQ0dnZCxPQURILENBQ1csRUFBRUYsU0FBUyxDQUFYLEVBRFgsRUFDMkIsRUFBRUEsU0FBUyxDQUFYLEVBRDNCLENBZkY7Ozs7K0JBb0JTO2FBQ0Z6aEQsT0FBSzJKLFNBQUwsQ0FBZXJLLFNBQVNnSixnQkFBVCxDQUEwQiw2REFBMUIsQ0FBZixFQUF5RzBHLE1BQXpHLENBQWdIO2VBQU8wbEUsSUFBSW5oRCxPQUFYO09BQWhILENBQVA7Ozs7RUE1RTZDNmdEOztBQzFCakQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBS0E7Ozs7SUFHcUJPOzs7K0JBRStDO21GQUFKLEVBQUk7MkJBQXBEbjVELE1BQW9EO1FBQXBEQSxNQUFvRCwrQkFBM0MsTUFBMkM7MEJBQW5DclAsS0FBbUM7UUFBbkNBLEtBQW1DLDhCQUEzQixDQUEyQjs2QkFBeEJELFFBQXdCO1FBQXhCQSxRQUF3QixpQ0FBYixJQUFhOzs7O3FJQUMxRCxFQUFFc1AsY0FBRixFQUFVclAsWUFBVixFQUFpQkQsa0JBQWpCLEVBRDBEOztVQUUzRG9oRCxVQUFMLEdBQWtCaHVELFNBQVNtSSxJQUFULENBQWNzNkMsWUFBaEMsQ0FGZ0U7UUFHNURuQixhQUFhQyw0QkFBYixFQUFKLEVBQWlEO1lBQzFDaUIsVUFBTCxHQUFrQixtQkFBbEI7S0FERixNQUVPLElBQUlsQixhQUFhRSw2QkFBYixFQUFKLEVBQWtEO1lBQ2xEZ0IsVUFBTCxHQUFrQixtQkFBbEI7S0FESyxNQUVBO1lBQ0FBLFVBQUwsR0FBa0IsTUFBbEI7Ozs7Ozs7Ozs7Ozs7eUJBUUNweEIsT0FBT3RwQixVQUFVO2NBQ1pzcEIsTUFBTUUsTUFBZDs7YUFFTzdSLE1BQVAsQ0FDRXdpQyxPQUFPN3dCLEtBQVAsRUFBYyxLQUFLaVUsR0FBbkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQywrQkFBNkIsS0FBS0UsVUFBbEMsU0FBRixFQUFzREwsU0FBUyxDQUEvRCxFQUZKLEVBR0ksRUFBRUcsV0FBVyxzQkFBYixFQUFxQ0gsU0FBUyxDQUE5QyxFQUhKLEVBS0c1akMsS0FMSCxDQUtTLGdCQUFRO29CQUNEelcsVUFBWjs7T0FOSixDQURGOzs7Ozs7Ozs7O3lCQWlCR3NwQixPQUFPdHBCLFVBQVU7Y0FDWnNwQixNQUFNRSxNQUFkOzthQUVPN1IsTUFBUCxDQUNFd2lDLE9BQU83d0IsS0FBUCxFQUFjLEtBQUtpVSxHQUFuQixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLFdBQVcsc0JBQWIsRUFBcUNILFNBQVMsQ0FBOUMsRUFGSixFQUdJLEVBQUVHLCtCQUE2QixLQUFLRSxVQUFsQyxTQUFGLEVBQXNETCxTQUFTLENBQS9ELEVBSEosRUFLRzVqQyxLQUxILENBS1MsZ0JBQVE7b0JBQ0R6VyxVQUFaOztPQU5KLENBREY7Ozs7b0NBYWNzcEIsT0FBTztVQUNqQjN0QixTQUFTMnRCLE1BQU10d0IsS0FBTixDQUFZeThCLEdBQXJCLEVBQTBCLEVBQTFCLE1BQWtDLENBQXRDLEVBQXlDO2NBQ2pDejhCLEtBQU4sQ0FBWXk4QixHQUFaLEdBQWtCbk0sTUFBTXR3QixLQUFOLENBQVk4aUUsTUFBWixHQUFxQixFQUF2Qzs7Ozs7RUF4RHlDa1I7O0FDekIvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFLQTs7OztJQUdxQlE7OzsrQkFFK0M7bUZBQUosRUFBSTsyQkFBcERwNUQsTUFBb0Q7UUFBcERBLE1BQW9ELCtCQUEzQyxNQUEyQzswQkFBbkNyUCxLQUFtQztRQUFuQ0EsS0FBbUMsOEJBQTNCLENBQTJCOzZCQUF4QkQsUUFBd0I7UUFBeEJBLFFBQXdCLGlDQUFiLElBQWE7Ozs7cUlBQzFELEVBQUVzUCxjQUFGLEVBQVVyUCxZQUFWLEVBQWlCRCxrQkFBakIsRUFEMEQ7O1FBRTVEMDBDLGFBQWFDLDRCQUFiLEVBQUosRUFBaUQ7WUFDMUNnMEIsVUFBTCxHQUFrQixvQkFBbEI7S0FERixNQUVPO1lBQ0FBLFVBQUwsR0FBa0IsT0FBbEI7Ozs7Ozs7Ozs7Ozs7eUJBUUNua0QsT0FBT3RwQixVQUFVO2NBQ1pzcEIsTUFBTUUsTUFBZDtXQUNLd0csZUFBTCxDQUFxQjFHLEtBQXJCOzthQUVPM1IsTUFBUCxDQUNFd2lDLE9BQU83d0IsS0FBUCxFQUFjLEtBQUtpVSxHQUFuQixFQUNHZ2QsT0FESCxDQUVJLEVBQUVDLCtCQUE2QixLQUFLaXpCLFVBQWxDLFNBQUYsRUFBc0RwekIsU0FBUyxDQUEvRCxFQUZKLEVBR0ksRUFBRUcsV0FBVyxzQkFBYixFQUFxQ0gsU0FBUyxDQUE5QyxFQUhKLEVBS0c1akMsS0FMSCxDQUtTLGdCQUFRO29CQUNEelcsVUFBWjs7T0FOSixDQURGOzs7Ozs7Ozs7O3lCQWlCR3NwQixPQUFPdHBCLFVBQVU7OztjQUNac3BCLE1BQU1FLE1BQWQ7V0FDS3dHLGVBQUwsQ0FBcUIxRyxLQUFyQjs7YUFFTzNSLE1BQVAsQ0FDRXdpQyxPQUFPN3dCLEtBQVAsRUFBYyxLQUFLaVUsR0FBbkIsRUFDR2dkLE9BREgsQ0FFSSxFQUFFQyxXQUFXLHNCQUFiLEVBQXFDSCxTQUFTLENBQTlDLEVBRkosRUFHSSxFQUFFRywrQkFBNkIsS0FBS2l6QixVQUFsQyxTQUFGLEVBQXNEcHpCLFNBQVMsQ0FBL0QsRUFISixFQUtHNWpDLEtBTEgsQ0FLUyxnQkFBUTtlQUNSdVosZUFBTCxDQUFxQjFHLEtBQXJCLEVBQTRCLElBQTVCO29CQUNZdHBCLFVBQVo7O09BUEosQ0FERjs7OztvQ0FjY3NwQixPQUFPb2tELFNBQVM7VUFDMUJDLG1CQUFKO1VBQ0luMEIsYUFBYUMsNEJBQWIsRUFBSixFQUFpRDtxQkFDbEMsTUFBYjtPQURGLE1BRU87cUJBQ1EsR0FBYjs7O1VBR0Vud0IsTUFBTXR3QixLQUFOLENBQVl5OEIsR0FBWixLQUFvQms0QyxVQUF4QixFQUFvQztjQUM1QjMwRSxLQUFOLENBQVl5OEIsR0FBWixHQUFrQms0QyxVQUFsQjtjQUNNMzBFLEtBQU4sQ0FBWThpRSxNQUFaLEdBQXFCLFNBQXJCOzs7OztFQWhFeUNrUjs7QUMxQi9DOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxBQWNBLElBQU12bEUsWUFBUztZQUNILFVBREc7cUJBRU0sbUJBRk47b0JBR0s7Q0FIcEI7O0FBTUEsSUFBTWcyQyxzQkFBbUIsT0FBekI7O0FBRUEsSUFBTXpCLGtCQUFnQjthQUNUeGhELFNBQVN5QyxTQUFULEtBQXVCaXdFLG1CQUF2QixHQUE2Q0ssaUJBRHBDO1VBRVpOLGlCQUZZO1lBR1ZDLG1CQUhVO1VBSVpLLGlCQUpZO1VBS1pDLGlCQUxZO1VBTVpSO0NBTlY7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdCcUJZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFtQkw7Ozs7O1VBR1AzeUIsV0FBTCxHQUFtQjthQUFLdjZDLEVBQUV3NkMsaUJBQUYsRUFBTDtLQUFuQjt3QkFDbUI7YUFBTSxNQUFLZ0IsUUFBTCxFQUFOO0tBQW5COzs7Ozs7NkNBV3VCOztXQUVsQjF5QixNQUFMLEtBQWdCLEtBQUtBLE1BQUwsQ0FBWXh3QixLQUFaLENBQWtCeThCLEdBQWxCLEdBQXdCLEtBQUtqTSxNQUFMLENBQVl4d0IsS0FBWixDQUFrQjhpRSxNQUFsQixHQUEyQixFQUFuRTs7YUFFTyxJQUFJcjRELGVBQUosQ0FBb0I7bUJBQ2R1NEMsZUFEYzttQkFFZGd4QixhQUZjO3VCQUdWLGVBSFU7MEJBSVAsS0FBSy95RSxZQUFMLENBQWtCLFdBQWxCO09BSmIsQ0FBUDs7Ozs7Ozs7Ozs7OzsrQkFnQlM7Z0JBQ0NzTSxPQUFWLENBQWtCLElBQWxCOztXQUVLdk4sS0FBTCxDQUFXc1IsT0FBWCxHQUFxQixNQUFyQjtXQUNLdFIsS0FBTCxDQUFXZ1MsTUFBWCxHQUFvQixLQUFwQixDQUpTOztVQU1INmlFLG1CQUFtQixnQkFBekI7VUFDTUMsa0JBQWtCLGVBQXhCOztVQUVJeGtELFFBQVExd0IsT0FBSzhVLFNBQUwsQ0FBZSxJQUFmLFFBQXlCK3ZDLG1CQUF6QixDQUFaO1VBQ0ksQ0FBQ24wQixLQUFMLEVBQVk7Z0JBQ0ZweEIsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBUjtjQUNNNkgsU0FBTixDQUFnQkUsR0FBaEIsQ0FBb0JtMkMsbUJBQXBCO2VBQ08sS0FBSzl2QyxVQUFMLENBQWdCLENBQWhCLENBQVAsRUFBMkI7Z0JBQ25CaEwsV0FBTixDQUFrQixLQUFLZ0wsVUFBTCxDQUFnQixDQUFoQixDQUFsQjs7OztVQUlBb1EsU0FBU25sQixPQUFLOFUsU0FBTCxDQUFlNGIsS0FBZixRQUEwQndrRCxlQUExQixDQUFiO1VBQ0ksQ0FBQy92RCxNQUFMLEVBQWE7aUJBQ0ZubEIsT0FBSzhVLFNBQUwsQ0FBZTRiLEtBQWYsRUFBc0I7aUJBQUsxd0IsT0FBS0gsS0FBTCxDQUFXaUksQ0FBWCxFQUFjLFNBQWQsS0FBNEI5SCxPQUFLSCxLQUFMLENBQVdpSSxDQUFYLEVBQWMsUUFBZCxDQUFqQztTQUF0QixDQUFUO1lBQ0lxZCxNQUFKLEVBQVk7aUJBQ0gzVyxTQUFQLENBQWlCSSxNQUFqQixDQUF3QixRQUF4QjtpQkFDT0osU0FBUCxDQUFpQkUsR0FBakIsQ0FBcUJ3bUUsZUFBckI7Z0JBQ01uckUsV0FBTixDQUFrQm9iLE1BQWxCOzs7O1VBSUEsQ0FBQ25sQixPQUFLOFUsU0FBTCxDQUFlNGIsS0FBZixRQUEwQnVrRCxnQkFBMUIsQ0FBTCxFQUFvRDtZQUM5Q3R3RSxVQUFVM0UsT0FBSzhVLFNBQUwsQ0FBZTRiLEtBQWYsRUFBc0IsVUFBdEIsQ0FBZDtZQUNJLENBQUMvckIsT0FBTCxFQUFjO29CQUNGckYsU0FBU3FILGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjtlQUNLLElBQUkzRixJQUFJMHZCLE1BQU0zYixVQUFOLENBQWlCOVQsTUFBakIsR0FBMEIsQ0FBdkMsRUFBMENELEtBQUssQ0FBL0MsRUFBa0RBLEdBQWxELEVBQXVEO2dCQUNqRDB2QixNQUFNM2IsVUFBTixDQUFpQi9ULENBQWpCLE1BQXdCbWtCLE1BQTVCLEVBQW9DO3NCQUMxQmhNLFlBQVIsQ0FBcUJ1WCxNQUFNM2IsVUFBTixDQUFpQi9ULENBQWpCLENBQXJCLEVBQTBDMkQsUUFBUXlVLFVBQWxEOzs7O2dCQUlFNUssU0FBUixDQUFrQkUsR0FBbEIsQ0FBc0J1bUUsZ0JBQXRCOztjQUVNOTdELFlBQU4sQ0FBbUJ4VSxPQUFuQixFQUE0QityQixNQUFNdFgsVUFBbEM7OztVQUdFc1gsTUFBTXZtQixVQUFOLEtBQXFCLElBQXpCLEVBQStCO2FBQ3hCSixXQUFMLENBQWlCMm1CLEtBQWpCOzs7bUJBR1dnekIsWUFBYixDQUEwQixJQUExQixFQUFnQyxLQUFLUixPQUFyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkEzRVk7YUFDTHIwQyxTQUFQOzs7OzJCQUdXO2FBQ0o3TyxPQUFLOFUsU0FBTCxDQUFlLElBQWYsUUFBeUIrdkMsbUJBQXpCLENBQVA7Ozs7cUNBK0lzQjlrRCxNQUFNOEwsVUFBVTtVQUNsQyxFQUFFQSxTQUFTcE0sU0FBVCxZQUE4QjIwRSxhQUFoQyxDQUFKLEVBQW9EO2VBQzdDMXZFLEtBQUwsQ0FBVyw2REFBWDs7c0JBRVkzRSxJQUFkLElBQXNCOEwsUUFBdEI7Ozs7MkJBR3FCO2FBQ2R1M0MsZUFBUDs7OzsyQkFHeUI7YUFDbEJneEIsYUFBUDs7OztFQTFMc0NweUI7O0FBOEwxQy9tQyxZQUFZazZELEtBQVosR0FBb0JILFlBQXBCO0FBQ0FqM0MsZUFBZUwsTUFBZixDQUFzQixXQUF0QixFQUFtQ3MzQyxZQUFuQzs7QUM5UEE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBd0NxQkk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBaUNMO2FBQ0wsRUFBRSxJQUFJLG1CQUFOLEVBQVA7Ozs7MkJBR3NCO2FBQ2YsZ0JBQVA7Ozs7MkJBR2U7YUFDUixDQUFDLElBQUQsRUFBT2psRSxTQUFQLEVBQWtCLEVBQUU4WCxRQUFRLEVBQVYsRUFBYyxRQUFRLFNBQXRCLEVBQWlDLGNBQWMsYUFBL0MsRUFBbEIsQ0FBUDs7OztFQTFDOEM0N0I7O0FBOENsRDVvQyxZQUFZbzZELGFBQVosR0FBNEJELG9CQUE1QjtBQUNBcjNDLGVBQWVMLE1BQWYsQ0FBc0Isb0JBQXRCLEVBQTRDMDNDLG9CQUE1Qzs7QUN4R0E7QUFDQSxBQW1EQWowRCxRQUFNNlQsS0FBTjtBQUNBNTFCLE9BQU9rMkUsZUFBUCxHQUF5QnRnRCxLQUF6Qjs7Ozs7Ozs7In0=
